.LOG

#include <stdio.h> include "platform.h" include "xil_printf.h" include <mb_interface.h>
typedef unsigned int ui; // begin queue
#define MAXQ 100
int pk = 0, kk = 0; int mqueue[MAXQ]; unsigned getnum() {
	char srb=0;
	unsigned num=0;
	// skip non digits
	while(srb < '0' || srb > '9') srb=XUartLite_RecvByte(STDIN_BASEADDRESS);
	// read all digits
	while(srb >= '0' && srb <= '9') {
		num=num*10+(srb-'0');
		srb=XUartLite_RecvByte(STDIN_BASEADDRESS);
	};
	return num;
}
void push(ui e) {
        mqueue[kk++%MAXQ] = e;
}
ui pop () {
        return mqueue[pk++%MAXQ];
}
char isempty() {
        return pk == kk;
}
int qlen() {
        return kk - pk;
}
void printq() {
        xil_printf("Queue:\n");
        xil_printf("Queue len: %d\n", qlen());
        for (int i = pk; i < kk; i++) {
                xil_printf("%d ", mqueue[i]);
        }
        xil_printf("End of queue\n");
}
// end quuee // ui gcd2 (ui a, ui b) {
        while (a != b) {
                if (b > a)
                        b -= a;
                else
                        a -= b;
        }
        return a;
}
int fillArray(const ui length){
        for(ui i = 0; i < length; i++){
                push(getnum());
        }
        return 0;
}
int main(void){
		xil_printf("GCD fastest program in the world(tm)\n v. 0.0.1");
        //const int BSZ = 0x100;
        ui length = getnum();
        ui buffer[length];
        ui mySol;
        fillArray(length);
        while (qlen() != 1) {
        	printq();
            int a = pop();
            int b = pop();
            int res = gcd2(a, b);
            push(res);
        }
        xil_printf("Result is: %d\n", pop());
}


// awesome fastest gcd everr!!


#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"


#include <mb_interface.h>

typedef unsigned int ui;

// begin queue

#define MAXQ 100
int pk = 0, kk = 0;
int mqueue[MAXQ];

unsigned getnum() {
	char srb=0;
	unsigned num=0;

	// skip non digits
	while(srb < '0' || srb > '9') srb=XUartLite_RecvByte(STDIN_BASEADDRESS);

	// read all digits
	while(srb >= '0' && srb <= '9') {
		num=num*10+(srb-'0');
		srb=XUartLite_RecvByte(STDIN_BASEADDRESS);
	};
	return num;
}


void push(ui e) {
        mqueue[kk++%MAXQ] = e;
}

ui pop () {
        return mqueue[pk++%MAXQ];
}

char isempty() {
        return pk == kk;
}

int qlen() {
        return kk - pk;
}

void printq() {
        xil_printf("Queue:\n");
        xil_printf("Queue len: %d\n", qlen());
        for (int i = pk; i < kk; i++) {
                xil_printf("%d ", mqueue[i]);
        }
        xil_printf("End of queue\n");
}
// end quuee
//
ui gcd2 (ui a, ui b) {
        while (a != b) {
                if (b > a)
                        b -= a;
                else
                        a -= b;
        }

        return a;
}

int fillArray(const ui length){
        for(ui i = 0; i < length; i++){
                push(getnum());
        }
        return 0;
}

int main(void){
		xil_printf("GCD fastest program in the world(tm)\n v. 0.0.1");
        //const int BSZ = 0x100;
        ui length = getnum();
        ui buffer[length];
        ui mySol;

        fillArray(length);

        while (qlen() != 1) {
        	printq();
            int a = pop();
            int b = pop();
            int res = gcd2(a, b);
            push(res);
        }

        xil_printf("Result is: %d\n", pop());
}

15:00 2019-04-29
Main core program:

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include <mb_interface.h>

unsigned getnum() {
	char srb=0;
	unsigned num=0;

	// skip non digits
	while(srb < '0' || srb > '9') srb=XUartLite_RecvByte(STDIN_BASEADDRESS);

	// read all digits
	while(srb >= '0' && srb <= '9') {
		num=num*10+(srb-'0');
		srb=XUartLite_RecvByte(STDIN_BASEADDRESS);
	};
	return num;
}

// begin queue

typedef unsigned int ui;

#define MAXQ 100
int pk = 0, kk = 0;
int mqueue[MAXQ];

void push(ui e) {
        mqueue[kk++%MAXQ] = e;
}

ui pop () {
        return mqueue[pk++%MAXQ];
}

char isempty() {
        return pk == kk;
}

int qlen() {
        return kk - pk;
}

void printq() {
        xil_printf("Queue:\n");
        xil_printf("Queue len: %d\n", qlen());
        for (int i = pk; i < kk; i++) {
                xil_printf("%d ", mqueue[i]);
        }
        xil_printf("End of queue\n");
}
// end quuee
//
ui gcd2 (ui a, ui b) {
        while (a != b) {
                if (b > a)
                        b -= a;
                else
                        a -= b;
        }

        return a;
}

int fillArray(const ui length){
        for(ui i = 0; i < length; i++){
                push(getnum());
        }
        return 0;
}

void communicate(int expectedReceive) {
	putfsl (expectedReceive, 0);
	for (int i = 0; i < expectedReceive; i++) {
		int rcvd = pop();
		putfsl(rcvd, 0);

		push(rcvd);
	}
}

int main(void){
		xil_printf("GCD fastest program in the world(tm)\n v. 0.0.1");
        //const int BSZ = 0x100;
        ui length = getnum();
        ui buffer[length];
        ui mySol;

        fillArray(length);

        int expectedReceive = qlen() / 2;
        communicate(expectedReceive);

        while (qlen() != 1) {
        	printq();
            int a = pop();
            int b = pop();
            int res = gcd2(a, b);
            push(res);
        }

        int aux_core_res;
        getfsl(aux_core_res, 0);

        xil_printf("Result of upper half is: %d\n", pop());
        xil_printf("Aux core returned: %d\n", aux_core_res);
}

Auxillary core program:

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include <mb_interface.h>

// begin queue
#define MAXQ 100
int pk = 0, kk = 0;
int mqueue[MAXQ];

typedef unsigned int ui;

void push(ui e) {
        mqueue[kk++%MAXQ] = e;
}

ui pop () {
        return mqueue[pk++%MAXQ];
}

char isempty() {
        return pk == kk;
}

int qlen() {
        return kk - pk;
}

void printq() {
        xil_printf("Queue:\n");
        xil_printf("Queue len: %d\n", qlen());
        for (int i = pk; i < kk; i++) {
                xil_printf("%d ", mqueue[i]);
        }
        xil_printf("End of queue\n");
}
// end quuee


ui gcd2 (ui a, ui b) {
    while (a != b) {
        if (b > a)
            b -= a;
        else
            a -= b;
    }
	return a;
}

// Global definitions for communications
int expectedReceive;

void communicate() {
	getfsl (expectedReceive, 0);
	for (int i = 0; i < expectedReceive; i++) {
		int rcvd;
		getfsl(rcvd, 0);

		push(rcvd);
	}
}

int main(void){
	communicate();
	while (qlen() != 1) {
		printq();
	    int a = pop();
	    int b = pop();
	    int res = gcd2(a, b);
	    push(res);
	}

	// send to main_cpu
	putfsl(pop(), 0);
}


Wrong answer on 2 1 3.

17:26 2019-05-15


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity user_logic is
    Port ( clk : in STD_LOGIC;
           rstN : in STD_LOGIC;
           wren : in STD_LOGIC;
           waddr : in STD_LOGIC_VECTOR (1 downto 0);
           wdata : in STD_LOGIC_VECTOR (31 downto 0);
           rden : in STD_LOGIC;
           raddr : in STD_LOGIC_VECTOR (1 downto 0);
           rdata : out STD_LOGIC_VECTOR (31 downto 0);
           busy : out STD_LOGIC);
end user_logic;

architecture slow_arch of user_logic is
   type state_type is (idle, swap, sub);
   signal state_reg, state_next: state_type;
   signal a_reg, a_next, b_reg, b_next: unsigned(31 downto 0);
   --signal wren_current : STD_LOGIC := '0';
   signal gcd_current : unsigned(31 downto 0);
begin
   -- state & data registers
   process(clk,rstN, wdata,a_next,b_next)
   begin
      if rstN='0' then
         state_reg <= idle;
         
         b_reg <= unsigned(wdata);
         a_reg <= unsigned(wdata);
      elsif (clk'event and clk='1') then
         state_reg <= state_next;
         a_reg <= a_next;
         b_reg <= b_next;
      end if;
   end process;
   
   -- next-state logic & data path functional units/routing
   process(state_reg,a_reg,b_reg,wren,wdata)
   begin
      busy <= '1';
      --a_next <= a_reg;
      --b_next <= b_reg;
      case state_reg is
         when idle =>
            if wren='1' then -- and wren_current='0' then
               -- if user enters a == b
               busy <= '0';
               a_next <= unsigned(wdata);
               
               state_next <= swap;
               if (a_next = b_next) then
                 state_next <= idle;
               end if;
            else
               state_next <= idle;
               busy <= '0';
            end if;
         when swap =>
            if (a_reg=b_reg) then
               state_next <= idle;
               --wren_current <= '0';
            else
               if (a_reg < b_reg) then
                  a_next <= b_reg;
                  b_next <= a_reg;
               end if;
               state_next <= sub;
            end if;
         when sub =>
            if (a_reg = b_reg) then
                state_next <= idle;
            else
                a_next <= a_reg - b_reg;
                state_next <= swap;
            end if;
         end case;
   end process;
   -- output
   busy <= '0' when state_reg=idle else '1';
   rdata <= std_logic_vector(a_reg);
end slow_arch;

--architecture Behavioral of user_logic is
--    type STATE_TYPE is (S0, S1, S2, S3);
--    --attribute ENUM_ENCODING: STRING;
--    --attribute ENUM_ENCODING of STATE_TYPE: type is "0001 0010 0100 1000";
    
--    signal CS, NS: STATE_TYPE;
--    signal reset : STD_LOGIC;
--begin
--    -- insert the following after 'begin'
--    reset <= not rstN;
--    busy <= '0';
    
--    SYNC_PROC: process(clk, reset)
--    begin
--        if (reset = '1') then
--            CS <= S0;
--            -- other state variables reset
--        elsif rising_edge(clk) then
--            CS <= NS;
--            -- other state variable assignment
--        end if;
--    end process;
    
--    COMB_PROC: process(CS, wdata)
--    begin
--        -- assign default signals here to avoid latches
--    case CS is
--        when S0 =>
--            NS <= S1;
--            rdata <= wdata;
--        when S1 =>
--            NS <= S2;
--            rdata <= wren & rden  & "0000000000000000000000000000000";
--        when S2 =>
--            NS <= S3;
--            rdata <= wdata;
--        when S3 =>
--            NS <= S0;
--            rdata <= wdata;
--    end case;
--    end process;

--end Behavioral;


-------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity user_logic is
    Port ( clk : in STD_LOGIC;
            rstN : in STD_LOGIC;
            wren : in STD_LOGIC;
            waddr : in STD_LOGIC_VECTOR (1 downto 0);
            wdata : in STD_LOGIC_VECTOR (31 downto 0);
            rden : in STD_LOGIC;
            raddr : in STD_LOGIC_VECTOR (1 downto 0);
            rdata : out STD_LOGIC_VECTOR (31 downto 0);
            busy : out STD_LOGIC);
end user_logic;

architecture slow_arch of user_logic is
    type state_type is (idle, start, sub);
    signal state_reg, state_next: state_type;
    signal a_reg, a_next, b_reg, b_next: unsigned(31 downto 0);
    signal gcd_current : unsigned(31 downto 0);
begin
     -- state & data registers
    process(clk)
    begin
    if rstN='0' then
        state_reg <= idle;
        b_reg <= "00000000000000000000000000000000";
        a_reg <= "00000000000000000000000000000000";
		gcd_current <= unsigned(wdata);
    elsif (clk'event and clk='1') then
		state_reg <= state_next;
		
		a_reg <= a_next;
		b_reg <= b_next;
    end if;
end process;

process(state_reg, wren, a_reg, b_reg, wdata)
begin
	case state_reg is
	when idle =>
		if wren = '1' then
			state_next <= start;
			a_next <= unsigned(wdata);
			b_next <= gcd_current;
		end if;
		b_next <= "00000000000000000000000000000000";
		busy <= '0';
	when start =>
		if b_reg = "00000000000000000000000000000000" then
			state_next <= idle;
			b_next <= a_next;
		end if;
		
		if a_reg = b_reg then
			state_next <= idle;
		end if;
		
		busy <= '1';
		state_next <= sub;
	when sub =>
		if a_reg = b_reg then
			state_next <= idle;
			gcd_current <= a_reg;
		end if;
		
		if a_reg < b_reg then
			a_next <= 5;
			b_next <= 8;
		else
			a_next <= 6;
			b_next <= 5;
		end if;
		
		busy <= '1';
		state_next <= start;
	end case;
end process;

end slow_arch;


13:11 2019-05-17

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity user_logic is
    Port ( clk : in STD_LOGIC;
            rstN : in STD_LOGIC;
            wren : in STD_LOGIC;
            waddr : in STD_LOGIC_VECTOR (1 downto 0);
            wdata : in STD_LOGIC_VECTOR (31 downto 0);
            rden : in STD_LOGIC;
            raddr : in STD_LOGIC_VECTOR (1 downto 0);
            rdata : out STD_LOGIC_VECTOR (31 downto 0);
            busy : out STD_LOGIC);
end user_logic;

architecture slow_arch of user_logic is
    type state_type is (idle, start, sub, schwift);
    signal state_reg, state_next: state_type;
    signal a_reg, a_next, b_reg, b_next: unsigned(31 downto 0);
    signal gcd_current : unsigned(31 downto 0);
begin
     -- state & data registers
    process(clk)
    begin
    if rstN='0' then
        state_reg <= idle;
        b_reg <= "00000000000000000000000000000000";
        a_reg <= "00000000000000000000000000000000";
		gcd_current <= "00000000000000000000000000000000";
    elsif (clk'event and clk='1') then
		state_reg <= state_next;
		
		a_reg <= a_next;
		b_reg <= b_next;
    end if;
end process;

process(state_reg, wren, a_reg, b_reg, wdata)
begin
	case state_reg is
	when idle =>
		if wren = '1' then
			state_next <= start;
			a_next <= unsigned(wdata);
			b_next <= gcd_current;
		end if;
		b_next <= "00000000000000000000000000000000";
		busy <= '0';
	when start =>
		if b_reg = "00000000000000000000000000000000" or (a_reg = b_reg) then
			state_next <= idle;
			gcd_current <= a_reg;
			b_next <= a_next;
		else
			state_next <= schwift;
		end if;
		
		busy <= '1';
	when schwift =>
		if a_reg < b_reg then
			a_next <= b_reg;
			b_next <= a_reg;
		else
			a_next <= a_reg;
			b_next <= b_reg;
		end if;
		state_next <= sub;
		busy <= '1';
	
	when sub =>
		if a_reg = b_reg then
			state_next <= idle;
			gcd_current <= a_reg;
		end if;
		
		a_next <= a_reg - b_reg;
		b_next <= b_reg;
		
		busy <= '1';
		state_next <= schwift;
	end case;
end process;

end slow_arch;

11:07 2019-05-22


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity user_logic is
    Port ( clk : in STD_LOGIC;
            rstN : in STD_LOGIC;
            wren : in STD_LOGIC;
            waddr : in STD_LOGIC_VECTOR (1 downto 0);
            wdata : in STD_LOGIC_VECTOR (31 downto 0);
            rden : in STD_LOGIC;
            raddr : in STD_LOGIC_VECTOR (1 downto 0);
            rdata : out STD_LOGIC_VECTOR (31 downto 0);
            busy : out STD_LOGIC);
end user_logic;

architecture slow_arch of user_logic is
    type state_type is (idle, start, sub, schwift);
    signal state_reg, state_next: state_type;
    signal a_reg, a_next, b_reg, b_next: unsigned(31 downto 0);
    signal gcd_current : unsigned(31 downto 0);
	signal gcd_next : unsigned(31 downto 0);
begin
     -- state & data registers
    process(clk)
    begin
    if rstN='0' then
        state_reg <= idle;
        b_reg <= "00000000000000000000000000000000";
        a_reg <= "00000000000000000000000000000000";
		gcd_current <= "10000000000000000000000000000000";
    elsif (clk'event and clk='1') then
		state_reg <= state_next;
		
		a_reg <= a_next;
		b_reg <= b_next;
    end if;
end process;

process(state_reg, wren, a_reg, b_reg, wdata, clk)
begin
	case state_reg is
	when idle =>
		if wren = '1' then
			state_next <= start;
			a_next <= unsigned(wdata);
			--b_next <= gcd_current;
			
			if a_reg = b_reg and b_reg = "00000000000000000000000000000000" then
				-- after reset b_next undefined. Lets fix it.
				b_next <= unsigned(wdata);
			end if;
		end if;
		
		busy <= '0';
		rdata <= std_logic_vector(a_reg);
	when start =>
		if (a_reg = b_reg) then
			state_next <= idle;
		else
			state_next <= schwift;
		end if;
		
		busy <= '1';
	when schwift =>
		if a_reg = b_reg then
			state_next <= idle;
		else
			if a_reg < b_reg then
				a_next <= b_reg;
				b_next <= a_reg;
			else
				a_next <= a_reg;
				b_next <= b_reg;
			end if;
			state_next <= sub;
			busy <= '1';
		end if;
	
	when sub =>
		if a_reg = b_reg then
			state_next <= idle;
			gcd_next <= a_reg;
		else
			a_next <= a_reg - b_reg;
			b_next <= b_reg;
			state_next <= schwift;
		end if;
		
		rdata <= std_logic_vector(a_reg);
		busy <= '1';
	end case;
end process;

end slow_arch;
