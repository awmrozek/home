<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Pliki</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apievnt.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apigraf.html">Nastêpna czêœæ kursu >></A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
1. Odczyt z pliku
</H2>

<P>
Marny los programisty, który nie umie odczytywaæ i zapisywaæ danych do pliku. Dlatego warto by siê w ten temat zag³êbiæ. Zrobimy to krótko i rzeczowo. Najpierw, ¿eby cokolwiek z plikiem zrobiæ, musimy go otworzyæ. Funkcji do wyboru mamy od czorta, ale najlepiej bêdzie skorzystaæ z <SPAN CLASS=T>CreateFile</SPAN>. Nazwa mo¿e niezbyt trafna, ale w ka¿dym razie funkcja ta robi, co trzeba:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: HANDLE CreateFile(<I>lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>lpFileName</I></TD><TD CLASS=ARGLIST>Nazwa pliku</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwDesiredAccess</I></TD><TD CLASS=ARGLIST>Tryb dostêpu (odczyt lub zapis)</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwShareMode</I></TD><TD CLASS=ARGLIST>Tryb wspó³dzielenia pliku (jakie operacje mog¹ wykonywaæ na nim inne procesy)</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpSecurityAttributes</I></TD><TD CLASS=ARGLIST>Atrybuty bezpieczeñstwa (nie interesuje nas to :-) )</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwCreationDistribution</I></TD><TD CLASS=ARGLIST>Jak utworzyæ plik</TD></TR> 
<TR><TD CLASS=ARGLIST><I>dwFlagsAndAttributes</I></TD><TD CLASS=ARGLIST>Flagi i atrybuty</TD></TR>
<TR><TD CLASS=ARGLIST><I>hTemplateFile</I></TD><TD CLASS=ARGLIST>Uchwyt pliku, którego atrybuty chcemy skopiowaæ na w³aœnie otwierany plik</TD></TR>
</TABLE>
 
<P>
Pierwszy argument, to oczywiœcie nazwa pliku, który chcemy otworzyæ. Pamiêtaj o podwójnych beksleszach <SPAN CLASS=T>\\</SPAN>, jeœli zawiera ona œcie¿kê dostêpu. Argument drugi okreœla rodzaj dostêpu: odczyt lub zapis. Na razie chcemy czytaæ, wiêc ustawiamy go na <SPAN CLASS=T>GENERIC_READ</SPAN>.
</P>
<P>
Nastêpny argument to tryb wspó³dzielenia pliku - w systemie Windows kilka programów mo¿e mieæ jednoczeœnie dostêp do jednego pliku, ale nie zawsze taka synchronizacja jest mo¿liwa. Jeœli nie chcemy, by jakiœ inny program grzeba³ w naszym pliku, dajemy w tym argumencie <SPAN CLASS=L>0</SPAN>. W przeciwnym wypadku mo¿emy ustawiæ <SPAN CLASS=T>FILE_SHARE_READ</SPAN> (jeœli chcemy, by inne programy mog³y równoczeœnie odczytywaæ z naszego pliku dane), <SPAN CLASS=T>FILE_SHARE_WRITE</SPAN> (zgadnij) lub <SPAN CLASS=T>FILE_SHARE_READ | FILE_SHARE_WRITE</SPAN>, czyli pe³ny dostêp. Najbezpieczniej bêdzie jednak ustawiæ <SPAN CLASS=L>0</SPAN>.
</P>
<P>
Argument <SPAN CLASS=T>lpSecurityAttributes</SPAN> na razie nas nie obchodzi, niech siê wypcha sianem (czyli <SPAN CLASS=T>NULL</SPAN>-em). Du¿o wa¿niejszy jest nastêpny argument, <SPAN CLASS=T>dwCreationDistribution</SPAN>. Okreœla on, co stanie siê podczas otwierania w zale¿noœci od tego, czy plik istnieje czy te¿ nie. Musimy wybraæ jedn¹ z nastêpuj¹cych sta³ych:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>CREATE_NEW</TD><TD CLASS=ARGLIST>Tworzy nowy plik, generuje b³¹d jeœli plik o podanej nazwie ju¿ istnieje.</TD></TR>
<TR><TD CLASS=ARGLIST>CREATE_ALWAYS</TD><TD CLASS=ARGLIST>Tworzy nowy plik, jeœli plik o podanej nazwie ju¿ istnieje, to zostaje on nadpisany.</TD></TR>
<TR><TD CLASS=ARGLIST>OPEN_EXISTING</TD><TD CLASS=ARGLIST>Otwiera istniej¹cy plik, jeœli plik nie istnieje, to generuje b³¹d.</TD></TR>
<TR><TD CLASS=ARGLIST>OPEN_ALWAYS</TD><TD CLASS=ARGLIST>Otwiera istniej¹cy plik, jeœli plik nie istnieje, to go tworzy.</TD></TR>
<TR><TD CLASS=ARGLIST>TRUNCATE_EXISTING</TD><TD CLASS=ARGLIST>Otwiera istniej¹cy plik, zeruj¹c go (obcinaj¹c do zerowej d³ugoœci), jeœli plik nie istnieje, to funkcja generuje b³¹d. Plik musi byæ otwarty co najmniej z dostêpem GENERIC_WRITE.</TD></TR>
</TABLE>

<P>
Nastêpnie - flagi, czyli argument <SPAN CLASS=T>dwFlagsAndAttributes</SPAN>. Tutaj mo¿liwoœci mamy doœæ sporo, miêdzy innymi takie:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_NORMAL itd.</TD><TD CLASS=ARGLIST>Atrybuty, jakie ma mieæ plik, jeœli tworzymy nowy. Dok³adny spis ni¿ej, w rozdziale o atrybutach.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_FLAG_RANDOM_ACCESS</TD><TD CLASS=ARGLIST>Okreœla, ¿e plik ma dostêp swobodny (patrz ni¿ej, rozdzia³ o wskaŸnikach pliku). System u¿ywa tego tylko jako wskazówki dla optymalizacji zapisu/odczytu.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_FLAG_SEQUENTIAL_SCAN</TD><TD CLASS=ARGLIST>Okreœla, ¿e plik ma dostêp sekwencyjny, od pocz¹tku do koñca pliku (patrz ni¿ej, rozdzia³ o wskaŸnikach pliku). System u¿ywa tego tylko jako wskazówki dla optymalizacji zapisu/odczytu. </TD></TR>
<TR><TD CLASS=ARGLIST>FILE_FLAG_DELETE_ON_CLOSE</TD><TD CLASS=ARGLIST>Okreœla, ¿e plik zostanie skasowany bezpoœrednio po zamkniêciu wszystkich odwo³uj¹cych siê do niego uchwytów (nie tylko tego uchwytu, dla którego ustawiona jest ta flaga).</TD></TR>
</TABLE>

<P>
Ostatni argument musi byæ równy <SPAN CLASS=T>NULL</SPAN>, jeœli piszemy pod Windowsem 95 lub pokrewnym. W przeciwnym razie spowodujemy b³¹d, na czym raczej nam nie zale¿y, tote¿ pos³uchamy grzecznie wskazañ Microsoftu.
</P>
<P>
Uff, to ju¿ wszystko. Tyle w³aœnie trzeba zachodu, ¿eby otworzyæ jeden g³upi plik. No ale teraz ju¿ sytuacja jest w miarê klarowna. Funkcja <SPAN CLASS=T>CreateFile</SPAN>, o ile siê jej powiedzie zadanie, powinna nam zwróciæ uchwyt do pliku, który jest typu <SPAN CLASS=T>HANDLE</SPAN>. W przeciwnym wypadku zwróci wartoœæ <SPAN CLASS=T>INVALID_HANDLE_VALUE</SPAN>.
<P>
</P>
Za³ó¿my, ¿e chcemy sobie ca³y nasz pliczek wczytaæ do jakiegoœ wczeœniej zaalokowanego bufora znakowego. Mo¿na to zrobiæ na co najmniej dwa sposoby: wczytywaæ plik bajt po bajcie, a¿ napotkamy znak <SPAN CLASS=Wazne>EOF</SPAN> (End Of File), co jednak bêdzie wykonywane w ¿ó³wim tempie, albo najpierw pobraæ rozmiar pliku, a nastêpnie od razu wczytaæ wszystkie bajty do bufora. Wybieramy oczywiœcie rozwi¹zanie nr 2.
</P>
<P>
Funkcja zwracaj¹ca rozmiar pliku nazywa siê (co za niespodzianka) <SPAN CLASS=T>GetFileSize</SPAN>. Zwracana wartoœæ jest typu <SPAN CLASS=T>DWORD</SPAN>, drugi argument funkcji (bo dwa s¹) zostawmy na razie w spokoju:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD dwSize = GetFileSize(hPlik, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(dwSize == <SPAN CLASS=L>0xFFFFFFFF</SPAN>) <SPAN CLASS=C>//b³¹d!</SPAN><BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Z³y rozmiar pliku!"</SPAN>, <SPAN CLASS=L>"B³¹d"</SPAN>, MB_ICONEXCLAMATION);<BR>
<SPAN CLASS=K>else</SPAN><BR>
&nbsp;<SPAN CLASS=C>//ok, mo¿emy wczytywaæ plik</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Jak nietrudno obliczyæ, zmienna typu <SPAN CLASS=T>DWORD</SPAN> mo¿e przedstawiæ rozmiar pliku tylko wtedy, gdy jest on mniejszy ni¿ jakieœ 4 GB, co powinno nam w wiêkszoœci wypadków wystarczyæ ;-). W razie czego jednak funkcja <SPAN CLASS=T>GetFileSize</SPAN> potrafi pobraæ równie¿ rozmiar znacznie wiêkszych plików i do tego w³aœnie s³u¿y ten drugi argument, gdzie wstawiliœmy <SPAN CLASS=T>NULL</SPAN>. Jak to zrobiæ, tego nie poka¿ê bo i tak nam siê nie powinno przydaæ ;-P. Jeœli kogoœ bêdzie bardzo ciekawoœæ drêczyæ, mo¿e spytaæ w mejlu.
</P>
<P>
Mamy wiêc plik, znamy jego rozmiar, w tym momencie mo¿emy sobie alokowaæ jakiœ zgrabny buforek. W "go³ym" C++ robiliœmy to operatorem <SPAN CLASS=K>new</SPAN>, teraz poznamy drugi sposób, zalecany dla okienkowych aplikacji. Jest to funkcja <SPAN CLASS=T>GlobalAlloc</SPAN> (lub <SPAN CLASS=T>LocalAlloc</SPAN>, która w Win95 robi dok³adnie to samo). Oto jak z niej korzystaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPSTR Bufor;<BR>
Bufor = (LPSTR)GlobalAlloc(GPTR, dwSize);<BR>
<SPAN CLASS=K>if</SPAN>(Bufor == NULL)<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"B³¹d alokacji"</SPAN>, <SPAN CLASS=L>"Ups..."</SPAN>, MB_ICONSTOP);<BR>
</TD></TR>
</TABLE>

<P>
<SPAN CLASS=T>GlobalAlloc</SPAN> zwraca wskaŸnik do œwie¿o alokowanego obszaru, podobnie jak <SPAN CLASS=K>new</SPAN>. Musimy jednak przekonwertowaæ jawnie ten wskaŸnik na taki typ, jakiego potrzebujemy (tutaj z kolei mamy podobieñstwo do <SPAN CLASS=T>malloc</SPAN>-a). Pierwszy argument funkcji, czyli sta³a <SPAN CLASS=T>GPTR</SPAN>, sprawia, ¿e nowo alokowany obszar zostaje od razu wype³niony zerami (co daje tej funkcji niejak¹ przewagê nad <SPAN CLASS=K>new</SPAN>). Jeœli tego nie chcemy, zamieniamy <SPAN CLASS=T>GPTR</SPAN> na <SPAN CLASS=T>GMEM_FIXED</SPAN>. Jeœli funkcja zwróci <SPAN CLASS=T>NULL</SPAN>, oznacza to oczywiœcie, ¿e mamy w systemie deficyt pamiêciowy i w zwi¹zku z tym nowe obszary przydzielane s¹ tylko na kartki ;-).
</P>
<P>
Przed nami ostatni, najwa¿niejszy etap - w³aœciwe czytanie z pliku. Pos³u¿ymy siê w tym celu funkcj¹ (znów niespodzianka) <SPAN CLASS=T>ReadFile</SPAN>. Jej sk³adnia wygl¹da tak:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: BOOL ReadFile(<I>hFile, lpBuffer, nBytesToRead, lpBytesRead, lpOverlapped</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hFile</I></TD><TD CLASS=ARGLIST>Uchwyt pliku do odczytu</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpBuffer</I></TD><TD CLASS=ARGLIST>WskaŸnik na bufor, do którego czytamy dane</TD></TR>
<TR><TD CLASS=ARGLIST><I>nBytesToRead</I></TD><TD CLASS=ARGLIST>Liczba bajtów do odczytania</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpBytesRead</I></TD><TD CLASS=ARGLIST>Adres zmiennej, otrzymuj¹cej liczbê bajtów, które uda³o siê przeczytaæ</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpOverlapped</I></TD><TD CLASS=ARGLIST>Adres struktury, otrzymuj¹cej dane</TD></TR>
</TABLE>
 

<P>
Wyjaœnienia wymagaj¹ chyba tylko ostatnie dwa argumenty. Otó¿ <SPAN CLASS=T>lpNumberOfBytesRead</SPAN> to adres zmiennej, do której funkcja wpisze liczbê bajtów, jak¹ uda jej siê przeczytaæ. Nie musimy z tej zmiennej korzystaæ, ale podanie jej adresu jest wymagane. Chyba, ¿e ostatni argument funkcji jest ró¿ny od <SPAN CLASS=T>NULL</SPAN>, ale nie bêdzie, bo i po co ;-). <SPAN CLASS=T>NULL</SPAN> tak bardzo u³atwia nam ¿ycie :-).
</P>
<P>
Jeœli dysk nie zardzewia³, nikt nie skasowa³ nam pliku kiedy nie patrzyliœmy, nie mamy akurat wirusa, napiêcie w sieci nie wzrasta powy¿ej jakichœ 400 V i nie spada poni¿ej 200, w pokoju panuje temperatura, w której komputerowe akcesoria siê nie topi¹ ani nie zamarzaj¹ i wszystkie inne warunki s¹ sprzyjaj¹ce, to dane z pliku zostan¹ wczytane i funkcja zwróci wartoœæ niezerow¹. Pozostaje nam wtedy jeszcze sprawdziæ, czy liczba przeczytanych bajtów, czyli wartoœæ zmiennej pod adresem <SPAN CLASS=T>lpNumberOfBytesRead</SPAN>, jest równa liczbie bajtów, które funkcja MIA£A przeczytaæ. Jeœli tak jest, to wszystko OK, jeœli nie - có¿, nieweso³o, ale ¿eby nie zapeszyæ sytuacji takich nie bêdziemy tutaj omawiaæ ;-).
</P>
<P>
Pora wszystko, co powiedziane zosta³o powy¿ej, pokazaæ na konkretnym przyk³adzie. Oto wczytywanie pliku do bufora:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPSTR Bufor;<BR>
DWORD dwRozmiar, dwPrzeczyt;<BR>
HANDLE hPlik;<BR>
<BR>
hPlik = CreateFile(<SPAN CLASS=L>"test.txt"</SPAN>, GENERIC_READ, <SPAN CLASS=L>0</SPAN>, NULL, OPEN_EXISTING, <SPAN CLASS=L>0</SPAN>, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(hPlik == INVALID_HANDLE_VALUE)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Nie mo¿na otworzyæ pliku."</SPAN>, <SPAN CLASS=L>"A to pech!"</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
dwRozmiar = GetFileSize(hPlik, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(dwRozmiar == <SPAN CLASS=L>0xFFFFFFFF</SPAN>)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Nieprawid³owy rozmiar pliku!"</SPAN>, <SPAN CLASS=L>"Niedobrze..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
Bufor = (LPSTR)GlobalAlloc(GPTR, dwRozmiar+<SPAN CLASS=L>1</SPAN>);<BR>
<SPAN CLASS=K>if</SPAN>(Bufor == NULL)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Za ma³o pamiêci!"</SPAN>, <SPAN CLASS=L>"Ale wiocha..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(!ReadFile(hPlik, Bufor, dwRozmiar, &dwPrzeczyt, NULL))<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"B³¹d czytania z pliku"</SPAN>, <SPAN CLASS=L>"Dupa blada!"</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
Bufor[dwRozmiar] = <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//dodaj zero na koñcu stringa</SPAN><BR>
SetWindowText(hwnd, Bufor); <SPAN CLASS=C>//zrób coœ z tekstem, np. wyœwietl go</SPAN><BR>
<BR>
GlobalFree(Bufor); <SPAN CLASS=C>//Zwolnij bufor</SPAN><BR>
CloseHandle(hPlik); <SPAN CLASS=C>//Zamknij plik</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, w przyk³adzie a¿ roi siê od rozmaitych <SPAN CLASS=K>if</SPAN>-ów, które pilnuj¹, ¿eby nam jakiœ straszliwy error siê nie zdarzy³. Zabawa z plikami to bowiem jak mecz mi³ki no¿nej na polu minowym - gdzie siê nie ruszysz, tam coœ mo¿na spieprzyæ, dlatego nale¿y zachowaæ najwy¿sz¹ ostro¿noœæ. 
</P>

<H2>
2. Zapis do pliku
</H2>

<P>
Ktoœ musi zapisywaæ, by odczytywaæ móg³ ktoœ. No wiêc teraz poka¿emy sobie, jak wrzuciæ dane do pliku. Stwórzmy sobie jakieœ pole tekstowe, w które bêdzie mo¿na powpisywaæ jakieœ g³upoty, które potem powêdruj¹ do pliku. Generalnie zasady s¹ bardzo podobne do odczytu, tzn. plik trzeba najpierw otworzyæ. Tym razem u¿yjemy flagi <SPAN CLASS=T>CREATE_ALWAYS</SPAN>, która... Nie, nie tworzy podpaski ze skrzyde³kami. Jeœli ustawimy tê flagê, bêdzie utworzony nowy plik, a jeœli plik o podanej nazwie ju¿ istnieje, zostanie wyzerowany.
</P>
<P>
Jak siê zapewne domyœlasz, trzeba te¿ bêdzie zamieniæ flagê <SPAN CLASS=T>GENERIC_READ</SPAN> na <SPAN CLASS=T>GENERIC_WRITE</SPAN>. Wreszcie, nale¿y uwzglêdniæ wspó³dzielenie pliku - generalnie najbezpieczniej nie dawaæ innym procesom dostêpu do pliku, kiedy akurat coœ do niego zapisujemy, wiêc ustawiamy odpowiedni argument na <SPAN CLASS=L>0</SPAN>.
</P>
<P>
Pobieranie rozmiaru pliku tym razem nam odpada, ze zrozumia³ych powodów. Bufor na tekst nadal jednak musimy sobie utworzyæ. Skopiujemy do niego tekst z pola tekstowego przy pomocy funkcji <SPAN CLASS=T>GetWindowText</SPAN>. Zanim jednak skopiujemy i zanim utworzymy bufor, musimy znaæ d³ugoœæ tekstu. I tutaj z kolei przyda nam siê funkcja <SPAN CLASS=T>GetWindowTextLength</SPAN>.
</P>
<P>
Funkcja zapisuj¹ca dane do pliku nazywa siê oczywiœcie <SPAN CLASS=T>WriteFile</SPAN> i ma w³aœciwie identyczn¹ sk³adniê co <SPAN CLASS=T>ReadFile</SPAN>. Dlatego te¿ nie bêdê siê powtarza³ i przejdê od razu do przyk³adu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPSTR Bufor;<BR>
DWORD dwRozmiar, dwZapisane;<BR>
HANDLE hPlik;<BR>
<BR>
hPlik = CreateFile(<SPAN CLASS=L>"test.txt"</SPAN>, GENERIC_WRITE, <SPAN CLASS=L>0</SPAN>, NULL, CREATE_ALWAYS, <SPAN CLASS=L>0</SPAN>, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(hPlik == INVALID_HANDLE_VALUE)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Nie mo¿na otworzyæ pliku."</SPAN>, <SPAN CLASS=L>"A to pech!"</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
dwRozmiar = GetWindowTextLength(hwnd);<BR>
<SPAN CLASS=K>if</SPAN>(dwRozmiar == <SPAN CLASS=L>0</SPAN>)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Nieprawid³owy rozmiar pliku!"</SPAN>, <SPAN CLASS=L>"Niedobrze..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
Bufor = (LPSTR)GlobalAlloc(GPTR, dwRozmiar+<SPAN CLASS=L>1</SPAN>);<BR>
<SPAN CLASS=K>if</SPAN>(Bufor == NULL)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Za ma³o pamiêci!"</SPAN>, <SPAN CLASS=L>"Ale wiocha..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
GetWindowText(hwnd, Bufor, dwRozmiar); <SPAN CLASS=C>//skopiuj do bufora tekst z jakiegoœ okna</SPAN><BR>
Bufor[dwRozmiar] = <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//dodaj zero na koñcu stringa</SPAN><BR>
<BR>
<SPAN CLASS=K>if</SPAN>(!WriteFile(hPlik, Bufor, dwRozmiar, &dwZapisane, NULL))<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"B³¹d zapisu do pliku"</SPAN>, <SPAN CLASS=L>"Dupa blada!"</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>); <SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
}<BR>
<BR>
GlobalFree(Bufor); <SPAN CLASS=C>//Zwolnij bufor</SPAN><BR>
CloseHandle(hPlik); <SPAN CLASS=C>//Zamknij plik</SPAN><BR>
</TD></TR>
</TABLE>

<H2>
3. Pomocne funkcje
</H2>

<H3>
3.1 Atrybuty plików
</H3>

<P>
Mo¿emy ³atwo sprawdziæ atrybuty pliku o podanej nazwie, wykorzystuj¹c funkcjê <SPAN CLASS=T>GetFileAttributes</SPAN>. Zwraca ona liczbê typu <SPAN CLASS=T>DWORD</SPAN>. Mo¿e ona byæ równa <SPAN CLASS=L>0xFFFFFFFF</SPAN> (co nie oznacza nic dobrego), albo te¿ przyj¹æ jedn¹ z nastêpuj¹cych wartoœci (mog¹ one byæ ³¹czone):
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_ARCHIVE</TD><TD CLASS=ARGLIST>Atrybut 'Archiwalny' - oznacza siê nim pliki lub katalogi, które poddane maj¹ byæ backup'owi.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_COMPRESSED</TD><TD CLASS=ARGLIST>Dla pliku oznacza, ¿e dane w nim s¹ skompresowane, dla katalogu - ¿e wszystkie nowe pliki tworzone w tym katalogu maj¹ byæ domyœlnie kompresowane.</TD></TR> 
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_DIRECTORY</TD><TD CLASS=ARGLIST>Cytuj¹c MSDN: "Plik lub katalog" jest katalogiem :-).</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_HIDDEN</TD><TD CLASS=ARGLIST>Plik lub katalog jest ukryty.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_NORMAL</TD><TD CLASS=ARGLIST>Taki zupe³nie zwyczajny plik lub katalog, bez ¿adnych innych atrybutów.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_OFFLINE</TD><TD CLASS=ARGLIST>Oznacza, ¿e plik jest przechowywany offline i nie jest dostêpny natychmiastowo.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_READONLY</TD><TD CLASS=ARGLIST>Plik lub katalog jest przeznaczony tylko do odczytu, aplikacje nie mog¹ go modyfikowaæ ani usun¹æ.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_SYSTEM</TD><TD CLASS=ARGLIST>Plik lub katalog jest czêœci¹ systemu operacyjnego, czyli tylko kumple Billa lub prawdziwi hakerzy wiedz¹, co jest w œrodku i jak w tym grzebaæ.</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_ATTRIBUTE_TEMPORARY</TD><TD CLASS=ARGLIST>Plik tymczasowy, powinien byæ usuniêty natychmiast w momencie, kiedy przestaje byæ potrzebny.</TD></TR>
</TABLE>
 
<P>
Dla wœcibskich: tak, istnieje funkcja <SPAN CLASS=T>SetFileAttributes</SPAN>. Pobiera ona dwa argumenty, tj. nazwê pliku i zmienn¹ typu <SPAN CLASS=T>DWORD</SPAN>, zawieraj¹c¹ dowoln¹ (prawie) kombinacjê powy¿szych sta³ych, zale¿nie jakie atrybuty chcemy ustawiæ. Zwraca <SPAN CLASS=K>true</SPAN> jeœli siê uda, <SPAN CLASS=K>false</SPAN> jeœli nie. Nie mo¿na ustawiaæ atrybutu <SPAN CLASS=T>FILE_ATTRIBUTE_COMPRESSED</SPAN> (tzn. b³¹d siê nie pojawi, ale te¿ taka operacja nie skompresuje pliku).
</P>

<H3>
3.2 Data i czas pliku
</H3>

<P>
Czasami mo¿e siê przydaæ informacja, kiedy dany plik zosta³ utworzony, zmodyfikowany lub w ogóle ostatnio u¿ywany. I na pewno nie zgadniesz, jaka funkcja zdobêdzie dla nas tak¹ informacjê - ano, <SPAN CLASS=T>GetFileTime</SPAN>. W przeciwieñstwie do funkcji pobieraj¹cej lub ustawiaj¹cej atrybuty, ta mo¿e operowaæ wy³¹cznie na plikach ju¿ otwartych, i to, co wiêcj, otwartych do odczytu (<SPAN CLASS=T>GENERIC_READ</SPAN>). 
</P>
<P>
Sk³adnia jest taka:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: BOOL GetFileTime(<I>hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>hFile</TD><TD CLASS=ARGLIST>Uchwyt pliku</TD></TR>
<TR><TD CLASS=ARGLIST>lpCreationTime</TD><TD CLASS=ARGLIST>WskaŸnik do struktury, w której funkcja zapisze czas utworzenia pliku</TD></TR>
<TR><TD CLASS=ARGLIST>lpLastAccessTime</TD><TD CLASS=ARGLIST>WskaŸnik do struktury, w której funkcja zapisze czas ostatniego dostêpu do pliku</TD></TR>
<TR><TD CLASS=ARGLIST>lpLastWriteTime</TD><TD CLASS=ARGLIST>WskaŸnik do struktury, w której funkcja zapisze czas ostatniej modyfikacji pliku</TD></TR>
</TABLE>

<P>
Pierwszy argument jest oczywisty, trzy pozosta³e to wskaŸniki do struktur typu <SPAN CLASS=T>FILETIME</SPAN>, przechowuj¹cych informacjê o dok³adnej dacie pliku. Jest to struktura <SPAN CLASS=L>64</SPAN>-bitowa (dwa <SPAN CLASS=L>32</SPAN>-bitowe pola typu <SPAN CLASS=T>DWORD</SPAN>). W MSDN natkn¹³em siê na informacjê, ¿e mo¿e pomieœciæ daty od 1601 roku, ale chyba im siê ta szóstka z dziewi¹tk¹ pomyli³a, bo po co komu XVII wiek w komputerze ;-). W tym samym miejscu twierdz¹ (co ju¿ bardziej prawdopodobne), ¿e dok³adnoœæ czasu przechowywanego w tej strukturze to 100 nanosekund.
</P>
<P>
Nie musimy deklarowaæ wszystkich trzech struktur na raz, jeœli np. potrzebna nam tylko data ostatniej modyfikacji, to podajemy tylko <SPAN CLASS=T>lpLastWriteTime</SPAN>, pozosta³e dwa wskaŸniki ustawiamy na <SPAN CLASS=T>NULL</SPAN>.
</P>
<P>
Jak u¿yæ danych ze struktury <SPAN CLASS=T>FILETIME</SPAN>? Najlepiej przekonwertowaæ j¹ na czas systemowy funkcj¹ <SPAN CLASS=T>FileTimeToSystemTime</SPAN>. Pierwszy jej argument to wskaŸnik do struktury typu <SPAN CLASS=T>FILETIME</SPAN>, drugi - do struktury typu <SPAN CLASS=T>SYSTEMTIME</SPAN>. Wartoœæ zwracana: jak zwykle, czyli <SPAN CLASS=L>0</SPAN> oznacza b³¹d, wartoœæ niezerowa - powodzenie. Struktura <SPAN CLASS=T>SYSTEMTIME</SPAN> jest ju¿ wcale przyjazna w u¿yciu, jej pola to: <SPAN CLASS=T>wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, wMiliseconds</SPAN>. Chyba nie trzeba wiêcej t³umaczyæ... No, mo¿e tylko, ¿e wartoœci wMonth zaczynaj¹ siê od <SPAN CLASS=L>1</SPAN> (co oczywiœcie oznacza styczeñ), natomiast <SPAN CLASS=T>DayOfWeek</SPAN> przyjmuje wartoœci <SPAN CLASS=L>0-6</SPAN>, gdzie <SPAN CLASS=L>0</SPAN> to niedziela, <SPAN CLASS=L>1</SPAN> poniedzia³ek itd.
</P>
<P>
Chcesz sobie zmieniæ datê modyfikacji pliku nie ruszaj¹c zawartych w nim danych ani daty systemowej? Nie ma sprawy, pobaw siê funkcj¹ <SPAN CLASS=T>SetFileTime</SPAN> (sk³adnia analogiczna do <SPAN CLASS=T>GetFileTime</SPAN>). Przyk³adów nie podajê, ¿eby pobudziæ twoj¹ kreatywnoœæ ;-).
</P>

<H2>
3.3 Rozszerzone informacje
</H2>

<P>
Jest taka jedna funkcja-gigant, pobieraj¹ca naraz informacjê o atrybutach pliku, wszystkich datach, rozmiarze i jeszcze kilku innych rzeczach. Zowie siê toto <SPAN CLASS=T>GetFileInformationByHandle</SPAN>. Prawda, ¿e niez³y potworek? Sk³adnia na szczêœcie jest bardzo prosta: pierwszy argument to uchwyt pliku, drugi - wskaŸnik na strukturê typu, tu g³êboki wdech, <SPAN CLASS=T>BY_HANDLE_FILE_INFORMATION</SPAN>. Sk³adniki tej struktury to:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>typedef struct</SPAN> _BY_HANDLE_FILE_INFORMATION<BR>
{<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; dwFileAttributes;<BR>
&nbsp;FILETIME ftCreationTime;<BR>
&nbsp;FILETIME ftLastAccessTime;<BR>
&nbsp;FILETIME ftLastWriteTime;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; dwVolumeSerialNumber;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; nFileSizeHigh;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; nFileSizeLow;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; nNumberOfLinks;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; nFileIndexHigh;<BR>
&nbsp;DWORD&nbsp;&nbsp;&nbsp; nFileIndexLow;<BR>
} BY_HANDLE_FILE_INFORMATION;<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, oprócz wspomnianych rzeczy, mo¿emy jeszcze uzyskaæ: numer seryjny woluminu, do którego przynale¿y nasz plik, liczbê skrótów, jakie siê do niego odwo³uj¹ oraz unikaln¹ liczbê zwi¹zan¹ z plikiem. Ma³o przydatne, ale fajne bajerki ;-).
</P>

<H3>
3.4 Informacje o dysku
</H3>

<P>
Przyda siê jeszcze coœ dla twórców wirusów :-). Najpierw dowiemy siê, jak sprawdziæ, jakie dyski s¹ dostêpne w komputerze. To z kolei rozpoczniemy od ustalenia, jakie literki-okreœlenia dysków s¹ w ogóle prawid³owe. S³u¿y do tego funkcja <SPAN CLASS=T>GetLogicalDrives</SPAN>. Nie ma ona ¿adnych argumentów, a zwraca wartoœæ typu <SPAN CLASS=T>DWORD</SPAN>, której kolejne bity wskazuj¹, czy dana literka jest okreœleniem dysku (pierwszy bit - A, drugi - B itd.). Jeœli wartoœæ zwrócona wynosi <SPAN CLASS=L>0</SPAN>, to, jak siê domyœlamy, nic dobrego ;-).
</P>
<P>
Jeœli nie chce nam siê grzebaæ w bitach, mamy alternatywê w postaci funkcji <SPAN CLASS=T>GetLogicalDriveStrings</SPAN>. Jeœli podamy jej rozmiar i adres bufora znaków, to ona wype³ni go wszystkimi dostêpnymi literkami dysków, porozdzielanymi przez znaki zerowe, a na koñcu tej wyliczanki postawi podwójny znak zerowy. Oto jak wykorzystaæ taki buforek do wypisania wszystkich literek na ekranie (przyk³ad wymaga w³¹czenia konsoli w opcjach kompilatora):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;<BR>
#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>const</SPAN> WORD nBufferSize = <SPAN CLASS=L>40</SPAN>;<BR>
LPSTR Bufor = (LPSTR)GlobalAlloc(GPTR, nBufferSize);<BR>
WORD Wymagane, i=<SPAN CLASS=L>0</SPAN>, flaga=<SPAN class=L>0</SPAN>;<BR>
<BR>
Wymagane = GetLogicalDriveStrings(nBufferSize, Bufor);<BR>
<SPAN CLASS=K>if</SPAN>(Wymagane &gt; nBufferSize)<BR>
{<BR>
&nbsp;cout << <SPAN CLASS=L>"Za maly bufor, potrzeba "</SPAN> << Wymagane << <SPAN CLASS=L>" bajtow."</SPAN> << endl;<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
}<BR>
cout << <SPAN CLASS=L>"Dostepne dyski:"</SPAN> << endl;<BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;koniec = <span class=L>0</span>;<br>
&nbsp;<SPAN CLASS=K>if</SPAN>(Bufor[i] != <SPAN CLASS=L>0</SPAN>) cout << Bufor[i];<BR>
&nbsp;<SPAN CLASS=K>else</SPAN> { cout << endl; flaga=<span class=L>0</span>; } <BR>
}<BR>
<SPAN CLASS=K>while</SPAN>(Bufor[++i] != <SPAN CLASS=L>0</SPAN> || flaga);<BR>
<BR>
GlobalFree(Bufor);<BR>
<BR>
system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Skoro mamy ju¿ literkê danego dysku, mo¿emy siê jeszcze dowiedzieæ, jakiego typu jest to dysk (sta³y, wymienny, CD-ROM, dysk sieciowy, RAM-dysk...). Za³atwimy to funkcj¹ <SPAN CLASS=T>GetDriveType</SPAN>. Ma ona tylko jeden argument, którym jest katalog g³ówny naszego dysku, czyli w³aœnie literka, któr¹ uzyskaliœmy w powy¿szym przyk³adzie z dwukropkiem na koñcu, mo¿e te¿ byæ jeszcze z beksleszem. <SPAN CLASS=T>GetDriveType</SPAN> zwraca jedn¹ z nastêpuj¹cych wartoœci:
</P>

<TABLE WIDTH=100%>
</TD></TR>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>DRIVE_UNKNOWN</TD><TD CLASS=ARGLIST>Nie mo¿na okreœliæ typu dysku</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_NO_ROOT_DIR</TD><TD CLASS=ARGLIST>Podano b³êdny argument (taki katalog g³ówny nie istnieje)</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_REMOVABLE</TD><TD CLASS=ARGLIST>Dysk wymienny</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_FIXED</TD><TD CLASS=ARGLIST>Dysk sta³y (zwyk³y twardy dysk)</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_REMOTE</TD><TD CLASS=ARGLIST>Dysk sieciowy</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_CDROM</TD><TD CLASS=ARGLIST>To ci dopiero zagadka ;-)</TD></TR>
<TR><TD CLASS=ARGLIST>DRIVE_RAMDISK</TD><TD CLASS=ARGLIST>RAM-dysk</TD></TR>
</TABLE>

<P>
Oczywiœcie stacje dyskietek podchodz¹ pod <SPAN CLASS=T>DRIVE_REMOVABLE</SPAN>, a nagrywarki - pod <SPAN CLASS=T>DRIVE_CDROM</SPAN>. 
</P>
<P>
SprawdŸmy sobie jeszcze, ile mamy miejsca na dysku. Mo¿na to zrobiæ funkcj¹ <SPAN CLASS=T>GetDiskFreeSpace</SPAN> lub <SPAN CLASS=T>GetDiskFreeSpaceEx</SPAN>. W bardzo starych Windowsach ta pierwsza mo¿e nawaliæ, jeœli zastosowaæ j¹ do dysku wiêkszego ni¿ 2 GB, ale na moim poczciwym 98 dzia³a bez zarzutu. Sk³adnia jest taka:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: BOOL GetDiskFreeSpace(<I>lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>lpRootPathName</I></TD><TD CLASS=ARGLIST>Katalog g³ówny dysku (literka dysku, wraz z dwukropkiem i ewentualnie beksleszem)</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpSectorsPerCluster</I></TD><TD CLASS=ARGLIST>Adres zmiennej, do której funkcja zapisze liczbê sektorów w 1 klastrze</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpBytesPerSector</I></TD><TD CLASS=ARGLIST>Adres zmiennej, do której funkcja zapisze liczbê bajtów w 1 sektorze</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpNumberOfFreeClusters</I></TD><TD CLASS=ARGLIST>Adres zmiennej, do której funkcja zapisze liczbê wolnych klastrów</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpTotalNumberOfClusters</I></TD><TD CLASS=ARGLIST>Adres zmiennej, do której funkcja zapisze liczbê wszystkich klastrów na dysku</TD></TR>
</TABLE> 

<P>
Pierwszy argument jest chyba oczywiste, cztery pozosta³e to wskaŸniki do 4 zmiennych typu <SPAN CLASS=T>DWORD</SPAN>, do których funkcja wpisze odpowiednie informacje. Po wywo³aniu funkcji i ewentualnym sprawdzeniu, czy zwróci³a <SPAN CLASS=K>true</SPAN>, mo¿emy ju¿ skorzystaæ z wyników. Tylko po kiego diab³a nam wiedzieæ, ile klastrów ma nasz dysk? Chcemy bajty! Wiemy, ile sektorów przypada na 1 klaster, wiemy te¿, ile sektor ma bajtów, wreszcie wiemy, ile mamy wszystkich klastrów na dysku i ile z nich jest wolnych. Wystarczy wiêc pomno¿yæ odpowiednie zmienne i mamy, co chcieliœmy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;<BR>
#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
DWORD Sektory, Bajty, Wolne, Klastry;<BR>
<SPAN CLASS=K>if</SPAN>(GetDiskFreeSpace(<SPAN CLASS=L>"c:\"</SPAN>, &Sektory, &Bajty, &Wolne, &Klastry))<BR>
{<BR>
&nbsp;cout << <SPAN CLASS=L>"Dysk C: ma "</SPAN> << Sektory*Bajty*Klastry << <SPAN CLASS=L>" bajtow, z tego "</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; << Sektory*Bajty*Wolne << <SPAN CLASS=L>" wolnych."</SPAN> << endl;<BR>
}<BR>
<BR>
system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Wspomniana funkcja <SPAN CLASS=T>GetDiskFreeSpaceEx</SPAN> jest trochê bardziej skomplikowana w u¿yciu, poniewa¿ wymaga Windowsa 95 w wersji <SPAN CLASS=Wazne>OSR 2</SPAN>, a wiêc trzeba przed jej wywo³aniem sprawdziæ wersjê systemu, potem za³adowaæ bibliotekê kernel32.dll, nastêpnie pobraæ adres funkcji i dopiero wtedy j¹ wywo³aæ. Szkoda tu miejsca na takie manewry, ale postaram siê pokazaæ to przy innej okazji.
</P>

<H3>
3.5 Kopiowanie, przenoszenie, usuwanie...
</H3>

<P>
Teraz dla rozluŸnienia pobawimy siê w mened¿era plików. Najpierw sprawdzimy, w jakim katalogu aktualnie jesteœmy. Funkcja <SPAN CLASS=T>GetCurrentDirectory</SPAN> wymaga podania bufora wraz z maksymalnym rozmiarem (tak jak <SPAN CLASS=T>GetLogicalDriveStrings</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#include &lt;windows.h&gt;<BR>
#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR>
</SPAN>
<BR>
<SPAN CLASS=K>const</SPAN> WORD dl = <SPAN CLASS=L>255</SPAN>;<BR>
LPSTR Bufor = (LPSTR)GlobalAlloc(GPTR, dl);<BR>
<BR>
GetCurrentDirectory(dl, Bufor);<BR>
cout << <SPAN CLASS=L>"Jestesmy w "</SPAN> << Bufor << endl;<BR>
<BR>
GlobalFree(Bufor);<BR>
system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
W podobny sposób dzia³aj¹ funkcje <SPAN CLASS=T>GetWindowsDirectory</SPAN> oraz <SPAN CLASS=T>GetSystemDirectory</SPAN>, przeznaczenia których bez w¹tpienia sam siê domyœlasz.
</P>
<P>
Kopiowaniem plików zajmuje siê funkcja, jak¿e by inaczej, <SPAN CLASS=T>CopyFile</SPAN>. Argumenty to:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: BOOL CopyFile(<I>lpSrcFileName, lpDstFileName, bFailIfExists</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>lpSrcFileName</I></TD><TD CLASS=ARGLIST>Nazwa pliku (mo¿e byæ ze œcie¿k¹)</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpDstFileName</I></TD><TD CLASS=ARGLIST>Nazwa pliku, do którego kopiujemy (mo¿e zawieraæ inn¹ œcie¿kê, ni¿ œcie¿ka do pliku ¿ród³owego)</TD></TR>
<TR><TD CLASS=ARGLIST><I>bFailIfExists</I></TD><TD CLASS=ARGLIST>Flaga okreœlaj¹ca co robiæ, jeœli podany plik istnieje</TD></TR>
</TABLE>
 
<P>
Pierwszych dwóch nie muszê chyba omawiaæ. Ostatni to flaga okreœlaj¹ca, co robiæ w wypadku, gdy plik docelowy ju¿ istnieje. Jeœli w takim wypadku ustawione jest <SPAN CLASS=T>TRUE</SPAN>, to funkcja nawala (zwraca <SPAN CLASS=L>0</SPAN>), natomiast jeœli <SPAN CLASS=T>FALSE</SPAN>, to nadpisuje (niszczy) istniej¹cy plik i zwraca wartoœæ niezerow¹. 
</P>
<P>
Przenoszenie lub zmiana nazwy plików to zadanie funkcji <SPAN CLASS=T>MoveFile</SPAN>. Ta ma tylko dwa argumenty, takie same, jak dwa pierwsze funkcji <SPAN CLASS=T>CopyFile</SPAN>. Œcie¿ka podana jako drugi argument NIE MO¯E istnieæ w chwili wywo³ania funkcji. Mo¿emy przenosiæ pliki na inny dysk, ale katalogi mo¿na przenosiæ tylko w obrêbie tego samego dysku. Jeœli chcesz zast¹piæ istniej¹cy plik, musisz u¿yæ innej funkcji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
MoveFileEx(Plik, PlikDoZastapienia, MOVEFILE_REPLACE_EXISTING);<BR>
</TD></TR>
</TABLE>

<P>
Kasowania plików móg³byœ siê bez trudu domyœliæ sam - funkcja <SPAN CLASS=T>DeleteFile</SPAN>, jedyny argument to nazwa pliku do skasowania. Równie proste jest tworzenie katalogów (funkcja <SPAN CLASS=T>CreateDirectory</SPAN>, argumenty: nazwa, <SPAN CLASS=T>NULL</SPAN>) oraz ich usuwanie (<SPAN CLASS=T>RemoveDirectory</SPAN>, nazwa). Ta ostatnia usuwa jedynie puste katalogi, coœ jak komenda rmdir w DOS-ie. Praca domowa - przeæwiczyæ samodzielnie ;-).
</P>

<H3>
3.6 WskaŸnik pliku
</H3>

<P>
S¹ dwa rodzaje dostêpu do danych, w tym tak¿e danych w pliku: <SPAN CLASS=Wazne>sekwencyjny</SPAN> i <SPAN CLASS=Wazne>swobodny</SPAN>. Dostêp sekwencyjny oznacza, ¿e musimy czytaæ wszystkie bajty pliku po kolei, a¿ dotrzemy do tego, który nas interesuje. Dostêp swobodny pozwala "przeskoczyæ" zbêdne bajty i odczytaæ od razu tê "w³aœciw¹" czêœæ pliku. U³atwia nam to tzw. <SPAN CLASS=T>wskaŸnik pliku</SPAN> (file pointer). Nie ma on nic wspólnego ze wskaŸnikami C++, po prostu jest to numer bajtu, na którym zakoñczyliœmy czytanie lub zapis. Jeœli czytamy sekwencyjnie, nie musimy siê o niego martwiæ. Jeœli chcemy przestawiæ wskaŸnik pliku, u¿ywamy funkcji <SPAN CLASS=T>SetFilePointer</SPAN>:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: DWORD SetFilePointer(<I>hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>hFile</TD><TD CLASS=ARGLIST>Uchwyt pliku</TD></TR>
<TR><TD CLASS=ARGLIST>lDistanceToMove</TD><TD CLASS=ARGLIST>Liczba bajtów, o które chcemy przesun¹æ wskaŸnik</TD></TR>
<TR><TD CLASS=ARGLIST>lpDistanceToMoveHigh</TD><TD CLASS=ARGLIST>Adres górnego s³owa dystansu, o który przesuwamy wskaŸnik</TD></TR>
<TR><TD CLASS=ARGLIST>dwMoveMethod</TD><TD CLASS=ARGLIST>Sposób w jaki przesuwamy wskaŸnik (tj. wzglêdem czego to robimy)</TD></TR>
</TABLE>
 
<P>
Argument <SPAN CLASS=T>lpDistanceToMoveHigh</SPAN> mo¿emy sobie darowaæ (tzn. ustawiæ na <SPAN CLASS=T>NULL</SPAN>), ale wtedy mo¿emy operowaæ na plikach mniejszych, ni¿ jakieœ 4 GB (patrz funkcja <SPAN CLASS=T>GetFileSize</SPAN> na górze tej czêœci kursu). W przeciwnym wypadku argument ten wskazuje na dodatkow¹ zmienn¹ typu <SPAN CLASS=T>LONG</SPAN>, zawieraj¹c¹ resztê liczby (wtedy funkcja mo¿e sobie operowaæ na plikach do <SPAN CLASS=L>18446744</SPAN> terabajtów (!)). Ostatni argument okreœla miejsce, wzglêdem którego liczymy bajty, o które przestawiamy wskaŸnik. 
</P>
 

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>FILE_BEGIN</TD><TD CLASS=ARGLIST>Przesuwamy wskaŸnik wzglêdem pocz¹tku pliku (podana wartoœæ DistanceToMove jest de facto nowym po³o¿eniem wskaŸnika)</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_CURRENT</TD><TD CLASS=ARGLIST>Przesuwamy wskaŸnik wzglêdem jego aktualnej pozycji</TD></TR>
<TR><TD CLASS=ARGLIST>FILE_END</TD><TD CLASS=ARGLIST>Przesuwamy wskaŸnik wzglêdem koñca pliku</TD></TR>
</TABLE>
 
<P>
Funkcja powinna zwróciæ now¹ wartoœæ wskaŸnika, przy czym z oczywistych powodów tak naprawdê zwraca tylko podwójne s³owo tej wartoœci (pierwsz¹ po³owê), co daje oczekiwany wynik tylko wtedy, kiedy ustawiliœmy <SPAN CLASS=T>lpDistanceToMoveHigh</SPAN> na <SPAN CLASS=T>NULL</SPAN>. Natomiast zwrócenie wartoœci <SPAN CLASS=L>0xFFFFFFFF</SPAN> (czyli maksymalnej wartoœci dla typu <SPAN CLASS=T>DWORD</SPAN>) oznacza b³¹d.
</P>
<P>
Tyle o plikach, gdyby ktoœ chcia³ wiedzieæ coœ wiêcej, mo¿e mejlowaæ - w koñcu trzeba trochê zape³niaæ dzia³ FAQ, no nie?
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apievnt.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apigraf.html">Nastêpna czêœæ kursu >></A>
</TD>
</TR>
</TABLE>
