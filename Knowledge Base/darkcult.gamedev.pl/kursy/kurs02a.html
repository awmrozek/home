<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, podstawowe konstrukcje, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs02.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs03.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Krótszy if - operator wyra¿enia warunkowego
</H2>

<P>
Teraz coœ dla lubi¹cych skróty. Z punktu widzenia programisty dosyæ g³upie jest pisanie instrukcji warunkowej w stylu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(licznik==<SPAN CLASS=L>7</SPAN>) a=<SPAN CLASS=L>4</SPAN>;<BR>
<SPAN CLASS=K>else</SPAN> a=<SPAN CLASS=L>8</SPAN>;
</TD></TR>
</TABLE>

<P>
W obu powy¿szych przypadkach przypisujemy liczbê do <SPAN CLASS=T>a</SPAN>, tylko ¿e w ka¿dym przypadku inn¹. Wa¿ne jest jednak to, ¿e operacja dla kompilatora jest identyczna, wiêc po co pisaæ to dwa razy? Twórcy C++, niech chwa³a im bêdzie po wieki, zadbali o nasze umêczone paluszki i wprowadzili do tego jêzyka fajny operator. Jest to jedyny w C++ operator <NOBR>3-argumentowy</NOBR> - <SPAN CLASS=T>?:</SPAN>. Powy¿szego <SPAN CLASS=K>if</SPAN>-a mo¿emy zast¹piæ w taki sposób - wykorzystuj¹c nasz nowy, porêczny operatorek:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
a = licznik == <SPAN CLASS=L>7</SPAN> ? <SPAN CLASS=L>4</SPAN> : <SPAN CLASS=L>8</SPAN>;
</TD></TR>
</TABLE>

<P>
Heh, niewiele tu widaæ. Ale od czego s¹ nawiasy, których mo¿emy tu wchrzaniæ, ile tylko siê da, oby tylko siê nie pogubiæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
a = (licznik==<SPAN CLASS=L>7</SPAN>)  ?  (<SPAN CLASS=L>4</SPAN>) : (<SPAN CLASS=L>8</SPAN>);
</TD></TR>
</TABLE>

<P>
No, trochê lepiej. Teraz chyba wszystko jasne - kompilator wartoœciuje wyra¿enie <SPAN CLASS=T>licznik==</SPAN><SPAN CLASS=L>7</SPAN>, jeœli jest ono prawdziwe (ró¿ne od zera), to ca³e wyra¿enie po znaku przypisania <SPAN CLASS=T>=</SPAN> przymuje wartoœæ <SPAN CLASS=L>4</SPAN>; w przeciwnym wypadku bêdzie równe <SPAN CLASS=L>8</SPAN>. Warto zauwa¿yæ, ¿e w razie gdyby jedno z alternatywnych wyra¿eñ, podanych po znaku <SPAN CLASS=T>?</SPAN> by³o bardziej skomplikowane, np. w miejscu <SPAN CLASS=L>4</SPAN> by³oby <SPAN CLASS=T>zmienna + </SPAN><SPAN CLASS=L>4</SPAN>, wyra¿enie to bêdzie obliczane TYLKO w wypadku, jeœli warunek jest prawdziwy, co pozwala oszczêdziæ prockowi wysi³ku, czyli przyspiesza program.
</P>
<P>
No i fajnie jest :-).
</P>

<H2>
Nie tylko dla desperatów - pêtle
</H2>

<P>
Czy naprawdê jest a¿ tak fajnie? No to zastanówcie siê, co by te¿ by³o, gdyby na przyk³ad Windows, po wpisaniu b³êdnego has³a koñczy³ pracê i trzeba by go by³o uruchamiaæ drugi raz (na marginesie: a¿ dziwne, ¿e tak nie jest, znaj¹c upodobania Billa i jego kumpli do utrudniania nam ¿ycia). Ojojoj. No w³aœnie. Nie mo¿emy byæ a¿ tacy podli dla userów. User te¿ cz³owiek, ostatecznie. Dlatego te¿ warto by by³o na przysz³oœæ stosowaæ tak¹ sztuczkê, ¿eby np. pisz¹c programik z dniami tygodnia, prosiæ usera a¿ do znudzenia o wpisanie liczby <SPAN CLASS=L>1-7</SPAN>, w koñcu nawet najbardziej upartemu znudzi siê wpisywanie nieprawid³owych wartoœci :-). Jak robiæ powtarzanie do znudzenia? Ot, tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê: \n"</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &liczba);<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>((liczba<<SPAN CLASS=L>1</SPAN>) || (liczba><SPAN CLASS=L>7</SPAN>));
</TD></TR>
</TABLE>

<P>
S³owo <SPAN CLASS=K>do</SPAN> informuje kompilator, ¿e nastêpuj¹cy po nim blok instrukcji ma byæ powtórzony; po s³owie <SPAN CLASS=K>while</SPAN> w nawiasie podany jest warunek wykonywania kolejnego powtórzenia. Jeœli warunek ten nie jest spe³niony (ma wartoœæ <SPAN CLASS=L>0</SPAN>), kolejne powtórzenie nie jest wykonywane i program idzie dalej (to znaczy, ¿e user siê znudzi³ i wpisa³ dobr¹ wartoœæ :-) ). Podobne dzia³anie bêdzie mia³a pêtla:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>while</SPAN>((liczba<<SPAN CLASS=L>1</SPAN>) || (liczba><SPAN CLASS=L>7</SPAN>));<BR>
{<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê: \n"</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &liczba);<BR>
}
</TD></TR>
</TABLE>

<P>
Ró¿nica polega na tym (oprócz braku s³owa <SPAN CLASS=K>do</SPAN>), ¿e tutaj warunek jest sprawdzany PRZED wykonaniem powtórzenia. Dlatego te¿ jeœli zmienna <SPAN CLASS=T>liczba</SPAN> nie zosta³aby w powy¿szym przyk³adzie zainicjalizowana wartoœci¹ spoza zakresu <SPAN CLASS=L>1-7</SPAN> PRZED dojœciem kompilatora do instrukcji <SPAN CLASS=K>while</SPAN>, program w ogóle nie poprosi³by usera o podanie liczby.
<BR><BR>
Pêtla <SPAN CLASS=K>while</SPAN> (i <SPAN CLASS=K>do-while</SPAN>) jest owszem, fajna, ale jeœli chcielibyœmy powtórzyæ dan¹ instrukcjê OKREŒLON¥ liczbê razy, by³oby ma³o elegancko (a wszak elegancja to wa¿na rzecz w programowaniu :-) ):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> licznik=<SPAN CLASS=L>0</SPAN>;<BR>
<BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;licznik++;<BR>
&nbsp;printf(<SPAN CLASS=L>"%d\n"</SPAN>, licznik);<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>(licznik<<SPAN CLASS=L>10</SPAN>);
</TD></TR>
</TABLE>

<P>
Przyk³ad ten s³u¿y wypisaniu liczb od <SPAN CLASS=L>1</SPAN> do <SPAN CLASS=L>10</SPAN> na ekranie. Niezbyt wznios³y cel, ale nie czepiajmy siê ;-). A oto identyczne zadanie wykonane przez pêtlê <SPAN CLASS=K>for</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> licznik=<SPAN CLASS=L>1</SPAN>; licznik<=<SPAN CLASS=L>10</SPAN>; licznik++) printf(<SPAN CLASS=L>"%d\n"</SPAN>, licznik);
</TD></TR>
</TABLE>

<P>
Krócej, ³adniej i przyjemniej :-). Tylko teraz musimy to rozszyfrowaæ... Argumenty instrukcji <SPAN CLASS=K>for</SPAN> s¹ trzy; pierwszy z nich to instrukcja inicjalizuj¹ca <SPAN CLASS=Wazne>licznik pêtli</SPAN>. W C++ dopuszcza siê równie¿ zadeklarowanie w tym miejscu zupe³nie nowej zmiennej (o zasiêgu ograniczonym do danej pêtli <SPAN CLASS=K>for</SPAN>), tak jak to uczyni³em powy¿ej. Argument drugi to warunek, który jeœli jest spe³niony, pozwala na wykonanie instrukcji nastêpuj¹cych po nawiasach (w tym przypadku jedna instrukcja - <SPAN CLASS=T>printf</SPAN>). Wreszcie instrukcja zwiêkszenia licznika, która zazwyczaj ma postaæ w³aœnie tak¹, jak w przyk³adzie. PrzeœledŸmy teraz, jaki jest "plan dzia³ania" naszej pêtelki:
</P>

<OL>
<LI>Zadeklaruj zmienn¹ <SPAN CLASS=T>licznik</SPAN> i zainicjalizuj j¹ wartoœci¹ <SPAN CLASS=L>1</SPAN>
<LI>SprawdŸ, czy <SPAN CLASS=T>licznik<=</SPAN><SPAN CLASS=L>10</SPAN>. Jeœli tak, to przejdŸ do punktu 3, jeœli nie - opuœæ pêtlê
<LI>Wykonaj instrukcjê (<SPAN CLASS=T>printf</SPAN>)
<LI>Zwiêksz <SPAN CLASS=T>licznik</SPAN> o <SPAN CLASS=L>1</SPAN>
<LI>Wróæ do punktu 2.
</OL>

<P>
Pêtle (zarówno poznane wczeœniej <SPAN CLASS=K>do-while</SPAN> i <SPAN CLASS=K>while</SPAN>, jak i <SPAN CLASS=K>for</SPAN>) mo¿emy zagnie¿d¿aæ (robiæ jedn¹ pêtlê wewn¹trz drugiej) i czêsto siê to stosuje. Mo¿na wykorzystaæ zagnie¿d¿one pêtle np. do wyœwietlenia tabliczki mno¿enia:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> y=<SPAN CLASS=L>1</SPAN>; y<=<SPAN CLASS=L>10</SPAN>; y++)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>1</SPAN>; x<=<SPAN CLASS=L>10</SPAN>; x++) printf(<SPAN CLASS=L>"%3d"</SPAN>, x*y);<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"\n"</SPAN>);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
Ktoœ uwa¿ny móg³by siê skapowaæ, ¿e zamiast zwyk³ego <SPAN CLASS=L>%d</SPAN> w instrukcji <SPAN CLASS=T>printf</SPAN> wpisaliœmy <SPAN CLASS=L>%3d</SPAN>. Oznacza to, ¿e nie wypisujemy po prostu samej liczby, tylko liczbê z tak¹ iloœci¹ spacji, aby ³¹czna d³ugoœæ wypisywanego przez <SPAN CLASS=T>printf</SPAN> ³añcucha wynosi³a <SPAN CLASS=L>3</SPAN>, np. jeœli wypisujemy liczbê <SPAN CLASS=L>9</SPAN>, doklejane s¹ do niej dwie spacje, jeœli <SPAN CLASS=L>15</SPAN> - jedna spacja, jeœli <SPAN CLASS=L>100</SPAN> - nie dopisuje siê ¿adna spacja.
<BR><BR>
Jak ju¿ wiemy, pêtla <SPAN CLASS=K>while</SPAN>/<SPAN CLASS=K>do-while</SPAN> jest wykonywana, dopóki podany w nawiasie warunek jest spe³niony; podobnie z pêtl¹ <SPAN CLASS=K>for</SPAN>. Mo¿emy jednak wymusiæ opuszczenie pêtli w przypadku, gdy jest to konieczne. Robimy to znan¹ ju¿ instrukcj¹ <SPAN CLASS=K>break</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(c=<SPAN CLASS=L>0</SPAN>; c&lt;max_c; c+=<SPAN CLASS=L>2</SPAN>)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(c==a) dlugosc=c;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(sprawdz_klawisze()) <SPAN CLASS=K>break</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Pokazany przeze mnie przypadek u¿ycia <SPAN CLASS=K>for</SPAN> to tylko niewielki fragment mo¿liwoœci, jakie daje nam ten rodzaj pêtli w C++. Chyba w ¿adnym innym jêzyku pêtla typu <SPAN CLASS=K>for</SPAN> nie jest tak bardzo rozbudowana. Zacznijmy od tego, ¿e zmienna u¿ywana jako licznik wcale nie musi byæ deklarowana w instrukcji <SPAN CLASS=K>for</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> i;<BR>
<SPAN CLASS=K>for</SPAN>(i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>10</SPAN>; i++)<BR>
&nbsp;tab[i] = i*i;<BR>
</TD></TR>
</TABLE>

<P>
Warunek wykonywania pêtli równie¿ niekoniecznie musi byæ taki, jak powy¿ej. Mo¿e to byæ praktycznie ka¿de wyra¿enie logiczne:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i!=<SPAN CLASS=L>100</SPAN> || i%<SPAN CLASS=L>2</SPAN>==<SPAN CLASS=L>0</SPAN>; i++)<BR>
&nbsp;printf(<SPAN CLASS=L>"%i"</SPAN>, i);<BR>
</TD></TR>
</TABLE>

<P>
Równie¿ instrukcja zwiêkszania licznika mo¿e przyj¹æ tak¹ formê, jaka nam najbardziej pasuje, na przyk³ad mo¿e zmniejszaæ licznik albo zwiêkszaæ go o <SPAN CLASS=L>2</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> c=<SPAN CLASS=L>0</SPAN>; c&lt;<SPAN CLASS=L>100</SPAN>; c+=<SPAN CLASS=L>2</SPAN>)<BR>
&nbsp;printf(<SPAN CLASS=L>"%i"</SPAN>, c);<BR>
</TD></TR>
</TABLE>

<P>
Ciekawostk¹ jest fakt, ¿e pêtla mo¿e mieæ wiêcej, ni¿ jeden licznik:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>0</SPAN>, j=<SPAN CLASS=L>1</SPAN>; a&lt;<SPAN CLASS=L>50</SPAN>; a++, j--)<BR>
&nbsp;printf(<SPAN CLASS=L>"%i,%i"</SPAN>, a, j);<BR>
</TD></TR>
</TABLE>

<P>
Albo nie mieæ w ogóle ¿adnego "oficjalnego" licznika:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(;;)<BR>
{<BR>
&nbsp;printf(<SPAN CLASS=L>"Napis\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(warunek) <SPAN CLASS=K>break</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
W powy¿szym przypadku pêtla wykonuje siê w nieskoñczonoœæ, chyba ¿e wewn¹trz niej znajdzie siê jakaœ instrukcja <SPAN CLASS=K>break</SPAN>, która w odpowiednim momencie zakoñczy wykonywanie pêtli. Takiej akurat postaci <SPAN CLASS=K>for</SPAN> raczej siê nie stosuje, a kiedy musimy skorzystaæ z us³ug pêtli nieskoñczonej, korzystamy z <SPAN CLASS=K>do</SPAN> lub <SPAN CLASS=K>while</SPAN>.
</P>
<P>
Warto wspomnieæ jeszcze o instrukcji <SPAN CLASS=K>continue</SPAN>. Powoduje ona opuszczenie wszystkich pozosta³ych instrukcji wewn¹trz pêtli i natychmiastowe przejœcie do bloku steruj¹cego (w jêzyku Basic podobn¹ rolê pe³ni s³owo Next, czyli "nastêpna iteracja"). Instrukcji <SPAN CLASS=K>continue</SPAN> u¿ywa siê rzadko, poniewa¿ praktycznie w  kazdym przypadku mo¿na skonstruowaæ pêtlê tak, by u¿ywanie "nienaturalnego" dla programisty <SPAN CLASS=K>continue</SPAN> nie by³o konieczne. Czasem jednak mo¿e siê zdarzyæ, ¿e napisaliœmy w³aœnie ogromn¹, skomplikowan¹ pêtlê na kilka ekranów i nagle okazuje siê, ¿e trzeba j¹ albo przebudowaæ w ca³oœci, albo daæ <SPAN CLASS=K>continue</SPAN>... ;-)
</P>

<H2>
Kowalski, do tablicy!
</H2>

<P>
W porównaniu do jêzyków bardzo wysokiego poziomu, tablice w C++ s¹ trudniejsze w obs³udze, jednak daj¹ wiêksze mo¿liwoœci. Deklarujemy je podobnie do zmiennych, tylko ¿e podajemy jeszcze rozmiar tablicy w nawiasach kwadratowych:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> tablica[<SPAN CLASS=L>10</SPAN>];
</TD></TR>
</TABLE>

<P>
I tutaj uwidacznia siê pierwsze powa¿ne utrudnienie w stosowaniu tablic - liczba <SPAN CLASS=L>10</SPAN> w nawiasach oznacza liczbê elementów tablicy. Jednak indeksy tych elementów to nie liczby od <SPAN CLASS=L>1</SPAN> do <SPAN CLASS=L>10</SPAN>, tylko od <SPAN CLASS=L>0</SPAN> do <SPAN CLASS=L>9</SPAN>. Ma³o intuicyjne, jak dla cz³owieka, chocia¿ dla komputera w pe³ni zrozumia³e. Niestety, musimy byæ grzeczni dla komputera. Zreszt¹ wbrew pocz¹tkowym trudnoœciom, ca³kiem ³atwo siê do tego przyzwyczaiæ.
</P>
<P>
Inna niemi³a rzecz zwi¹zana z tablicami to ich inicjowanie. Nie jest ono, jak w wielu innych jêzykach wysokiego poziomu, automatyczne. Deklaracja tablicy, podobnie jak deklaracja zwyk³ej zmiennej, oznacza tylko zarezerwowanie danego obszaru pamiêci, ale nie troszczy siê ju¿ o jego wyzerowanie. Dlatego te¿ œwie¿o utworzone tablice zawieraj¹ zwykle œmieci, przypadkowe dane - pozosta³oœci po "poprzednich w³aœcicielach" tego obszaru pamiêci. S¹ na szczêœcie dwa wyj¹tki od tej regu³y. Pierwszy to <SPAN CLASS=Wazne>tablice globalne</SPAN>, czyli zdeklarowane na zewn¹trz wszystkich funkcji programu. Taka tablica jest zawsze zerowana podczas deklaracji. Wyj¹tek drugi to <SPAN CLASS=Wazne>tablice statyczne</SPAN> (deklaracja poprzedzona s³owem <SPAN CLASS=K>static</SPAN> - patrz czêœæ kursu poœwiêcona funkcjom). Tablica statyczna jest zerowana bez wzglêdu na to, czy jest te¿ jednoczeœnie globalna czy nie.
</P>
<P>
Oto przyk³ad korzystania z tablic:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> tablica[<SPAN CLASS=L>10</SPAN>];<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i<<SPAN CLASS=L>10</SPAN>; i++) tablica[i]=(i+<SPAN CLASS=L>1</SPAN>)*<SPAN CLASS=L>2</SPAN>;<BR>
<BR>
&nbsp;printf(<SPAN CLASS=L>"tablica[5]==%d\n"</SPAN>, tablica[<SPAN CLASS=L>5</SPAN>]); <BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
Przyk³ad ten deklaruje tablicê <SPAN CLASS=L>10</SPAN> elementów typu <SPAN CLASS=K>int</SPAN>, po czym wype³nia j¹ kolejnymi <SPAN CLASS=L>10</SPAN> liczbami parzystymi. Instrukcja <SPAN CLASS=T>printf</SPAN> wypisuje nam na ekranie SZÓSTY element tablicy, a wiêc liczbê <SPAN CLASS=L>12</SPAN>.
</P>
<P>
Tablice mog¹ byæ te¿ <SPAN CLASS=Wazne>wielowymiarowe</SPAN>. Wystarczy napisaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> tab[<SPAN CLASS=L>10</SPAN>][<SPAN CLASS=L>10</SPAN>];
</TD></TR>
</TABLE>

<P>
i ju¿ mamy tablicê (macierz) <SPAN CLASS=L>10x10</SPAN> pól.
</P>
<P>
A teraz pobawimy siê trochê w szyfrowanie ;-). Program bêdzie kodowa³ XOR-em jak¹œ tablicê. Najlepiej niech bêdzie to tablica typu <SPAN CLASS=K>char</SPAN>, wtedy bêdziemy mogli sobie ³atwo wyobraziæ, ¿e szyfrujemy jakiœ tekst (wiêkszego programu nie chce mi siê pisaæ ;-)):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>const char</SPAN> klucz = <SPAN CLASS=L>113</SPAN>; <SPAN CLASS=C>//mo¿esz wpisaæ inny klucz</SPAN><BR>
<BR>
<SPAN CLASS=K>char</SPAN> tab[<SPAN CLASS=L>256</SPAN>]; <SPAN CLASS=C>//mo¿esz wpisaæ wiêcej, jeœli wola...</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i<<SPAN CLASS=L>256</SPAN>; i++)  tab[i] ^= klucz;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
I to wszystko. Deklarujemy sobie dowolnie du¿¹ tablicê, która ma zawieraæ nasz tekst czy inne tam dane do zaszyfrowania. Deklarujemy te¿ sta³¹ <SPAN CLASS=T>klucz</SPAN>, czyli dowoln¹ liczbê, pe³ni¹c¹ rolê has³a w naszym szyfrze. Liczbê tê trzeba bêdzie znaæ, ¿eby odszyfrowaæ póŸniej tablicê. Do szyfrowania i deszyfrowania mo¿e s³u¿yæ dok³adnie ta sama procedura - pod warunkiem, ¿e u¿yjemy te¿ tego samego klucza.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs02.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs03.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>