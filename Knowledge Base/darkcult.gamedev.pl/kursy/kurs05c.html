<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 4</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05b.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05d.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Konwersje obiektów
</H2>

<P>
Pewnie nawet sobie nie wyobra¿asz, jak wiele niejawnych konwersji jest wykonywanych w twoich programach. A jeœli sobie tego nie wyobra¿asz, to trudno ci doceniæ znaczenie konwersji. Ale nie bój nic, bo podczas zabawy z klasami zwrócisz uwagê na bardzo wiele rzeczy, których wczeœniej nie dostrzega³eœ ;-).
</P>
<P>
Kiedyœ zdarzy ci siê zapewne napisaæ klasê, która bêdzie bardzo podobna do wbudowanych w C++ typów, na przyk³ad klasê <SPAN CLASS=T>String</SPAN>, zachowuj¹c¹ siê podobnie jak ³añcuchy typu <SPAN CLASS=K>char*</SPAN>, albo klasê <SPAN CLASS=T>NowyInt</SPAN>, stanowi¹c¹ rozszerzenie typu podstawowego <SPAN CLASS=K>int</SPAN>. W takim przypadku, aby nasza nowa klasa mog³a w pe³ni wspó³pracowaæ z C++, niezbêdne bêd¹ konwersje z typów wbudowanych do naszej klasy - oraz odwrotnie. WeŸmy ten drugi przyk³ad, czyli klasê <SPAN CLASS=T>NowyInt</SPAN>. W praktyce bêdzie to zwyk³y <SPAN CLASS=K>int</SPAN>, na którym w dodatku nie bêdzie mo¿na wykonywaæ ¿adnych operacji oprócz wpisywania do niego liczb, ale dodatkowe operacje mo¿na sobie bêdzie zawsze zdefiniowaæ, a jeœli umo¿liwimy konwersjê z <SPAN CLASS=T>NowyInt</SPAN> do <SPAN CLASS=K>int</SPAN>, to na obiektach naszej nowej klasy bêdzie mo¿na wykonywaæ wszystko to, co na zwyk³ych <SPAN CLASS=K>int</SPAN>. Oto nasza klasa <SPAN CLASS=T>NowyInt</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> NowyInt<BR>
{<BR>
<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;NowyInt(<SPAN CLASS=K>int</SPAN>=<SPAN CLASS=L>0</SPAN>);<BR>
};<BR>
<BR>
NowyInt::NowyInt(<SPAN CLASS=K>int</SPAN> n=<SPAN CLASS=L>0</SPAN>) { liczba=n; }<BR>
</TD></TR>
</TABLE>

<P>
Klasa jest, jak widaæ, niezbyt skomplikowana ;-). W zasadzie mo¿emy tylko zainicjalizowaæ obiekt typu <SPAN CLASS=T>NowyInt</SPAN> i nic wiêcej. Ale przy okazji wynajêliœmy sobie jednego murzyna do odwalania konwersji ró¿nych typów wbudowanych do naszego typu <SPAN CLASS=T>NowyInt</SPAN>. Przecie¿ taki zapis:
</P>

<SPAN CLASS=T>
NowyInt test = <SPAN CLASS=L>17</SPAN>;<BR>
</SPAN>

<P>
...to w³aœnie konwersja. Mog³oby siê wydawaæ, ¿e daje nam to niewiele poza mo¿liwoœci¹ ³atwej inicjalizacji obiektu. Mog³oby siê te¿ wydawaæ, ¿e nasza klasa jest zbyt prymitywna, ¿eby po inicjalizacji raz wpisanej wartoœci nie mo¿na ju¿ zmieniæ. Ale kryje siê tu pewien podstêp:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
NowyInt test;<BR>
test = (NowyInt)<SPAN CLASS=L>17</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Wygl¹da podejrzanie, ale jest jak najbardziej prawid³owe. Mo¿emy wiêc wykonaæ zwyk³¹, jawn¹ konwersjê, a dziêki niej wpisywaæ liczby typu <SPAN CLASS=K>int</SPAN> do naszego obiektu w dowolnym momencie programu. Jakim cudem? Przyjrzyj siê drugiej linijce, mo¿emy j¹ sobie zapisaæ nawet w alternatywnej postaci:
</P>

<SPAN CLASS=T>
test = NowyInt(<SPAN CLASS=L>17</SPAN>);<BR>
</SPAN>

<P>
...w której wyraŸnie widaæ, ¿e konwersja odby³a siê przy pomocy... Kostruktora klasy <SPAN CLASS=T>NowyInt</SPAN>!. Konstruktor stworzy³ nam z liczby <SPAN CLASS=K>17</SPAN> nowy obiekt typu <SPAN CLASS=T>NowyInt</SPAN>, a nastêpnie przy pomocy domyœlnego konstruktora kopiuj¹cego, wygenerowanego przez kompilator, przypisa³ go do zmiennej <SPAN CLASS=T>test</SPAN>.
</P>
<P>
Tak wiêc potrafimy przekonwertowaæ typ <SPAN CLASS=K>int</SPAN> do naszego typu <SPAN CLASS=T>NowyInt</SPAN>. A co z konwersj¹ w drug¹ stronê? Tu ju¿ nie ma tak ³atwo, bo przecie¿ konstruktory klasy <SPAN CLASS=K>int</SPAN> nie znaj¹ naszego <SPAN CLASS=T>NowyInt</SPAN>! Dlatego te¿ musimy stworzyæ w naszej nowej klasie funkcjê, która bêdzie dokonywa³a konwersji obiektu <SPAN CLASS=T>NowyInt</SPAN> na zmienn¹ typu <SPAN CLASS=K>int</SPAN>. Bêdzie on wygl¹da³ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>operator int</SPAN>() { <SPAN CLASS=K>return</SPAN> liczba; };
</TD></TR>
</TABLE>

<P>
Ostatecznie, nasza nowa klasa, wzbogacona o mo¿liwoœæ konwersji na typ <SPAN CLASS=K>int</SPAN> bêdzie wygl¹da³a nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> NowyInt<BR>
{<BR>
<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;NowyInt(<SPAN CLASS=K>int</SPAN>=<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>operator int</SPAN>() { <SPAN CLASS=K>return</SPAN> liczba; }<BR>
};<BR>
<BR>
NowyInt::NowyInt(<SPAN CLASS=K>int</SPAN> n=<SPAN CLASS=L>0</SPAN>) { liczba=n; }<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie u¿ywanie tej klasy jest kompletnie bez sensu, gdy¿ ma ona teraz takie same mo¿liwoœci, jak wbudowany typ <SPAN CLASS=K>int</SPAN>, ale po dodaniu do niej paru fajnych funkcji sk³adowych mo¿emy stworzyæ klasê, która potrafi wszystko to, co <SPAN CLASS=K>int</SPAN>, a dodatkowo jeszcze to, co sobie do niej dodamy :-).
</P>

<H2>
Przeci¹¿anie operatorów
</H2>
<P>
Jedn¹ z najfajniejszych cech C++ jest mo¿liwoœæ przeci¹¿ania operatorów, czyli nadawanie im nowych znaczeñ. Wykorzystujemy to najczêœciej do redefiniowania dzia³añ wykonywanych przez standardowe operatory dla zdefiniowanych przez siebie klas. Na przyk³ad - przy wykorzystaniu standardowego "plusa" nie mo¿esz dodaæ dwóch obiektów typu <SPAN CLASS=T>Punkt</SPAN>. Ale nic nie stoi na przeszkodzie, aby np. "nauczyæ" C++ dodawania punktów czy wektorów.
</P>
<P>
Zanim jednak w to siê pobawimy, powiem kilka wa¿nych rzeczy o przeci¹¿aniu operatorów. Po pierwsze: ka¿da klasa ma swoje w³asne definicje operatorów, a wiêc redefiniuj¹c np. dodawanie dla swojej klasy <SPAN CLASS=T>Punkt</SPAN> mo¿esz siê nie obawiaæ, ¿e dodawanie np. dwóch liczb typu <SPAN CLASS=K>int</SPAN> przestanie byæ mo¿liwe (jeœli czyta to ktoœ bardziej doœwiadczonym, to pewnie siê uœmiecha w tym miejscu, ale wiem, ¿e "nowi" miewaj¹ czasem tego typu obawy). Po prostu dla dwóch <SPAN CLASS=K>int</SPAN>-ów bêdzie wywo³ywana jedna funkcja operatorowa, a dla obiektów <SPAN CLASS=T>Punkt</SPAN> - inna.
</P>
<P>
Po drugie: nie wszystkie operatory da siê przeci¹¿aæ. Takich, jak: <SPAN CLASS=T>.</SPAN>, <SPAN CLASS=T>.*</SPAN>, <SPAN CLASS=T>::</SPAN>, <SPAN CLASS=T>?:</SPAN>, <SPAN CLASS=K>sizeof</SPAN>, oraz symboli <SPAN CLASS=C>#</SPAN> i <SPAN CLASS=C>##</SPAN> nawet nie dotykaj :-). Zreszt¹ gdyby siê dobrze zastanowiæ, by³oby to albo bez sensu, albo bardzo trudne do zaimplementowania w jêzyku, wiêc nie ma co ¿a³owaæ ;-).
</P>
<P>
Po trzecie: ka¿dy z redefiniowanych operatorów jest œciœle zwi¹zany ze swoim "pierwowzorem", wiêc ma taki sam priorytet, ³¹cznoœæ, liczbê argumentów. Regu³a ta wydaje siê trochê usztywniaæ mechanizm przeci¹¿ania operatorów, ale nie martw siê - to, co nam wolno, w zupe³noœci wystarczy ;-).
</P>
<P>
Warto jeszcze wiedzieæ, ¿e jeœli nie przeci¹¿ymy ¿adnego operatora, to niektóre w naszej nowej klasie bêd¹ dzia³aæ i tak (podobnie jak jest w przypadku konstruktora kopiuj¹cego). Oprócz wymienionych operatorów (których przeci¹¿aæ nie mo¿na w ogóle), s¹ to: <SPAN CLASS=T>=</SPAN> (jako operator przypisania), <SPAN CLASS=T>&</SPAN> (jako operator pobrania adresu) i przecinek <SPAN CLASS=T>,</SPAN>. Wszystkie trzy mo¿emy redefiniowaæ jeœli mamy ochotê, ale jeœli tego nie zrobimy, to mimo wszystko bêd¹ sobie funkcjonowaæ - co najwy¿ej niezupe³nie tak, jakbyœmy chcieli ;-).
</P>
<P>
Czas na konkrety. Jeden operator w³aœciwie ju¿ sobie przeci¹¿yliœmy przed chwil¹ - by³ to nawias okr¹g³y jako operator konwersji. Przeci¹¿anie pozosta³ych operatorów jest w³aœciwie równie proste. Najpierw redefiniujemy operator dodawania <SPAN CLASS=T>+</SPAN> dla klasy <SPAN CLASS=T>Punkt</SPAN> (bêdzie ona reprezentowa³a punkt na p³aszczyŸnie, wektor, liczbê zespolon¹ czy jak to jeszcze nazwiemy):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Punkt<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> x,y;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Punkt(<SPAN CLASS=K>int</SPAN> nx=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> ny=<SPAN CLASS=L>0</SPAN>);<BR>
<SPAN CLASS=C>//tutaj powinna byæ reszta klasy...<BR>
//ale nie chce mi siê jej wpisywaæ ;-)</SPAN><BR>
&nbsp;Punkt <SPAN CLASS=K>operator+</SPAN>(Punkt);<BR>
};<BR>
<BR>
Punkt Punkt::<SPAN CLASS=K>operator+</SPAN>(Punkt p)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> Punkt(x+p.x, y+p.y);<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Pisaæ definicjê konstruktora? Eee, nie chce mi siê ;-)</SPAN>
</TD></TR>
</TABLE>

<P>
Nasza klasa jest raczej trywialna, w³aœciwie jest to doœæ prowizoryczna implementacja punktu, ale nie czepiajmy siê ;-). Funkcja redefiniuj¹ca operator ma nazwê z³o¿on¹ ze s³owa <SPAN CLASS=K>operator</SPAN> i symbolu danego operatora (tutaj plusik). Poza tym jest to najzwyczajniejsza w œwiecie funkcja. Musisz jednak pamiêtaæ, by mia³a ona odpowiedni typ zwracany oraz argumenty - tutaj akurat nie mo¿esz siê wykazaæ w³asn¹ fantazj¹, lecz dopasowaæ to wszystko do odpowiedniego standardowego operatora.
</P>
<P>
Nie bêdê podawa³, w jaki sposób przeci¹¿aæ ka¿dy jeden operator - mo¿esz do tego dojœæ sam lub ewentualnie pomóc sobie wszelk¹ dostêpn¹ literatur¹ (polecam Megatutorial - zobacz dzia³ 'Linki');
</P>
<P>
¯eby zrozumieæ, jak dzia³a nasza funkcja operatorowa w praktyce, musisz wiedzieæ, ¿e instrukcjê typu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
A = B + C;<BR>
</TD></TR>
</TABLE>

<P>
...mo¿na zapisaæ w postaci:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
A = B.<SPAN CLASS=K>operator+</SPAN>(C);
</TD></TR>
</TABLE>

<P>
Taka postaæ jest oczywiœcie mniej ekonomiczna (zu¿ycie klawiatury ;-)), ale wiele t³umaczy. Widzimy ju¿, jak dzia³a dodawanie: wywo³ywana jest odpowiednia funkcja operatorowa dla pierwszego sk³adnika (czyli <SPAN CLASS=K>this</SPAN> wewn¹trz tej funkcji operatorowej wskazuje na pierwszy sk³adnik) z drugim sk³adnikiem w postaci argumentu dla funkcji operatorowej. 
</P>
<P>
Napiszmy sobie jeszcze operator relacyjny <SPAN CLASS=T>==</SPAN>. Jest on w tym przypadku równie banalny co dodawanie, ale chcê, ¿ebyœ mia³ wiêcej przyk³adów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Punkt<BR>
{<BR>
<SPAN CLASS=C>//resztê dopisz sam ;-)</SPAN><BR>
&nbsp;<SPAN CLASS=K>int operator==</SPAN>(Punkt);<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> Punkt::<SPAN CLASS=K>operator==</SPAN>(Punkt p)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(p.x==x && p.y==y) <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>-1</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>else return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Poniewa¿ nasza prosta klasa jest tylko "opakowaniem" na dwie zmienne typu <SPAN CLASS=K>int</SPAN>, wiêc i funkcje operatorowe wykonuj¹ po prostu "rozbicie" danego operatora na dwa operatory wbudowane - tak samo, jak w przypadku dodawania. Nie musimy siê wiêc babraæ w jakichœ niskopoziomowych operacjach na "go³ej" pamiêci, gdy¿ implementacja poszczególnych operatorów mo¿e wykorzystywaæ funkcje operatorowe innych klas - w tym przypadku s¹ to operatory dla typu wbudowanego <SPAN CLASS=K>int</SPAN>. 
</P>


<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05b.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05d.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</BODY>
</HTML>