<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Podstawy DirectDraw</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw02.html">Animacja &gt;&gt;</A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Kurs DirectDraw
</H1>

<P>
Witam w kursie <SPAN CLASS=Wazne>DirectDraw</SPAN>! Zg³êbimy tu trochê tajników jednego ze sk³adników s³ynnego DirectX-a, odpowiedzialnego za "p³ask¹" grafikê. Co prawda ju¿ od lat ¿aden szanuj¹cy siê producent gier nie splami³by swojego honoru, zajmuj¹c siê grami z dwuwymiarow¹ grafik¹, ale dla wielu programistów-amatorów 3D jest z ró¿nych wzglêdów niedostêpny, wiêc jeœli ju¿ tworz¹ grê, a standardowe funkcje API s¹ dla ich celów zbyt powolne, to najlepszym rozwi¹zaniem pozostaje w³aœnie DirectDraw.
</P>
<P>
Zanim przyst¹pimy do dzie³a, przypominam o koniecznoœci dolinkowania biblioteki DirectDraw. Utwórz nowy projekt windowsowy, wejdŸ do opcji projektu i w pole "Further object files" wpisz nazwê pliku: libddraw.a. Nastêpnie na pocz¹tku programu dodaj linijkê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;ddraw.h&gt;</SPAN><BR>
</TD></TR>
</TABLE>

<H2>
1.1 Tworzenie g³ównego obiektu DirectDraw
</H2>

<P>
Fundamentem dla programowania w DirectX s¹ tak zwane <SPAN CLASS=Wazne>obiekty g³ówne</SPAN>. Ka¿dy modu³ DirectX-a (np. DirectSound, Direct3D, DirectInput) ma swój w³asny obiekt g³ówny. Zanim zrobimy w DX cokolwiek, musimy najpierw taki obiekt utworzyæ. Na szczêœcie nie jest to zbyt skomplikowana operacja:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPDIRECTDRAW lpDDGlowny;<BR>
<SPAN CLASS=K>if</SPAN>(DirectDrawCreate(NULL, &lpDDGlowny, NULL) != DD_OK) Blad();<BR>
</TD></TR>
</TABLE>

<P>
Nale¿y zadeklarowaæ wskaŸnik do obiektu, który tworzymy, a nastêpnie wywo³aæ funkcjê <SPAN CLASS=T>DirectDrawCreate</SPAN> i przekazaæ jej jako jeden z argumentów adres tego wskaŸnika, który zadeklarowaliœmy. Z pozosta³ych argumentów pierwszy oznacza kartê graficzn¹, której bêdziemy u¿ywaæ z danym obiektem <SPAN CLASS=T>DirectDraw</SPAN> (wiêkszoœæ userów ma tylko jedn¹ i podaje tu <SPAN CLASS=T>NULL</SPAN>, aczkolwiek niektórych od przybytku g³owa nie boli), zaœ drugi argument... A cholera zreszt¹ wie, do czego on s³u¿y - wrzucamy <SPAN CLASS=T>NULL</SPAN>. <SPAN CLASS=T>DirectDrawCreate</SPAN> powinna zwróciæ wartoœæ <SPAN CLASS=T>DD_OK</SPAN> - jeœli nie zwróci, no to bêdzie bieda, trzeba pokazaæ stosowny komunikat i zakoñczyæ program. Tutaj skrótowo napisa³em <SPAN CLASS=T>Blad()</SPAN>.
</P>
<P>
Mamy wiêc obiekt g³ówny, teraz trzeba z nim podpisaæ umowê o wspó³pracy z g³ównym okienkiem programu. Bez umowy ani rusz, w koñcu obiekt g³ówny DirectDraw to porz¹dny goœæ i na czarno nie bêdzie pracowa³. Chcia³by z góry wiedzieæ, jaki ma zakres obowi¹zków i tak dalej. DirectDraw mo¿e zostaæ zwyk³ym robolem (tryb wspó³pracy <SPAN CLASS=T>DDSCL_NORMAL</SPAN>), albo te¿ dostaæ specjalne przywileje - <SPAN CLASS=T>DDSCL_EXCLUSIVE</SPAN>. A jeœli ju¿ zdecydujemy siê na ten drugi (w wiêkszoœci przypadków pewnie tak bêdzie), to musimy te¿ ustawiæ dodatkowo tryb <SPAN CLASS=T>DDSCL_FULLSCREEN</SPAN> - jak sama nazwa wskazuje oznacza on, ¿e nasz program bêdzie pracowa³ na pe³nym ekranie. Funkcja podpisywania umowy miêdzy DirectDraw a naszym okienkiem zwie siê <SPAN CLASS=T>SetCooperativeLevel</SPAN> i jest funkcj¹ sk³adow¹ naszego obiektu g³ównego DD:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpDDGlowny->SetCooperativeLevel(hwnd, DDSCL_FULLSCREEN | DDSCL_EXCLUSIVE);<BR>
</TD></TR>
</TABLE>

<P>
Jeœli ju¿ bawimy siê na pe³nym ekranie, to nie zaszkodzi dowiedzieæ siê, jak siê zmienia tryb graficzny. Na szczêœcie nie jest to takie pokrêcone, jak w go³ym WinAPI, mamy bowiem bardzo intuicyjn¹ funkcjê <SPAN CLASS=T>SetDisplayMode</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpDDGlowny->SetDisplayMode(<SPAN CLASS=L>800</SPAN>, <SPAN CLASS=L>600</SPAN>, <SPAN CLASS=L>16</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Co oznaczaj¹ dwa pierwsze argumenty, to chyba widaæ. Trzeci to oczywiœcie liczba bitów przypadaj¹ca na jeden piksel, czyli g³êbia koloru. Ró¿ne karty graficzne obs³uguj¹ ró¿ne tryby; wiêkszoœæ kart powinna mieæ zaimplementowany tryb <SPAN CLASS=L>16</SPAN>-bitowy (<SPAN CLASS=L>65</SPAN> tys. kolorów), chyba wszystkie nowoczesne karty obs³uguj¹ <SPAN CLASS=L>32</SPAN>-bitowy, natomiast z <SPAN CLASS=L>24</SPAN>-bitowym bywa rozmaicie.
</P>
<P>
Jak to zwykle jest z windowsowymi aplikacjami, cokolwiek utworzymy - trzeba póŸniej zniszczyæ albo zwolniæ. Nie inaczej z naszym g³ównym obiektem DD. Dlatego pod koniec programu dorzucamy tak¹ oto linijkê, mówi¹c¹ obiektowi, ¿e ma ju¿ fajrant:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpddGlowny->Release();<BR>
</TD></TR>
</TABLE>

<H2>
1.2 Powierzchnie DirectDraw
</H2>

<P>
Dziêki obiektowi g³ównemu mo¿emy zmieniæ rozdzielczoœæ ekranu, ale nie da siê na nim nic narysowaæ. Obiekt g³ówny tylko nadzoruje rysowanie, a naszym prawdziwym polem do popisu bêd¹ tzw. <SPAN CLASS=Wazne>powierzchnie</SPAN>. ¯eby rysowaæ, musimy stworzyæ przynajmniej jedn¹ powierzchniê i przypisaæ j¹ do ekranu - od tej pory wszystko, co wrzucimy na powierzchniê, wyœwietli siê automatycznie na ekranie. Mo¿emy te¿ tworzyæ "zapasowe" powierzchnie i wykorzystywaæ je jako bufory, ale o tym póŸniej. Powierzchniê tworzymy podobnie jak obiekt g³ówny DirectDraw, czyli deklaruj¹c wskaŸnik do niej i nastêpnie wywo³uj¹c funkcjê <SPAN CLASS=T>CreateSurface</SPAN>. Zanim jednak tê funkcjê wywo³amy, trzeba bêdzie wype³niæ odpowiedni¹ strukturê pomocnicz¹ (to z kolei przypomina tworzenie okna w WinAPI):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//wskaŸnik do naszej powierzchni</SPAN><BR>
LPDIRECTDRAWSURFACE lpDSPow; <BR>
<SPAN CLASS=C>//deklarujemy strukturê...</SPAN><BR>
DDSURFACEDESC ddsdStruktura;<BR>
<SPAN CLASS=C>//...wype³niamy j¹...</SPAN><BR>
ddsdStruktura.dwSize         = sizeof(ddsdStruktura);<BR>
ddsdStruktura.dwFlags        = DDSD_CAPS;<BR>
ddsdStruktura.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;<BR>
<SPAN CLASS=C>//...i wreszcie mamy powierzchniê!</SPAN><BR>
<SPAN CLASS=K>if</SPAN>(lpDDGlowny->CreateSurface(&ddsdStruktura, &lpDSPow, NULL) != DD_OK)<BR>
&nbsp;Blad(); <SPAN CLASS=C>//albo i nie mamy... ;-)</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Pewnie jesteœ ciekaw, o co chodzi z tymi polami struktury <SPAN CLASS=T>DDSURFACEDESC</SPAN>. Teoretycznie jest to doœæ spora struktura (zw³aszcza, ¿e zawiera w sobie nastêpne poziomy struktur), ale do naszych skromnych zastosowañ wystarcz¹ w zupe³noœci te trzy pola, które wype³niliœmy powy¿ej. Pierwsze z nich, <SPAN CLASS=T>dwSize</SPAN>, okreœla rozmiar ca³ej struktury w bajtach i tutaj dajemy po prostu <SPAN CLASS=K>sizeof</SPAN><SPAN CLASS=T>(ddsdStruktura)</SPAN>. Pole <SPAN CLASS=T>dwFlags</SPAN> okreœla, z których pól struktury korzystamy. Przyda nam siê na razie tylko pole <SPAN CLASS=T>ddsCaps</SPAN>, wiêc ustawiamy <SPAN CLASS=T>dwFlags</SPAN> na wartoœæ <SPAN CLASS=T>DDSD_CAPS</SPAN>.
</P>
<P>
Pole ddsCaps to osobna struktura. Zawiera ona tylko jedno pole - <SPAN CLASS=T>dwCaps</SPAN>, do którego wrzucamy flagi okreœlaj¹ce rodzaj naszej powierzchni. Chcemy utworzyæ g³ówn¹ powierzchniê, wiêc ustawiamy to pole na <SPAN CLASS=T>DDSCAPS_PRIMARYSURFACE</SPAN>.
</P>
<P>
Wywo³anie funkcji <SPAN CLASS=T>CreateSurface</SPAN> to ju¿ ¿adna filozofia; pierwszy argument to adres struktury, któr¹ w³aœnie wype³nialiœmy, drugi to adres wskaŸnika, do którego przypisana zostanie nowa powierzchnia, ostatni argument nas nie interesuje i ustawiamy go na <SPAN CLASS=T>NULL</SPAN>.
</P>

<H2>
1.3 Wczytywanie i rysowanie bitmap
</H2>

<P>
Jeœli chcesz zrobiæ grê z prawdziwego zdarzenia, a chyba po to zagl¹dasz do kursu DirectDraw, to w zdecydowanej wiêkszoœci przypadków bêdziesz korzystaæ z bitmap, zrobionych w jakimœ programie graficznym albo bezczelnie ukradzionych z cudzej gry. Bitmapkê tak¹ najpierw trzeba wczytaæ z dysku do pamiêci. Tutaj mo¿emy siê pos³u¿yæ standardow¹ funkcj¹ WinAPI, czyli <SPAN CLASS=T>LoadImage</SPAN>, oraz odpowiednimi strukturami danych, równie¿ z WinAPI. Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmObrazek = LoadImage(NULL, <SPAN CLASS=L>"obrazek.bmp"</SPAN>, IMAGE_BITMAP, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, LR_LOADFROMFILE);<BR>
</TD></TR>
</TABLE>

<P>
Funkcjê <SPAN CLASS=T>LoadImage</SPAN> powinieneœ znaæ z kursu WinAPI, ale na wszelki wypadek przypomnê jej sk³adniê. Pierwszy argument to uchwyt programu - wymagany jeœli bitmapê przechowujemy w pliku <SPAN CLASS=Wazne>*.exe</SPAN>. Jeœli wczytujemy j¹ z pliku <SPAN CLASS=Wazne>*.bmp</SPAN> (a tak siê sk³ada, ¿e w³aœnie to robimy powy¿ej), to mo¿na tu wstawiæ <SPAN CLASS=T>NULL</SPAN>. Drugi argument to oczywiœcie œcie¿ka i nazwa pliku BMP, trzeci to rodzaj pliku graficznego - dla zwyk³ej bitmapy <SPAN CLASS=T>IMAGE_BITMAP</SPAN>. Kolejne dwa argumenty to wymiary obrazka - co siê bêdziemy mêczyæ, dajemy po zerze. Ostatni argument oznacza, sk¹d ³adujemy bitmapê - do tej pory po samych argumentach najg³upsza ma³pa by siê skapowa³a, ¿e z pliku, co jeszcze g³upszemu kompilatorowi trzeba dodatkowo t³umaczyæ, wstawiaj¹c <SPAN CLASS=T>LR_LOADFROMFILE</SPAN>.
</P>

<P>
Jeœli w systemie nie panuje akurat chaos, podany plik istnieje i w dodatku jest bitmap¹ w rozs¹dnym formacie, to funkcja <SPAN CLASS=T>LoadImage</SPAN> wczyta go i zwróci do niego uchwyt (typu <SPAN CLASS=T>HBITMAP</SPAN>). W przeciwnym wypadku zwróci oczywiœcie <SPAN CLASS=T>NULL</SPAN>.
</P>
<P>
Mamy bitmapê w pamiêci, co z ni¹ teraz pocz¹æ? Na szczêœcie powierzchnie w DirectX s¹ kompatybilne ze standardowymi strukturami GDI WinAPI, tote¿ bez wiêkszych problemów mo¿emy nasz¹ bitmapkê z tych struktur na nowoutworzon¹ powierzchniê g³ówn¹ DD skopiowaæ. Potrzebny nam bêdzie roboczy <SPAN CLASS=T>HDC</SPAN>, któremu przypiszemy nasz¹ bitmapkê, oraz funkcja <SPAN CLASS=T>BitBlt</SPAN>, która skopiuje bitmapê z tego roboczego kontekstu na powierzchniê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//Utwórz tymczasowy kontekst</SPAN><BR>
HDC tmphdc = CreateCompatibleDC(NULL);<BR>
<SPAN CLASS=C>//i przypisz mu nasz¹ bitmapê</SPAN><BR>
SelectObject(tmphdc, hbmOBrazek);<BR>
</TD></TR>
</TABLE>

<P>
Teraz musimy uzyskaæ <SPAN CLASS=T>HDC</SPAN> naszej powierzchni. Ma ona specjaln¹ funkcjê sk³adow¹ <SPAN CLASS=T>GetDC</SPAN> (która jednak nie ma nic wspólnego z funkcj¹ o tej samej nazwie, wchodz¹c¹ w sk³ad WinAPI), z tym ¿e najpierw musimy zadeklarowaæ zmienn¹ typu <SPAN CLASS=T>HDC</SPAN>, a nastêpnie adres tej zmiennej przekazaæ jako argument funkcji <SPAN CLASS=T>GetDC</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcPow;<BR>
lpDDPow->GetDC(&hdcPow);<BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>GetDC</SPAN> powinna zwróciæ <SPAN CLASS=T>DD_OK</SPAN>, czego z lenistwa tutaj nie sprawdza³em. Jeœli faktycznie zwróci, to zmienna <SPAN CLASS=T>hdcPow</SPAN> bêdzie zawieraæ <SPAN CLASS=T>HDC</SPAN> zwi¹zany z nasz¹ powierzchni¹. Teraz nic nie stoi ju¿ na przeszkodzie, ¿eby w klasyczny sposób skopiowaæ zawartoœæ jednego kontekstu na drugi - w tym przypadku z tymczasowego <SPAN CLASS=T>HDC</SPAN> na <SPAN CLASS=T>HDC</SPAN> powierzchni:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BitBlt(hdcPow, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>200</SPAN>, tmphdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
lpDDPow->ReleaseDC(hdcPow);<BR>
</TD></TR>
</TABLE>

<P>
W przyk³adzie za³o¿yliœmy, ¿e obrazek ma wymiary <SPAN CLASS=L>100x200</SPAN>. Po skopiowaniu bitmapy na powierzchniê musimy (tak jak w przypadku rysowania po zwyk³ym oknie) zwolniæ jej <SPAN CLASS=T>HDC</SPAN>, co robimy przy pomocy funkcji <SPAN CLASS=T>ReleaseDC</SPAN>. No i mamy obrazek na ekranie...
</P>
<P>
Nie pozostaje nic innego, jak tylko wiosenne porz¹dki - wyrzucamy nasz¹ bitmapê i kasujemy tymczasowy kontekst:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DeleteObject(hbmObrazek);<BR>
DeleteDC(tmphdc);<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie przy wyjœciu z samego programu nale¿y jeszcze zniszczyæ powierzchniê, a na koniec zwolniæ g³ówny obiekt DD, ale o tym mówiliœmy ju¿ wczeœniej.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw02.html">Animacja &gt;&gt;</A>
</TD>
</TR>
</TABLE>

</HTML>