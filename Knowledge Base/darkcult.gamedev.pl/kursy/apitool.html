<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Toolbary</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apimenu.html"><< Tworzenie menu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool2.html">Toolbary, cz.2 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Tworzenie toolbaru
</H2>

<P>
Aplikacje windowsowe, nawet te wyposa¿one w menu, s¹ wredne i nieprzyjazne u¿ytkownikowi, jeœli nie maj¹ paska narzêdzi, zwanego te¿ z angielska toolbarem. Za chwilê dowiemy siê o tym fajnym urz¹dzeniu wszystkiego, albo raczej prawie wszystkiego ;-).
</P>
<P>
Na pocz¹tek zaznaczam, ¿e toolbar jest kontrolk¹ nale¿¹c¹ do grona tzw. <SPAN CLASS=Inglisz>Common Controls</SPAN>. Jest to grupa kontrolek, z której korzysta ka¿dy bardziej rozbudowany program windowsowy, a czêsto nawet ca³kiem malutkie programiki. Mimo tej powszechnoœci korzystanie z nich wymaga nieco zachodu - przede wszystkim musimy dolinkowaæ do programu odpowiedni¹ bibliotekê. W Devie jest to plik <SPAN CLASS=C>libcomctl32.a</SPAN>, w innych œrodowiskach (np. VC++, LCC) nazywa siê on <SPAN CLASS=C>comctl32.lib</SPAN>. Nastêpnie - do³¹czamy nag³ówek <SPAN CLASS=C>commctrl.h</SPAN>. Wreszcie - umieszczamy PRZED jakimikolwiek instrukcjami odwo³uj¹cymi siê do kontrolek typu <SPAN CLASS=Inglisz>Common Controls</SPAN> wywo³anie funkcji <SPAN CLASS=T>InitCommonControls</SPAN> - najlepiej uczyniæ to gdzieœ w okolicach miejsca, gdzie tworzymy g³ówne okno:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
InitCommonControls();<BR>
</TD></TR>
</TABLE>

<P>
Po tych zabiegach mo¿emy wreszcie utworzyæ toolbar. Metody s¹ dwie: albo robimy to znan¹ ju¿ doskonale funkcj¹ <SPAN CLASS=T>CreateWindowEx</SPAN> (wtedy korzystamy ze sta³ej <SPAN CLASS=T>TOOLBARCLASSNAME</SPAN>, okreœlaj¹c¹ nazwê klasy toolbaru), albo te¿ (to wersja wygodniejsza) - specjaln¹ funkcj¹ <SPAN CLASS=T>CreateToolbarEx</SPAN>.
</P>
<P>
Metoda numer dwa jest o tyle lepsza, ¿e daje nam mo¿liwoœæ zrobienia od razu kompletnego toolbaru (z przyciskami), wiêc nie bêdziemy musieli ich póŸniej dodawaæ po kolei. Argumentów ma ta <SPAN CLASS=T>CreateToolbarEx</SPAN> sporo, a najwa¿niejszy z nich to tablica struktur typu <SPAN CLASS=T>TBBUTTON</SPAN> - jak siê pewnie domyœlasz, ka¿da z takich struktur opisuje kolejny przycisk. I jak siê pewnie domyœlasz, za moment sobie tê strukturê dok³adnie omówimy ;-).
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<SPAN CLASS=K>struct </SPAN><SPAN CLASS=T>TBBUTTON</SPAN>
</TD></TR><TR></TR><TR></TR><TR></TR>
<TR><TH CLASS=ARGLIST>Pole</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=K>int</SPAN> <SPAN CLASS=T>iBitmap</SPAN></TD><TD CLASS=ARGLIST>Indeks bitmapy</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=K>int</SPAN> <SPAN CLASS=T>idCommand</SPAN></TD><TD CLASS=ARGLIST>Indeks komendy</TD></TR> 
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>BYTE fsState</SPAN></TD><TD CLASS=ARGLIST>Stan (lub kombinacja stanów) przycisku</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>BYTE fsStyle</SPAN></TD><TD CLASS=ARGLIST>Styl (lub kombinacja stylów) przycisku</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>DWORD dwData</SPAN></TD><TD CLASS=ARGLIST>Do wszelakich zastosowañ ;-)</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T><SPAN CLASS=K>int</SPAN> iString</SPAN></TD><TD CLASS=ARGLIST>Indeks etykiety przycisku lub wskaŸnik do stringa</TD></TR>
</TABLE>

<P>
Jak widzisz, przyciskom nie przypisujemy pojedynczych uchwytów do bitmap, tylko indeksy - to dlatego, ¿e toolbar posiada w³asn¹, wewnetrzn¹ listê bitmap. Indeks, który przypisujemy przyciskowi z toolbaru, to w³aœnie numer bitmapy na wewnêtrznej liœcie. Podobnie sprawa wygl¹da z etykietami przycisków - najpierw tworzymy listê stringów, potem przypisujemy ich indeksy przyciskom (chocia¿ niekoniecznie - o tym póŸniej).
</P>
<P>
Przyciski toolbaru nie maj¹ sztywno przypisanych identyfikatorów - mo¿emy je ustaliæ sami, wype³niaj¹c pole <SPAN CLASS=T>idCommand</SPAN>. Wciœniêcie przycisku na toolbarze powoduje wys³anie "zwyk³ego" komunikatu <SPAN CLASS=T>WM_COMMAND</SPAN>. Jak wiemy, parametr <SPAN CLASS=T>lParam</SPAN> tego komunikatu zawiera zawsze uchwyt kontrolki, która wysy³a ten komunikat (tym razem bêdzie to uchwyt toolbaru), natomiast parametr <SPAN CLASS=T>wParam</SPAN> zawiera kod notyfikacji (górne s³owo) oraz identyfikator kontrolki lub elementu, którego dotyczy komunikat (dolne s³owo). To ostatnie to bêdzie w tym przypadku w³aœnie wartoœæ, któr¹ podamy jako <SPAN CLASS=T>idCommand</SPAN>.
</P>
<P>
Style przycisku mog¹ zaœ byæ nastêpuj¹ce:
</P>
<UL>
<SPAN CLASS=T>
<LI>TBSTYLE_BUTTON
<LI>TBSTYLE_CHECK
<LI>TBSTYLE_GROUP
<LI>TBSTYLE_CHECKGROUP
<LI>TBSTYLE_SEP
</SPAN>
</UL>

<P>
Zazwyczaj u¿ywamy tego pierwszego. Dzia³anie stylu <SPAN CLASS=T>TBSTYLE_CHECK</SPAN> chyba nietrudno odgadn¹æ. <SPAN CLASS=T>TBSTYLE_GROUP</SPAN>, jak równie¿ sama nazwa wskazuje, s³u¿y do grupowania przycisków (bêdzie wciœniêty, dopóki u¿ytkownik nie wciœnie innego przycisku z grupy). Podobnie dzia³a <SPAN CLASS=T>TBSTYLE_CHECKGROUP</SPAN>, tylko ¿e dla przycisków typu <SPAN CLASS=T>TBSTYLE_CHECK</SPAN>. Ostatni styl tworzy nam nie tyle normalny przycisk, co separator - czyli po prostu odstêp miêdzy poszczególnymi grupami przycisków.
</P>
<P>
Stylów jest trochê wiêcej, niektóre z nich s¹ dostêpne tylko dla okreœlonych wersji biblioteki, inne w nowszych wersjach s¹ dostêpne, ale pod inn¹ nazw¹, jeszcze inne stosuje siê nie do pojedynczych przycisków, lecz do ca³ego toolbaru - krótko mówi¹c, burdel na kó³kach z tym jest. Tak wiêc omówimy je sobie przy konkretnych przypadkach.
</P>
<P>
Stany przycisku mog¹ byæ takie:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<SPAN CLASS=K>stany przycisków
</TD></TR><TR></TR><TR></TR><TR></TR>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_CHECKED</SPAN></TD><TD CLASS=ARGLIST>Przycisk ma styl <SPAN CLASS=T>TBSTYLE_CHECKED</SPAN> i jest wciœniêty</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_PRESSED</SPAN></TD><TD CLASS=ARGLIST>Przycisk jest wciœniêty</TD></TR> 
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_ENABLED</SPAN></TD><TD CLASS=ARGLIST>Przycisk jest w³¹czony (mo¿e reagowaæ na dzia³ania u¿ytkownika)</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_HIDDEN</SPAN></TD><TD CLASS=ARGLIST>Przycisk jest niewidoczny i wy³¹czony</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_INDETERMINATE</SPAN></TD><TD CLASS=ARGLIST>Przycisk jest wy³¹czony (nie reaguje na klikanie)</TD></TR>
<TR><TD CLASS=ARGLIST><SPAN CLASS=T>TBSTATE_WRAP</SPAN></TD><TD CLASS=ARGLIST>Po przycisku nastêpuje z³amanie linii (czyli nastêpny przycisk znajduje siê w nowej linii). Ten stan musi byæ po³¹czony z <SPAN CLASS=T>TBSTATE_ENABLED</SPAN>.</TD></TR>
</TABLE>
 
<P>
Tyle teorii, bierzemy siê do roboty. Nasze zadanie to zrobienie toolbaru do programiku, który tworzyliœmy sobie w odcinku poœwiêconym menu. Bêdzie on mia³ na razie trzy przyciski: Nowy, Otwórz i Zapisz. W tym momencie nie wymigam siê ju¿ od przedstawienia pe³nej sk³adni funkcji <SPAN CLASS=T>CreateToolbarEx</SPAN>, oto i ona:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
HWND CreateToolbarEx(HWND hwnd,
DWORD ws,
UINT wID,
int nBitmaps,
HINSTANCE hBMInst, 
UINT wBMID, 
LPCTBBUTTON lpButtons, 
int iNumButtons, 
int dxButton, 
int dyButton, 
int dxBitmap, 
int dyBitmap, 
UINT uStructSize
); 


</TD></TR><TR></TR><TR></TR><TR></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hwnd</I></TD><TD CLASS=ARGLIST>Uchwyt do okna rodzicielskiego tworzonego toolbaru</TD></TR>
<TR><TD CLASS=ARGLIST><I>ws</I></TD><TD CLASS=ARGLIST>Style okna toolbaru. Musi zawieraæ styl <SPAN CLASS=T>WS_CHILD</SPAN>.</TD></TR> 
<TR><TD CLASS=ARGLIST><I>wID</I></TD><TD CLASS=ARGLIST>Identyfikator tworzonego toolbaru</TD></TR>
<TR><TD CLASS=ARGLIST><I>nBitmaps</I></TD><TD CLASS=ARGLIST>Liczba fragmentów, na jakie ma byæ podzielona bitmapa, okreœlona przez nastêpne dwa parametry.</TD></TR>
<TR><TD CLASS=ARGLIST><I>hBMInst</I></TD><TD CLASS=ARGLIST>Uchwyt programu, w którego zasobach znajduje siê bitmapa.</TD></TR>
<TR><TD CLASS=ARGLIST><I>wBMID</I></TD><TD CLASS=ARGLIST>Identyfikator zasobu z bitmap¹ dla toolbaru. Jeœli <SPAN CLASS=T>hBMInst</SPAN> równy jest <SPAN CLASS=T>NULL</SPAN>, to parametr ten powinien zawieraæ nie identyfikator, lecz uchwyt (<SPAN CLASS=T>HBITMAP</SPAN>) do bitmapy.</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpButtons</I></TD><TD CLASS=ARGLIST>WskaŸnik do tablicy struktur <SPAN CLASS=T>TBBUTTON</SPAN>, zawieraj¹cych informacjê o poszczególnych przyciskach.</TD></TR>
<TR><TD CLASS=ARGLIST><I>iNumButtons</I></TD><TD CLASS=ARGLIST>Liczba przycisków na toolbarze.</TD></TR>
<TR><TD CLASS=ARGLIST><I>dxButton, dyButton</I></TD><TD CLASS=ARGLIST>Wymiary przycisku w pikselach.</TD></TR>
<TR><TD CLASS=ARGLIST><I>dxBitmap, dyBitmap</I></TD><TD CLASS=ARGLIST>Wymiary bitmap przycisków (ty¿ w pikselach).</TD></TR>
<TR><TD CLASS=ARGLIST><I>uStructSize</I></TD><TD CLASS=ARGLIST>Rozmiar (w bajtach) struktury <SPAN CLASS=T>TBBUTTON</SPAN>.</TD></TR>
</TABLE>

<P>
Funkcja zwraca uchwyt do nowego toolbaru (uchwyt typu <SPAN CLASS=T>HWND</SPAN>, oczywiœcie), jeœli tworzenie siê powiedzie. Jeœli funkcja potknie siê po drodze, to zwróci <SPAN CLASS=T>NULL</SPAN>.
</P>
<P>
Zaczynamy od stworzenia bitmapy z odpowiednimi ikonami. Domyœlne wymiary pojedynczej ikony to <SPAN CLASS=L>16x15</SPAN> pikseli, ale nic nie stoi na przeszkodzie, by je sobie zmieniæ. Nasze bêd¹ mia³y <SPAN CLASS=L>16x16</SPAN> pikseli. Ca³a bitmapa bêdzie wygla³a tak:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/toolbmp.gif" ALT="Przyk³adowa bitmapa do toolbaru">
</P>

<P>
Musimy j¹ wczytaæ z dysku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmTool = (HBITMAP)LoadImage(hThisInstance, <SPAN CLASS=L>"tool.bmp"</SPAN>, IMAGE_BITMAP, <SPAN CLASS=L>0, 0,</SPAN> LR_LOADFROMFILE|LR_LOADMAP3DCOLORS);
</TD></TR>
</TABLE>

<P>
Teraz tworzymy sobie tablicê trzech elementów typu <SPAN CLASS=T>TBBUTTON</SPAN> i wype³nieniamy j¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBBUTTON tbb[<SPAN CLASS=L>3</SPAN>];<BR>
<BR>
ZeroMemory(tbb, <SPAN CLASS=K>sizeof</SPAN>(tbb));<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>3</SPAN>; ++i)<BR>
{<BR>
&nbsp;tbb[i].idCommand = i;<BR>
&nbsp;tbb[i].iBitmap = tbb[i].iString = i;<BR>
&nbsp;tbb[i].fsState = TBSTATE_ENABLED;<BR>
&nbsp;tbb[i].fsStyle = TBSTYLE_BUTTON;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, stworzyliœmy trzy przyciski. Ich identyfikatory to kolejne liczby: <SPAN CLASS=L>0, 1, 2</SPAN>. Takie same s¹ indeksy bitmap. Program wczyta bitmapê i "podzieli" j¹ na trzy fragmenty (wed³ug wymiarów, które za chwilê podamy w funkcji <SPAN CLASS=T>CreateToolbarEx</SPAN>), które bêd¹ identyfikowane w³aœnie kolejnymi liczbami ca³kowitymi. Najwy¿sza pora stworzyæ nasz toolbar:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hToolbar = CreateToolbarEx(hwnd, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>500, 3</SPAN>, NULL, (UINT)hbmTool, tbb, <SPAN CLASS=L>3, 16,16,16,16</SPAN>, <SPAN CLASS=K>sizeof</SPAN>(TBBUTTON));
</TD></TR>
</TABLE>

<P>
Mamy ju¿ toolbar, nadaliœmy mu identyfikator <SPAN CLASS=L>500</SPAN> oraz trzy przyciski na podstawie tablicy <SPAN CLASS=T>tbb</SPAN>. Przyciski maj¹ wymiary <SPAN CLASS=L>16x16</SPAN>, tak jak sobie zapowiadaliœmy. Oto nasze cudo:
</P>

<P ALIGN=CENTER>
<img SRC="../gfx/toolbar1.gif" Alt="Pierwsze koty za p³oty ;-)">
</P>

<P>
Biblioteka <SPAN CLASS=C>comctl32</SPAN> udostêpnia nam szereg standardowych ikonek do toolbaru. S¹ wœród nich miêdzy innymi nasze trzy: Nowy, Otwórz i Zapisz. Po co wiêc mamy siê mêczyæ tworzeniem w³asnych bitmap, skoro mo¿na skorzystaæ z gotowych? Robi siê to bardzo prosto. Po pierwsze - zamiast <SPAN CLASS=T>NULL</SPAN>, podajemy funkcji <SPAN CLASS=T>CreateToolbarEx</SPAN> uchwyt do biblioteki <SPAN CLASS=C>comctl32</SPAN>. Jest on zawarty w sta³ej <SPAN CLASS=T>HINST_COMMCTRL</SPAN>. Nastêpnie jako identyfikator bitmapy podajemy sta³¹ <SPAN CLASS=T>IDB_STD_SMALL_COLOR</SPAN> (nietrudno zgadn¹æ, ¿e <SPAN CLASS=T>IDB_STD_LARGE_COLOR</SPAN> oznacza du¿e wersje ikon). Wreszcie usuwamy z pêtli linijki, w których przypisujemy numer bitmapy i wszystkie trzy ustawiamy "rêcznie":</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
tbb[<SPAN CLASS=L>0</SPAN>].iBitmap = STD_FILENEW;<BR>
tbb[<SPAN CLASS=L>1</SPAN>].iBitmap = STD_FILEOPEN;<BR>
tbb[<SPAN CLASS=L>2</SPAN>].iBitmap = STD_FILESAVE;<BR>
</TD></TR>
</TABLE>

<P>
Pe³n¹ listê dostêpnych sta³ych znajdziesz w pliku <SPAN CLASS=C>commctrl.h</SPAN>. A tymczasem wprowadzamy wszystkie omówione zmiany do wywo³ania <SPAN CLASS=T>CreateToolbarEx</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hToolbar = CreateToolbarEx(hwnd, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>500, 3</SPAN>, HINST_COMMCTRL, IDB_STD_SMALL_COLOR, tbb, <SPAN CLASS=L>3,16,16,16,16</SPAN>, <SPAN CLASS=K>sizeof</SPAN>(TBBUTTON));
</TD></TR>
</TABLE>

<P>
Uda³o siê, zamiast ikonek w stylu Dev-a mamy zwyk³e, nudne ikonki windowsowe ;-).
</P>

<P align=center>
<img src="../gfx/toolbar2.gif" alt="By³o Ÿle, jest jeszcze gorzej - stare, nudne, doskonale znane ikonki ;-)">
</P>

<P>
Bardzo czêsto siê zdarza, ¿e wiêkszoœæ przycisków na toolbarze to przyciski ze standardowymi ikonkami, ale potrzebujemy te¿ jednego lub kilka przycisków z w³asnymi obrazkami. Nie pozostaje nam nic innego, jak tylko dodawaæ w³asne przyciski i bitmapy do nich ju¿ po utworzeniu "g³ównej" czêœci toolbaru. Za³ó¿my przyk³adowo, ¿e chcemy sobie dorzuciæ na koñcu przycisk Koniec ;-). Dorzucimy te¿ separator - choæby po to, ¿ebyœ póŸniej nie pyta³, jak to zrobiæ ;-).
</P>
<P>
Zacznijmy od wczytania bitmapy do przycisku Koniec - tego ju¿ nie bêdê pokazywa³ któryœ tam raz z rzêdu, popatrz sobie wy¿ej. Za³ó¿my, ¿e mamy ju¿ bitmapê i uchwyt do niej - <SPAN CLASS=T>hbmKoniec</SPAN>. Musimy teraz stworzyæ oraz wype³niæ strukturê <SPAN CLASS=T>TBADDBITMAP</SPAN>, co te¿ czynimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBADDBITMAP tbab;<BR>
tbab.hInst = NULL;<BR>
tbab.nID = (UINT)hbmKoniec;<BR>
</TD></TR>
</TABLE>

<P>
Z powy¿szego mo¿emy wywnioskowaæ, ¿e istnieje równie¿ mo¿liwoœæ dodawania bitmap z pliku zasobów programu, jeœli jako <SPAN CLASS=T>hInst</SPAN> podamy uchwyt od tego programu, a jako <SPAN CLASS=T>nID</SPAN> - identyfikator bitmapy w pliku zasobów. Mo¿emy te¿, analogicznie do powy¿szego przyk³adu, dodawaæ przy wykorzystaniu struktury <SPAN CLASS=T>TBADDBITMAP</SPAN> pojedyncze ikony z <SPAN CLASS=C>comctl32</SPAN>.
</P>
<P>
Teraz musimy jedynie wys³aæ komunikat <SPAN CLASS=T>TB_ADDBITMAP</SPAN>, przekazuj¹c w nim liczbê bitmap, które dodajemy (u nas tylko jedna), oraz adres struktury <SPAN CLASS=T>TBADDBITMAP</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> nIndeks = SendMessage(hToolbar, TB_ADDBITMAP, <SPAN CLASS=L>1</SPAN>, (LPARAM)&tbab);<BR>
</TD></TR>
</TABLE>

<P>
Nastêpnie tworzymy drug¹ tablicê z przyciskami. Tym razem dodajemy dwa przyciski - jeden separator i jeden zwyk³y przycisk:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBBUTTON tbb2[<SPAN CLASS=L>2</SPAN>];<BR>
<BR>
ZeroMemory(tbb2, <SPAN CLASS=K>sizeof</SPAN>(tbb2));<BR>
tbb2[<SPAN CLASS=L>0</SPAN>].idCommand = <SPAN CLASS=L>3</SPAN>;<BR>
tbb2[<SPAN CLASS=L>0</SPAN>].iString = <SPAN CLASS=L>3</SPAN>;<BR>
tbb2[<SPAN CLASS=L>0</SPAN>].iBitmap = <SPAN CLASS=L>0</SPAN>;<BR>
tbb2[<SPAN CLASS=L>0</SPAN>].fsState = TBSTATE_ENABLED;<BR>
tbb2[<SPAN CLASS=L>0</SPAN>].fsStyle = TBSTYLE_SEP;<BR>
tbb2[<SPAN CLASS=L>1</SPAN>].idCommand = <SPAN CLASS=L>4</SPAN>;<BR>
tbb2[<SPAN CLASS=L>1</SPAN>].iString = <SPAN CLASS=L>4</SPAN>;<BR>
tbb2[<SPAN CLASS=L>1</SPAN>].iBitmap = nIndeks;<BR>
tbb2[<SPAN CLASS=L>1</SPAN>].fsState = TBSTATE_ENABLED;<BR>
tbb2[<SPAN CLASS=L>1</SPAN>].fsStyle = TBSTYLE_BUTTON;<BR>
</TD></TR>
</TABLE>

<P>
Dodajemy przyciski, wykorzystuj¹c odpowiedni komunikat:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hToolbar, TB_ADDBUTTONS, <SPAN CLASS=L>2</SPAN>, (LPARAM)&tbb2);<BR>
</TD></TR>
</TABLE>

<P>
Otrzymujemy w rezultacie coœ w tym stylu:
</P>

<P align=center>
<img src="../gfx/toolbar3.gif" alt="Przyby³o to i owo... ;-)">
</P>

<H2>
Obs³uga zdarzeñ
</H2>

<P>
Taki toolbar mo¿e i fajnie wygl¹da, ale zda siê psu na budê, jeœli nie bêdzie do tego dzia³a³ jak nale¿y, tzn. wywo³ywa³ odpowiednich komend po wciœniêciu odpowiednich przycisków. Zaimplementowanie tego jest na szczêœcie ca³kiem proste. Jak ju¿ wspomnia³em, wciœniêcie przycisku wysy³a komunikat <SPAN CLASS=T>WM_COMMAND</SPAN>. Musimy najpierw sprawdziæ, czy komunikat ten faktycznie pochodzi od toolbaru i w tym celu mo¿emy pos³u¿yæ siê parametrem <SPAN CLASS=T>lParam</SPAN> komunikatu. Z kolei parametr <SPAN CLASS=T>wParam</SPAN>, a konkretniej jego dolna po³ówka, zawiera identyfikator wciœniêtego przycisku (o ile mu go nadaliœmy).
</P>
<P>
W naszym przyk³adzie mamy teraz 5 przycisków (w tym jeden separator) o identyfikatorach od <SPAN CLASS=L>0</SPAN> do <SPAN CLASS=L>4</SPAN>. Warto by zdefiniowaæ jakieœ sta³e dla tych identyfikatorów, coby w kodzie by³o od razu widaæ, ¿e chodzi o przyciski:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#define</SPAN> TOOL_NOWY&nbsp;&nbsp;&nbsp;<SPAN CLASS=L>0</SPAN><BR>
<SPAN CLASS=C>#define</SPAN> TOOL_OTWORZ <SPAN CLASS=L>1</SPAN><BR>
<SPAN CLASS=C>#define</SPAN> TOOL_ZAPISZ <SPAN CLASS=L>2</SPAN><BR>
<SPAN CLASS=C>#define</SPAN> TOOL_KONIEC <SPAN CLASS=L>4</SPAN><BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Identyfikatora dla separatora oczywiœcie nie potrzebujemy, gdy¿ nie generuje on ¿adnych komunikatów :-). Teraz pora napisaæ sobie obs³ugê komunikatu <SPAN CLASS=T>WM_COMMAND</SPAN>. Zrobimy to tylko dla przycisku Koniec, bo to bêdzie najprostsze ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//sprawdzamy, czy komunikat pochodzi od toolbaru</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>((HWND)lParam == hToolbar)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//selekcja identyfikatorów</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>switch</SPAN>(LOWORD(wParam))<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TOOL_NOWY:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//brak zdarzenia ;-)</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TOOL_OTWORZ:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//brak zdarzenia ;-)</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break;<BR>
&nbsp;&nbsp;&nbsp;case</SPAN> TOOL_ZAPISZ:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//brak zdarzenia ;-)</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break;<BR>
&nbsp;&nbsp;&nbsp;case</SPAN> TOOL_KONIEC:<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//Zakoñcz program</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;DestroyWindow(hwnd);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Dziêki tym zabiegom klikniêcie ikonki drzwi bêdzie nas faktycznie wywala³o za drzwi ;-). Jeœli do wypróbowania przyk³adów z tego odcinka wykorzystujesz ten sam kod, w którym æwiczy³eœ tworzenie menu (co jest zalecane), to prawdopodobnie ju¿ masz w nim obs³ugê innych komunikatów <SPAN CLASS=T>WM_COMMAND</SPAN> (np. pochodz¹cych od menu), wiêc musisz to uwzglêdniæ przy wklejaniu fragmentu dotycz¹cego toolbaru, inaczej narobisz sobie niez³ej kaszanki ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apimenu.html"><< Tworzenie menu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool2.html">Toolbary, cz.2 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

