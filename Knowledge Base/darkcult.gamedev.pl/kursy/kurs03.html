<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, wskaŸniki, cz. 1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs02a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs03a.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
<B>3. WskaŸniki</B>
</H1>

<H2>
3.1 Nie taki wskaŸnik straszny, jak go maluj¹, chocia¿...
</H2>

Jedn¹ z najbardziej przydatnych rzeczy w C++, której nie ma w wielu innych jêzykach s¹ <SPAN CLASS=Wazne>wskaŸniki</SPAN>. WskaŸnik to taka specjalna zmienna, która mo¿e przechowywaæ <SPAN CLASS=Wazne>adres</SPAN> innej zmiennej. Ka¿demu typowi zmiennej odpowiada jeden <SPAN CLASS=Wazne>typ wskaŸnika</SPAN>. Do czego wskaŸniki siê przydaj¹ - zobaczymy póŸniej, a na razie przyjrzyj siê przyk³adowi deklaracji zmiennej wskaŸnikowej:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>56</SPAN>;<BR>
<SPAN CLASS=K>int</SPAN>* wsk_a = &a;
</TD></TR>
</TABLE>
<BR>

W pierwszej linijce zadeklarowaliœmy zmienn¹ typu <SPAN CLASS=K>int</SPAN>; w drugiej zmienn¹ wskaŸnikow¹ tego¿ typu. Ta œliczna gwiazdeczka oznacza w³aœnie, i¿ podana zmienna bêdzie wskaŸnikiem. Ponadto w drugiej linijce wystêpuje inicjalizacja zmiennej wskaŸnikowej <SPAN CLASS=T>wsk_a</SPAN> adresem zmiennej <SPAN CLASS=T>a</SPAN> - od tej pory <SPAN CLASS=T>wsk_a</SPAN> wskazuje na <SPAN CLASS=T>a</SPAN>, czyli zawiera jej adres w pamiêci. Có¿ to oznacza dla programisty? Otó¿ od tej pory mo¿emy operowaæ na zmiennej <SPAN CLASS=T>a</SPAN> bez podawania jej w jakimkolwiek wyra¿eniu - mo¿emy pos³ugiwaæ siê samym adresem:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
b = *wsk_a;<BR>
*wsk_a += <SPAN CLASS=L>4</SPAN>;
</TD></TR>
</TABLE>
<BR>

Jeœli <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>wsk_a</SPAN> bêd¹ mia³y takie same wartoœci, jak w poprzednim przyk³adzie, to <SPAN CLASS=T>b</SPAN> bêdzie równe tyle samo, co <SPAN CLASS=T>a</SPAN>, natomiast druga linijka zwiêkszy <SPAN CLASS=T>a</SPAN> o <SPAN CLASS=L>4</SPAN> (czyli <SPAN CLASS=T>a</SPAN> bêdzie równe <SPAN CLASS=L>60</SPAN>). Tylko po co te gwiazdki, mo¿na by spytaæ? Pamiêtajmy, ¿e zmienna <SPAN CLASS=T>wsk_a</SPAN> zawiera ADRES zmiennej <SPAN CLASS=T>a</SPAN>. Gwiazdka w tym przypadku, przy³o¿ona do zmiennej oznacza poœrednie odwo³anie siê do zmiennej wskazywanej (zapis: <SPAN CLASS=T>*wsk_a</SPAN> jest równowa¿ny zapisowi: <SPAN CLASS=T>a</SPAN>). Gdyby nie by³o gwiazdek, pierwsza instrukcja zapisa³aby ADRES zmiennej <SPAN CLASS=T>a</SPAN> do zmiennej <SPAN CLASS=T>b</SPAN>, co by³oby jednym wielkim nieporozumieniem (chcieliœmy zapisaæ WARTOŒÆ <SPAN CLASS=T>a</SPAN> do <SPAN CLASS=T>b</SPAN>), natomiast druga instrukcja zwiêkszy³aby ADRES zawarty w <SPAN CLASS=T>wsk_a</SPAN> o <SPAN CLASS=L>4</SPAN>. Poniewa¿ d³ugoœæ typu <SPAN CLASS=K>int</SPAN> wynosi zwykle w³aœnie <SPAN CLASS=L>4</SPAN> bajty, wiêc raczej nie mamy bladego pojêcia, co mo¿e siedzieæ w pamiêci te <SPAN CLASS=L>4</SPAN> bajty dalej od naszej zmiennej <SPAN CLASS=T>a</SPAN>. Mo¿e to byæ inna zmienna naszego programu, mo¿e to byæ kawa³ek kodu naszego Windowsa, cokolwiek. Ju¿ widzisz, dlaczego pomylenie wartoœci z adresem mo¿e byæ niemi³e w skutkach - jeœli zmienimy sobie niechc¹cy adres w <SPAN CLASS=T>wsk_a</SPAN>, ¿eby wskazywa³ adres kodu jakiegoœ windowsowego sterownika, potem zechcemy zmieniæ poœrednio wartoœæ <SPAN CLASS=T>a</SPAN>, wiêc zmienimy wartoœæ jednego z bajtów naszego sterownika, no i globalna katastrofa gotowa :-).
<BR><BR>
Wa¿ne jest, by nauczyæ siê rozró¿niaæ wszelkie mo¿liwe konteksty, w których wystêpuje operator <SPAN CLASS=T>*</SPAN>. Symbol mo¿e byæ ten sam, ale rodzaj wykonywanej przezeñ operacji - zupe³nie ró¿ny. Zauwa¿, ¿e tê sam¹ gwiazdkê stosujemy do mno¿enia, do deklaracji zmiennej wskaŸnikowej i do "zamiany" adresu na zmienn¹, posiadaj¹c¹ ów adres.
<BR><BR>
Wracaj¹c wiêc do naszego przyk³adu - jak ju¿ byæ mo¿e za³apa³eœ, zapis:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
*wsk_a += <SPAN CLASS=L>4</SPAN>;
</TD></TR>
</TABLE>
<BR>

oznacza dok³adnie: zwiêksz wartoœæ zmiennej, której adres jest w <SPAN CLASS=T>wsk_a</SPAN>, o <SPAN CLASS=L>4</SPAN>. Innymi zaœ s³owy: Zwiêksz zmienn¹ <SPAN CLASS=T>a</SPAN> o <SPAN CLASS=L>4</SPAN>. Myœlê, ¿e powinieneœ ju¿ rozumieæ :-). Jeœli nie, to rzuæ okiem na rysunek:
<BR><BR>

<P ALIGN=CENTER>
<IMG SRC="../gfx/pointers.gif"><BR><BR>
</P>

Przedstawia on jakiœ tam wycinek pamiêci operacyjnej naszego kompa. Kolejne bajty pogrupowane s¹ <SPAN CLASS=Wazne>s³owami</SPAN> (s³owo to <SPAN CLASS=L>2</SPAN> bajty - wiesz o tym, prawda?), w systemie szesnastkowym (¿eby siê ³adnie uk³ada³y w kolumny :-) ). Niebieskie cyferki po lewej to adresy - konkretnie adresy ka¿dego pierwszego bajtu z kolumny po lewej stronie. Dla u³atwienia adresy zaczynaj¹ siê tu od <SPAN CLASS=L>0</SPAN> (w praktyce raczej nie uda nam siê zaj¹æ zerowej komórki pamiêci), a wyœwietlane s¹ w systemie dziesi¹tkowym (zwykle w szesnastkowym, ale tutaj akurat nie ma sensu siê w to bawiæ). Teraz programik:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>short int</SPAN> z = <SPAN CLASS=L>15</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>short int</SPAN>* wsk = &z;<BR>
&nbsp;<BR>
&nbsp;wsk += <SPAN CLASS=L>2</SPAN>; <SPAN CLASS=C>//teraz wsk nie zawiera ju¿ adresu z</SPAN><BR>
&nbsp;*wsk = <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//w tym momencie prawdopodobnie namieszaliœmy...</SPAN> <BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Porównaj ten kod z rysunkiem. Pierwsza instrukcja funkcji <SPAN CLASS=T>main</SPAN> deklaruje zmienn¹ <SPAN CLASS=T>z</SPAN>, przypisuj¹c jej wartoœæ <SPAN CLASS=L>15</SPAN>. To system operacyjny musi siê martwiæ, która komórka pamiêci zostanie przydzielona zmiennej <SPAN CLASS=T>z</SPAN>, nas to nie interesuje. System, po wielu nanosekundach bezowocnego poszukiwania :-) znajduje wreszcie upragnion¹ woln¹ komórkê pamiêci - ma ona adres <SPAN CLASS=L>26</SPAN> (bajty: <SPAN CLASS=L>26</SPAN>-ty i <SPAN CLASS=L>27</SPAN>-my nie s¹ zajmowane przez ¿aden program). Tak wiêc nasza zmienna z bêdzie od teraz siê panoszy³a pod tym <SPAN CLASS=L>26</SPAN>-tym i <SPAN CLASS=L>27</SPAN>-mym bajtem pamiêci. Na rysunku pod adresem <SPAN CLASS=L>26</SPAN> widzimy wartoœæ: <SPAN CLASS=L>000F</SPAN>, czyli w przeliczeniu na system dziesi¹tkowy - <SPAN CLASS=L>15</SPAN>.
<BR><BR>
Druga instrukcja deklaruje wskaŸnik do typu <SPAN CLASS=K>int</SPAN> i przypisuje mu adres zmiennej <SPAN CLASS=T>z</SPAN>, czyli <SPAN CLASS=L>26</SPAN>. Tym samym zmienna <SPAN CLASS=T>wsk</SPAN> zawiera po prostu liczbê <SPAN CLASS=L>26</SPAN>. Dlatego te¿ instrukcja nastêpna zwiêkszy t¹ wartoœæ do <SPAN CLASS=L>28</SPAN>. Jak widaæ na rysunku, pod adresem <SPAN CLASS=L>28</SPAN> mamy ju¿ zupe³nie inn¹ wartoœæ, <SPAN CLASS=L>12FF</SPAN>, która mo¿e byæ wartoœci¹ innej zmiennej innego programu, albo np. fragmentem kodu wspomnianego Windowsa. Instrukcja <SPAN CLASS=T>*wsk = </SPAN><SPAN CLASS=L>0</SPAN> zmienia wiêc wartoœæ obszaru wskazywanego przez <SPAN CLASS=T>wsk</SPAN>, czyli bajtów: <SPAN CLASS=L>28</SPAN>-go i <SPAN CLASS=L>29</SPAN>-go. Tym samym zniszczyliœmy pamiêciow¹ "w³asnoœæ" innego programu, ewentualnie czêœæ naszego programu, i co gorsza nie wiemy nawet, co w³aœciwie zniszczyliœmy i jaki bêdzie efekt. Dlatego te¿ zawsze musimy uwa¿aæ przy modyfikowaniu wskaŸników, oraz uwa¿aæ na to, czy modyfikujemy ADRES, czy WARTOŒÆ.

<H2>
3.2 Stringi (ale nie takie, jak myœlicie, zboczki)
</H2>

W normalnych jêzykach (C++ do takich nie nale¿y ;-) ) obs³uga tak zwanych stringów, czyli zmiennych ³añcuchowych, jest prosta, ³atwa, logiczna itp. Twórcy C++ nie lubi¹ jednak tak "lamerskiego" podejœcia do programowania i lubi¹ sobie od czasu do czasu skomplikowaæ najprostsze rzeczy do granic mo¿liwoœci. Tak te¿ i z nieszczêsnymi stringami uczynili. W roli tej zaszczytnej wystêpuj¹ w C++ tablice typu <SPAN CLASS=K>char</SPAN>. W³aœciwie to w innych jêzykach te¿ s¹ to tablice, tyle ¿e programista nie musi tego nawet wiedzieæ. Ale jak pamiêtamy, C++ to wy¿sza szko³a jazdy. 
<BR><BR>
Standardowe biblioteki C++ zawieraj¹ kilka po¿ytecznych funkcji, przeznaczonych do operowania na stringach. Dostêp do wiêkszoœci z nich uzyskujemy doklejaj¹c  do naszego programu linijkê:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;string.h&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>

Jest jeden warunek, mianowicie nasz string musi byæ zakoñczony znakiem pustym (o kodzie <SPAN CLASS=L>0</SPAN>). Jak ju¿ wiemy, stringi w C++ to tablice, a wiêc znak zerowy umieszczamy w ostatnim elemencie tablicy i muzyczka gra:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN> string[] = <SPAN CLASS=L>"Tekst"</SPAN>;
</TD></TR>
</TABLE>
<BR>

Powy¿szy zapis deklaruje nam tablicê, inicjalizuj¹c j¹ ³añcuchem <SPAN CLASS=L>"Tekst"</SPAN>. Nie musimy wpisywaæ, ile znaków ma mieæ tablica, kompilator sam sobie policzy. Co wiêcej - bêdzie na tyle mi³y, ¿eby do tego dodaæ jeden element wiêcej i wpisaæ do niego znak zerowy. Czegó¿ nam wiêcej trzeba? Otó¿ sporo. Zauwa¿, ¿e o ile inicjalizacja tablicy stringiem jest jak najbardziej mo¿liwa, to ju¿ "zwyk³e" przypisanie nie ujdzie. Powód: w C++ nie mo¿na przypisywaæ jednej tablicy do drugiej tablicy.
<BR><BR>
W tym jak¿e powa¿nym problemie przychodz¹ nam z pomoc¹ nieocenione wskaŸniki. Otó¿ okazuje siê, ¿e w C++ nazwa tablicy jest traktowana przy okazji jako wskaŸnik do jej pierwszego elementu. Zdeklarujmy teraz wskaŸnik i przypiszmy mu stringa:


<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN> tab[] = <SPAN CLASS=L>"Tekst"</SPAN>;<BR>
<SPAN CLASS=K>char</SPAN>* wsk = tab;
</TD></TR>
</TABLE>
<BR>


Teraz, skoro <SPAN CLASS=T>wsk</SPAN> zawiera adres tablicy <SPAN CLASS=T>tab</SPAN>, czyli adres jej pierwszego elementu (literka <SPAN CLASS=L>T</SPAN>), to <SPAN CLASS=T>wsk+</SPAN><SPAN CLASS=L>1</SPAN> bêdzie zawiera³ adres literki <SPAN CLASS=L>e</SPAN> itd. Skoro <SPAN CLASS=T>wsk</SPAN> wskazuje na pierwszy element tablicy, i nazwa tablicy <SPAN CLASS=T>tab</SPAN> równie¿ jest wskaŸnikiem na jej pierwszy element, to nic nie stoi na przeszkodzie, by zamiast np. <SPAN CLASS=T>tab[<SPAN CLASS=L>4</SPAN>]</SPAN> u¿yæ <SPAN CLASS=T>wsk[<SPAN CLASS=L>4</SPAN>]</SPAN>. Wynika z tego, ¿e nie musimy deklarowaæ tablic do korzystania ze stringów - wystarczy nam wskaŸnik:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN>* tekst = <SPAN CLASS=L>"Tekst"</SPAN>;
</TD></TR>
</TABLE>
<BR>

Mo¿na sobie jeszcze wyt³umaczyæ to zjawisko w inny sposób. Kompilator traktuje tekst w cudzys³owiu jako stringa, zakoñczonego znakiem zerowym. W powy¿szej instrukcji inicjalizacji kompilator rezerwuje najpierw odpowiedni¹ iloœæ miejsca w pamiêci, nastêpnie wpisuje do niego nasz tekst, wreszcie przekazuje wskaŸnik do tego miejsca w pamiêci do zmiennej wskaŸnikowej <SPAN CLASS=T>tekst</SPAN>.

<H2>
3.3 Zaprzêgamy stringi do pracy
</H2>

Jak ju¿ wczeœniej wspomnia³em, obs³uga stringów w C++ jest tak cholernie niewygodna, ¿e tylko zgrzytaæ zêbami. Od ca³kowitej tragedii ratuj¹ nas funkcje, zadeklarowane w pliku <SPAN CLASS=C>string.h</SPAN>. Pozwalaj¹ one na kopiowanie, z³¹czanie i porównywanie stringów, wyszukiwanie w nim znaków i innych stringów oraz kilka innych po¿ytecznych rzeczy.
<BR><BR>
Zajmijmy siê najpierw kopiowaniem. Realizuje je funkcja <SPAN CLASS=T>strcpy</SPAN> o sk³adni:
<BR><BR>
<SPAN CLASS=K>char</SPAN><SPAN CLASS=T>* strcpy(<SPAN CLASS=K>char</SPAN>* to, <SPAN CLASS=K>char</SPAN>* from)</SPAN>
<BR><BR>

Jak nietrudno siê domyœliæ, funkcja kopiuje znaki z <SPAN CLASS=T>from</SPAN> do <SPAN CLASS=T>to</SPAN>. Dodatkowo zwraca nam jeszcze wskaŸnik do <SPAN CLASS=T>to</SPAN>, czyli do ³añcucha, w którym bêdzie ostateczny wynik. Dziêki temu mo¿emy napisaæ coœ w rodzaju:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;string.h&gt;<BR>
#include &lt;stdio.h&gt;</SPAN>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* tekst = <SPAN CLASS=L>"Napis"</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* bufor = <SPAN CLASS=L>"Stojê na murze"</SPAN>;<BR>
<BR>
&nbsp;printf(<SPAN CLASS=L>"bufor zawiera tekst %s\n"</SPAN>, strcpy(bufor, tekst));<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>
<BR>

Program wypisze tekst <SPAN CLASS=L>"Napis na murze"</SPAN>. Sekwencja <SPAN CLASS=L>%s</SPAN> oznacza stringa, jak byæ mo¿e siê ju¿ domyœlasz. Powinieneœ jeszcze wiedzieæ o funkcji <SPAN CLASS=T>strncpy</SPAN>, która kopiuje tylko okreœlon¹ liczbê znaków z <SPAN CLASS=T>from</SPAN>:

<BR><BR>
<SPAN CLASS=K>char</SPAN><SPAN CLASS=T>* strncpy(<SPAN CLASS=K>char</SPAN>* to, <SPAN CLASS=K>char</SPAN> *from, liczba_znaków)</SPAN>
<BR><BR>

Jedn¹ z najbardziej wnerwiaj¹cych przeszkód w korzystaniu ze stringów jest brak jakichœ fajnych operatorów, dzia³aj¹cych na tych stringach. Najbardziej razi brak jakiegoœ operatorka <SPAN CLASS=T>+</SPAN>, który s³u¿y³by do "sklejania" dwóch stringów. Zamiast tego musimy korzystaæ z funkcji <SPAN CLASS=T>strcat</SPAN>:

<BR><BR>
<SPAN CLASS=K>char</SPAN><SPAN CLASS=T>* strcat(<SPAN CLASS=K>char</SPAN>* to, <SPAN CLASS=K>char</SPAN> *from)</SPAN>
<BR><BR>

Funkcja do³¹cza ³añcuch <SPAN CLASS=T>from</SPAN> do <SPAN CLASS=T>to</SPAN>; zwraca natomiast wskaŸnik do <SPAN CLASS=T>to</SPAN>, tak samo jak <SPAN CLASS=T>strcpy</SPAN>. I podobnie jak w przypadku <SPAN CLASS=T>strcpy</SPAN>, istnieje funkcja <SPAN CLASS=T>strncat</SPAN>, która bierze tylko n znaków z <SPAN CLASS=T>from</SPAN>. Przyk³ad u¿ycia <SPAN CLASS=T>strcat</SPAN>:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;string.h&gt;<BR>
#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* tekst = <SPAN CLASS=L>"Napis"</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* tekst2 = <SPAN CLASS=L>"ik"</SPAN>;<BR>
&nbsp;printf(<SPAN CLASS=L>"%s\n"</SPAN>, strcat(tekst, tekst2));<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>
<BR>

Program wyœwietli na ekranie <SPAN CLASS=L>"Napisik"</SPAN>.
<BR><BR>
Jeœli chodzi o porównywanie stringów, to ju¿ mo¿na by siê k³óciæ, czy jeden operator <SPAN CLASS=T>==</SPAN> rozwi¹za³by sprawê. Mo¿na bowiem uznaæ, ¿e stringi s¹ równe wtedy i tylko wtedy, gdy ka¿dy jeden kod znaku z jednego stringa jest równy odpowiedniemu kodowi znaku z drugiego stringa. Czyli na przyk³ad <SPAN CLASS=L>"Napis"</SPAN> to bêdzie co innego ni¿ <SPAN CLASS=L>"napis"</SPAN> (pierwsze znaki maj¹ ró¿ne kody). W takim wypadku do porównania dwóch stringów mo¿emy u¿yæ funkcji <SPAN CLASS=T>strcmp</SPAN> o postaci:

<BR><BR>
<SPAN CLASS=T>strcmp(<SPAN CLASS=K>char</SPAN>* s1, <SPAN CLASS=K>char</SPAN>* s2)</SPAN>
<BR><BR>

Zwraca ona <SPAN CLASS=L>0</SPAN>, jeœli ³añcuchy <SPAN CLASS=T>s1</SPAN> i <SPAN CLASS=T>s2</SPAN> s¹ identyczne. Inna funkcja, <SPAN CLASS=T>strcasecmp</SPAN> dzia³a podobnie, z tym ¿e ignoruje ró¿nice w wielkoœci liter. Istniej¹ te¿ odpowiednie funkcje <SPAN CLASS=T>strncmp</SPAN> i <SPAN CLASS=T>strncasecmp</SPAN>, których dzia³ania zapewne siê domyœlasz.
<BR><BR>
Bardzo przydatne przy korzystaniu z ³añcuchów jest przeszukiwanie ich. Szukaniem pojedynczych znaków zajmuje siê funkcja <SPAN CLASS=T>strchr</SPAN> (proszê siê nie œmiaæ - to nie ja wymyœla³em te nazwy ;-)):

<BR><BR>
<SPAN CLASS=T>strchr(<SPAN CLASS=K>char</SPAN>* string, <SPAN CLASS=K>char</SPAN> c)</SPAN>
<BR><BR>

Szuka ona znaku <SPAN CLASS=T>c</SPAN> w <SPAN CLASS=T>string</SPAN> i jeœli znajdzie, zwraca wskaŸnik do niego. Funkcja <SPAN CLASS=T>strrchr</SPAN> (trzeba mieæ zboczone poczucie humoru, ¿eby tak¹ nazwê stworzyæ ;-)) robi to samo, tylko ¿e zaczynaj¹c od koñca stringa.
<BR><BR>
Do wyszukiwania ca³ych s³ów w stringu mamy funkcjê <SPAN CLASS=T>strstr</SPAN> (znowu œmieszna nazwa):
<BR><BR>
<SPAN CLASS=T>strstr(<SPAN CLASS=K>char</SPAN>* haystack, <SPAN CLASS=K>char</SPAN>* needle)</SPAN>
<BR><BR>

Nierozmawiaj¹cych w jêzyku Szekspira oœwiecam, ¿e "haystack" to stog siana, a "needle" to ig³a - taki sposób na ³atwe zapamiêtania kolejnoœci argumentów funkcji <SPAN CLASS=T>strstr</SPAN>. Aha, funkcja 'strrstr' niestety nie istnieje, co jest jeszcze jednym powodem do napisania w³asnej klasy do obs³ugi stringów.
<BR><BR>
Coœ, czym standardowa biblioteka C++ bije na g³owê biblioteki jêzyków wy¿szego poziomu, jest funkcja <SPAN CLASS=T>strtok</SPAN>, która s³u¿y do... Wyci¹gania pojedynczych wyrazów z tekstu. Kto by siê spodziewa³ takich luksusów w tak "surowym" jêzyku, jak C++? Wystarczy podaæ zestaw znaków, kórymi mog¹ byæ rozdzielone te wyrazy, czyli: spacje, przecinki, wykrzykniki itp., po czym kolejnymi wywo³aniami <SPAN CLASS=T>strtok</SPAN> uzyskiwaæ kolejne wyrazy.
<BR><BR>
Tak konkretnie mówi¹c, dzia³anie funkcji <SPAN CLASS=T>strtok</SPAN> o sk³adni:
<BR><BR>
<SPAN CLASS=K>char</SPAN><SPAN CLASS=T>* strtok(<SPAN CLASS=K>char</SPAN>* newstring, <SPAN CLASS=K>char</SPAN>* delimiters)</SPAN>
<BR><BR>
polega na tym, ¿e zwraca ona wskaŸnik do pierwszego znaku ze s³owa, które nie zawiera ¿adnego ze znaków, podanych jako <SPAN CLASS=T>delimiters</SPAN>. Np:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN>* zdanie = <SPAN CLASS=L>"Oto jest zdanie"</SPAN>;<BR>
<SPAN CLASS=K>char</SPAN>* wyraz;<BR>
wyraz = strtok(zdanie, <SPAN CLASS=L>" "</SPAN>);<BR>
</TD></TR>
</TABLE>
<BR>

Zmienna <SPAN CLASS=T>wyraz</SPAN> bêdzie zawiera³a tekst <SPAN CLASS=L>"Oto"</SPAN>. Co zrobiæ, aby wyci¹gn¹æ resztê s³ów? Wywo³ywaæ <SPAN CLASS=T>strtok</SPAN> a¿ do skutku:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN>* temp, delim = <SPAN CLASS=L>" ,!?#$%&*"</SPAN>;<BR>
<SPAN CLASS=K>char</SPAN>* zdanie = <SPAN CLASS=L>"To jest nasze piêkne, d³ugie zdanie! Podoba siê?"</SPAN><BR>
temp = strtok(zdanie, delim);<BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;printf(<SPAN CLASS=L>"%s\n"</SPAN>, temp);<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>((temp=strtok(NULL, delim)) != NULL);<BR>
</TD></TR>
</TABLE>
<BR>

Program wypisze:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
To<BR>
jest<BR>
nasze<BR>
piêkne<BR>
d³ugie<BR>
zdanie<BR>
Podoba<BR>
siê<BR>
</SPAN>
</TD></TR>
</TABLE>
<BR>

Zauwa¿, ¿e nie wszystkie znaki, wpisane do <SPAN CLASS=T>delim</SPAN> s¹ wykorzystywane do podzia³u naszego zdania. Zauwa¿ te¿, ¿e tylko przy pierwszym wywo³aniu <SPAN CLASS=T>strtok</SPAN> podaliœmy pierwszy argument; podanie <SPAN CLASS=T>NULL</SPAN> mówi funkcji <SPAN CLASS=T>strtok</SPAN>, ¿e ma pobieraæ nastêpny wyraz. Gdybyœmy podali znowu <SPAN CLASS=T>zdanie</SPAN>, w wyniku otrzymywalibyœmy w nieskoñczonoœæ pierwszy wyraz (<SPAN CLASS=L>"To"</SPAN>), i program by siê zapêtli³, co stanowi sytuacjê wysoce niekorzystn¹ ;-).
<BR><BR>
Pewnie ciê ciekawi, sk¹d funkcja <SPAN CLASS=T>strtok</SPAN> wie, który wyraz ostatnio pobra³a? Otó¿ <SPAN CLASS=T>strtok</SPAN> oznacza to sobie w... stringu, który podaliœmy jako pierwszy argument! Czyli praktycznie niszczy go. Trochê niegrzecznie z jej strony, tak traktowaæ cudz¹ w³asnoœæ. Ale takie jest ¿ycie ;-). Dlatego te¿ zanim u¿yjesz <SPAN CLASS=T>strtok</SPAN> na stringu, najpierw go skopiuj, bo póŸniej bêdzie siê nadawa³ tylko do wyrzucenia ;-).
<BR><BR>
Jeœli zabawa ze standardowymi stringami ci siê nie spodoba³a, albo po prostu uwa¿asz owe stringi za niepraktyczne, a potrzeba ci do jakiegoœ programu wygodnej w u¿yciu klasy imituj¹cej stringi, mo¿esz skorzystaæ ze stworzonej ze mnie klasy PBString. Pliki klasy s¹ w dziale <A HREF="../download.html">download</A>, a opis - <A HREF="pbstring.html">tutaj</A>.
<BR><BR>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs02a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs03a.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>
