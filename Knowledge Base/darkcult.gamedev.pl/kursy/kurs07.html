<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs06a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs08.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Wirtualne klasy bazowe
</H2>

<P>
Jak nietrudno siê domyœliæ, dziedziczenie zastosowane na masow¹ skalê ³atwo mo¿e doprowadziæ do powstania wielu ró¿nych œmiesznych sytuacji. Jedn¹ z najprostszych, a wiêc i najczêœciej wystêpuj¹cych jest wielokrotne odziedziczenie przez jak¹œ klasê innej klasy. Mo¿e siê to zdarzyæ, jeœli jakaœ klasa <SPAN CLASS=T>D</SPAN> dziedziczy od co najmniej dwóch klas (np. <SPAN CLASS=T>B</SPAN> i <SPAN CLASS=T>C</SPAN>), z których ka¿da dziedziczy z kolei od jakiejœ klasy <SPAN CLASS=T>A</SPAN>.
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/krata.gif" ALT="Schemat kraty klas">
</P>
 
<P>
Taki uk³ad nosi bardzo mi siê podobaj¹c¹ nazwê - <SPAN CLASS=Wazne>krata klas</SPAN>. Jeœli chcesz komuœ zaszpanowaæ jeszcze bardziej "fachowym" okreœleniem, to powiedz mu o <SPAN CLASS=Wazne>skierowanym grafie acyklicznym</SPAN>. Pewnie trudno by³oby ci wymyœliæ na poczekaniu jak¹œ konkretn¹ programistyczn¹ sytuacjê, w której by takie "cuœ" wyst¹pi³o, aczkolwiek mo¿esz mi uwierzyæ na s³owo, ¿e wystêpuje, i to wcale nierzadko ;-).
</P>
<P>
Spróbujmy sobie tak¹ sytuacjê przedstawiæ przy pomocy przyk³adowego kodu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> a;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> C : <SPAN CLASS=K>public</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> c;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> B : <SPAN CLASS=K>public</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> b;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> D : <SPAN CLASS=K>public</SPAN> B, C<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> d;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Komplikacji, jakich sobie w³aœnie narobiliœmy, na razie mo¿emy nie dostrzegaæ. Ale w momencie, gdy spróbujemy sobie wyobraziæ, jakie sk³adowe s¹ dostêpne w klasie <SPAN CLASS=T>D</SPAN>, ju¿ nie bêdzie tak ró¿owo. No bo jakie s¹ te sk³adowe? Na pewno w klasie <SPAN CLASS=T>D</SPAN> mamy dostêp do <SPAN CLASS=T>d</SPAN> (¿adna rewelacja), na pewno mamy dostêp do bezpoœrednio dziedziczonych zmiennych <SPAN CLASS=T>b</SPAN> i <SPAN CLASS=T>c</SPAN>. Jak siê zapewne domyœlasz, poœrednio dziedzimy równie¿ sk³adow¹ <SPAN CLASS=T>a</SPAN>. No w³aœnie - sk³adow¹? Lepszym okreœleniem by³oby "sk³adowe <SPAN CLASS=T>a</SPAN>", bowiem dziedziczymy tê zmienn¹ podwójnie - raz od klasy <SPAN CLASS=T>B</SPAN>, raz od <SPAN CLASS=T>C</SPAN>. I nie ma tu znaczenia, ¿e pochodz¹ one od jednej klasy <SPAN CLASS=T>A</SPAN>!
</P>
<P>
Mimo wszystko powy¿szy kod bêdzie jak najbardziej poprawny, dopóki nie odwo³amy siê w nim do sk³adowej <SPAN CLASS=T>a</SPAN>. Zróbmy to jednak, poniewa¿ nauka na b³êdach jest zazwyczaj bardzo skuteczna ;-). Oto kod, który siê nie skompiluje:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;D Obiekt;<BR>
&nbsp;cout &lt;&lt; Obiekt.a &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Zapewne nasz kompilator powy¿sze wypociny skwituje pogardliwym komunikatem, zawieraj¹cym s³owo <SPAN CLASS=Inglisz>ambiguous</SPAN> (niejednoznaczny). Nic dziwnego - sk¹d ma biedak wiedzieæ, do której <SPAN CLASS=T>a</SPAN> chcemy siê odwo³aæ? Tej odziedziczonej od <SPAN CLASS=T>B</SPAN> czy tej od <SPAN CLASS=T>C</SPAN>?
</P>
<P>
Jedn¹ z mo¿liwoœci dogadania siê z kompilatorem bez stosowania przemocy ;-) jest jawne okreœlenie klasy sk³adowej, do której siê odwo³ujemy, za pomoc¹ operatora zasiêgu <SPAN CLASS=T>::</SPAN>, poprzedzaj¹cego jak zwykle nazwê tej sk³adowej. Na przyk³ad tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;D Obiekt;<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Skladowa a od klasy B: "</SPAN> &lt;&lt; Obiekt.B::a &lt;&lt; endl;<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Skladowa a od klasy C: "</SPAN> &lt;&lt; Obiekt.C::a &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jest to skuteczne, ale ma³o czytelne i doœæ k³opotliwe; w dodatku gdy tworzymy kratê klas, zazwyczaj nie zale¿y nam na tworzeniu kopii sk³adowych "superbazowej" klasy (u nas <SPAN CLASS=T>A</SPAN>). Ba, zdarza siê nawet, ¿e obecnoœæ dodatkowych sk³adowych najzwyczajniej w œwiecie przeszkadza (zajmuje dodatkow¹ pamiêæ itp.). I w tym miejscu pora wreszcie dowiedzieæ siê, co to takiego <SPAN CLASS=Wazne>klasa wirtualna</SPAN>.
</P>
<P>
Otó¿ odwo³uj¹c siê do naszego "abecad³owego" przyk³adu: gdyby klasa <SPAN CLASS=T>A</SPAN> by³a wirtualna, to jej sk³adowe by³yby przez klasê <SPAN CLASS=T>D</SPAN> dziedziczone TYLKO RAZ (trochê nieprecyzyjne zdanie, ale nie chcê zaciemniaæ sprawy na samym pocz¹tku). Innymi s³owy, w klasie <SPAN CLASS=T>D</SPAN> by³by tylko jeden "egzemplarz" zmiennej <SPAN CLASS=T>a</SPAN>, a wiêc mo¿na by by³o siê do niego odwo³ywaæ bez wykorzystania operatora <SPAN CLASS=T>::</SPAN>.
</P>
<P>
PrzejdŸmy do praktyki. Zmieniony kod bêdzie wygl¹da³ teraz tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> a;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> C : <SPAN CLASS=K>virtual public</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> c;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> B : <SPAN CLASS=K>virtual public</SPAN> A<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> b;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> D : <SPAN CLASS=K>public</SPAN> B, C<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> d;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
¯ebyœmy nie musieli siê trudziæ wyszukiwaniem ró¿nic: doda³em tylko dwa s³owa <SPAN CLASS=K>virtual</SPAN> po operatorze dziedziczenia w klasach <SPAN CLASS=T>C</SPAN> i <SPAN CLASS=T>B</SPAN>. W ten sposób klasa <SPAN CLASS=T>A</SPAN> sta³a siê klas¹ wirtualn¹. Byæ mo¿e wydaje ci siê dziwne, ¿e zrobiliœmy to w³aœnie w klasach <SPAN CLASS=T>C</SPAN> i <SPAN CLASS=T>B</SPAN>, a nie na przyk³ad w <SPAN CLASS=T>D</SPAN>. Dlatego od razu musimy sobie zdaæ sprawê z pewnej w³aœciwoœci klas wirtualnych:
</P>
<P CLASS=UWAGA>
Wirtualnoœæ klas jest wzglêdna - nie jest cech¹ klasy wirtualnej, tylko tych spoœród jej klas pochodnych, w których zadeklarowano tê klasê jako wirtualn¹.
</P>
<P>
To oznacza, ¿e sama klasa <SPAN CLASS=T>A</SPAN> "nie wie" o tym, ¿e jest wirtualna. Co wiêcej, dla niektórych klas pochodnych mo¿e ona byæ wirtualna, a dla innych nie. Wszystko zale¿y od tego, która z tych pochodnych klas zawiera s³ówko <SPAN CLASS=K>virtual</SPAN>.
</P>
<P>
Wracaj¹c do "ulepszonej" wersji naszych czterech klas - teraz, dysponuj¹c wirtualn¹ klas¹ bazow¹ <SPAN CLASS=T>D</SPAN>, mo¿emy wykonaæ tamten "sporny" kod bez ryzykowania pyskówki z kompilatorem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;D Obiekt;<BR>
&nbsp;cout &lt;&lt; Obiekt.a &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Dzia³a? Dzia³a. No to fajnie ;-).
</P>
<P>
Ktoœ dociekliwy móg³by jeszcze spytaæ, co takiego by siê sta³o, gdyby np. tylko w klasie <SPAN CLASS=T>B</SPAN> by³o <SPAN CLASS=K>virtual</SPAN>, natomiast w klasie <SPAN CLASS=T>C</SPAN> - nie. Wtedy kompilator niestety nie zrozumia³by, o co nam w³aœciwie chodzi³o - nie skojarzy³by klas <SPAN CLASS=T>C</SPAN> i <SPAN CLASS=T>B</SPAN> w "wirtualn¹ parê" i zmienna <SPAN CLASS=T>a</SPAN> znów by³aby dziedziczona podwójnie, a wiêc wrócilibyœmy do z³owrogiego komunikatu o niejednoznacznoœci (praktycznie taka sama sytuacja, jak wtedy).
</P>
<H2>
Wirtualne destruktory
</H2>
<P>
Jak doskonale wiemy, w przypadku niszczenia obiektu klasy pochodnej najpierw wywo³ywany jest destruktor klasy pochodnej, a nastêpnie - destruktor klasy bazowej. Jest to naturalne i oczywiste. Dlatego te¿ konia z rzêdem temu, kto wyt³umaczy, dlaczego nie jest tak w poni¿szym przyk³adzie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Baza<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN>* wsk;<BR>
&nbsp;Baza()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Konstruktor Bazy"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;wsk = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>5</SPAN>]; <BR>
&nbsp;}<BR>
&nbsp;~Baza()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Destruktor Bazy"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>delete[]</SPAN> wsk;<BR>
&nbsp;}<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Pochodna<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN>* nic;<BR>
&nbsp;Pochodna()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Kostruktor Pochodnej"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;nic = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>100</SPAN>];<BR>
&nbsp;}<BR>
&nbsp;~Pochodna()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Destruktor Pochodnej"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>delete[]</SPAN> nic;<BR>
&nbsp;}<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Bazowa* lpObiekt = <SPAN CLASS=K>new</SPAN> Pochodna;<BR>
&nbsp;<SPAN CLASS=K>delete</SPAN> lpObiekt;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Wynik? Dla przysz³ego w³aœciciela konia z rzêdem oczywisty, pozosta³ym pewnie siê wyda dziwny:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Konstruktor Bazy<BR>
Kostruktor Pochodnej<BR>
Destruktor Bazy<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Dlaczego nie ma wywo³ania destruktora klasy <SPAN CLASS=T>Pochodna</SPAN>? Jeœli jesteœ spostrzegawczy, to pewnie nie umknê³a ci pierwsza linijka funkcji <SPAN CLASS=T>main</SPAN>. Mamy w niej przypisanie wskaŸnika - œwie¿o utworzonegp obiektu klasy <SPAN CLASS=T>Pochodna</SPAN> - do wskaŸnika typu <SPAN CLASS=T>Bazowa</SPAN>. Przypisanie takie jest mo¿liwe, o czym wspomnieliœmy (byæ mo¿e ;-) ) w czêœci kursu o dziedziczeniu. Problem w tym, ¿e w momencie wykonania instrukcji <SPAN CLASS=K>delete</SPAN><SPAN CLASS=T> lpObiekt</SPAN> kompilator nic nie wie o typie obiektu, wskazywanego przez ten wskaŸnik. Mo¿e to byæ zarówno <SPAN CLASS=T>Bazowa</SPAN>, jak i dowolna jej klasa pochodna. Dlatego kompilator domyœlnie przyjmuje, ¿e obiekt nale¿y do klasy bazowej i wywo³uje destruktor klasy <SPAN CLASS=T>Bazowa</SPAN>. Natomiast w klasie <SPAN CLASS=T>Bazowa</SPAN> nie ma ¿adnych informacji o tym, ¿e nale¿y jeszcze wywo³aæ destruktor klasy <SPAN CLASS=T>Pochodna</SPAN>.
</P>
<P>
Konsekwencje s¹ nader przykre. Nie ma wywo³anego destruktora, wiêc <SPAN CLASS=L>100</SPAN> cennych bajtów pamiêci operacyjnej idzie na wycieczkê i nie wraca. Wycieczek takich nie lubimy i nie bêdziemy tolerowaæ, wiêc trzeba wymyœliæ jakiœ sposób na zapobie¿enie takowym. Wspomnia³em o braku informacji o istnieniu destruktora klasy pochodnej, który trzeba wywo³aæ z klasy <SPAN CLASS=T>Bazowa</SPAN> przy niszczeniu obiektu, wskazywanego przez wskaŸnik do tej¿e klasy <SPAN CLASS=T>Bazowa</SPAN>. Mo¿emy wiêc tak¹ informacjê umieœciæ, a uczynimy to przy pomocy znanego nam ju¿ s³ówka <SPAN CLASS=K>virtual</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Baza<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN>* wsk;<BR>
&nbsp;Baza()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Konstruktor Bazy"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;wsk = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>5</SPAN>]; <BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>virtual</SPAN> ~Baza()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Destruktor Bazy"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>delete[]</SPAN> wsk;<BR>
&nbsp;}<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Pochodna<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN>* nic;<BR>
&nbsp;Pochodna()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Kostruktor Pochodnej"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;nic = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>100</SPAN>];<BR>
&nbsp;}<BR>
&nbsp;~Pochodna()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Destruktor Pochodnej"</SPAN> &lt;&lt; endl;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>delete[]</SPAN> nic;<BR>
&nbsp;}<BR>
};<BR>
<SPAN CLASS=C>// Funkcja main oczywiœcie zostaje jaka by³a</SPAN>
</TD></TR>
</TABLE>

<P>
Jedno ma³e virtual, a ile dobra ;-). Teraz oczywiœcie wszystko dzia³a, jak nale¿y:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Konstruktor Bazy<BR>
Kostruktor Pochodnej<BR>
Destruktor Pochodnej<BR>
Destruktor Bazy<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Nasze magiczne s³ówko zmienia plan dzia³ania kompilatora podczas wywo³ywania <SPAN CLASS=K>delete </SPAN><SPAN CLASS=T> lpObiekt</SPAN>. Wczeœniej kompilator po prostu wywo³ywa³ destruktor klasy <SPAN CLASS=T>Bazowa</SPAN>, po czym bezmyœlnie odpuszcza³ sobie dalsze dzia³anie, bo nie wiedzia³, ¿e coœ jeszcze musi zrobiæ. Tutaj nasze ma³e sprytne <SPAN CLASS=K>virtual</SPAN> sygnalizuje mu: te, kompilator - uwa¿aj, w tym wskaŸniku mo¿e siedzieæ obiekt klasy pochodnej, wiêc trzeba wtedy dodatkowo wywo³aæ jego w³asny destruktor. I kompilator robi, co mu ka¿¹: sprawdza, czy wskazywany obiekt jest klas¹ bazow¹ czy pochodn¹, w tym drugim przypadku wywo³uje destruktor klasy pochodnej, i dopiero potem destruktor klasy bazowej.
</P>
<P CLASS=UWAGA>
Jeœli twoja klasa pochodna ma jawny destruktor, to w jej klasie bazowej zadeklaruj koniecznie wirtualny destruktor.
</P>
<P>
Mo¿e jeszcze zaistnieæ sytuacja, ¿e w klasie pochodnej bêdziesz potrzebowa³ napisaæ destruktor, a w bazowej - nie. Wówczas bez chwili zastanowienia do klasy bazowej wrzuæ wirtualny destruktor - mo¿e on nawet nic konkretnego nie robiæ (pusty blok instrukcji), byle tylko by³ wirtualny.
</P>

<H2>
Funkcje wirtualne
</H2>

<P>
Mo¿liwoœæ wskazywania przez wskaŸniki klasy bazowej na obiekty klasy pochodnej, a ogólnie mówi¹c: wykorzystywania wirtualnoœci, poszerza doœæ znacznie nasze programistyczne horyzonty. Dziêki temu mo¿emy nie tylko tworzyæ klasy dziedzicz¹ce cechy innych klas, ale równie¿ "unowoczeœniaæ" dzia³anie "starych" klas przez zastêpowanie "starych" funkcji "nowymi" ich wersjami. Przyjrzymy siê takiemu zastêpowaniu na najprostszym mo¿liwym przyk³adzie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Stara<BR>
{<BR>
&nbsp;<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> a;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;Stara(<SPAN CLASS=K>int</SPAN> na=<SPAN CLASS=L>0</SPAN>) { a=na; }<BR>
&nbsp;&nbsp;<SPAN CLASS=K>virtual void </SPAN>Podaj() { cout &lt;&lt; <SPAN CLASS=L>"a: "</SPAN> &lt;&lt; a &lt;&lt; endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Nowa : <SPAN CLASS=K>public</SPAN> Stara<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> b;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;Nowa(<SPAN CLASS=K>int</SPAN> na=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> nb=<SPAN CLASS=L>0</SPAN>) : Stara(na) { b=nb; }<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Podaj() { cout &lt;&lt; <SPAN CLASS=L>"a: "</SPAN> &lt;&lt; a &lt;&lt; <SPAN CLASS=L>", b: "</SPAN> &lt;&lt; b &lt;&lt; endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Stara *StaryObiekt, *NowyObiekt;<BR>
<BR>
&nbsp;StaryObiekt = <SPAN CLASS=K>new</SPAN> Stara(<SPAN CLASS=L>5</SPAN>);<BR>
&nbsp;NowyObiekt  = <SPAN CLASS=K>new</SPAN> Nowa(<SPAN CLASS=L>7,19</SPAN>);<BR>
<BR>
&nbsp;StaryObiekt->Podaj();<BR>
&nbsp;NowyObiekt->Podaj();<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Co otrzymujemy na ekranie?
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
a: 5<BR>
a: 7, b: 19<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Mamy w powy¿szym programiku klasê <SPAN CLASS=T>Stara</SPAN>, posiadaj¹c¹ jedn¹ chronion¹ zmienn¹ sk³adow¹ <SPAN CLASS=T>a</SPAN>, oraz klasê <SPAN CLASS=T>Nowa</SPAN>, która oprócz dziedziczonej <SPAN CLASS=T>a</SPAN> posiada te¿ w³asn¹ sk³adow¹ <SPAN CLASS=T>b</SPAN>. Obydwie sk³adowe mog¹ byæ zainicjalizowane przy pomocy odpowiednich konstruktorów. Oprócz tego mamy metodê <SPAN CLASS=T>Podaj</SPAN>, s³u¿¹c¹ do wypisywania wartoœci tych sk³adowych. Klasa <SPAN CLASS=T>Stara</SPAN> posiada tylko sk³adow¹ <SPAN CLASS=T>a</SPAN>, wiêc jej metoda <SPAN CLASS=T>Podaj</SPAN> tylko tê jedn¹ sk³adow¹ wypisuje. Natomiast w klasie <SPAN CLASS=T>Nowa</SPAN> funkcja <SPAN CLASS=T>Podaj</SPAN> uwzglêdnia dodatkowo sk³adow¹ <SPAN CLASS=T>b</SPAN>.
</P>
<P>
W funkcji <SPAN CLASS=T>main</SPAN> mamy deklaracjê dwóch wskaŸników do klasy <SPAN CLASS=T>Stara</SPAN>. Jeden z nich wykorzystujemy do wskazania w³aœnie na obiekt klasy <SPAN CLASS=T>Stara</SPAN> (utworzony dynamicznie - zwalnianie pamiêci mo¿esz sobie dopisaæ sam, pamiêtaj¹c o wirtualnych destruktorach), drugi - do wskazania na obiekt klasy <SPAN CLASS=T>Nowa</SPAN>. Nastêpnie przez te wskaŸniki wywo³ujemy metodê <SPAN CLASS=T>Podaj</SPAN>. Program wykona siê zgodnie z nasz¹ intuicj¹ - dla wskaŸnika <SPAN CLASS=T>StaryObiekt</SPAN> wywo³a <SPAN CLASS=T>Podaj</SPAN> z klasy <SPAN CLASS=T>Stara</SPAN>, dla <SPAN CLASS=T>NowyObiekt</SPAN> - z klasy <SPAN CLASS=T>Nowa</SPAN>.
</P>
<P>
Co zaœ sta³oby siê, gdyby usun¹æ s³ówko <SPAN CLASS=K>virtual</SPAN> sprzed definicji metody <SPAN CLASS=T>Podaj</SPAN> w klasie <SPAN CLASS=T>Stara</SPAN>? Wtedy, czego powinieneœ ju¿ domyœliæ siê sam, podczas dziedziczenia "stara" wersja <SPAN CLASS=T>Podaj</SPAN> zosta³aby po prostu przes³oniêta przez jej wersjê z klasy <SPAN CLASS=T>Nowa</SPAN>. Natomiast przy wywo³ywaniu tej metody przez wskaŸnik do klasy <SPAN CLASS=T>Stara</SPAN> kompilator po prostu by siê pogubi³, bo nie wiedzia³by, jakiej klasy jest de facto obiekt wskazywany. Tymczasem s³owo <SPAN CLASS=K>virtual</SPAN> sygnalizuje mu, ¿e gdzieœ w innej klasie mo¿e wyst¹piæ redefinicja funkcji <SPAN CLASS=T>Podaj</SPAN> i przy wywo³ywaniu tej¿e funkcji przez wskaŸnik nale¿y poszukaæ tej innej wersji.
</P>
<P>
"Nowa" wersja funkcji, której "stara" definicja zosta³a oznaczona jako wirtualna, sama równie¿ automatycznie staje siê wirtualna. Mo¿emy wiêc i tê "now¹" wersjê oznaczyæ s³owem <SPAN CLASS=K>virtual</SPAN>, ale nie musimy.
</P>
<P>
Nie pomyœl sobie przypadkiem, ¿e wirtualnoœæ funkcji zmienia regu³y przys³aniania "starej" wersji przez "now¹". Tamta "stara" wersja nadal jest dostêpna, oczywiœcie za pomoc¹ operatora <SPAN CLASS=T>::</SPAN>. Wirtualnoœæ wp³ywa praktycznie tylko na to, co dzieje siê przy wywo³ywaniu funkcji przez "uniwersalny" wskaŸnik:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Stara *StaryObiekt, *NowyObiekt;<BR>
<BR>
&nbsp;StaryObiekt = <SPAN CLASS=K>new</SPAN> Stara(<SPAN CLASS=L>5</SPAN>);<BR>
&nbsp;NowyObiekt  = <SPAN CLASS=K>new</SPAN> Nowa(<SPAN CLASS=L>7,19</SPAN>);<BR>
<BR>
&nbsp;StaryObiekt->Podaj();<BR>
&nbsp;NowyObiekt->Podaj();<BR>
<BR>
&nbsp;<SPAN CLASS=C>// "stara" wersja wci¹¿ dostêpna</SPAN><BR>
&nbsp;NowyObiekt->Stara::Podaj();<BR>
<BR>
&nbsp;<SPAN CLASSKT>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Tym razem efekt jest taki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
a: 5<BR>
a: 7, b: 19<BR>
a: 7<BR>
</SPAN>
</TD></TR>
</TABLE>

<H2>
Funkcje czysto wirtualne
</H2>

<P>
Czasami klasê projektuje siê tak, ¿eby stanowi³a ona tylko coœ w rodzaju makiety, która bêdzie s³u¿y³a tylko do przekazania innym klasom pewnych cech, natomiast sama nie bêdzie stanowiæ samodzielnej klasy. Klasê tak¹ nazywamy <SPAN CLASS=Wazne>abstrakcyjn¹</SPAN>, poniewa¿ nie da siê utworzyæ obiektów takiej klasy. Przynajmniej jedna z funkcji sk³adowych takiej klasy jest <SPAN CLASS=Wazne>czysto wirtualna</SPAN>, tzn. nie posiada ¿adnej definicji, a jest w³aœnie tylko "makiet¹". Klasa, która dziedziczy od klasy abstrakcyjnej MUSI tak¹ czysto wirtualn¹ funkcjê zdefiniowaæ sama - chyba, ¿e sama te¿ ma byæ abstrakcyjna.
</P>
<P class=UWAGA>
Jeœli klasa, dziedzicz¹ca od klasy abstrakcyjnej nie zdefiniuje czysto wirtualnych metod z klasy bazowej, to sama automatycznie staje siê klas¹ abstrakcyjn¹.
</P>
<P>
¯eby pokazaæ to na przyk³adzie, stworzymy sobie jak¹œ klasê abstrakcyjn¹. Nie bêdzie ona mia³a ¿adnych sk³adowych, a jedynie funkcjê czysto wirtualn¹ <SPAN CLASS=T>Podaj</SPAN>. Deklaracja takiej funkcji wygl¹da doœæ œmiesznie i myl¹co, ale nic to. Do dzie³a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Abstrakcja<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>virtual void</SPAN> Podaj() = <SPAN CLASS=L>0</SPAN>;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, ró¿nica miêdzy funkcj¹ czysto wirtualn¹ a "zwyk³¹" wirtualn¹ polega w deklaracji wy³¹cznie na przyrównaniu jej do zera. Twórcom jêzyka chodzi³o zapewne o podkreœlenie faktu, ¿e funkcja taka nic nie robi, niemniej jestem w stanie wyobraziæ sobie zrêczniejsz¹ notacjê dla funkcji czysto wirtualnej. Mniejsza zreszt¹ o to. Teraz pora na "w³aœciw¹" klasê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Wlasciwa : <SPAN CLASS=K>public</SPAN> Abstrakcja<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Podaj() { cout &lt;&lt; <SPAN CLASS=L>"Tu funkcja Podaj"</SPAN> &lt;&lt; endl;  }<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Nie mo¿emy stworzyæ zmiennej typu <SPAN CLASS=T>Abstrakcja</SPAN> (zgodnie z tym, co powiedzieliœmy sobie wy¿ej), ale wskaŸnik do takiego typu - owszem, i nawet takie rozwi¹zanie jest praktycznie podstawowym powodem wprowadzenia funkcji czysto wirtualnych w C++. WskaŸnik taki bêdzie zawsze zawiera³ adres obiektu jakiejœ klasy pochodnej od <SPAN CLASS=T>Abstrakcja</SPAN> (oczywiœcie o ile nie bêdzie pusty). 
</P>
<P>
Jak widzimy na powy¿szym przyk³adzie, funkcja czysto wirtualna spe³nia w praktyce tak¹ sam¹ rolê, jak "zwyk³a" wirtualna, jedyna ró¿nica polega na tym, ¿e na kompilatorze <SPAN CLASS=Wazne>wymuszana</SPAN> jest definicja danej funkcji w klasie pochodnej (przy "zwyk³ych" wirtualnych redefinicja jest <SPAN CLASS=Wazne>opcjonalna</SPAN>).
</P>
<P>
Jeœli nie za³apa³eœ nic z funkcji/klas wirtualnych, to niekoniecznie musisz podcinaæ sobie ¿y³y tudzie¿ robiæ coœ równie weso³ego - ma³o kto ³apie za pierwszym razem, tak te¿ zreszt¹ by³o i w przypadku autora tego kursu ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs06a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs08.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>