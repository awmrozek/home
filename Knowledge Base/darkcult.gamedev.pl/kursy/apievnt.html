<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Mysz & klawiatura</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apictrl.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apifile.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Obs³uga urz¹dzeñ wejœciowych
</H1>

<P>
W Windowsie zazwyczaj siê coœ dzieje. Oprócz b³êdów krytycznych, zapêtleñ, wyczerpywania zasobów systemowych, blue screenów tudzie¿ zwyk³ej niestabilnoœci zdarza siê te¿ czasem, ¿e Windows wykonuje coœ po¿ytecznego. Polega to ogólnie na tym, ¿e u¿ytkownik wprowadza jakieœ dane i otrzymuje inne dane w zamian. Zjawisko to nazywamy interakcj¹. Aby by³o to mo¿liwe, generowane s¹ tzw. <SPAN CLASS=Wazne>zdarzenia</SPAN> (<SPAN CLASS=Inglisz>events</span>). Zdarzeniem mo¿e byæ poruszenie mysz¹, wciœniêcie klawisza, wybranie jakiejœ pozycji menu, zamkniêcie lub przesuniêcie okna itp. 
</P>
<P>
Ka¿de zdarzenie w Windows jest skojarzone z odpowiednim komunikatem. ¯eby obs³u¿yæ jakieœ zdarzenie (przypisaæ mu konkretne dzia³anie, np. naje¿d¿amy kursorem myszy na obiekt - kszta³t kursora siê zmienia), musimy dopisaæ odpowiedni kod do procedury obs³ugi komunikatów. Procedura ta mo¿e mieæ ró¿ne nazwy (zale¿y od fantazji programisty), ale najczêœciej nazywa siê <SPAN CLASS=T>WindowProcedure</SPAN> (procedurê o takiej nazwie generuje domyœlnie Dev-C++) albo krócej <SPAN CLASS=T>WndProc</SPAN>. Ja bêdê raczej u¿ywa³ tej pierwszej - d³u¿sza, ale dla pocz¹tkuj¹cych byæ mo¿e bardziej wymowna.
</P>
<P>
Przyjrzyjmy siê bli¿ej tej procedurze:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK WindowProcedure(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN> (message)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_CLOSE:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;DestroyWindow(hwnd);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> DefWindowProc(hwnd, message, wParam, lParam);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Tak mniej wiêcej wygl¹da domyœlna procedura obs³ugi komunikatów, wygenerowana przez Dev-C++ jeœli stworzymy w nim nowy projekt windowsowy. Na razie obs³uguje ona tylko dwa komunikaty: <SPAN CLASS=T>WM_CLOSE</SPAN>, wysy³any przez system w przypadku gdy u¿ytkownik zamknie okno programu (reakcj¹ jest zniszczenie zamkniêtego okna funkcj¹ <SPAN CLASS=T>DestroyWindow</SPAN>), oraz <SPAN CLASS=T>WM_DESTROY</SPAN> wysy³any przez system w momencie niszczenia okna (reakcj¹ jest wys³anie komunikatu o zakoñczeniu dzia³ania programu). Jak nietrudno siê domyœliæ, wys³anie tego pierwszego komunikatu w tym przypadku powoduje automatycznie wys³anie tego drugiego, zaœ z kolei ten drugi spowoduje w linii prostej wyjœcie z programu.
</P>
<P>
Procedura obs³ugi komunikatów powinna zawsze zwróciæ <SPAN CLASS=L>0</SPAN> w przypadku poprawnego obs³u¿enia komunikatu. Do procedury <SPAN CLASS=T>WindowProcedure</SPAN> wysy³any jest ka¿dy komunikat, jaki trafi siê podczas dzia³ania programu, wiêc jeœli programista nie przewiduje obs³ugi danego komunikatu (tj. nie jest mu to potrzebne), musi ten komunikat przekazaæ (w stanie nienaruszonym ;-)) do domyœlnej funkcji obs³ugi - <SPAN CLASS=T>DefWindowProc</SPAN> (która zreszt¹ najczêœciej nie robi z tym komunikatem nic konkretnego, ale takie traktowanie jest wymagane).
</P>
<P>
Jak widaæ, wewn¹trz funkcji <SPAN CLASS=T>WindowProcedure</SPAN> mamy do dyspozycji cztery parametry, które musz¹ nam wystarczyæ do obs³u¿enia danego komunikatu. Pierwszy (tutaj <SPAN CLASS=T>hwnd</SPAN>) to uchwyt naszego g³ównego okna - chyba nie trzeba t³umaczyæ, po co jest. Drugi (tutaj <SPAN CLASS=T>message</SPAN>) to kod komunikatu - u¿ywamy go najczêœciej tylko w g³ównej kontrukcji <SPAN CLASS=K>switch-case</SPAN> do wybrania w³aœciwego fragmentu kodu do danego komunikatu. Pozosta³e parametry (<SPAN CLASS=T>wParam</SPAN> i <SPAN CLASS=T>lParam</SPAN>) s¹ dodatkow¹ informacj¹ o komunikacie, i tak na przyk³ad w przypadku komunikatu o klikniêciu mysz¹ bêd¹ one zawiera³y kod konkretnego przycisku myszy, który zosta³ wciœniêty przez usera oraz wspó³rzêdne wskaŸnika myszy w chwili wciœniêcia.
</P>
<P>
W poprzedniej czêœci tego kursu, poœwiêconej kontrolkom, zobaczyliœmy jak siê obs³uguje podstawowe komunikaty zwi¹zane z tymi kontrolkami. Poznaliœmy te¿ niektóre aspekty korzystania z parametrów <SPAN CLASS=T>wParam</SPAN> i <SPAN CLASS=T>lParam</SPAN>, przekonuj¹c siê przy okazji w praktyce, jak wa¿ne one s¹. Teraz dowiemy siê, jak obs³ugiwaæ komunikaty zwi¹zane z mysz¹ i klawiatur¹.
</P>

<H2>
Obs³uga klikniêæ mysz¹
</H2>

<P>
Aby nasz kochany, szary gryzoñ zacz¹³ ¿yæ w³asnym ¿yciem, trzeba dodaæ obs³ugê kilku komunikatów myszy. Zacznijmy od zwyk³ego klikniêcia. Dla systemu klikniêcie sk³ada siê z dwóch faz: wciœniêcia danego przycisku myszy i zwolnienia go. Dziêki takiemu rozró¿nieniu mo¿liwe s¹ operacje typu "przeci¹gnij-i-upuœæ" (nawiasem mówi¹c jedna z najbardziej wkurzaj¹cych cech Windows, przyczyna wielu zaginiêæ plików, które póŸniej odnajduj¹ siê w zaskakuj¹cych miejscach). Któr¹ z tych dwóch faz uznasz za w³aœciwe klikniêcie, to ju¿ tylko od ciebie zale¿y. Mo¿esz tak¿e akceptowaæ tylko pe³ne klikniêcie: zapamiêtywaæ w jakiejœ zmiennej, ¿e user wcisn¹³ przycisk myszy w obrêbie danej kontrolki i póŸniej gdy go zwolni, a wskaŸnik myszy bêdzie nadal nad t¹ kontrolk¹, wywo³aæ jakieœ dzia³anie.
</P>
<P>
Windows domyœlnie rozró¿nia trzy przyciski myszy (lewy, prawy i œrodkowy). Wciœniêcie tych przycisków wywo³uje odpowiednio komunikaty: <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN>, <SPAN CLASS=T>WM_RBUTTONDOWN</SPAN>, <SPAN CLASS=T>WM_MBUTTONDOWN</SPAN>. Jeœli interesuj¹ ciê jakieœ dodatkowe przyciski, to musisz siêgn¹æ do odpowiednich bibliotek (np. DirectInput z pakietu DirectX) lub szukaæ innych sposobów ich zaprogramowania. Jak siê zapewne domyœlasz, zwolnienie przycisków powoduje wys³anie komunikatów <SPAN CLASS=T>WM_LBUTTONUP</SPAN>, <SPAN CLASS=T>WM_RBUTTONUP</SPAN> i <SPAN CLASS=T>WM_MBUTTONUP</SPAN>.
</P>
<P>
Kompletne pojedyncze klikniêcie na danym obiekcie musimy sobie wiêc wykryæ sami, ale na szczêœcie podwójne klikniêcia w ca³oœci zale¿¹ od ustawieñ systemowych, wiêc te¿ i system je wykrywa, wysy³aj¹c nam wtedy odpowiedni komunikat, np. <SPAN CLASS=T>WM_LBUTTONDBLCLK</SPAN> (mam nadziejê, ¿e nie bêdziesz mia³ problemów z rozszyfrowaniem tego skrótu ;-)). Jest jednak ma³y haczyk - podwójne klikniêcia wykrywane s¹ tylko dla okien, które nale¿¹ do klasy z ustawionym stylem <SPAN CLASS=T>CS_DBLCLKS</SPAN>. Musimy wiêc zajrzeæ do kodu rejestrowania klasy okna i upewniæ siê, czy ten styl jest faktycznie ustawiony. Fragment ten powinien wygl¹daæ mniej wiêcej tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
wincl.style = CS_DBLCLKS;<BR>
</TD></TR>
</TABLE>

<P>
Warto od razu wspomnieæ, ¿e jeœli piszesz jak¹œ grê (lub inny program), gdzie trzeba du¿o i szybko klikaæ, to pewnie zauwa¿ysz, ¿e na niektóre klikniêcia program ten po prostu nie reaguje. Winowajc¹ mo¿e byæ w³aœnie ta flaga - <SPAN CLASS=T>CS_DBLCLKS</SPAN>, która powoduje, ¿e czêœæ klikniêæ "znika", czego w wiêkszoœci przypadków nie chcemy - w takim przypadku nale¿y usun¹æ tê flagê.
</P>

<P>
Najlepiej jest pokazaæ dzia³anie komunikatów myszy, bawi¹c siê w rysowanie po okienku, tak ¿e jeœli jeszcze nie wiesz nic na temat grafiki w WinAPI, radzê rzuciæ okiem na jedn¹ z nastêpnych czêœci tego kursu, coby wszystko w tym przyk³adzie by³o jasne. Napiszemy sobie programik, który ³¹czy nam liniami punkty, w których klikniemy z lewym górnym rogiem okienka. Ponadto przy ka¿dym dwukrotnym klikniêciu bêdzie stawia³ kó³eczko. Wystarczy nam dodaæ obs³ugê komunikatów <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN> i <SPAN CLASS=T>WM_LBUTTONDBLCLK:</SPAN>
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONDOWN:<BR>
{<BR>
&nbsp;HDC hdc = GetDC(hwnd);<BR>
&nbsp;LineTo(hdc, LOWORD(lParam), HIWORD(lParam));<BR>
&nbsp;ReleaseDC(hwnd, hdc);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONDBLCLK:<BR>
{<BR>
&nbsp;HDC hdc = GetDC(hwnd);<BR>
&nbsp;Ellipse(hdc, LOWORD(lParam)-<SPAN CLASS=L>3</SPAN>, HIWORD(lParam)-<SPAN CLASS=L>3</SPAN>, LOWORD(lParam)+<SPAN CLASS=L>3</SPAN>, HIWORD(lParam)+<SPAN CLASS=L>3</SPAN>);<BR>
&nbsp;ReleaseDC(hwnd, hdc);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Jedyna prawdziwa nowoœæ w tym przyk³adziku to wyra¿enia <SPAN CLASS=T>LOWORD(lParam)</SPAN> i <SPAN CLASS=T>HIWORD(lParam)</SPAN>. Otó¿ komunikat <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN>, podobnie jak inne komunikaty myszy, niesie ze sob¹ w argumencie <SPAN CLASS=T>lParam</SPAN> informacjê o wspó³rzêdnych wskaŸnika myszy w chwili wys³ania tego komunikatu (czyli tutaj w chwili klikniêcia). Wspó³rzêdna X jest przechowywana w dolnym s³owie zmiennej <SPAN CLASS=T>lParam</SPAN>, natomiast wspó³rzêdna Y - w górnym s³owie. Do "wyci¹gniêcia" wspó³rzêdnych (czyli podzia³u lParam na dwie po³ówki) u¿ywamy wiêc makr <SPAN CLASS=T>LOWORD</SPAN> i <SPAN CLASS=T>HIWORD</SPAN>.
</P>
<P>
Jak widaæ na tym przyk³adzie, Windows wysy³a wprawdzie komunikaty dla pojedynczych i podwójnych klikniêæ osobno, ale jeœli wykonamy podwójne klikniêcie, to zostan¹ wys³ane obydwa te komunikaty. Dlatego jeœli chcemy zaprogramowaæ zarówno pojedyncze kliniêcie, jak i podwójne, aby ka¿de z nich mia³o przypisan¹ inn¹ akcjê, musimy byæ ostro¿ni. 
</P>

<H2>
Poruszanie mysz¹
</H2>

<P>
Oprócz klikania, mysz¹ mo¿na poruszaæ (to ci dopiero nowoœæ, nieprawda¿? ;-)). Za ruchy myszy odpowiedzialny jest komunikat <SPAN CLASS=T>WM_MOUSEMOVE</SPAN>, wysy³any za ka¿dym razem, gdy jakaœ rolka w myszy choæby drgnie - ten to dopiero ma w Windowsie przechlapane! Pomyœl sobie, ile razy jest on wywo³ywany w ci¹gu dnia! :-)
</P>
<P>
Argumenty komunikatu <SPAN CLASS=T>WM_MOUSEMOVE</SPAN> pe³ni¹ identyczn¹ rolê jak w komunikatach obs³uguj¹cych klikniêcia. Napiszmy wiêc sobie teraz jeszcze fajniejszy program do rysowania po okienku. Tym razem bêdzie to ju¿ prawie program graficzny z prawdziwego zdarzenia ;-). Biega nam o to, aby rysowany by³ pojedynczy punkt za ka¿ym razem, gdy u¿ytkownik wciœnie lewy przycisk myszy, a tak¿e (czy nawet przede wszystkim) gdy user przesuwa mysz, jeœli przycisk jest wciœniêty. Potrzeba nam wiêc obs³ugi wszystkich trzech komunikatów <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN>, <SPAN CLASS=T>WM_LBUTTONUP</SPAN>, <SPAN CLASS=T>WM_MOUSEMOVE</SPAN>, a tak¿e globalnej zmiennej, która bêdzie mówi³a nam, czy w danej chwili przycisk jest wciœniêty czy nie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>bool</SPAN> Przyc = <SPAN CLASS=K>false</SPAN>;
</TD></TR>
</TABLE>

<P>
Mamy zmienn¹, dodajemy obs³ugê komunikatów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONDOWN:<BR>
{<BR>
&nbsp;Przyc = <SPAN CLASS=K>true</SPAN>;<BR>
&nbsp;SendMessage(hwnd, WM_MOUSEMOVE, wParam, lParam);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONUP:<BR>
&nbsp;Przyc = <SPAN CLASS=K>false</SPAN>;<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
<SPAN CLASS=K>case</SPAN> WM_MOUSEMOVE:<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(Przyc)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;HDC hdc = GetDC(hwnd);<BR>
&nbsp;&nbsp;SetPixel(hdc, LOWORD(lParam), HIWORD(lParam), RGB(<SPAN CLASS=L>255</SPAN>,<SPAN CLASS=L>0</SPAN>,<SPAN CLASS=L>0</SPAN>));<BR>
&nbsp;&nbsp;ReleaseDC(hwnd, hdc);<BR>
&nbsp;}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
No i proszê, mo¿emy sobie rysowaæ ;-). Myœlê, ¿e wszystko powinno byæ tu jasne, no, mo¿e opócz tej funkcji <SPAN CLASS=T>SendMessage</SPAN>. Nietrudno siê jednak chyba domyœliæ, ¿e s³u¿y ona do "sztucznego" wywo³ywania komunikatów, czyli u¿ywamy jej gdy chcemy symulowaæ jakieœ zdarzenie, które "tak naprawdê" nie mia³o miejsca. W tym przypadku gdy u¿ytkownik kliknie mysz¹ w danym punkcie, zostanie "sztucznie" wywo³any komunikat <SPAN CLASS=T>WM_MOUSEMOVE</SPAN>, czyli narysuje siê w tym miejscu punkt, nawet jeœli u¿ytkownik wcale nie poruszy³ mysz¹, a tylko wcisn¹³ lewy przycisk.
</P>

<H2>
Kursor myszy
</H2>

<P>
Ta strza³eczka, która lata sobie po ca³ym ekranie jest ca³kiem fajowa, ale od czasu do czasu dobrze by³oby zmieniæ j¹ np. na klepsydrê czy inny kszta³t, albo i ca³kiem schowaæ. Mo¿emy siê w tym celu pos³u¿yæ funkcj¹ <SPAN CLASS=T>SetCursor</SPAN>. Jej jedyny parametr to uchwyt nowego kursora. Uchwyt taki mo¿emy zdobyæ od funkcji <SPAN CLASS=T>CreateCursor</SPAN> (która tworzy nowy kursor "od zera"), albo te¿ od funkcji <SPAN CLASS=T>LoadCursor</SPAN> (wczytuje kursor z pliku zasobów). Na razie polecam znacznie prostsz¹ funkcjê <SPAN CLASS=T>LoadCursor</SPAN>, która poza ³adowaniem kursora z zasobów naszego programu potrafi równie¿ pobraæ jeden ze standardowych kursorów Windows:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HCURSOR StaryKursor;<BR>
StaryKursor = SetCursor(LoadCursor(NULL, IDC_WAIT));<BR>
</TD></TR>
</TABLE>

<P>
Powy¿szy przyk³adzik zmienia wskaŸnik myszy na klepsydrê. Jak widaæ, funkcja <SPAN CLASS=T>SetCursor</SPAN> zwraca uchwyt do poprzednio u¿ywanego kursora (jeœli nie by³o ¿adnego, to zwraca <SPAN CLASS=T>NULL</SPAN>), który najlepiej jest przechowaæ w odpowiedniej zmiennej (tutaj <SPAN CLASS=T>StaryKursor</SPAN>) i przy zakoñczeniu programu ustawiæ z powrotem jako aktualny kursor. Pierwszy argument funkcji <SPAN CLASS=T>LoadCursor</SPAN> musi zawsze byæ <SPAN CLASS=T>NULL</SPAN>, jeœli ³adujemy jakiœ standardowy kursor Windowsa, w przeciwnym wypadku (jeœli ³adujemy kursor z zasobów programu), argument ten musi zawieraæ uchwyt do programu (<SPAN CLASS=T>HINSTANCE</SPAN>).
</P>
<P>
Drugi argument funkcji <SPAN CLASS=T>LoadCursor</SPAN> mo¿e równie¿ przybieraæ wartoœci: <SPAN CLASS=T>IDC_ARROW</SPAN> - zwyk³a strza³ka, <SPAN CLASS=T>IDC_CROSS</SPAN> - krzy¿, <SPAN CLASS=T>IDC_IBEAM</SPAN> - kursor edycji tekstu, <SPAN CLASS=T>IDC_APPSTARTING</SPAN> - strza³ka z ma³¹ klepsydr¹ itd.
</P>
<P>
Oprócz funkcji <SPAN CLASS=T>LoadCursor</SPAN>, do wczytania kursora mo¿emy jeszcze u¿yæ funkcji <SPAN CLASS=T>LoadImage</SPAN>, która pozwoli nam wczytaæ kursor z samodzielnego pliku - kursora (*.cur), czy nawet ikony (*.ico) lub bitmapy (*.bmp). Trzeba jednak bêdzie w tym przypadku zastosowaæ jawn¹ konwersjê obrazka zwróconego przez <SPAN CLASS=T>LoadImage</SPAN> na typ <SPAN CLASS=T>HCURSOR</SPAN>.
</P>
<P class=UWAGA>
Zwróæ uwagê, ¿e pliki *.ico czy *.bmp nie zawieraj¹ wspó³rzêdnych tzw. hotspot-a, czyli punktu, który jest uznawany jako "czubek strza³ki", a wiêc hotspot jest domyœlnie ustawiany na lewy górny róg. Z tego wzglêdu te rodzaje plików nie bardzo nadaj¹ siê do przechowywania kursorów.
</P>
<P>
Mo¿emy równie¿ podaæ <SPAN CLASS=T>NULL</SPAN> jako argument dla <SPAN CLASS=T>SetCursor</SPAN> - stosujemy to wówczas, gdy chcemy wskaŸnik  myszy po prostu schowaæ.
</P>
<P>
Jak uzyskaæ uchwyt do aktualnie wybranego kursora? Proste - u¿ywamy funkcji <SPAN CLASS=T>GetCursor</SPAN> (nie ma ona ¿adnych argumentów).
</P>
<P>
Ostatni¹ rzecz¹, któr¹ jeszcze warto wiedzieæ na temat wskaŸnika myszy, mo¿e byæ poruszanie nim... bez udzia³u myszy ;-). Aby przemieœciæ kursor w dowolne miejsce na ekranie... no, mo¿e nie na ekranie, tylko na oknie - u¿ywamy <SPAN CLASS=T>SetCursorPos</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(!SetCursorPos(<SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>150</SPAN>))<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Nie mo¿na ruszyæ kursora (mo¿e siê przylepi³?)"</SPAN>,<BR>
&nbsp;<SPAN CLASS=L>"B³¹d"</SPAN>, MB_ICONEXCLAMATION);<BR>
</TD></TR>
</TABLE>

<P>
W ten sposób mo¿emy np. zaprogramowaæ poruszanie mysz¹ przy pomocy klawiatury, co z pewnoœci¹ doceni¹ u¿ytkownicy naszych aplikacji, gdy mysz im siê popsuje ;-). Oczywiœcie w tym celu powinieneœ przeczytaæ nastêpny rozdzia³...
</P>

<H2>
Obs³uga klawiatury
</H2>

<P>
Generalnie rzecz ujmuj¹c, mysza to naprawdê mi³e stworzonko, ale figê nam po niej, jeœli robimy grê w stylu Robaka. Poza tym klawiatura jest ³atwiejsza w u¿yciu, jeœli chcemy szybko w³¹czyæ jak¹œ opcjê czy wywo³aæ komendê menu - nie trzeba w nic celowaæ strza³k¹, co bywa k³opotliwe zw³aszcza po spo¿yciu kilku... napojów. Nie mówi¹c ju¿ o tym, ¿e myszy czasami siê psuj¹. Krótko mówi¹c: potrzebujemy obs³ugi klawiatury!
</P>
<P>
Metod jest kilka, omówiê tylko tê najprostsz¹ i zarazem najbardziej przydatn¹. Wciœniêcie klawisza powoduje wys³anie komunikatu <SPAN CLASS=T>WM_KEYDOWN</SPAN> lub <SPAN CLASS=T>WM_KEYUP</SPAN> - analogicznie jak dla mychy. Sêk w tym, ¿eby wydedukowaæ, który klawisz zosta³ wciœniêty (jak wiadomo, jest ich na klawiaturze sporo). Kod klawisza przekazywany jest w argumencie <SPAN CLASS=T>wParam.</SPAN> Trzeba tylko zastosowaæ konstrukcjê <SPAN CLASS=K>switch-case</SPAN>. Kodom klawiszy odpowiadaj¹ sta³e rozpoczynaj¹ce siê od przedrostka <SPAN CLASS=T>VK</SPAN> (od Virtual Key). Niestety, nie s¹ one zbyt intuicyjne (<SPAN CLASS=T>VK_RETURN</SPAN> - klawisz Enter, <SPAN CLASS=T>VK_MENU</SPAN> - klawisz Alt, <SPAN CLASS=T>VK_NEXT</SPAN> - klawisz Page Down itd.), a w dodatku autorzy SDK u¿ytego w Dev-C++ zapomnieli najwyraŸniej umieœciæ definicji sta³ych od <SPAN CLASS=T>VK_A</SPAN> do <SPAN CLASS=T>VK_Z</SPAN>. Na szczêœcie maj¹ one kody odpowiadaj¹ce kodom ASCII du¿ych liter, np. <SPAN CLASS=L>A</SPAN> zakodowane jest jako <SPAN CLASS=L>0x41</SPAN> (<SPAN CLASS=L>65</SPAN> dziesi¹tkowo).
</P>
<P CLASS=UWAGA>
Jeœli nie chce ci siê samodzielnie poprawiaæ twórców SDK do Dev-a, to zajrzyj do dzia³u Download i œci¹gnij plik keys.zip - zawiera on plik nag³ówkowy z definicjami klawiszy A-Z, wystarczy go tylko do³¹czyæ wiadom¹ dyrektyw¹.
</P>
<P>
Pozostaje tylko pokazaæ, jak to w praktyce wygl¹da:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_KEYDOWN:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>((<SPAN CLASS=K>int</SPAN>)wParam)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> VK_RETURN:<BR>
&nbsp;&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wciœniêto Entera"</SPAN>, <SPAN CLASS=L>"Yeah"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> VK_ESCAPE:<BR>
&nbsp;&nbsp;&nbsp;DestroyWindow(hwnd);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Chyba katastrofy by nie by³o, gdybyœmy pominêli tê konwersjê parametru <SPAN CLASS=T>wParam</SPAN> na <SPAN CLASS=K>int</SPAN>, ale tak by³o w MSDN, wiêc przepisa³em ;-). Funkcja <SPAN CLASS=T>DestroyWindow</SPAN> s³u¿y do niszczenia podanego okienka, jak sama nazwa zreszt¹ wskazuje. Jest to niez³y sposób na zakoñczenie programu, o ile mamy w kodzie obs³ugi komunikatu <SPAN CLASS=T>WM_DESTROY</SPAN> wywo³anie funkcji <SPAN CLASS=T>PostQuitMessage</SPAN> (ten fragment jest generowany przez Dev-C++ razem z kodem tworz¹cym okno g³ówne). Jeœli tego nie masz w swoim kodzie, to samo zniszczenie g³ównego okna spowoduje doœæ niezrêczn¹ sytuacjê - program trzeba bêdzie wywaliæ z pamiêci przez Ctrl+Alt+Del :-/.
</P>

<H2>
Trochê wspó³dzia³ania
</H2>

<P>
Niezliczone iloœci opcji w programach sprawiaj¹, ¿e setki kombinacji klawiaturowych plus mysza z czterema przyciskami i dwoma scrollerami przestaj¹ wystarczaæ. Dlatego ktoœ wpad³ na pomys³, ¿e mo¿na by po³¹czyæ myszê z klawiatur¹ - st¹d czasami mo¿na wyczytaæ w instrukcji, ¿e aby coœ w danej grze czy programie zrobiæ, musisz np. przytrzymaæ Ctrl i klikn¹æ mysz¹. To doœæ fajna sprawa, wiêc postanowi³em pokazaæ, jak to siê robi w WinAPI.
</P>
<P>
Koncepcja jest bardzo prosta. Jak pamiêtamy (prawda, ¿e pamiêtamy?), komunikaty typu <SPAN CLASS=T>WM_LBUTTONCLICK</SPAN> czy <SPAN CLASS=T>WM_MOUSEMOVE</SPAN> przekazywa³y nam w swoich argumentach <SPAN CLASS=T>lParam</SPAN> pozycjê myszy. A drugi argument - <SPAN CLASS=T>wParam</SPAN> - daje nam informacjê o specjalnych klawiszach, które by³y wciœniête tu¿ przed wygenerowaniem komunikatu. Te specjalne klawisze mog¹ byæ klawiszami myszy (sta³e <SPAN CLASS=T>MK_LBUTTON</SPAN>, <SPAN CLASS=T>MK_MBUTTON</SPAN>, <SPAN CLASS=T>MK_RBUTTON</SPAN>), ale mog¹ te¿ byæ klawiszami Ctrl (sta³a <SPAN CLASS=T>MK_CONTROL</SPAN>) lub Shift (<SPAN CLASS=T>MK_SHIFT</SPAN>). Oto jak to wykorzystaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONDOWN:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wParam & MK_CONTROL)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wciœniêty jest Ctrl"</SPAN>, NULL, MB_ICONINFORMATION);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wParam & MK_SHIFT)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wciœniêty jest Shift"</SPAN>, NULL, MB_ICONINFORMATION);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Zauwa¿, ¿e np. dla komunikatu <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN> zmienna <SPAN CLASS=T>wParam</SPAN> nigdy nie powinna byæ RÓWNA <SPAN CLASS=T>MK_CONTROL</SPAN>, nawet jeœli w czasie klikniêcia przytrzymany by³ Ctrl! Zmienna <SPAN CLASS=T>wParam</SPAN> zawiera KOMBINACJÊ aktualnie wciœniêtych klawiszy, a wiêc jeœli przytrzymamy Ctrl i klikniemy lewym przyciskiem, to <SPAN CLASS=T>wParam</SPAN> bêdzie zawiera³ wartoœæ <SPAN CLASS=T>MK_CONTROL | MK_LBUTTON</SPAN>. Dlatego te¿ nie mo¿emy stosowaæ tutaj konstrukcji <SPAN CLASS=K>switch</SPAN> do sprawdzenia, który klawisz na klawiaturze by³ przytrzymany, a za to musimy stosowaæ operator <span class=T>&</span>.
</P>

<h2>
Parê s³ów o przechwytywaniu
</h2>

<p>
Jedna z windowsowych regu³ mówi, ¿e tylko jedno okno mo¿e w danym momencie otrzymywaæ komunikaty pochodz¹ce od myszy. Dlatego jeœli ju¿ mu siê uda pokonaæ inne konkurencyjne okienka i otrzyma do obs³u¿enia jakieœ myszkowe zdarzenie, to mówimy o tym oknie, ¿e przechwyci³o mysz.
<P>
<p>
Jak ju¿ wiesz, wszelkie kontrolki równie¿ s¹ oknami. Dlatego w³aœnie jeœli np. klikniesz lewym przyciskiem myszy na przycisku, to g³ówne okno twojego programu NIE otrzyma ani komunikatu <span class=T>WM_LBUTTONDOWN</Span>, ani <span class=T>WM_LBUTTONUP</Span>. Otrzyma za to <span class=T>WM_COMMAND</Span>, wygenerowane przez przycisk. Dzieje siê tak dlatego, ¿e przycisk przechwytuje mysz, wewnêtrzna procedura okna-przycisku (ka¿de okno ma swoj¹ w³asn¹ procedurê do obs³ugi komunikatów!) obs³uguje <span class=T>WM_LBUTTONDOWN</Span> i <span class=T>WM_LBUTTONUP</Span>, stwierdza, ¿e nast¹pi³o pe³noprawne klinkniêcie na przycisku i wówczas wysy³a do swojego okna-rodzica (czyli naszego g³ównego okna) komunikat <span class=T>WM_COMMAND</Span>.
</P>
<P>
Z powy¿szego wynika, ¿e nie mo¿emy w znany nam sposób obs³u¿yæ "myszowych" zdarzeñ dla kontrolek. Na szczêœcie nie do koñca jest to prawd¹; gdy ju¿ trochê wiêcej dowiesz siê o WinAPI, poczytaj artyku³ poœwiêcony subclassingowi.
</p>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apictrl.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apifile.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</HTML>

 