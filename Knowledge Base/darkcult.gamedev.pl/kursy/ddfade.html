<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Efekty przejœcia</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h1>
Efekty przejœcia
</h1>

<P>
W wielu grach wystêpuje efekt, zwany <span class=Inglisz>fade-out</span> (obraz stopniowo zaciemnia siê, a¿ staje siê ca³kowicie czarny, dlatego te¿ efekt ten bywa te¿ nazywany <span class=Inglisz>fade to black</span> - lubicie Metallikê? ;-)) lub <SPAN CLASS=Inglisz>fade-in</SPAN> (na czarnym ekranie stopniowo pojawia siê obraz). Mo¿na te¿ spotkaæ coœ w rodzaju po³¹czenia tych dwóch efektów - jeden obraz przechodzi stopniowo w drugi. Wszystko to zazwyczaj znacznie podnosi estetyczne walory gry, wiêc warto wiedzieæ, jak siê to robi. Jeœli nie dysponujemy akurat bibliotek¹ graficzn¹, która posiada specjalnie stworzone w tym celu funkcje, mo¿emy sami zaimplementowaæ podobne efekty.
</P>

<h2>
Fade-out
</h2>

<P>
Zacznijmy od œciemy - dos³ownie i w przenoœni :-). Na ch³opski rozum efekt fade-out polega po prostu na stopniowym zmniejszaniu jasnoœci pikseli. W modelu HSL jest to wrêcz banalne do wykonania - wystarczy zmniejszaæ sk³adow¹ Lightness. Jednak w WinAPI i DirectX stosowany jest raczej model RGB, gdzie zreszt¹ przyciemnianie pikseli jest równie¿ stosunkowo proste. Wystarczy proporcjonalnie zmniejszaæ wszystkie trzy sk³adowe koloru. Proporcjonalnie, a wiêc najlepiej mno¿yæ je przez liczbê z zakresu <SPAN CLASS=L>&lt;0; 1&gt;</SPAN>. Tak wiêc trzeba roz³o¿yæ ka¿dy piksel na trzy sk³adowe, ka¿d¹ przemno¿yæ przez "wspó³czynnik zaciemnienia" i z powrotem z³o¿yæ w 32-bitow¹ liczbê.
</P>
<P>
Oczywiœcie potrzebujemy bezpoœredniego dostêpu do powierzchni DirectDraw, aby siê w coœ takiego pobawiæ. Dlatego zaczynamy od zablokowania powierzchni ekranu. Zak³adaj¹c wiêc, ¿e mamy ju¿ wszystko zainicjalizowane, ustawiony tryb 32-bitowy, rozdzielczoœæ 800x600 i gotowy obraz wczytany na powierzchniê ekranu (dostêpn¹ pod globalnym wskaŸnikiem <SPAN CLASS=T>g_lpScreen</SPAN>), piszemy... 
</P>
<P>
Odpalamy (z samodzielnym napisaniem nie mia³eœ problemu, gdy¿ czytasz uwa¿nie moje kursy ;-P) i... rozczarowanie. Wprawdzie obraz siê zaciemnia, ale trwa to ca³e wieki. Dlaczego tak siê dzieje? Czy¿ nie stosujemy bezpoœredniego dostêpu do powierzchni, który jest najszybsz¹ metod¹ manipulowania pikselami? Czy¿ nie piszemy w jêzyku C++, tak samo jak twórcy dziesi¹tek gier, w których fade-out dzia³a znacznie szybciej? Wiêc co jest, doktorku?
</P>
<P>
Podstawowym b³êdem, który byæ mo¿e pope³niliœmy, by³o grzebanie w pikselach powierzchni ekranu. Tak-siê-nie-robi. Powinniœmy raczej utworzyæ robocz¹ powierzchniê pozaekranow¹, przekopiowaæ do niej obraz, ca³y proces przyciemniania wykonaæ na tej powierzchni pozaekranowej, wreszcie skopiowaæ rezultat na ekran.
</P>
<P>
Kolejn¹ potencjaln¹ pu³apk¹ jest formu³a wyliczania indeksu piksela do zmodyfikowania, któr¹ przedstawi³em w odcinku o bezpoœrednim dostêpie do powierzchni:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
((DWORD*)ddsd.lpSurface)[ddsd.dwWidth * y + x] = k;<BR>
</TD></TR>
</TABLE>

<P>
Jest metoda dobra, ale nie bardzo dobra - dzia³a najzupe³niej prawid³owo, ale niekoniecznie z optymaln¹ wydajnoœci¹.
Mamy tu bardzo kosztowne obliczeniowo mno¿enie, które nie jest tu tak naprawdê do niczego potrzebne. Bierzemy przecie¿ po prostu kolejne piksele. O wiele lepiej by by³o po prostu przesuwaæ wskaŸnik na bity powierzchni o 1 dla ka¿dego piksela. Wtedy mielibyœmy do czynienia jedynie z szybkim dodawaniem. 
</P>
<P>
I wreszcie ostatni, najbardziej ¿mudny trick optymalizacyjny. Tracimy sporo mocy obliczeniowej na rozk³adanie koloru ka¿dego piksela na sk³adowe, mno¿enie ka¿dej sk³adowej przez liczbê zmiennoprzecinkow¹ (o zmiennoprzecinkowym liczniku zewnêtrznej pêtli nawet nie ma co wspominaæ), sk³adanie piksela z powrotem w liczbê 16-bitow¹. Co mo¿na z tym zrobiæ?
</P>
<P>
Mo¿emy... stablicowaæ wszystkie wykorzystywane odcienie dla wszystkich mo¿liwych kolorów! Spytasz pewnie, czy taka tablica nie bêdzie przypadkiem zajmowa³a zbyt du¿o miejsca. Oczywiœcie, bêdzie. Nawet jeœli zmienimy tryb na 16-bitowy (stablicowanie wszystkich <SPAN CLASS=L>16 777 216</SPAN> kolorów trybu 24-bitowego i 32-bitowego oczywiœcie nie jest zbyt praktycznym pomys³em ;-)), to i tak tablica bêdzie spora.  Policzmy: <SPAN CLASS=L>65000 * 30 * 2</SPAN> daje razem prawie 4 MB! (<SPAN CLASS=L>30</SPAN> jest to za³o¿ona przez nas liczba iteracji, czyli mo¿liwych odcieni ka¿dego piksela w efekcie fadingu, a <SPAN CLASS=L>2</SPAN> - tyle bajtów tworzy <SPAN CLASS=L>16</SPAN> bitów) Jednak w dzisiejszych czasach nie jest to a¿ tak wiele, wiêc mo¿emy sobie bez problemu wygenerowaæ tak¹ tablicê, któr¹ - gdyby nam zaczê³o brakowaæ miejsca w RAM-ie, zawsze mo¿na zrzuciæ tymczasowo na dysk. 
</P>
<h2>
Kilka funkcji u³atwiaj¹cych ¿ycie
</h2>
<P>
Zanim przyst¹pimy do dzia³ania, ujmiemy w procedury garœæ operacji, które bêdziemy musieli wykonywaæ czêsto. Operacje te to: tworzenie powierzchni, blokowanie i odblokowywanie. Wszystko to ju¿ robiliœmy w poprzednich odcinkach kursu DirectDraw, wiêc w szczegó³y nie wchodzimy. Ewentualne w¹tpliwoœci rozwiej¹ siê póŸniej ;-).
</P>
<TABLE BORDER WIDTH=100%>
<TR><TD>
LPDIRECTDRAWSURFACE DDCreateSurface(DWORD dwWidth, DWORD dwHeight, DWORD dwFlags)<BR>
{<BR>
&nbsp;LPDIRECTDRAWSURFACE temp = NULL;<BR>
&nbsp;DDSURFACEDESC ddsd;<BR>
&nbsp;ZeroMemory(&ddsd,<SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC));<BR>
&nbsp;ddsd.dwSize         = <SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC);<BR>
&nbsp;ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;<BR>
&nbsp;ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | dwFlags;<BR>
&nbsp;ddsd.dwWidth        = dwWidth;<BR>
&nbsp;ddsd.dwHeight       = dwHeight; <BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpDD->CreateSurface(&ddsd, &temp, NULL) != DD_OK)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> NULL;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> temp;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie zak³adamy tu, ¿e lpDD jest globalnym wskaŸnikiem na obiekt g³ówny DirectDraw.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WORD *DDLockSurface(LPDIRECTDRAWSURFACE lpSurf, <SPAN CLASS=K>int</SPAN> *lpitch)<BR>
{<BR>
&nbsp;DDSURFACEDESC ddsd;<BR>
&nbsp;ZeroMemory(&ddsd,<SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC));
&nbsp;ddsd.dwSize = <SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC);<BR>
&nbsp;lpSurf->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);<BR>
<BR>
&nbsp;*lpitch = ddsd.lPitch &gt;&gt; <SPAN CLASS=L>1</SPAN>;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> (WORD*)ddsd.lpSurface;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> DDUnlockSurface(LPDIRECTDRAWSURFACE lpSurf)<BR>
{<BR>
&nbsp;lpSurf-&gt;Unlock(NULL);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mo¿na dojœæ do wniosku, ¿e nie ma wiêkszego sensu tworzyæ funkcjê <SPAN CLASS=T>DDUnlockSurface</SPAN>, skoro wszystko, co ma ona za zadanie, to wywo³anie metody <SPAN CLASS=T>Unlock</SPAN> dla podanej powierzchni. Jednak jakoœ brzydko tak wygl¹da, gdy siê blokuje w³asn¹ funkcj¹, a odblokowuje funkcj¹ biblioteczn¹, wiêc niniejszym zapewniamy symetriê ;-).
</P>

<h2>
Kolor w trybie 16-bitowym
</h2>

<P>
Skoro ustaliliœmy sobie, ¿e bêdziemy dzia³aæ w trybie 16-bitowym, to wypada³oby wiedzieæ, jak dok³adnie zbudowany jest piksel w tym trybie. W trybie 32-bitowym wszystko jest stosunkowo proste: mamy 4 bajty na piksel, przy czym trzy opisuj¹ kolor (ka¿dy bajt to inna sk³adowa w modelu RGB), czwarty jest zarezerwowany na kana³ alfa. 
Ale jak podzieliæ dwa bajty (czyli 16 bitów) miêdzy trzy sk³adowe? Wybrniêto z tego problemu w ten sposób, ¿e jedna ze sk³adowych jest "uprzywilejowana" i dostaje 6 bitów, zaœ pozosta³e dwie - po 5. Ta "uprzywilejowana" sk³adowa to umownie zieleñ (kolor ¿ycia, jak by nie by³o ;-)). Tak wiêc mo¿na sobie wyobraziæ przyk³adowy piksel w postaci binarnej:
</P>

<P>
<b><font color=red>11111</font><font color=green>111111</font><font color=blue>11111</font></b>
</P>

<P>
Poniewa¿ mamy tu same jedynki, z ca³¹ pewnoœci¹ piksel ten jest bia³y, ale mniejsza z tym. Powinniœmy raczej skupiæ nasze mózgownice na tym, jak wy³uskaæ poszczególne sk³adowe z takiej 16-bitowej liczby oraz jak je potem z³o¿yæ z powrotem - takie bowiem operacje bêdziemy wykonywaæ (o czym ju¿ sobie zreszt¹ wspomnieliœmy). Zacznijmy od prostszej rzeczy, czyli w³aœnie od sk³adania. Wystarczy tu tylko przesun¹æ bity na odpowiednie pozycje, zgodnie ze schematem, który przedstawiliœmy powy¿ej oraz po przesuniêciu pododawaæ do siebie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define KOLOR16(r, g, b)   (  (r &lt;&lt; 11) | (g &lt;&lt; 5) | b  )<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Nieco wiêcej zachodu jest z rozk³adaniem. Musimy tu skorzystaæ z masek, aby "usun¹æ" (wyzerowaæ) z danej liczby wszystkie bity oprócz tych, które nas akurat interesuj¹. Przesuwamy w tym celu wszystkie bity, które le¿¹ na lewo od bitów interesuj¹cej nas sk³adowej, poza "obrêb" naszych 16 bitów. Nastêpnie aplikujemy maskê za pomoc¹ operatora AND - operacja ta usuwa lew¹ czêœæ nieinteresuj¹cych nas bitów. Wreszcie przesuwamy w prawo pozosta³e bity, by usun¹æ praw¹ czêœæ zbêdnych bitów. W przypadku czerwonej sk³adowej musimy oczywiœcie wykonaæ tylko przesuniêcie w prawo, gdy¿ po lewej nie ma ¿adnych bitów danych:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define RED(k)      (  (k &gt;&gt; 11)  )<BR>
#define GREEN(k)    (  ((k &lt;&lt; 5) & 0xFFFF) &gt;&gt; 10 )<BR>
#define BLUE(k)     (  ((k &lt;&lt; 11) & 0xFFFF) &gt;&gt; 11  )<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Mamy wiêc makra, które zapewni¹ nam ³atw¹ obs³ugê koloru 16-bitowego. Pora na wspomnian¹ du¿¹ tablicê odcieni pikseli. Oto ona:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WORD Odcien[<SPAN CLASS=L>30</SPAN>][<SPAN CLASS=L>65536</SPAN>];<BR>
</TD></TR>
</TABLE>

<P>
Generowanie tablicy bêdzie wygl¹da³o mniej wiêcej tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> InicjalizujOdcienie()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>const double</SPAN> alfa[<SPAN CLASS=L>30</SPAN>] = {<SPAN CLASS=L> 0.00, 0.01, 0.04, 0.08, 0.12, 0.16, 0.20, 0.24, 0.28, 0.32, 0.36, 0.40, 0.44, 0.48,<BR>
&nbsp;0.51, 0.54, 0.58, 0.61, 0.65, 0.68, 0.72, 0.75, 0.79, 0.82, 0.86, 0.89, 0.93, 0.96, 0.99, 1.00</SPAN> };<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>;i&lt;<SPAN CLASS=L>30</SPAN>;++i)<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> j=<SPAN CLASS=L>0</SPAN>;j&lt;<SPAN CLASS=L>65536</SPAN>;++j)<BR>
&nbsp;&nbsp;Odcien[i][j] = KOLOR16((BYTE)(RED(j)*alfa[i]), (BYTE)(GREEN(j)*alfa[i]), (BYTE)(BLUE(j)*alfa[i]));<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Có¿ my tu mamy? Wartoœci w tablicy <SPAN CLASS=T>alfa</SPAN> odpowiadaj¹ po prostu procentowemu "zaciemnieniu" obrazu i ró¿nica miêdzy nimi jest mniej wiêcej sta³a (pi razy drzwi ;-)), aby zapewniæ z³udzenie p³ynnoœci zanikania obrazu. Jest <SPAN CLASS=L>30</SPAN> wspó³czynników alfa - tyle samo, ile bêdzie naszych etapów "zaciemniania". Nastêpnie dla ka¿dego z tych etapów (dla ka¿dego wspó³czynnika alfa) i dla ka¿dego z 65 tys. kolorów obliczamy odcieñ piksela, korzystaj¹c ze zdefiniowanych wczeœniej makr <SPAN CLASS=T>RED, GREEN</SPAN> i <SPAN CLASS=T>BLUE</SPAN>. W ten oto sposób tablica <SPAN CLASS=T>Odcien</SPAN> zostaje wype³niona.
</P>

<h2>
Ciemnoœæ widzê...
</h2>
<P>
Teraz droga do optymalizacji jest ju¿ prosta. Stworzyliœmy sobie tak¹ oto procedurkê "fejdinguj¹c¹", któr¹ za chwilê dok³adniej sobie objaœnimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> DDFadeToBlack()<BR>
{<BR>
&nbsp;RECT rect = {<SPAN CLASS=L>0, 0, 800, 600</SPAN>}; <SPAN CLASS=C>// prostok¹t kadruj¹cy - obejmuje ca³y ekran</SPAN><BR>
&nbsp;WORD *tmp, *ref, *prm; <SPAN CLASS=C>// wskaŸniki na piksele powierzchni</SPAN><BR>
&nbsp;WORD *wsk_tmp, *wsk_prm; <SPAN CLASS=C>// wskaŸniki pomocnicze do kopiowania na pow. ekranu</SPAN><BR>
&nbsp;WORD *fastref, *fasttmp; <SPAN CLASS=C>// "szybkie" wskaŸniki</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> tpitch, rpitch, ppitch;<BR>
&nbsp;WORD *lpOdcien;<BR>
&nbsp;LPDIRECTDRAWSURFACE lpTemp, lpRef;<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Stwórz powierzchnie robocze</SPAN><BR>
&nbsp;lpTemp = DDCreateSurface(<SPAN CLASS=L>800, 600</SPAN>, DDSCAPS_SYSTEMMEMORY);<BR>
&nbsp;lpRef  = DDCreateSurface(<SPAN CLASS=L>800, 600</SPAN>, DDSCAPS_SYSTEMMEMORY);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Blituj obraz na ekranie do powierzchni roboczej</SPAN><BR>
&nbsp;lpRef-&gt;Blt(&rect, g_lpScreen, &rect, DDBLT_WAIT, NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Zablokuj powierzchnie</SPAN><BR>
&nbsp;tmp = DDLockSurface(lpTemp, &tpitch);<BR>
&nbsp;ref = DDLockSurface(lpRef, &rpitch);<BR>
&nbsp;prm = DDLockSurface(g_lpScreen, &ppitch);<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> c=<SPAN CLASS=L>29</SPAN>; c&gt;=<SPAN CLASS=L>0</SPAN>; --c)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// pobierz odpowiedni fragment tablicy odcieni</SPAN><BR>
&nbsp;&nbsp;lpOdcien = Odcien[c];<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// inicjalizuj "szybkie" wskaŸniki</SPAN><BR>
&nbsp;&nbsp;fastref = ref;<BR>
&nbsp;&nbsp;fasttmp = tmp;<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// dla ka¿dego piksela powierzchni (800*600=480000)</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>480000</SPAN>; ++i,++fasttmp,++fastref)<BR>
&nbsp;&nbsp;&nbsp;*fasttmp = lpOdcien[*fastref];<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// kopiuj roboczy obszar na powierzchniê ekranu</SPAN><BR>
&nbsp;&nbsp;wsk_prm = prm;<BR>
&nbsp;&nbsp;wsk_tmp = tmp;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>600</SPAN>; ++i) <SPAN CLASS=C>// dla ka¿dej linii obrazu</SPAN><BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;memcpy(wsk_prm, wsk_tmp, <SPAN CLASS=L>1600</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;wsk_prm += ppitch;<BR>
&nbsp;&nbsp;&nbsp;wsk_tmp += tpitch;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ¿eby w ogóle da³o siê coœ zauwa¿yæ - ma³e opóŸnienie ;-)</SPAN><BR>
&nbsp;&nbsp;Sleep(<SPAN CLASS=L>20</SPAN>);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>// odblokowanie powierzchni</SPAN><BR>
&nbsp;DDUnlockSurface(lpTemp);<BR>
&nbsp;DDUnlockSurface(lpRef);<BR>
&nbsp;DDUnlockSurface(g_lpScreen);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// sprz¹tanie</SPAN><BR>
&nbsp;lpTemp-&gt;Release();<BR>
&nbsp;lpRef-&gt;Release();<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Procedurka dzia³a tak: najpierw tworzy sobie dwie powierzchnie robocze. W pierwszej (<SPAN CLASS=T>lpRef</SPAN>) bêd¹ pobierane wyjœciowe wartoœci pikseli, w drugiej (<SPAN CLASS=T>lpTemp</SPAN>) bêd¹ zapisywane piksele po przetworzeniu. Z powierzchni ekranu (<SPAN CLASS=T>g_lpScreen</SPAN>) nie bêdziemy ani odczytywaæ, ani zapisywaæ, gdy¿ by³oby to zbyt powolne. Dlatego jeœli chcemy skopiowaæ coœ z powierzchni ekranu lub na ni¹, to korzystamy albo z <SPAN CLASS=T>Blt</SPAN> (<SPAN CLASS=T>BltFast</SPAN>), albo ewentualnie funkcji typu <SPAN CLASS=T>memcpy</SPAN> - nigdy nie kopiujemy pojedynczych bajtów w pêtli.
</P>
<P>
Nastêpnym krokiem jest zablokowanie powierzchni. U¿yta funkcja <SPAN CLASS=T>DDLockSurface</SPAN> (zdefiniowana powy¿ej) zwraca przy okazji parametr <SPAN CLASS=Wazne>pitch</SPAN> dla blokowanej powierzchni oraz wskaŸnik do pikseli powierzchni (zaraz powiemy, co to ten pitch ;-)). 
</P>
<P>
Wreszcie wchodzimy w pêtlê, powtarzan¹ <SPAN CLASS=L>30</SPAN> razy (czyli dla ka¿dego stadium zaciemnienia). Najpierw pobieramy wskaŸnik (<SPAN CLASS=T>lpOdcien</SPAN>), który bêdzie nam wskazywa³ fragment tablicy <SPAN CLASS=T>Odcien</SPAN>, odpowiadaj¹cy aktualnej fazie zaciemnienia (<SPAN CLASS=T>c</SPAN>). Inicjalizujemy wskaŸniki <SPAN CLASS=T>fastref</SPAN> i <SPAN CLASS=T>fasttmp</SPAN>, tak aby wskazywa³y na pocz¹tek powierzchni roboczych. Nastêpnie w wewnêtrznej pêtli dla kolejnych <SPAN CLASS=L>480&nbsp;000</SPAN> pikseli (tyle liczy sobie ekran w rozdzielczoœci <SPAN CLASS=L>800x600</SPAN>) pobieramy now¹ wartoœæ piksela z tablicy Odcien poprzez wskaŸnik <SPAN CLASS=T>lpOdcien</SPAN>. Dodatkowe przyœpieszenie uzyskujemy dziêki u¿yciu wskaŸników <SPAN CLASS=T>fasttmp</SPAN> i <SPAN CLASS=T>fastref</SPAN> - operacja <SPAN CLASS=T>'++'</SPAN> dzia³a szybciej, ni¿ <SPAN CLASS=T>'+=<SPAN CLASS=L>2</SPAN>'</SPAN> (zw³aszcza, gdy wykonywana jest w bloku kontrolnym pêtli), natomiast <SPAN CLASS=T>'++'</SPAN> dla zmiennej <SPAN CLASS=T>WORD*</SPAN> daje ten sam efekt, co <SPAN CLASS=T>'+=<SPAN CLASS=L>2</SPAN>'</SPAN> dla <SPAN CLASS=T>WORD</SPAN>. 
</P>
<P>
Po wyjœciu z wewnêtrznej pêtli mamy ju¿ w roboczej powierzchni <SPAN CLASS=T>lpTemp</SPAN> przygotowan¹ "zaciemnion¹ wersjê" obrazu. Wystarczy j¹ wyœwietliæ, czyli skopiowaæ na powierzchniê ekranu. Poniewa¿ jednak powierzchnia ekranu jest nadal zablokowana, nie mo¿emy skorzystaæ z metody <SPAN CLASS=T>Blt</SPAN> czy <SPAN CLASS=T>FastBlt</SPAN>. Nie mo¿emy te¿ odblokowaæ powierzchni, gdy¿ jest to zbyt czasoch³onna operacja i mog³aby zmniejszyæ wydajnoœæ, o któr¹ tak dzielnie walczymy. Jedynym wyjœciem jest skopiowanie bajtów "rêcznie", czyli na przyk³ad za pomoc¹ standardowej funkcji <SPAN CLASS=T>memcpy</SPAN>. Niestety, nie mo¿emy tego uczyniæ przez pojedyncze wywo³anie <SPAN CLASS=T>memcpy</SPAN> (co by³oby z pewnoœci¹ najszybsze), a to ze wzglêdu na parametr <SPAN CLASS=T>lPitch</SPAN> powierzchni...
</P>
<P>
Tutaj ma³a dygresja. Sk³adowa <SPAN CLASS=T>lPitch</SPAN> nale¿y do struktury DDSURFACEDESC. Nie wspomnia³em o niej w odcinku o bezpoœrednim dostêpie do powierzchni, a byæ mo¿e powinienem. Otó¿ pamiêæ powierzchni bywa czasem wype³niona zupe³nie nas nie interesuj¹cymi "œmieciami". Z tego wzglêdu ka¿da linia obrazu mo¿e zajmowaæ wiêcej, ni¿ wynika³oby z formu³y <SPAN CLASS=T>rozdzielczoœæ_pozioma * 2_bajty</SPAN>. Najlepiej to zrozumieæ na obrazku:
</P>
<P align=center>
<img src="../gfx/pitch.gif" alt="Parametr pitch powierzchni DirectDraw">
</P>

<P>
Jak widaæ, po prawej mamy szary prostok¹t - to w³aœnie obszar, który nas w tym momencie w ogóle nie interesuje. Wystêpuje on z regu³y tylko w przypadku powierzchni g³ównej ekranu oraz tych powierzchni pozaekranowych, na których wykonujemy obroty. Tutaj ¿adnych obrotów nie potrzebujemy, wiêc "szary obszar" dotyczy tylko powierzchni ekranu. Niemniej kopiowanie pikseli musimy zrealizowaæ w pêtli, uwzglêdniaj¹c przesuniêcie linii (<SPAN CLASS=Inglisz>pitch</SPAN>). Poniewa¿ metoda <SPAN CLASS=T>Lock</SPAN> us³u¿nie zwraca nam przesuniêcie blokowanej powierzchni, skorzystamy z tego i w ten w³aœnie sposób pobierzemy przesuniêcie dla powierzchni ekranu. Natomiast piksele kopiujemy w ten sposób, ¿e bierzemy pojedyncz¹ liniê (<SPAN CLASS=L>1600</SPAN> bajtów), przesuwamy wskaŸnik "nad szarym obszarem", bierzemy kolejne <SPAN CLASS=L>1600</SPAN> bajtów, itd.
</P>
<P>
Musimy jeszcze gdzieœ wywo³aæ stworzone przez nas procedurki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
InicjalizujOdcienie();<BR>
DDFadeToBlack();<BR>
</TD></TR>
</TABLE>

<P>
I tak oto zrobiliœmy wreszcie stopniowe zanikanie obrazu. Czy teraz jest ono optymalne? Przekonaj siê sam. Powiem tylko, ¿e raczej nie jest ju¿ mo¿liwe jakieœ znacz¹ce zwiêkszenie wydajnoœci przedstawionych algorytmów. Natomiast jakieœ drobne optymalizacje zawsze da siê wynaleŸæ, tyle, ¿e chyba szkoda zachodu...
</P>
<P>
Wspomnê jeszcze, i¿ przez analogiê ³atwo mo¿emy teraz zrobiæ efekt odwrotny, czyli stopniowe pojawianie siê bitmapy na pustym ekranie. Wystarczy dokonaæ odpowiednich zmian w zewnêtrznej pêtli oraz oczywiœcie zamieniæ powierzchnie (tj. bitmapê blitujemy nie z powierzchni ekranu, tylko z wczeœniej przygotowanej powierzchni pozaekranowej). Potraktujmy to jako pracê domow¹ ;-).
</P>

<h2>
Alfa-blending
</h2>

<P>
Drugim efektem, który mo¿emy wykonaæ niejako z rozpêdu, jest tzw. alfa-blending, czyli wzajemne przenikanie siê dwóch bitmap.  Jest to nic innego, jak tylko po³¹czenie opisanego wy¿ej efektu fade-out z efektem fade-in. Z tego powodu zreszt¹ alfa-blending bywa te¿ nazywany <SPAN CLASS=Inglisz>cross-fading</SPAN> (albo jeszcze inaczej: <SPAN CLASS=Inglisz>alpha transition</SPAN>).
</P>
<P>
Do tego efektu potrzebowaæ bêdziemy a¿ czterech powierzchni jednoczeœnie. Oprócz powierzchni ekranu (co oczywiste) u¿yjemy po jednej powierzchni referencyjnej dla ka¿dego z dwóch obrazków. Jedn¹ bêdziemy nazywaæ Ÿród³ow¹ (<SPAN CLASS=T>lpSrc</SPAN>) - to bêdzie ten obrazek, który na pocz¹tku jest widoczny, a potem stopniowo zanika. Druga bêdzie zwana powierzchni¹ docelow¹ (<SPAN CLASS=T>lpDst</SPAN>) - obrazek, którego na pocz¹tku nie widaæ, a póŸniej stopniowo pojawia siê. Czwarta powierzchnia to powierzchnia robocza, w której bêdziemy zapisywaæ wynik blendingu.
</P>
<P>
W procedurce <SPAN CLASS=T>DDFadeToBlack</SPAN> mieliœmy wskaŸnik <SPAN CLASS=T>lpOdcien</SPAN>, który wykorzystywaliœmy do wskazywania na odpowiedni fragment tablicy <SPAN CLASS=T>Odcien</SPAN>. Tym razem bêdziemy potrzebowaæ dwóch takich wskaŸników. Jeden bêdzie pokazywaæ na pocz¹tek wspomnianej tablicy, drugi na koniec i w miarê wykonywania kolejnych iteracji algorytmu wskaŸniki te bêd¹ siê do siebie zbli¿a³y, a nastêpnie "wymin¹ siê" i znowu zaczn¹ oddalaæ. Nazwiemy je <SPAN CLASS=T>AlphaPtr</SPAN> i <SPAN CLASS=T>InvAlphaPtr</SPAN>.
</P>
<P>
Poniewa¿ mamy wiêcej powierzchni, bêdzie te¿ wiêcej "szybkich" wskaŸników. Pytanie tylko - jak¹ w³aœciwie operacjê wykonamy w celu "zmiksowania" kolorów pikseli, pochodz¹cych z dwóch obrazów? Otó¿ wystarczy... zwyk³e dodawanie:
</P>
<TABLE BORDER WIDTH=100%>
<TR><TD>
*fasttmp = AlphaPtr[*fastsrc] + InvAlphaPtr[*fastdst];<BR>
</TD></TR>
</TABLE>
<P>
Jeœli wydaje ci siê to trochê dziwne, to przypomnij sobie, ¿e dok³adnie to samo robiliœmy przy efekcie fade-out. Tyle tylko, ¿e tam obraz docelowy by³ czarny, a wiêc do wartoœci piksela nic nie trzeba by³o dodawaæ (innymi s³owy: dodawaliœmy zero).
</P>
<P>
Poza opisanymi przed chwil¹ drobiazgami procedura, któr¹ nazwiemy sobie <SPAN CLASS=T>DDAlphaTransition</SPAN>, nie bêdzie siê zbytnio ró¿niæ od <SPAN CLASS=T>DDFadeToBlack</SPAN>. Tak wiêc nie przed³u¿ajmy gadaniny i weŸmy siê do dzie³a.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> DDAlphaTransition()<BR>
{<BR>
&nbsp;RECT rect = {<SPAN CLASS=L>0, 0, 800, 600</SPAN>}; <SPAN CLASS=C>// prostok¹t kadruj¹cy - obejmuje ca³y ekran</SPAN><BR>
&nbsp;WORD *tmp, *src, *dst, *prm; <SPAN CLASS=C>// wskaŸniki na piksele powierzchni</SPAN><BR>
&nbsp;WORD *wsk_tmp, *wsk_prm; <SPAN CLASS=C>// wskaŸniki pomocnicze do kopiowania na pow. ekranu</SPAN><BR>
&nbsp;WORD *fastsrc, *fasttmp, *fastdst; <SPAN CLASS=C>// "szybkie" wskaŸniki</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> spitch, tpitch, dpitch, ppitch;<BR>
&nbsp;LPDIRECTDRAWSURFACE lpTemp, lpSrc, lpDst;<BR>
&nbsp;WORD *AlphaPtr, *InvAlphaPtr;<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Stwórz powierzchnie robocze</SPAN><BR>
&nbsp;lpTemp = DDCreateSurface(<SPAN CLASS=L>800, 600</SPAN>, DDSCAPS_SYSTEMMEMORY);<BR>
&nbsp;lpSrc  = DDCreateSurface(<SPAN CLASS=L>800, 600</SPAN>, DDSCAPS_SYSTEMMEMORY);<BR>
&nbsp;lpDst  = DDCreateSurface(<SPAN CLASS=L>800, 600</SPAN>, DDSCAPS_SYSTEMMEMORY);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Blituj obraz na ekranie (znikaj¹cy) do powierzchni roboczej Ÿród³owej</SPAN><BR>
&nbsp;lpSrc-&gt;Blt(&rect, g_lpScreen, &rect, DDBLT_WAIT, NULL);<BR>
&nbsp;<SPAN CLASS=C>// ...i drugi obraz (pojawiaj¹cy siê) do powierzchni docelowej</SPAN><BR>
&nbsp;lpDst-&gt;Blt(&rect, g_lpImage, &rect, DDBLT_WAIT, NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// Zablokuj powierzchnie</SPAN><BR>
&nbsp;tmp = DDLockSurface(lpTemp, &tpitch);<BR>
&nbsp;src = DDLockSurface(lpSrc, &spitch);<BR>
&nbsp;dst = DDLockSurface(lpDst, &dpitch);<BR>
&nbsp;prm = DDLockSurface(g_lpScreen, &ppitch);<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> alfa=<SPAN CLASS=L>29</SPAN>; alfa&gt;=<SPAN CLASS=L>0</SPAN>; --alfa)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// pobierz odpowiedni fragment tablicy odcieni</SPAN><BR>
&nbsp;&nbsp;AlphaPtr = Odcien[alfa];<BR>
&nbsp;&nbsp;InvAlphaPtr = Odcien[29-alfa];<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// inicjalizuj "szybkie" wskaŸniki</SPAN><BR>
&nbsp;&nbsp;fastsrc = src;<BR>
&nbsp;&nbsp;fastdst = dst;<BR>
&nbsp;&nbsp;fasttmp = tmp;<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// dla ka¿dego piksela powierzchni (800*600=480000)</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>480000</SPAN>; ++i,++fasttmp,++fastsrc,++fastdst)<BR>
&nbsp;&nbsp;&nbsp;*fasttmp = AlphaPtr[*fastsrc] + InvAlphaPtr[*fastdst];<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// kopiuj roboczy obszar na powierzchniê ekranu</SPAN><BR>
&nbsp;&nbsp;wsk_prm = prm;<BR>
&nbsp;&nbsp;wsk_tmp = tmp;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>600</SPAN>; ++i) <SPAN CLASS=C>// dla ka¿dej linii obrazu</SPAN><BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;memcpy(wsk_prm, wsk_tmp, <SPAN CLASS=L>1600</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;wsk_prm += ppitch;<BR>
&nbsp;&nbsp;&nbsp;wsk_tmp += tpitch;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ¿eby w ogóle da³o siê coœ zauwa¿yæ - ma³e opóŸnienie ;-)</SPAN><BR>
&nbsp;&nbsp;Sleep(<SPAN CLASS=L>20</SPAN>);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>// odblokowanie powierzchni</SPAN><BR>
&nbsp;DDUnlockSurface(lpTemp);<BR>
&nbsp;DDUnlockSurface(lpSrc);<BR>
&nbsp;DDUnlockSurface(lpDst);<BR>
&nbsp;DDUnlockSurface(g_lpScreen);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// sprz¹tanie</SPAN><BR>
&nbsp;lpTemp-&gt;Release();<BR>
&nbsp;lpSrc-&gt;Release();<BR>
&nbsp;lpDst-&gt;Release();<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Gotowe. Nie by³o tak trudno, a jeœli nawet, to po kilkakrotnym przeczytaniu artyku³u i przeanalizowaniu przyk³adowego kodu w¹tpliwoœci na pewno znikn¹. Teraz pozostaje tylko wykorzystaæ opisane efekty w twoich grach ;-).
</P>

<P align=center>
<img src="../gfx/blend.jpg" alt="Dwie bitmapy potraktowane powy¿sz¹ procedur¹ blendingu">
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>

</HTML>