<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, cz. 4</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">

<style type="text/css">
<!--
body { color: #000000; background-color: #000000; }
.cpp1-assembler { color: #00FF00; }
.cpp1-character { color: #FF00FF; }
.cpp1-comment { color: #969696; font-style: italic; }
.cpp1-float { color: #FF00FF; }
.cpp1-hexadecimal { color: #FF00FF; }
.cpp1-identifier { color: #00FF00; }
.cpp1-illegalchar { background-color: #800000; color: #FF0000; }
.cpp1-number { color: #FF00FF; }
.cpp1-octal { color: #FF00FF; }
.cpp1-preprocessor { color: #00FF00; }
.cpp1-reservedword { color: #3366FF; font-weight: bold; }
.cpp1-space { background-color: #464646; color: #FFFFFF; }
.cpp1-string { color: #FF00FF; }
.cpp1-symbol { color: #FFFF00; }
-->
</style>

</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Konwersje typów
</h2>
<P>
Wspomnieliœmy ju¿, ¿e operacje takie jak dodawanie czy dzielenie na dwóch wartoœciach jest mo¿liwe tylko wtedy, gdy te wartoœci s¹ dok³adnie tych samych typów. Nie sk³amaliœmy tutaj za bardzo, ale nie mo¿na st¹d wyci¹gn¹æ wniosku, ¿e np. dodanie do siebie dwóch liczb, z których jedna jest typu float, a druga typu int, nie jest wykonalne. Jest. Tylko ¿e najpierw trzeba te wartoœci sprowadziæ do tego samego typu, podobnie jak na lekcji matematyki sprowadza siê dwa u³amki do wspólnego mianownika.
</P>
<P>
Istniej¹ generalnie dwa sposoby takiego &quot;sprowadzania&quot;. Mo¿emy to zrobiæ sami albo zleciæ tê brudn¹ robotê kompilatorowi. Dlaczego brudn¹, zaraz siê przekonamy. Przekonamy siê równie¿, ¿e czasami lepiej coœ zrobiæ samemu, ni¿ polegaæ na bliŸnich, którzy nie zawsze siê na brudnej robocie znaj¹ ;-). Najpierw prosty przyk³ad dodawania dwóch liczb ró¿nych typów:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-preprocessor">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

</span><span class="cpp1-reservedword">using</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">namespace</span><span class="cpp1-space"> </span><span class="cpp1-identifier">std</span><span class="cpp1-symbol">;

</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">main</span><span class="cpp1-symbol">()
{</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">7</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wynik</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">float</span><span class="cpp1-space"> </span><span class="cpp1-identifier">b</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">3</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">wynik</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">+</span><span class="cpp1-space"> </span><span class="cpp1-identifier">b</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;Wynik: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wynik</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">system</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-string">&quot;pause&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}</span><span class="cpp1-space"> 
</span></span>
</code></pre>
<P>
Wynik to 10. No pewnie. Kompilator po prostu zamieni³ sobie typ zmiennej a na float, a maj¹c ju¿ dwie liczby typu float nie mia³ oczywiœcie problemu z ich dodaniem do siebie. Na koniec znowu zamieni³ rezultat dodawania na int, poniewa¿ musia³ przypisaæ ten rezultat do zmiennej wynik, która jest w³aœnie typu int. Wszystko piêknie i g³adko. No, mo¿e z wyj¹tkiem tego warninga numer C4244, jaki poka¿e nam Visual Studio.
</P>
<P>
Taki sposób zamiany typów wartoœci w obliczeniach przez kompilator nazywamy konwersj¹ niejawn¹ (ang. <span class=Inglisz>implicit conversion</span>). W praktyce nie s¹ rzadkoœci¹ sytuacje, kiedy kompilator bêdzie du¿o mniej przydatny, jeœli chodzi o konwersjê - nie bêdzie móg³ siê &quot;domyœliæ&quot;, jaki typ chcemy otrzymaæ albo &quot;domyœli&quot; siê Ÿle. Popatrzmy tutaj:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-preprocessor">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

</span><span class="cpp1-reservedword">using</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">namespace</span><span class="cpp1-space"> </span><span class="cpp1-identifier">std</span><span class="cpp1-symbol">;

</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">main</span><span class="cpp1-symbol">()
{</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">unsigned</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">char</span><span class="cpp1-space"> </span><span class="cpp1-identifier">A</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">65</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
    
    </span><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;A wynosi: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">A</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">system</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-string">&quot;pause&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}</span><span class="cpp1-space"> 
</span></span>
</code></pre>
<P>
Co siê dzieje? Proste i ju¿ o tym mówiliœmy: strumienie traktuj¹ zmienne typu char (a wiêc tak¿e unsigned char) jako znaki ASCII. Czasem nam to pasuje, a czasem nie. Tutaj akurat chcieliœmy dostaæ na ekranie liczbê 65, a nie ¿adn¹ tam literkê. Potrzebujemy wiêc sposobu, by powiedzieæ strumieniowi, ¿e to jest liczba (na przyk³ad typu int), a nie znak - innymi s³owy, zastosowaæ jawn¹ konwersjê (ang. <span class=Inglisz>explicit conversion</span>). Sposoby s¹ dwa. Pierwszy jest charakterystyczny dla jêzyka C i wygl¹da tak:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;A wynosi: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">)</span><span class="cpp1-identifier">A</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span></span>
</code>
<P>
Drugi wygl¹da nastêpuj¹co:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;A wynosi: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">A</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span></span>
</code>
<P>
Oczywiœcie dzia³anie jest dok³adnie takie samo. Zmienna A zostaje przekazana do strumienia nie jako unsigned char, tylko jako int, wiêc strumieñ &quot;rozumie&quot; j¹ jako liczbê i jako liczbê wyœwietla na ekranie. Tego chcieliœmy. Której z dwóch pokazanych konstrukcji sk³adniowych wolisz stosowaæ, zale¿y tylko i wy³¹cznie od ciebie. Powszechnie przyjmuje siê, ¿e w przypadku prostych typów lepiej u¿ywaæ sk³adni (int)A, natomiast dla bardziej z³o¿onych typów danych (na razie znamy w³aœciwie tylko jeden taki, string) lepsza jest sk³adnia int(A). Ale oczywiœcie jest to kwestia gustu.
</P>
<P class=UWAGA>
W jêzyku C++ wprowadzono dodatkowo trzeci sposób przeprowadzania jawnych konwersji - poprzez operator static_cast. Jego u¿ycie w naszym przypadku wygl¹da³oby tak:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;A wynosi: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">static_cast</span><span class="cpp1-symbol">&lt;</span><span class="cpp1-reservedword">int</span><span class="cpp1-symbol">&gt;(</span><span class="cpp1-identifier">A</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span></span>
</code>
<P class=UWAGA>
Sposób ten jednak zupe³nie siê nie przyj¹³ w praktyce, co nie jest dziwne, zwa¿ywszy na czytelnoœæ takiego zapisu (i jego d³ugoœæ) i dziœ stosuj¹ go niemal wy³¹cznie ortodoksyjne ugrupowania programistów ;-). Kiedyœ omówimy go dok³adniej i dowiemy siê, w jakich nielicznych sytuacjach ma przewagê nad konwersj¹ w stylu C.
</P>
<h2><br>
Konwersje bezpieczne i niebezpieczne
</h2>
<P><br>
Mo¿emy przyj¹æ, ¿e &quot;bezpieczna&quot; jest konwersja z typu int na long int (na wiêkszoœci platform 32-bitowych), &quot;bezpieczna&quot; jest konwersja z char na int, z short int na long int, z float na double. Krótko mówi¹c, z typu &quot;mniejszego&quot; na typ &quot;wiêkszy&quot;. Kompilator po prostu &quot;do³o¿y&quot; dodatkowe bity jeœli trzeba. Gorzej, gdy mamy konwersjê z typu &quot;wiêkszego&quot; na &quot;mniejszy&quot;. Wtedy powinniœmy &quot;obcinaæ&quot; bity, ale one mog¹ zawieraæ wa¿n¹ informacjê lub nie. Popatrzmy:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-preprocessor">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

</span><span class="cpp1-reservedword">using</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">namespace</span><span class="cpp1-space"> </span><span class="cpp1-identifier">std</span><span class="cpp1-symbol">;

</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">main</span><span class="cpp1-symbol">()
{</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">short</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">40000</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
    </span><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;a: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">system</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-string">&quot;pause&quot;</span><span class="cpp1-symbol">);
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}</span><span class="cpp1-space"> 
</span></span>
</code></pre>
<P>
Oczywiœcie wiemy, ¿e liczba 40000 nie zmieœci siê w zmiennej typu short int, gdy¿ ta ma (zazwyczaj) tylko 16 bitów, w tym jeden przeznacza na znak, wiêc najwiêksza liczba, jak¹ w niej zapiszemy to 32767. Kompilator ma tu wiêc niez³y orzech do zgryzienia. Visual C++ radzi sobie w ten sposób, ¿e bity owszem, odcina, ale wyœwietli nam te¿ stosowne ostrze¿enie (tym razem numer C4309 :-)). Dziêki temu nawet bez odpalania programu i bez sprawdzania, jaki te¿ jest rozmiar zmiennej typu short int dowiemy siê, ¿e coœ jest nie w porz¹dku. A nie w porz¹dku jest fakt, ¿e obcinamy bity z wartoœci typu int (bo wszystkie sta³e ca³kowite wartoœci liczbowe, czyli w³aœnie takie, jak w powy¿szym programie liczba 40000, s¹ przez kompilator traktowane jako int, chyba ¿e s¹ zbyt du¿e). 
</P>
<P>
Innym przypadkiem niebezpiecznej konwersji jest zamiana dowolnego typu zmiennoprzecinkowego na ca³kowity. Tutaj akurat nie ma znaczenia, czy fizycznie s¹ one &quot;mniejsze&quot; czy &quot;wiêksze&quot;. Liczy siê tylko fakt, ¿e przy takiej zamianie bezpowrotnie tracimy u³amkow¹ czêœæ liczby:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-preprocessor">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

</span><span class="cpp1-reservedword">using</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">namespace</span><span class="cpp1-space"> </span><span class="cpp1-identifier">std</span><span class="cpp1-symbol">;

</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">main</span><span class="cpp1-symbol">()
{</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wynik</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">float</span><span class="cpp1-space"> </span><span class="cpp1-identifier">pi</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-float">3.1415926</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">wynik</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">pi</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
    
    </span><span class="cpp1-identifier">cout</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;Wynik: &quot;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wynik</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;&lt;</span><span class="cpp1-space"> </span><span class="cpp1-identifier">endl</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    
    </span><span class="cpp1-identifier">system</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-string">&quot;pause&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> 
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}</span><span class="cpp1-space"> 
</span></span>
</code></pre>
<P>
Có¿ z tego, ¿e zarówno float, jak i int s¹ (zazwyczaj) 32-bitowe. Typ int nie potrafi przechowywaæ u³amków i ju¿, tak wiêc kompilator bêdzie musia³ czêœæ u³amkow¹ po prostu zlikwidowaæ, zostanie nam tylko ca³kowite 3. Warto mieæ na uwadze to niebezpieczeñstwo, gdy¿ jest ono przyczyn¹ licznych b³êdów programistycznych. Na przyk³ad jeœli zajmujemy siê grafik¹ 3D i wykorzystujemy jakieœ zmienne typu int w obliczaniu pozycji jakiegoœ obiektu (zazwyczaj czyni siê to od nowa w ka¿dej klatce), to mo¿e siê okazaæ, ¿e kompilator w którymœ miejscu niejawnie przekonwertowa³ czêœæ skomplikowanego wyra¿enia na int, przez co animacja obiektu przestaje byæ p³ynna. 
</P>
<P>

</P>
<h2><br>
Jawna specyfikacja typu
</h2>
<P><br>
Jak ju¿ powiedzieliœmy, kompilator domyœlnie potraktuje wiêkszoœæ liczb wpisanych w kodzie programu jako int. W wielu sytuacjach jest nam to obojêtne. Bywa jednak, ¿e nie jest. W takich sytuacjach mo¿emy &quot;wmówiæ&quot; kompilatorowi, ¿e dana sta³a liczbowa jest okreœlonego typu, koñcz¹c sta³¹ liczbow¹ odpowiedni¹ kombinacj¹... literek. Na przyk³ad:
</P>

<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">unsigned</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">100u</span><span class="cpp1-symbol">;
</span></span>
</code>
<P>
Literka u (albo U) powoduje, ¿e kompilator uzna liczbê za wartoœæ bez znaku (domyœlnie wszystkie wartoœci s¹ ze znakiem, o czym ju¿ chyba mówiliœmy). Mo¿emy równie¿ u¿yæ literki l (lub L). Dzia³a ona podobnie, jak modyfikator typu long, czyli zamiast int dostaniemy wartoœæ typu long int, a zamiast double - long double. Mo¿emy oczywiœcie po³¹czyæ te dwa specyfikatory, np.:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">unsigned</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">long</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">100UL</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> </span><span class="cpp1-comment">// mo¿e byæ te¿ 100LU
</span></span>
</code>
<P>
Znaczenie specyfikatorów L i U jest raczej niewielkie, za to bardzo przydatne s¹ specyfikatory typów zmiennoprzecinkowych. Jeœli na przyk³ad chcemy otrzymaæ wartoœæ typu float, zamiast domyœlnego dla liczb zmiennoprzecinkowych double, piszemy:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">liczba</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-float">7.13f</span><span class="cpp1-symbol">;
</span></span>
</code>
<P>
W wielu sytuacjach nie ma to ¿adnego znaczenia z punktu widzenia dzia³ania programu, ale ma ogromne, jeœli chodzi o jego czytelnoœæ. Co prawda pocz¹tkuj¹cy programiœci nie odnosz¹ siê ze zbytnim entuzjazmem do wszelkich udziwnieñ zapisu (po co, do diaska, mieszaæ literki z liczbami?), ale ich bardziej zaawansowani koledzy z pewnoœci¹ doceniaj¹ fakt, ¿e w programie zmienne typu float czy double s¹ wyraŸnie oznaczone i dziêki temu ³atwo je odró¿niæ od zmiennych typu int (o niebezpieczeñstwach wynikaj¹cych z ewentualnej pomy³ki ju¿ wspomnieliœmy).
</P>
<P>
Warto jeszcze zauwa¿yæ, ¿e gdy chcemy, by wartoœæ ca³kowita &quot;sta³a siê&quot; wartoœci¹ typu zmiennoprzecinkowego (float lub double), wystarczy... dodaæ jej ów przecinek (czyli kropkê - programiœci musz¹ zapomnieæ o istnieniu przecinka w liczbach, s¹ tylko kropki ;-)). Mo¿na to czyniæ na rozmaite sposoby:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">float</span><span class="cpp1-space"> </span><span class="cpp1-identifier">a</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-float">2.</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
</span><span class="cpp1-reservedword">float</span><span class="cpp1-space"> </span><span class="cpp1-identifier">b</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-float">.2</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 
</span><span class="cpp1-reservedword">float</span><span class="cpp1-space"> </span><span class="cpp1-identifier">c</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-float">2.0</span><span class="cpp1-symbol">;
</span></span>
</code></pre>
<P>
Ciekawy jest fakt, ¿e w przypadku zmiennej b kompilator Visual C++ wyœwietli nam ostrze¿enie o &quot;przyciêciu&quot; typu double do float. Ten przyk³ad dobrze obrazuje przydatnoœæ specyfikatora 'f', gdy¿ jak widzimy, w zale¿noœci od tego, czy przed przec... kropk¹ wystêpuje liczba czy te¿ nie, kompilator mo¿e potraktowaæ tak¹ sta³¹ liczbow¹ jako float lub jako double. Stawiaj¹c na koñcu 'f' pozbawiamy kompilator (i siebie) w¹tpliwoœci. Oczywiœcie gdybyœmy chcieli operowaæ na double, a nie na float, nie potrzebujemy ¿adnego specyfikatora, gdy¿ ewentualna konwersja z float na double jest zawsze bezpieczna.
</P>
<P class=UWAGA>
Liczby zmiennoprzecinkowe mo¿emy te¿ zapisywaæ w notacji wyk³adniczej, np. 3.1e-3 (takie liczby s¹ traktowane jako double). Przydatnoœæ takiego zapisu w C++ jest jednak dyskusyjna. Zostawmy takie rzeczy matematycznym zboczuchom ;-).
</P>
<P>
Na koniec dla porz¹dku wspomnijmy, ¿e literki 'L' mo¿na jeszcze u¿ywaæ jako prefiksu do stringów. String poprzedzony takim prefiksem traktowany jest jako ³añcuch znaków Unicode. O ró¿nicach miêdzy stringami Unicode i &quot;zwyk³ymi&quot; opowiemy sobie kiedyœ w osobnym artykule, a tymczasem mówimy o tym tylko po to, by nie zdziwiæ siê, gdy pewnego piêknego dnia spotkamy taki prefiks w czyimœ kodzie.
</P>
<P>

</P>
<P>
Ufff... Wiem, ¿e nie by³o lekko i prawdopodobnie te¿ niezbyt ciekawie, ale musieliœmy przez to przebrn¹æ, gdy¿ C++ jako jêzyk o silnej typizacji nie wybacza b³êdów zwi¹zanych z typami :-). Bêdziemy siê jeszcze o te kwestie potykaæ nieraz, ale po dawce teorii z tej czêœci kursu powinno ju¿ byæ nieco ³atwiej. 
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TR>
</TABLE>

</HTML>