<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - W³asne kontrolki, cz.2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apicc.html">&lt;&lt; W³asne kontrolki, cz. 1</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Mazanie po kontrolce
</h2>

<P>
Bez wzglêdu na to, jak du¿e mo¿liwoœci mo¿na uzyskaæ przez wykorzystywanie standardowych kontrolek do tworzenia w³asnych, i tak wiem, ¿e co innego przyci¹gnê³o ciê do tego artyku³u :-). Zapewne chcia³byœ po prostu zmieniæ wygl¹d tych standardowych, kanciastych, szarych, nudnych kontrolek windowsowych. Oczywiœcie, jest to mo¿liwe.
</P>
<P>
Spróbujmy stworzyæ swój w³asny przycisk. Jego wygl¹d bêdzie okreœlony przez przygotowan¹ wczeœniej bitmapê. ¯eby by³o ciekawiej, zmienimy te¿ kszta³t tego przycisku na okr¹g³y. Moja bitmapka do tego przycisku wygl¹da tak:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/przycisk.jpg" ALT="Bitmapa z przyciskiem">
</P>

<P>
Bitmapa ta bêdzie wspólna dla wszystkich przycisków tworzonej przez nas klasy, tak wiêc dobrze by by³o przechowywaæ j¹ (a dok³adniej: uchwyt do niej) w dodatkowej pamiêci klasy (wspomnieliœmy sobie o tej pamiêci wczeœniej). Zasady korzystania z pamiêci klasy s¹ podobne, jak w przypadku pamiêci okna.
</P>
<P>
Jak pamiêtamy z odcinka o grafice, rysowanie bitmapy polega na jej kopiowaniu z kontekstu pomocniczego na kontekst ekranu. Ten pierwszy oczywiœcie musimy sobie stworzyæ sami i podobnie jak bitmapê, bêdziemy jego uwchyt przechowywaæ w pamiêci klasy, ¿eby nie trzeba by³o tego kontekstu tworzyæ za ka¿dym razem, gdy chcemy narysowaæ kontrolkê.

</P>
<P>
Zapewne zauwa¿y³eœ, ¿e bitmapa do naszego przycisku ma urocze, pedalsko ró¿owe t³o. To oczywiœcie nie w ramach poprawnoœci politycznej, tylko aby stworzyæ do tej bitmapy maskê. Maska, jak pamiêtamy, to równie¿ uchwyt typu <SPAN CLASS=T>HBITMAP</SPAN> i równie¿ trzeba j¹ zapamiêtaæ dla ca³ej klasy. Dlatego w³aœnie potrzebujemy <SPAN CLASS=L>16</SPAN> bajtów dodatkowej pamiêci (<SPAN CLASS=L>4*3+4</SPAN>).
</P>
<P>
W poprzednim odcinku kursu rejestrowaliœmy now¹ kontrolkê bezpoœrednio z funkcji <SPAN CLASS=L>WinMain</SPAN>. Nie jest to mo¿e niedopuszczalne, ale i niezbyt eleganckie, gdy¿ kontrolki tworzy siê z regu³y w oddzielnym pliku, a najlepiej w ogóle w osobnym module DLL. Dlatego dobrze by by³o stworzyæ jak¹œ funkcjê, która bêdzie odwala³a ca³¹ robotê zwi¹zan¹ z przygotowaniem nowej kontrolki, to jest rejestracjê jej klasy oraz inicjalizacjê (wczytanie bitmapy, stworzenie maski, stworzenie kontekstu pomocniczego, umieszczenie tego wszystkiego w pamiêci klasy).

</P><P>
Wreszcie jeszcze jedna uwaga: do tej pory korzystaliœmy z superclassingu, a wiêc braliœmy istniej¹c¹ klasê i rozszerzaliœmy jej mo¿liwoœci. Tym razem zrobimy wszystko sami - od zera. Nie bêdzie pobierania informacji o klasie, wiêc wszystkie pola struktury <SPAN CLASS=L>WNDCLASS</SPAN> musimy teraz wype³niæ samodzielnie. Do dzie³a zatem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BOOL RejestrujPrzycisk(HINSTANCE hInst)<BR>
{<BR>
&nbsp;WNDCLASS wc;<BR>
&nbsp;wc.style = <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//stylowy kibel? ;-)</SPAN><BR>
&nbsp;wc.lpszMenuName = NULL;<BR>
&nbsp;wc.lpszClassName = <SPAN CLASS=L>"BitmapowyPrzycisk"</SPAN>;<BR>
&nbsp;wc.hInstance = hInst;<BR>
&nbsp;wc.lpfnWndProc = ControlProc;<BR>
&nbsp;wc.cbWndExtra = <SPAN CLASS=L>8</SPAN>;<BR>
&nbsp;wc.cbClsExtra = <SPAN CLASS=L>16</SPAN>;<BR>
&nbsp;wc.hIcon = NULL;<BR>
&nbsp;wc.hCursor = NULL;<BR>
&nbsp;wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);<BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(!RegisterClass(&wc)) <SPAN CLASS=K>return</SPAN> FALSE;<BR>
<BR>
&nbsp;<SPAN CLASS=C>//wczytanie bitmapy, stworzenie maski i kontekstu dla ca³ej klasy</SPAN><BR>
&nbsp;HBITMAP hbmBmp = (HBITMAP)LoadImage(NULL, <SPAN CLASS=L>"przycisk.bmp"</SPAN>, IMAGE_BITMAP, <SPAN CLASS=L>0, 0</SPAN>, LR_LOADFROMFILE),<BR>
&nbsp;hbmMask = CreateBitmapMask(hbmBmp, RGB(<SPAN CLASS=L>255,0,255</SPAN>));<BR>
&nbsp;HDC hdcMem = CreateCompatibleDC(NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//tworzymy tymczasowe okno nowej klasy</SPAN><BR>
&nbsp;HWND hTmp = CreateWindowEx(<SPAN CLASS=L>0, "BitmapowyPrzycisk"</SPAN>, NULL, WS_POPUP,
           <SPAN CLASS=L>0, 0, 0, 0,</SPAN> NULL, NULL, hInst, NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//zapamiêtanie kontekstu i bitmap w dodatkowej pamiêci okna</SPAN><BR>
&nbsp;SetClassLong(hTmp, <SPAN CLASS=L>0</SPAN>, (LONG)hdcMem);<BR>
&nbsp;SetClassLong(hTmp, <SPAN CLASS=L>4</SPAN>, (LONG)hbmBmp);<BR>
&nbsp;SetClassLong(hTmp, <SPAN CLASS=L>8</SPAN>, (LONG)hbmMask);<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> TRUE;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Czêœæ kodu odpowiedzialna za rejestrowanie nowej klasy nie jest dla nas niespodziank¹ - przerabialiœmy to ju¿ w poprzednim odcinku kursu (nie mówi¹c ju¿ o tworzeniu okna we wprowadzeniu do WinAPI). Wczytywanie bitmapy to te¿ nie nowoœæ - by³o to ju¿ w odcinku o GDI (tam te¿ znajduje siê "przepis" na funkcjê <SPAN CLASS=T>CreateBitmapMask</SPAN>). Drobnego komentarza mo¿e wymagaæ natomiast funkcja <SPAN CLASS=T>CreateWindowEx</SPAN>. Co ona tu robi? Ano, korzystamy tutaj z us³ug <SPAN CLASS=T>SetClassLong</SPAN>, aby zapamiêtaæ uchwyty w pamiêci klasy, zaœ funkcji tej nie wystarczy niestety sama nazwa klasy - potrzebny jest uwchyt dowolnego okna tej klasy. Dlatego te¿ tworzymy takie okno (do niczego innego nie jest ono wykorzystywane, dlatego te¿ u¿yliœmy takich nietypowych parametrów dla <SPAN CLASS=T>CreateWindowEx</SPAN>). Taka ma³a niedogodnoœæ WinAPI.
</P>
<P>
Zarezerwowaliœmy te¿ po <SPAN CLASS=L>8</SPAN> bajtów dla ka¿dego okna tworzonej przez nas klasy <SPAN CLASS=L>BitmapowyPrzycisk</SPAN>. Bêdzie tam przechowywana informacja, czy przycisk jest aktualnie wciœniêty - aby kod odpowiedzialny za rysowanie przycisku wiedzia³, któr¹ po³ówkê bitmapy ma w danym momencie pokazaæ. Oczywiœcie jest to spora rozrzutnoœæ - jeden bajt (plus cztery nieu¿ywane, jak zwykle) wystarczy³by, ale nie mamy powodu, ¿eby tak sk¹piæ (a na wartoœciach 32-bitowych ³atwiej siê operuje). Powinniœmy zainicjalizowaæ tê pamiêæ w <SPAN CLASS=T>WM_CREATE</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_CREATE:<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//inicjalizacja stanu przycisku - na niewciœniêty</SPAN><BR>
&nbsp;SetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>, (LONG)FALSE);  <BR>
&nbsp;<SPAN CLASS=C>//pobierz wymiary bitmapy</SPAN><BR>
&nbsp;BITMAP bmInfo;<BR>
&nbsp;HBITMAP hbmBmp = (HBITMAP)GetClassLong(hwnd, <SPAN CLASS=L>4</SPAN>);<BR>
&nbsp;GetObject((HGDIOBJ)hbmBmp, <SPAN CLASS=K>sizeof</SPAN>(BITMAP), &bmInfo); <BR>
&nbsp;<SPAN CLASS=C>//zmieñ rozmiar przycisku na taki sam, jak ma bitmapa</SPAN><BR>
&nbsp;SetWindowPos(hwnd, NULL, <SPAN CLASS=L>0, 0</SPAN>, bmInfo.bmWidth/<SPAN CLASS=L>2</SPAN>, bmInfo.bmHeight, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);<BR>
&nbsp;<SPAN CLASS=C>//ustaw okr¹g³y kszta³t</SPAN><BR>
&nbsp;HRGN hRgn = CreateEllipticRgn(<SPAN CLASS=L>0,0</SPAN>,bmInfo.bmWidth/<SPAN CLASS=L>2-1</SPAN>,bmInfo.bmHeight-<SPAN CLASS=L>1</SPAN>);<BR>
&nbsp;SetWindowRgn(hwnd, hRgn, FALSE);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Robimy tu przy okazji trochê wiêcej rzeczy. Pobieramy wymiary bitmapy wyœwietlanej na naszym przycisku, a nastêpnie dostosowujemy ca³e okno (przycisk) do tego wymiaru. Dziêki temu niezale¿nie od tego, jakie parametry poda u¿ytkownik naszej kontrolki przy wywo³ywaniu <SPAN CLASS=T>CreateWindowEx</SPAN>, przycisk zawsze bêdzie mia³ te same rozmiary (chyba, ¿e u¿ytkownik "rêcznie" zmieni jego rozmiary, czemu mo¿emy z kolei zapobiec, obs³uguj¹c komunikat <SPAN CLASS=T>WM_SIZE</SPAN>). Wreszcie tworzymy sobie region w kszta³cie ko³a i przypisujemy ten region naszemu przyciskowi. Sprawia to, ¿e nie s¹ rysowane fragmenty okna spoza podanego regionu, a tak¿e - ¿e klikniêcie poza tym regionem nie powoduje wys³ania komunikatu do kontrolki (trafia on do okna-rodzica). Zauwa¿, ¿e nie zapamiêtujemy nigdzie uchwytu tego regionu - odk¹d jest on przypisany do okna, mo¿emy go pobraæ przez <SPAN CLASS=T>GetWindowRgn</SPAN>.
</P>
<P>
Kolejnym krokiem w tworzeniu naszego przycisku bêdzie obs³uga klikniêæ mysz¹. Musimy w zwi¹zku z tym zrobiæ trzy rzeczy. Po pierwsze - zmieniamy stan przycisku w jego pamiêci okna (wciœniêty/niewciœniêty), odrysowujemy przycisk (wywo³ujemy niejawnie <SPAN CLASS=T>WM_PAINT</SPAN> przez <SPAN CLASS=T>InvalidateRgn</SPAN>) oraz przechwytujemy mysz (o tym zaraz). 

</P><P>
Wspomnia³em o przechwytywaniu myszy. Po co to? Otó¿ nasz przycisk ma dzia³aæ tak, jak standardowe przyciski Windows - kiedy u¿ytkownik trzyma wciœniêty przycisk myszy nad kontrolk¹, a nastêpnie kursor mu siê zeœlizguje poza obrêb kontrolki, przycisk siê "wyciska". ¯eby otrzymaæ taki sam efekt, musimy jakoœ sprawiæ, ¿eby komunikat <SPAN CLASS=T>WM_LBUTTONUP</SPAN> zosta³ wys³any kontrolce tak¿e w tym momencie, gdy kursor wyje¿d¿a poza jej obrêb. Dlatego w³aœnie w <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN> wywo³ujemy <SPAN CLASS=T>SetCapture</SPAN> - od tego momentu do kontrolki docieraj¹ WSZYSTKIE komunikaty zwi¹zane z mysz¹, bez wzglêdu na to, gdzie jest akurat kursor. W obs³udze <SPAN CLASS=T>WM_LBUTTONUP</SPAN> "oddajemy" myszkê z powrotem systemowi dziêki <SPAN CLASS=T>ReleaseCapture</SPAN> i wszystko wraca wówczas do normy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_LBUTTONDOWN:<BR>
{    <BR>
&nbsp;SetWindowLong(hwnd, <SPAN CLASS=L>0<SPAN CLASS=T>, (LONG)TRUE);<BR>
&nbsp;InvalidateRgn(hwnd, NULL, TRUE);<BR>
&nbsp;SetCapture(hwnd);<BR>
}<BR>
<SPAN CLASS=K>break;<BR>
case</SPAN> WM_LBUTTONUP:<BR>
{<BR>
&nbsp;SetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>, (LONG)FALSE);<BR>
&nbsp;InvalidateRgn(hwnd, NULL, TRUE);<BR>
&nbsp;ReleaseCapture();<BR>
&nbsp;<SPAN CLASS=C>//Wyœlij komunikat WM_COMMAND</SPAN><BR>
&nbsp;SendMessage(GetParent(hwnd), WM_COMMAND, (WPARAM)MAKELONG((WORD)GetWindowLong(hwnd, GWL_ID), BN_CLICKED), (LPARAM)hwnd); 
<BR><BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Obydwa komunikaty s¹ zbudowane podobnie, ale <SPAN CLASS=T>WM_LBUTTONUP</SPAN> pe³ni jeszcze jedn¹, dodatkow¹ funkcjê - wysy³a komunikat <SPAN CLASS=T>WM_COMMAND</SPAN> do okna-rodzica. Dziêki temu mo¿emy przypisaæ naszemu przyciskowi jakieœ zdarzenie i obs³u¿yæ je w komunikacie <SPAN CLASS=T>WM_COMMAND</SPAN>, tak jak dla standardowego przycisku.
</P>
<P>
To oczywiœcie jeszcze nie koniec, jeœli chodzi o mysz. Musimy przecie¿ obs³u¿yæ to przechwycone zeœlizgniêcie siê kursora z przycisku. ¯eby przekonaæ siê, czy rzeczywiœcie dany ruch mysz¹ jest tym zeœlizgniêciem, sprawdzamy, czy kursor znajduje siê w regionie okna. Region ten nale¿y pobraæ funkcj¹ <SPAN CLASS=T>GetWindowsRgn</SPAN>. Funkcja ta ¿¹da jednak podania uchwytu do dowolnego, istniej¹cego ju¿ regionu, który nastêpnie zostanie zast¹piony kopi¹ regionu pobieranego (trochê zakrêcone, ale trudno). Dlatego w³aœnie tworzymy tu sobie taki tymczasowy, kilkupikselowy region.
</P>
<P>
Trzeba zwróciæ uwagê na to, ¿e wspó³rzêdne regionu s¹ wyra¿ane wzglêdem okna (przycisku), natomiast wspó³rzêdne kursora, pobierane funkcj¹ <SPAN CLASS=T>GetCursorPos</SPAN> - wzglêdem ekranu. St¹d konwersja za pomoc¹ <SPAN CLASS=T>ScreenToClient</SPAN>. Teraz dopiero mo¿emy sprawdziæ, czy kursor jest nad kontrolk¹, do czego wykorzystujemy funkcjê <SPAN CLASS=T>PtInRegion</SPAN>. Jeœli kursor znajdzie siê poza przyciskiem, to wysy³amy komunikat <SPAN CLASS=T>WM_LBUTTONUP</SPAN> (co sprawia, ¿e przycisk siê "wyciska") Natomiast ten drugi warunek w instrukcji <SPAN CLASS=K>if</SPAN> s³u¿y do tego, ¿eby przycisk rysowany by³ tylko wtedy, gdy rzeczywiœcie zmienia siê jego stan, co eliminuje mo¿liwe miganie.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_MOUSEMOVE:<BR>
{<BR>
&nbsp;POINT cur;<BR>
&nbsp;HRGN hRgn = CreateRectRgn(<SPAN CLASS=L>0,0,1,1</SPAN>);<BR>
&nbsp;GetCursorPos(&cur);   <BR>
&nbsp;ScreenToClient(hwnd, &cur);<BR>
&nbsp;GetWindowRgn(hwnd, hRgn);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(!PtInRegion(hRgn, cur.x, cur.y) && (BOOL)GetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>))<BR>
&nbsp;&nbsp;SendMessage(hwnd, WM_LBUTTONUP, wParam, lParam);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Pora zaj¹æ siê najwa¿niejsz¹ czêœci¹ zadania, czyli w³aœciwym kodem rysuj¹cym przycisk. Potrzebujemy w tym donios³ym momencie wszystkich informacji, jakie wpakowaliœmy do pamiêci klasy, a wiêc uchwytów: do bitmapy, do maski i do kontekstu pomocniczego. Potrzebujemy te¿ "wyci¹gn¹æ" z pamiêci okna, czy przycisk jest aktualnie wciœniêty, czy te¿ nie. Nastêpnie pobieramy wymiary bitmapy, no i wreszcie rysujemy za pomoc¹ <SPAN CLASS=T>BitBlt</SPAN>. 
Dodam jeszcze, ¿e szerokoœæ bitmapy dzielimy przez <SPAN CLASS=L>2</SPAN>, poniewa¿ za ka¿dym razem rysujemy tylko po³ówkê bitmapy (raz jedn¹, raz drug¹).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_PAINT:<BR>
{<BR>
&nbsp;PAINTSTRUCT ps;<BR>
&nbsp;HDC hdc = BeginPaint(hwnd, &ps);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//wczytaj uchwyty z dodatkowej pamiêci klasy</SPAN><BR> 
&nbsp;HBITMAP hbmBmp, hbmMask;<BR>
&nbsp;HDC hdcMem;<BR>
&nbsp;hdcMem = (HDC)GetClassLong(hwnd, <SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;hbmBmp = (HBITMAP)GetClassLong(hwnd, <SPAN CLASS=L>4</SPAN>);<BR>
&nbsp;hbmMask = (HBITMAP)GetClassLong(hwnd, <SPAN CLASS=L>8</SPAN>); <BR>
<BR>
&nbsp;<SPAN CLASS=C>//pobierz wymiary bitmapy</SPAN><BR>
&nbsp;BITMAP bmInfo;<BR>
&nbsp;GetObject((HGDIOBJ)hbmBmp, <SPAN CLASS=K>sizeof</SPAN>(BITMAP), &bmInfo); <BR> 
<BR>
&nbsp;<SPAN CLASS=C>//sprawdŸ, czy przycisk jest wciœniêty</SPAN><BR>
&nbsp;BOOL bWcisniety = (BOOL)GetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;WORD x = (bWcisniety) ? bmInfo.bmWidth/<SPAN CLASS=L>2 : 0</SPAN>;<BR>
<BR>
&nbsp;<SPAN CLASS=C>//rysowanie bitmapy z mask¹</SPAN><BR>
&nbsp;SelectObject(hdcMem, hbmMask);<BR>
&nbsp;BitBlt(hdc, <SPAN CLASS=L>0, 0,</SPAN> bmInfo.bmWidth/<SPAN CLASS=L>2</SPAN>, bmInfo.bmHeight, hdcMem, x, <SPAN CLASS=L>0</SPAN>, SRCAND);<BR>
&nbsp;SelectObject(hdcMem, hbmBmp);<BR>
&nbsp;BitBlt(hdc, <SPAN CLASS=L>0, 0,</SPAN> bmInfo.bmWidth/<SPAN CLASS=L>2</SPAN>, bmInfo.bmHeight, hdcMem, x, <SPAN CLASS=L>0</SPAN>, SRCPAINT);<BR>
 <BR>
&nbsp;EndPaint(hwnd, &ps); <BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie wszystkie podane wy¿ej komunikaty dotycz¹ <SPAN CLASS=T>ControlProc</SPAN> i tam te¿ mamy je umieœciæ. Pora wytestowaæ, coœmy tutaj zmajstrowali. U¿ycie naszej pachn¹cej œwie¿oœci¹ kontrolki polegaæ bêdzie na tym, ¿e wywo³amy sobie funkcjê <SPAN CLASS=T>RejestrujPrzycisk</SPAN>, a nastêpnie bêdziemy tworzyæ kolejne przyciski funkcj¹ <SPAN CLASS=T>CreateWindowEx</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(!RejestrujPrzycisk(hThisInstance))<BR>
{<BR>
&nbsp;MessageBox(g_hwnd, <SPAN CLASS=L>"Nie uda³o siê zarejestrowaæ klasy przycisku.", "Yh..."</SPAN>, MB_ICONSTOP);<BR>
&nbsp;DestroyWindow(g_hwnd);<BR>
}<BR>
<BR>
HWND hControl = CreateWindowEx(<SPAN CLASS=L>0, "BitmapowyPrzycisk"</SPAN>, NULL, 
           WS_CHILD|WS_VISIBLE,
           <SPAN CLASS=L>5, 5, 32, 32</SPAN>, g_hwnd,
           (HMENU)IDC_BUTTON1, hThisInstance, NULL);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(hControl==NULL)<BR>
{<BR>
&nbsp;MessageBox(g_hwnd, <SPAN CLASS=L>"Nie uda³o siê stworzyæ przycisku.", "Yh..."</SPAN>, MB_ICONSTOP);<BR>
&nbsp;DestroyWindow(g_hwnd);<BR>
}<BR>
<BR>
HWND hControl2 = CreateWindowEx(<SPAN CLASS=L>0, "BitmapowyPrzycisk"</SPAN>, NULL, 
          WS_CHILD|WS_VISIBLE,
           <SPAN CLASS=L>50, 5, 32, 32</SPAN>, g_hwnd,
           (HMENU)IDC_BUTTON2, hThisInstance, NULL);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(hControl2==NULL)<BR>
{<BR>
&nbsp;MessageBox(g_hwnd, <SPAN CLASS=L>"Nie uda³o siê stworzyæ przycisku 2.", "Yh..."</SPAN>, MB_ICONSTOP);<BR>
&nbsp;DestroyWindow(g_hwnd);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
To wystarczy, by po uruchomieniu aplikacji ukaza³a nam siê para piêknych (no, nie przesadzajmy mo¿e - takich sobie), okr¹g³ych, kolorowych przycisków. Stworzyliœmy je ca³kiem
 samodzielnie, nie korzystaj¹c w ogóle z klas dostarczonych razem z Windowsem. Teraz pozostaje tylko umieœciæ nasz kod w jakimœ DLL-u i mamy gotowy komponent do swoich przysz³ych aplikacji:
</P>
<P ALIGN=CENTER>
<IMG SRC="../gfx/cc2.jpg" ALT="Nasze dwa okr¹g³e przyciski w ca³ej okaza³oœci">
<P>
Mo¿emy jeszcze obs³u¿yæ sobie <SPAN CLASS=T>WM_COMMAND</SPAN> (tym razem ju¿ w procedurze g³ównego okna), ¿eby sprawdziæ, czy jest on wysy³any prawid³owo:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(HIWORD(wParam)==BN_CLICKED)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>char</SPAN> buf[<SPAN CLASS=L>255</SPAN>];<BR>
&nbsp;&nbsp;wsprintf(buf, <SPAN CLASS=L>"Wciœniêty przycisk o identyfikatorze %hu."</SPAN>, LOWORD(wParam));<BR>
&nbsp;&nbsp;MessageBox(hwnd, buf, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break;</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Powinno byæ OK :-). Oczywiœcie trudno jeszcze nazwaæ nasz¹ kontrolkê profesjonalnie zrobion¹. Brakuje jeszcze wielu rzeczy, które powinna ona posiadaæ, ale to ju¿ zadanie dla ciebie ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apicc.html">&lt;&lt; W³asne kontrolki, cz. 1</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>