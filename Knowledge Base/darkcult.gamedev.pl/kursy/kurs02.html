<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, podstawowe konstrukcje, cz. 1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs01b.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs02a.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Najwa¿niejsze konstrukcje programowe
</H1>

<H2>
Instrukcja if
</H2>


<P>
Bez instrukcji warunkowych nie zrobisz nic, wiêc dobrze by³oby je poznaæ ;-). Najwa¿niejsz¹ tak¹ instrukcj¹ jest <SPAN CLASS=K>if</SPAN>, ponadto mamy instrukcjê (a w³aœciwie konstrukcjê) <SPAN CLASS=K>switch</SPAN>. Na razie zajmiemy siê <SPAN CLASS=K>if</SPAN>-em. Ma on postaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN><SPAN CLASS=T>(warunek) akcja;</SPAN><BR>
</TD></TR>
</TABLE>

<P>
W praktyce takie coœ wygl¹da nastêpuj¹co: jeœli <SPAN CLASS=Wazne>warunek</SPAN> jest ró¿ny od zera (czyli jest <SPAN CLASS=Wazne>prawdziwy</SPAN>), wykonywana jest <SPAN CLASS=T>akcja</SPAN>; mo¿e to byæ pojedyñcza instrukcja b¹dŸ te¿ kilka instrukcji (tzw. <SPAN CLASS=Wazne>blok</SPAN>), ujêtych w nawiasy klamrowe. Jeœli warunek jest równy zero (czyli <SPAN CLASS=Wazne>fa³szywy</SPAN>), to instrukcja (blok instrukcji) <SPAN CLASS=T>akcja</SPAN> jest ignorowany. Oto i stosowny przyk³adzik:
</P>

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>5</SPAN>, b=<SPAN CLASS=L>-1</SPAN>;<BR>
<SPAN CLASS=K>if</SPAN>(a==<SPAN CLASS=L>1</SPAN>) <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
<SPAN CLASS=K>if</SPAN>(b) printf(<SPAN CLASS=L>"b jest ró¿ne od zera\n"</SPAN>);<BR>
</TD></TR>
</TABLE>
<BR>

<P>
W drugiej linijce warunek to wyra¿enie a==<SPAN CLASS=L>1</SPAN>. Poniewa¿ jednak <SPAN CLASS=T>a</SPAN> jest u nas równe <SPAN CLASS=L>5</SPAN>, to warunek nie jest spe³niony, a wiêc instrukcja <SPAN CLASS=K>return</SPAN> nie zostanie wykonana. Porównujemy, u¿ywaj¹c podwójnego znaku równoœci; to dla odró¿nienia od instrukcji przypisania, która robi coœ zupe³nie innego (z punktu widzenia kompilatora). Inne operatory relacyjne to: <SPAN CLASS=T>></SPAN> (wiêksze), <SPAN CLASS=T><</SPAN>, <SPAN CLASS=T>>=</SPAN> (wiêksze lub równe), <SPAN CLASS=T><=</SPAN>,  <SPAN CLASS=T>!=</SPAN> (nierówne).
</P>
<P>
W trzeciej linijce sprawdzamy, czy <SPAN CLASS=T>b</SPAN> jest ró¿ne od zera (prawdziwe). Faktycznie jest, a zatem pojawi siê na ekranie odpowiedni napis.
</P>
<P>
Postaæ instrukcji <SPAN CLASS=K>if</SPAN>, któr¹ poda³em wy¿ej, nie jest pe³na. W niektórych przypadkach warto stosowaæ w³aœnie tak¹ postaæ, dla uproszczenia - jednak nie zawsze. Mo¿e siê zdarzyæ, ¿e chcemy wykonaæ akcjê A tylko wtedy gdy warunek jest spe³niony, natomiast w wypadku przeciwnym (i tylko wtedy) - akcja B. U¿ywamy do tego s³owa kluczowego <SPAN CLASS=K>else</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(warunek) akcja1;<BR>
<SPAN CLASS=K>else</SPAN> akcja2;
</TD></TR>
</TABLE>

<P>
Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(sa_bledy)<BR>
{<BR>
&nbsp;printf(<SPAN CLASS=L>"Wyst¹pi³ b³¹d.\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>255</SPAN>;<BR>
}<BR>
<SPAN CLASS=K>else return</SPAN> <SPAN CLASS=L>0</SPAN>;
</TD></TR>
</TABLE>

<P>
Jeœli zmienna <SPAN CLASS=T>sa_bledy</SPAN> bêdzie niezerowa, to program zwróci kod <SPAN CLASS=L>255</SPAN> po wypisaniu odpowiedniego komunikatu, zaœ jeœli <SPAN CLASS=T>sa_bledy</SPAN> jest równe <SPAN CLASS=L>0</SPAN>, to po prostu program zwróci kod <SPAN CLASS=L>0</SPAN>. Przy okazji po raz pierwszy u¿yliœmy <SPAN CLASS=K>if</SPAN> z blokiem instrukcji.
</P>
<P>
Napiszmy teraz programik, który bêdzie ¿¹da³ od nas podania liczby z zakresu <SPAN CLASS=L>1-10</SPAN>, a nastêpnie bêdzie orzeka³, czy jest to liczba parzysta czy nieparzysta. Bêdziemy tu potrzebowali dwóch nowych rzeczy. Po pierwsze, instrukcja wprowadzania z klawiatury, <SPAN CLASS=T>scanf</SPAN>, zdeklarowana w tym samym pliku nag³ówkowym, co i <SPAN CLASS=T>printf</SPAN>. Ma ona sk³adniê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
scanf(³añcuch_ster, adres_zmiennej);<BR>
</TD></TR>
</TABLE>

<P>
Jako <SPAN CLASS=T>³añcuch_ster</SPAN> wpisujemy zazwyczaj coœ w rodzaju <SPAN CLASS=T>%d</SPAN> - odsy³am do poprzednich czêœci kursu, gdzie trochê opisa³em te œmieszne kody przy okazji omawiania <SPAN CLASS=T>printf</SPAN>. <SPAN CLASS=Wazne>Adres zmiennej</SPAN>, wymagany przez sk³adniê polecenia <SPAN CLASS=T>scanf</SPAN>, uzyskujemy przez przy³o¿enie operatora <SPAN CLASS=T>&</SPAN> do nazwy zmiennej:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> zmienna=<SPAN CLASS=L>0</SPAN>;<BR>
scanf(<SPAN CLASS=L>"%d"</SPAN>, &zmienna);
</TD></TR>
</TABLE>

<P>
Co to jest ten adres zmiennej - wiedzieæ na razie nie musisz, niech ci wystaczy, ¿e po znaczku <SPAN CLASS=T>&</SPAN> musi wyst¹piæ nazwa zmiennej, w której chcemy zapamiêtaæ wprowadzan¹ z klawiatury liczbê ;-).
</P>
<P>
W momencie wywo³ania instrukcji <SPAN CLASS=T>scanf</SPAN> wykonywanie programu zatrzymuje siê, daj¹c u¿ytkownikowi mo¿liwoœæ wpisania z klawiatury liczby (w praktyce mo¿e on wpisaæ cokolwiek lub nic nie wpisaæ) i zatwierdzenia <SPAN CLASS=Wazne>Enterem</SPAN>. Wypada³oby siê zabezpieczyæ przed co g³upszymi userami, którzy wpadn¹ na jak¿e rewelacyjny pomys³ wpisywania czegoœ innego, ni¿ liczby od <SPAN CLASS=L>1</SPAN> do <SPAN CLASS=L>10</SPAN>. Czynimy to oczywiœcie za pomoc¹ <SPAN CLASS=K>if</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>((zmienna<<SPAN CLASS=L>1</SPAN>) || (zmienna><SPAN CLASS=L>10</SPAN>))<BR>
 {<BR>
&nbsp;printf(<SPAN CLASS=L>"Nie ze mn¹ te numery!\n"</SPAN>);<BR>
&nbsp;return <SPAN CLASS=L>1</SPAN>;<BR>
 }
</TD></TR>
</TABLE>

<P>
Nowoœæ w powy¿szym fragmencie to para znaczków <SPAN CLASS=T>||</SPAN>, która jest w C++ operatorem <SPAN CLASS=Wazne>logicznej alternatywy</SPAN>, czyli w zdaniu logicznym pe³ni funkcjê s³owa 'lub'. Czyli kompilator odczytuje powy¿szy warunek nastêpuj¹co: "Je¿eli zmienna jest mniejsza ni¿ <SPAN CLASS=L>1</SPAN> LUB wiêksza ni¿ <SPAN CLASS=L>10</SPAN>, to wypisz komunikat o b³êdzie i zakoñcz program". Inny wa¿ny operator logiczny to <SPAN CLASS=Wazne>koniunkcja</SPAN>, czyli s³owo 'i', reprezentowany przez parê znaków <SPAN CLASS=T>&&</SPAN>.
</P>
<P CLASS=UWAGA>
Niektóre (nowsze) kompilatory akceptuj¹ wersjê "dla lamerów" ;-), czyli zamiast || mo¿na u¿ywaæ s³owa or, natomiast w miejsce && - s³owa and. Dev-C++ z takiego w³aœnie kompilatora korzysta.
</P>
<P>
Zwróæ uwagê na nawiasy, w które ujêliœmy wyra¿enia <SPAN CLASS=T>zmienna<</SPAN><SPAN CLASS=L>1</SPAN> i <SPAN CLASS=T>zmienna></SPAN><SPAN CLASS=L>10</SPAN>. Nie s¹ one konieczne, poniewa¿ operatory relacji i tak maj¹ priorytet mniejszy ni¿ operatory logiczne (patrz: tabelka operatorów w poprzedniej czêœci), ale zazwyczaj wstawia siê je, poniewa¿ zwiêkszaj¹ czytelnoœæ zapisu. Zw³aszcza, gdy wyra¿enie w <SPAN CLASS=K>if</SPAN>-ie jest d³ugie i skomplikowane.
</P>
<P>
Teraz, kiedy w zmiennej mamy ju¿ podan¹ przez u¿ytkownika liczbê, nale¿a³oby sprawdziæ, czy jest ona parzysta, czy nie. Jak wiemy ze szko³y podstawowej (mam nadziejê :-) ), jeœli liczba nie jest parzysta, to reszta z jej dzielenia przez <SPAN CLASS=L>2</SPAN> wynosi <SPAN CLASS=L>1</SPAN>, w przeciwnym wypadku - <SPAN CLASS=L>0</SPAN>. I taka wiedza nam wystarczy do napisania odpowiedniego warunku, przy czym musimy jeszcze znaæ operator zwracaj¹cy resztê z dzielenia. Jest to ulubiony operator alkoholików i ma on postaæ:
</P>

<SPAN CLASS=T><SPAN CLASS=L>liczba_ktora_dzielimy</SPAN> % <SPAN CLASS=L>liczba_przez_ktora_dzielimy</SPAN>
</SPAN>

<P>
...a wiêc jak widaæ, wstawiamy go w miejsce zwyk³ego operatora dzielenia, tylko ¿e wynikiem dzia³ania nie bêdzie wynik dzielenia, tylko reszta z tego dzielenia. W praktyce bêdzie to wygl¹da³o tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(zmienna % <SPAN CLASS=L>2</SPAN>) printf(<SPAN CLASS=L>"%d jest liczb¹ nieparzyst¹.\n"</SPAN>, zmienna);<BR>
<SPAN CLASS=K>else</SPAN> printf(<SPAN CLASS=L>"%d jest liczb¹ parzyst¹.\n"</SPAN>, zmienna);
</TD></TR>
</TABLE>

<P>
Jeœli wyra¿enie <SPAN CLASS=T>zmienna % </SPAN><SPAN CLASS=L>2</SPAN> (czyli reszta z dzielenia przez 2) bêdzie ró¿ne od zera (<SPAN CLASS=Wazne>prawda logiczna</SPAN>), to znaczy, ¿e liczba nie jest podzielna przez <SPAN CLASS=L>2</SPAN> i tym samym nieparzysta - zostanie wyœwietlony odpowiedni komunikat. W wypadku przeciwnym - komunikat o parzystoœci.
</P>
<P>
Skoro wiemy ju¿ wszystko, czego nam by³o trzeba, piszemy nasz program:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> zmienna=<SPAN CLASS=L>0</SPAN>;<BR>
 <BR>
&nbsp;printf(<SPAN CLASS=L>"Proszê o podanie liczby z zakresu 1-10: "</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &zmienna);<BR>
&nbsp;printf(<SPAN CLASS=L>"\n"</SPAN>);<BR>
 <BR>
&nbsp;<SPAN CLASS=K>if</SPAN>((zmienna<<SPAN CLASS=L>1</SPAN>) || (zmienna><SPAN CLASS=L>10</SPAN>))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"Nie ze mn¹ te numery!\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;}<BR>
 <BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(zmienna % <SPAN CLASS=L>2</SPAN>) printf(<SPAN CLASS=L>"Poda³eœ liczbê nieparzyst¹.\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>else</SPAN> printf(<SPAN CLASS=L>"Poda³eœ parzyst¹ liczbê.\n"</SPAN>);<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<H2>
Po co siê mêczyæ, switch ciê wyrêczy
</H2>

<P>
W poprzednim podrozdziale mieliœmy stosunkowo prosty przypadek: liczba mog³a byæ albo parzysta, albo nie - a wiêc tylko dwie mo¿liwoœci. Czêsto bywa jednak, ¿e mo¿liwoœci bywa znacznie wiêcej. Pisanie oddzielnego <SPAN CLASS=K>if</SPAN>-a dla ka¿dej z nich mo¿e byæ nu¿¹ce, a i nie wygl¹da zbyt ³adnie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;if((liczba<<SPAN CLASS=L>1</SPAN>) || (liczba><SPAN CLASS=L>7</SPAN>))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"Musisz podaæ liczbê 1-7!\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>1</SPAN>) printf(<SPAN CLASS=L>"Poniedzia³ek\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>2</SPAN>) printf(<SPAN CLASS=L>"Wtorek\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>3</SPAN>) printf(<SPAN CLASS=L>"Œroda\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>4</SPAN>) printf(<SPAN CLASS=L>"Czwartek\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>5</SPAN>) printf(<SPAN CLASS=L>"Pi¹tek\n</SPAN>");<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>6</SPAN>) printf(<SPAN CLASS=L>"Sobota\n"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(liczba==<SPAN CLASS=L>7</SPAN>) printf(<SPAN CLASS=L>"Niedziela\n"</SPAN>);<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
U ¿ó³todzioba takie rozwi¹zanie nie wzbudzi w¹tpliwoœci, jednak z punktu widzenia kompilatora jest to ewidentnie nieekonomiczne: siedem razy powtarzamy operacjê, któr¹ procesor móg³by rozwi¹zaæ niejako za jednym razem, przypisuj¹c konkretnej liczbie konkretny dzieñ tygodnia. W dodatku co bardziej zaawansowany programista niechybnie dosta³by na widok takich cudów zawa³u. W wypadkach takich ratuje nas nieoceniona instrukcja <SPAN CLASS=K>switch</SPAN>. Oto i ona w akcji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê 1-7, a powiem ci, jaki oznacza dzieñ tygodnia:\n"</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &liczba);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>((liczba<<SPAN CLASS=L>1</SPAN>) || (liczba><SPAN CLASS=L>7</SPAN>))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"Musisz podaæ liczbê 1-7!\n"</SPAN>); <BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(liczba)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>1</SPAN>: printf(<SPAN CLASS=L>"Poniedzia³ek\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>2</SPAN>: printf(<SPAN CLASS=L>"Wtorek\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>3</SPAN>: printf(<SPAN CLASS=L>"Œroda\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>4</SPAN>: printf(<SPAN CLASS=L>"Czwartek\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>5</SPAN>: printf(<SPAN CLASS=L>"Pi¹tek\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>6</SPAN>: printf(<SPAN CLASS=L>"Sobota\n"</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>7</SPAN>: printf(<SPAN CLASS=L>"Niedziela\n"</SPAN>);<BR>
&nbsp;}  <BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
Od razu lepiej; co prawda pisaniny dalej jest du¿o, ale ju¿ procesorek nie zamêcza siê ka¿dorazowym porównywaniem wartoœci zmiennej - porównywanie koñczy siê w momencie, gdy zmienna bêdzie równa odpowiedniej wartoœci, podanej po <SPAN CLASS=K>case</SPAN>. Na przyk³ad gdy u¿ytkownik wpisze liczbê <SPAN CLASS=L>2</SPAN>, program najpierw porówna zmienn¹ (z wartoœci¹ <SPAN CLASS=L>2</SPAN>) do jedynki, odkrywczo stwierdzi, ¿e nie jest ona jedynce równa, nastêpnie przejdzie do porównywania zmiennej z dwójk¹, równie odkrywczo stwierdzi, ¿e tym razem dwójka jest równa dwójce, po czym reszta mo¿liwoœci zostanie po prostu ominiêta...
</P>
<P>
Ale czy aby na pewno? Tak byæ powinno w naszym przypadku, ale niestety, nie ma tak ³atwo. Okazuje siê, ¿e tak naprawdê program dalej bêdzie porównywa³ a¿ do koñca wszystkich <SPAN CLASS=K>case</SPAN>'ów, choæ w tym przypadku nie bêdzie to mia³o oczywiœcie najmniejszego sensu! Dlatego musimy zastosowaæ chwyt w postaci instrukcji <SPAN CLASS=K>break</SPAN></B>, która s³u¿y tutaj do tego, by "wyjœæ" na zewn¹trz instrukcji <SPAN CLASS=K>switch</SPAN>, gdy odpowiedni wybór bêdzie ju¿ dokonany. Oto prawid³owy program:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê 1-7, a powiem ci, jaki oznacza dzieñ tygodnia: \n"</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &liczba);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>((liczba<<SPAN CLASS=L>1</SPAN>) || (liczba><SPAN CLASS=L>7</SPAN>))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"Musisz podaæ liczbê 1-7!\n"</SPAN>); <BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(liczba)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>1</SPAN>: printf(<SPAN CLASS=L>"Poniedzia³ek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>2</SPAN>: printf(<SPAN CLASS=L>"Wtorek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>3</SPAN>: printf(<SPAN CLASS=L>"Œroda\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>4</SPAN>: printf(<SPAN CLASS=L>"Czwartek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>5</SPAN>: printf(<SPAN CLASS=L>"Pi¹tek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>6</SPAN>: printf(<SPAN CLASS=L>"Sobota\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>7</SPAN>: printf(<SPAN CLASS=L>"Niedziela\n"</SPAN>);<BR>
&nbsp;}  <BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>
<BR>

<P>
Widzimy tu dwie ciekawe rzeczy. Po pierwsze, po etykietach (np. <SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>1</SPAN>) mo¿emy wpisywaæ tyle instrukcji, ile nam siê podoba bez koniecznoœci u¿ywania klamerek. Ostrzegam jednak, ¿e nie zawsze tak jest i czasami klamerkê jednak trzeba daæ, bo program siê wykrzaczy. W takim prostym przypadku (1 instrukcja + <SPAN CLASS=K>break</SPAN>) mo¿na j¹ œmia³o pomin¹æ, ale gdy instrukcji jest wiêcej - klamerki lepiej daæ ;-). Po drugie, w ostatnim <SPAN CLASS=K>case</SPAN> nie ma <SPAN CLASS=K>break</SPAN> - nie jest bowiem potrzebne (chocia¿ z drugiej strony gdyby je wpisaæ, nic by siê nie sta³o, a program wygl¹da³by estetyczniej).
</P>
<P>
Nasz programik mo¿na jeszcze nieco skróciæ, przy wykorzystaniu etykiety <SPAN CLASS=K>default</SPAN>. Instrukcja pod t¹ etykiet¹ wykonywana jest wówczas, gdy ¿aden z <SPAN CLASS=K>case</SPAN>'ów "nie pasuje". Zwykle etykieta <SPAN CLASS=K>default</SPAN> u¿ywana jest do "wy³apywania" b³êdnych wartoœci porównywanej zmiennej (nie mieszcz¹cych siê w przewidzianym zakresie), co te¿ i uczynimy (u nas b³êdne s¹ wartoœci mniejsze od <SPAN CLASS=L>1</SPAN> i wiêksze od <SPAN CLASS=L>7</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê 1-7, a powiem ci, jaki oznacza dzieñ tygodnia: \n"</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &liczba);<BR>
<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(liczba)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>1</SPAN>: printf(<SPAN CLASS=L>"Poniedzia³ek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>2</SPAN>: printf(<SPAN CLASS=L>"Wtorek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>3</SPAN>: printf(<SPAN CLASS=L>"Œroda\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>4</SPAN>: printf(<SPAN CLASS=L>"Czwartek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>5</SPAN>: printf(<SPAN CLASS=L>"Pi¹tek\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>6</SPAN>: printf(<SPAN CLASS=L>"Sobota\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>7</SPAN>: printf(<SPAN CLASS=L>"Niedziela\n"</SPAN>); <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default</SPAN>: printf(<SPAN CLASS=L>"Musisz podaæ liczbê 1-7!\n"</SPAN>); <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;}  <BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
Dziêki temu zabiegowi nie musimy ju¿ za pomoc¹ <SPAN CLASS=K>if</SPAN> sprawdzaæ, czy user nie wpisa³ przypadkiem jakichœ g³upot, a program jest krótszy i bardziej przejrzysty. Jeœli wpisana liczba bêdzie siê mieœci³a w zakresie <SPAN CLASS=L>1-7</SPAN>, zostanie wybrana instrukcja pod odpowiednim <SPAN CLASS=K>case</SPAN>, jeœli liczba bêdzie za du¿a lub za ma³a - instrukcja pod <SPAN CLASS=K>default</SPAN>.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs01b.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs02a.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>