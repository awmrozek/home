<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - DLL</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apiclass.html">&lt;&lt; Subclassing i superclassing</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>DLL</H1>

<p>
DLL, czyli <span class=Inglisz>Dynamic Link Libraries</span>, jak sama nazwa wskazuje, s¹ bibliotekami dynamicznie linkowanymi. Oznacza to, w du¿ym uproszczeniu, ¿e kod wykonywalny zawartych w tych bibliotekach funkcji nie jest do³¹czany do twojego programu, lecz wywo³ywany dopiero podczas jego dzia³ania. Takie rozwi¹zanie ma dwie podstawowe zalety: ten sam kod mo¿e byæ wspó³dzielony przez wiele ró¿nych aplikacji, a rozmiar twoich plików wykonywalnych jest mniejszy. Wady wiêkszoœæ z nas pozna³a ju¿ na w³asnej skórze: DLL-ki maj¹ tê przykr¹ cechê, ¿e czêsto siê "gubi¹" i trzeba je potem sprowadzaæ z rozmaitych zak¹tków internetu tudzie¿ p³yt instalacyjnych. Bywa te¿, ¿e mamy potrzebn¹ DLL-kê, ale w nieodpowiedniej wersji. Poza tym dynamiczne linkowanie jest oczywiœcie równie¿ mniej wydajne.
</p>
<p>
Jeœli mimo wszystko dalej czytasz ten artyku³, zdecydowa³eœ siê jednak stworzyæ w³asn¹ bibliotekê dynamiczn¹, choæby z ciekawoœci. Do dzie³a wiêc.
</P>
<h2>
Najprostsza DLL
</h2>
<P>
Najbardziej typow¹ rzecz¹, któr¹ eksportujemy z DLL, jest oczywiœcie zwyk³a funkcja. ¯eby zanadto nie komplikowaæ sobie zadania, za³ó¿my, ¿e nasza funkcja ma po prostu obliczaæ kwadrat danej liczby. Oczywiœcie nie bêdzie to zbyt praktyczne, skoro istnieje œwietnie dzia³aj¹ca funkcja <SPAN CLASS=T>pow</SPAN>, ale - jak ju¿ powiedzia³em - nie komplikujmy sobie zadania ;-).
</P>
<P>
Poniewa¿ tworzenie biblioteki nieco siê ró¿ni od tworzenia aplikacji, wiêc sporo czynnoœci z tym zwi¹zanych zale¿nych jest od IDE. Tutaj poka¿emy sobie to na przyk³adzie œrodowiska Dev-C++, które wiêkszoœæ mokrej roboty odwala za nas. Do dyspozycji mamy bowiem gotowy szablon projektu DLL. Wystarczy wybraæ go podczas tworzenia nowego projektu i ju¿ mamy szkielet prostego DLL. Sk³ada siê on z dwóch plików, <SPAN CLASS=C>dllmain.cpp</SPAN> i <SPAN CLASS=C>dll.h</SPAN> (oczywiœcie te nazwy mo¿esz sobie zmieniæ). Pierwszy z nich przedstawia siê nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>/* Replace "dll.h" with the name of your header */</SPAN><BR>
<SPAN CLASS=C>#include "dll.h"<BR>
#include &lt;windows.h&gt;</SPAN><BR>
<BR>
DllClass::DllClass()<BR>
{<BR>
<BR>
}<BR>
<BR>
DllClass::~DllClass()<BR>
{<BR>
<BR>
}<BR>
<BR>
BOOL APIENTRY DllMain (HINSTANCE hInst    <SPAN CLASS=C> /* Library instance handle. */</SPAN>,<BR>
&nbsp;DWORD reason        <SPAN CLASS=C>/* Reason this function is being called. */</SPAN>,<BR>
&nbsp;LPVOID reserved     <SPAN CLASS=C>/* Not used. */</SPAN>)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(reason)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> DLL_PROCESS_ATTACH:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> DLL_PROCESS_DETACH:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> DLL_THREAD_ATTACH:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> DLL_THREAD_DETACH:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>/* Returns TRUE on success, FALSE on failure */</SPAN><BR>
&nbsp;<SPAN CLASS=K>return</SPAN> TRUE;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Widzimy w³¹czenie nag³ówka <SPAN CLASS=C>windows.h</SPAN> (co jest oczywiste), naszego <SPAN CLASS=C>dll.h</SPAN> (o którym zaraz pogadamy), puste cia³a konstruktora i destruktora jakiejœ klasy oraz funkcjê <SPAN CLASS=T>DllMain</SPAN>. Ta ostatnia, jak zapewne siê domyœlasz, jest czymœ w rodzaju punktu wyjœciowego DLL-ki, odpowiednikiem <SPAN CLASS=T>WinMain</SPAN> w "normalnym" projekcie. Mo¿na w niej wykonaæ inicjalizacjê naszej DLL, o ile to potrzebne. Jeœli nie, to w ogóle nie musimy takiej funkcji umieszczaæ w naszej bibliotece. Skoro jednak Dev nam j¹ wstawi³, to niech sobie zostanie ;-).
</P>
<P>
Wiêcej ciekawych rzeczy w pliku <SPAN CLASS=C>dllmain.cpp</SPAN> nie ma, wiêc przejdŸmy do <SPAN CLASS=C>dll.h</SPAN>. Jest on trochê krótszy, ale te¿ w tym momencie znacznie dla nas wa¿niejszy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#ifndef _DLL_H_<BR>
#define _DLL_H_<BR>
<BR>
#if BUILDING_DLL<BR>
# define DLLIMPORT __declspec (dllexport)<BR>
#else /* Not BUILDING_DLL */<BR>
# define DLLIMPORT __declspec (dllimport)<BR>
#endif /* Not BUILDING_DLL */<BR></SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> DLLIMPORT DllClass<BR>
{<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;DllClass();<BR>
&nbsp;<SPAN CLASS=K>virtual</SPAN> ~DllClass(<SPAN CLASS=K>void</SPAN>);<BR>
<BR>
<SPAN CLASS=K>private:</SPAN><BR>
<BR>
};<BR>
<SPAN CLASS=C>
#endif /* _DLL_H_ */
</SPAN>
</TD></TR>
</TABLE>

<P>
W tej chwili mamy tu jedynie deklaracjê owej pustej klasy, której obecnoœæ zauwa¿yliœmy przy omawianiu <SPAN CLASS=C>dllmain.cpp</SPAN>. Oczywiœcie nie pe³ni ona ¿adnej roli w DLL - jest to tylko makieta klasy, któr¹ mo¿emy sobie zast¹piæ w³asn¹ deklaracj¹, jeœli bêdziemy chcieli napisaæ i wyeksportowaæ jak¹œ w³asn¹ klasê. O tym jednak póŸniej.
</P>
<P>
Znacznie wa¿niejsz¹ rzecz¹ jest definicja makra <SPAN CLASS=T>DLLIMPORT</SPAN>. Widzimy, ¿e jest to proste zast¹pienie s³owa kluczowego <SPAN CLASS=K>__declspec</SPAN> . O wartoœæ <SPAN CLASS=T>BUILDING_DLL</SPAN> nie musisz siê martwiæ - wszystko za³atwi¹ odpowiednie prze³¹czniki dla kompilatora, które zosta³y ju¿ automatycznie ustawione (mo¿esz sprawdziæ w opcjach projektu). Wstawiaj¹c <SPAN CLASS=T>DLLIMPORT</SPAN> do deklaracji funkcji lub klasy okreœlasz, ¿e ma ona byæ wyeksportowana "na zewn¹trz" (ten sam plik nag³ówkowy jest wykorzystywany do zbudowania DLL-ki oraz w aplikacjach wykorzystuj¹cych jej statyczn¹ wersjê, st¹d koniecznoœæ stosowania takiego makra).
</P>
<P>
Otrzaskaliœmy siê mniej wiêcej z budow¹ kodu Ÿród³owego DLL, wiêc mo¿emy siê zabraæ za stworzenie naszej funkcji licz¹cej kwadrat liczby. Najpierw definicja w pliku <SPAN CLASS=C>dllmain.cpp</SPAN> - bana³:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>double</SPAN> kwadrat(<SPAN CLASS=K>double</SPAN> liczba)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> liczba*liczba;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Teraz czêœæ wa¿niejsza - deklaracja funkcji w <SPAN CLASS=C>dll.h</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>double</SPAN> DLLIMPORT kwadrat(<SPAN CLASS=K>double</SPAN> liczba);<BR>
</TD></TR>
</TABLE>

<P>
To wszystko, czego potrzebujemy, by zbudowaæ DLL-kê z nasz¹ funkcj¹. W³¹czamy wiêc kompilacjê i patrzymy, co siê sta³o. Powinno przybyæ kilka plików. Oprócz wszystkiego tego, co zwykle tworzy siê podczas kompilacji, mamy jeszcze plik <SPAN CLASS=C>libNazwaProjektu.a</SPAN>, który mo¿na wykorzystaæ do statycznego linkowania naszej biblioteki, plik <SPAN CLASS=C>*.DEF</SPAN> (zawieraj¹cy informacje o tym, co dok³adnie eksportujemy) oraz upragnion¹ DLL-kê :-).
</P>
<P>
Jeœli ju¿ w tym miejscu przejdziesz do nastêpnego rozdzia³u i spróbujesz zdobyæ adres wyeksportowanej funkcji w celu jej u¿ycia, spotka ciê niemi³e rozczarowanie. Funkcja o nazwie <SPAN CLASS=L>"kwadrat"</SPAN> nie zostanie odnaleziona. Powodem jest tzw. wik³anie nazw, czyli dodawanie do nich przez kompilator dodatkowych ci¹gów znaków. Nie jest to oczywiœcie proces uboczny ani przypadkowy, niemniej jednak wik³anie utrudnia nam mocno korzystanie z funkcji bibliotecznych - tym bardziej, ¿e ró¿ne kompilatory generuj¹ ró¿ne nazwy. Na szczêœcie wik³anie mo¿na po prostu wy³¹czyæ, a to w taki sposób:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>extern</SPAN> <SPAN CLASS=L>"C"</SPAN><BR>
{<BR>
&nbsp;<SPAN CLASS=K>double</SPAN> DLLIMPORT kwadrat(<SPAN CLASS=K>double</SPAN> liczba);<BR>
}<BR>
</TD></TR>
</TABLE>

<H2>
Statyczne linkowanie funkcji i klas
</H2>

<P>
Mo¿na siê do woli zachwycaæ nasz¹ now¹ DLL-k¹, ale oczywiœcie nic nam po niej, jeœli nie bêdziemy potrafili wywo³aæ zawartych w niej funkcji z innego programu. Jak uczyniæ te funkcje dostêpnymi dla naszej aplikacji? Do wyboru s¹ dwie mo¿liwoœci. Mo¿emy u¿yæ linkowania podczas ³adowania programu (<SPAN CLASS=Inglisz>load-time linking</SPAN>), zwanego te¿ linkowaniem statycznym, wykorzystuj¹c do tego utworzony przed chwil¹ plik <SPAN CLASS=C>lib*.a</SPAN>, lub podczas jego dzia³ania (<SPAN CLASS=Inglisz>run-time linking</SPAN>, linkowanie dynamiczne). Ta druga metoda jest generalnie lepsza, gdy¿ nie wymaga statycznego do³¹czania pliku *.a, a poza tym umo¿liwia dalsze dzia³anie naszego programu nawet wtedy, gdyby jakiœ niecny user skasowa³ nam niezbêdn¹ DLL-kê (bêdziemy mogli wówczas np. poprosiæ go, a¿eby by³ ³askaw wrzuciæ j¹ z powrotem na w³aœciwe miejsce).
</P>
<P>
Zacznijmy jednak od linkowania statycznego. Opiera siê ono (jak ju¿ wspomnia³em) na do³¹czeniu pliku <SPAN CLASS=C>lib*.a </SPAN>do listy plików linkowanych wraz z naszym projektem. Oczywiœcie musimy te¿ do³¹czyæ plik nag³ówkowy (ten sam, który utworzyliœmy wraz z projektem DLL). Teraz - o ile posiadamy do tego gotow¹ DLL-kê - mo¿emy u¿ywaæ zawartych w niej funkcji i klas tak, jakby znajdowa³y siê one bezpoœrednio w naszym projekcie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//u¿ycie funkcji z DLL</SPAN><BR>
DWORD L = (DWORD)kwadrat(<SPAN CLASS=L>256</SPAN>);<BR>
wsprintf(buf, <SPAN CLASS=L>"256 do potêgi 2 jest równe %lu."</SPAN>, L);<BR>
MessageBox(hwnd, buf, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
<BR>
<SPAN CLASS=C>//u¿ycie klasy z DLL</SPAN><BR>
DllClass D;<BR>
</TD></TR>
</TABLE>

<P>
Zalety statycznego linkowania widaæ na pierwszy rzut oka. Nie potrzeba ¿adnych dodatkowych czarów - do³¹czamy nag³ówek i lib-a, mamy dostêp do zawartoœci biblioteki. G³ówn¹ wad¹ jest sama nazwa (statyczne linkowanie dynamicznie linkowanej biblioteki?). O innej wadzie ju¿ wspomnieliœmy - po skasowaniu, przeniesieniu lub zmianie nazwy DLL-ki program w ogóle siê nie uruchomi (ale przynajmniej poka¿e komunikat z wyjaœnieniem).
</P>

<h2>
Dynamiczne linkowanie funkcji
</h2>

<P>
Aby skorzystaæ z dobrodziejstw linkowania run-time, musimy zrobiæ trzy rzeczy:
<UL>
<li>za³adowaæ DLL
<li>pobraæ adres wybranej funkcji
<li>wywo³aæ funkcjê przez adres
</UL>
</P>

<P>
£adowanie biblioteki DLL nie nale¿y do szczególnie skomplikowanych zadañ. Specjalizuj¹ca siê w takich zadaniach funkcja <SPAN CLASS=T>LoadLibrary</SPAN> przyjmuje jako parametr nazwê DLL-ki, zaœ zwraca uchwyt do modu³u biblioteki. Uchwyt ten zapamiêtujemy, przyda siê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HINSTANCE hDll;<BR>
hDll = LoadLibrary(<SPAN CLASS=L>"dlltest"</SPAN>);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(hDll != NULL)<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//jeœli wszystko posz³o dobrze, tutaj mo¿emy wywo³aæ jak¹œ funkcjê biblioteczn¹</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Przyjêliœmy tutaj, ¿e nasza biblioteka znajduje siê w pliku <SPAN CLASS=C>DLLTest.dll</SPAN> (zwróæ uwagê, ¿e nazwê biblioteki mo¿emy podawaæ bez rozszerzenia <SPAN CLASS=C>.dll</SPAN>). Jeœli uda³o siê za³adowaæ bibliotekê, to mo¿emy teraz pobraæ adres funkcji <SPAN CLASS=T>kwadrat</SPAN>. Naturalnie pobraæ nie po to, ¿eby pos³aæ go w kosmos - potrzebujemy wiêc odpowiedniego wskaŸnika:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>typedef double</SPAN> (*MYPROC)(<SPAN CLASS=K>double</SPAN>);<BR>
<BR>
MYPROC FunkcjaKwadrat;<BR>
</TD></TR>
</TABLE>

<P>
Wracamy teraz do miejsca, gdzie wczytywaliœmy nasz¹ DLL-kê i zmuszamy j¹ do podania adresu funkcji <SPAN CLASS=T>kwadrat</SPAN> oraz uczynienia zeñ po¿ytku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD L;<BR>
<SPAN CLASS=K>char</SPAN> buf[<SPAN CLASS=L>1024</SPAN>];<BR>
<BR>
HINSTANCE hDll;<BR>
hDll = LoadLibrary(<SPAN CLASS=L>"dlltest"</SPAN>);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(hDll != NULL)<BR>
{<BR>
&nbsp;FunkcjaKwadrat = (MYPROC)GetProcAddress(hDll, <SPAN CLASS=L>"kwadrat"</SPAN>);<BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(FunkcjaKwadrat != NULL)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;L = (FunkcjaKwadrat)(<SPAN CLASS=L>256</SPAN>);<BR>
&nbsp;&nbsp;wsprintf(buf, <SPAN CLASS=L>"256 do potêgi 2 jest równe %lu."</SPAN>, L);<BR>
&nbsp;&nbsp;MessageBox(hwnd, buf, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;}<BR>
<BR>
&nbsp;FreeLibrary(hDll);<BR>
}<BR>
</TD></TR>
</TABLE>

<h2>
Dynamiczne linkowanie klas
</h2>

<P>
Proceduralny model programowania odchodzi ju¿ w zapomnienie, wiêc umieszczanie w dynamicznych bibliotekach "go³ych" funkcji jest dla nas ma³o przydatne. Znacznie ciekawiej by by³o, gdyby da³o siê to robiæ z klasami. Wiemy ju¿, ¿e mo¿na wyeksportowane klasy u¿ywaæ poprzez statyczne linkowanie i tak te¿ najczêœciej wykorzystuje siê klasy zawarte w DLL. A czy mo¿liwe jest dynamiczne linkowanie klas?
</P>
<P>
OdpowiedŸ wprost brzmi: nie. 
Jednak nie oznacza to, ¿e w ogóle nie da siê skorzystaæ z DLL-owych klas bez statycznego linkowania. Mo¿na przecie¿ wyeksportowaæ z DLL funkcjê, która stworzy nowy obiekt danej klasy i zwróci wskaŸnik na niego:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DllClass* CreateObject()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return new</SPAN> DllClass;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie, tworz¹c obiekt dynamicznie powinniœmy równie¿ zadbaæ o jego zniszczenie, wiêc tworzymy i eksportujemy drug¹ funkcjê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> DestroyObject(DllClass* ptr)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>delete</SPAN> ptr;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Nie zawsze siê nam chce pamiêtaæ o uci¹¿liwym obowi¹zku niszczenia obiektów, wiêc warto tutaj pomyœleæ o mechanizmie automatycznego zwalniania pamiêci, jak na przyk³ad bazowa klasa dla wszystkich obiektów, przechowuj¹ca statyczn¹ (tj. deklarowan¹ ze s³owem <SPAN CLASS=K>static</SPAN>) tablicê wskaŸników na tworzone dynamicznie obiekty.
</P>
<P>
Do klasy <SPAN CLASS=T>DllClass</SPAN> mo¿emy sobie równie¿ dorzuciæ metodê <SPAN CLASS=T>Test</SPAN>, aby sprawdziæ, czy wszystko dzia³a jak nale¿y. Metody <SPAN CLASS=T>Test</SPAN> nie mo¿emy oczywiœcie wyeksportowaæ, ale te¿ nie musimy, gdy¿ bêdziemy j¹ wywo³ywaæ przez wskaŸnik do naszego obiektu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> DllClass::Test()<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Wywo³ano metodê Test.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Pozostaje tylko napisaæ odpowiednie deklaracje (pamiêtaj¹c o <SPAN CLASS=K>extern</SPAN><SPAN CLASS=L> "C"</SPAN>), aby funkcje zosta³y wyeksportowane:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>extern</SPAN> <SPAN CLASS=L>"C"</SPAN><BR>
{<BR>
&nbsp;DllClass* DLLIMPORT CreateObject();<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> DLLIMPORT DestroyObject(DllClass* ptr);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Od tego momentu (o ile mamy poprawn¹ deklaracjê metody <SPAN CLASS=T>Test</SPAN>, której chyba nie muszê tutaj umieszczaæ?) mo¿na wreszcie tworzyæ w dowolnym programie, wykorzystuj¹cy dynamiczne linkowanie z nasz¹ DLL-k¹, obiekty klasy <SPAN CLASS=T>DllClass</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DllClass *D = CreateObject();<BR>
D->Test();<BR>
DestroyObject(D);<BR>
</TD></TR>
</TABLE>

<P>
Sztuczka ta jest doœæ czêsto stosowana, gdy¿ w przeciwieñstwie do innych poœrednich rozwi¹zañ ma niewiele wad. Pewn¹ niedogodnoœci¹ jest oczywiœcie koniecznoœæ tworzenia i przeci¹¿ania funkcji <SPAN CLASS=T>CreateObject</SPAN> i <SPAN CLASS=T>DestroyObject</SPAN> dla ka¿dej klasy deklarowanej w DLL. Niektórym mo¿e siê te¿ nie spodobaæ koniecznoœæ dynamicznego tworzenia obiektów i - co za tym idzie - korzystania z nich tylko przez wskaŸnik. Pamiêtajmy jednak, ¿e jest to preferowany sposób tworzenia obiektów w OOP, wiêc ta akurat wada nie powinna mieæ dla nas wiêkszego znaczenia :-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apiclass.html">&lt;&lt; Subclassing i superclassing</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>