<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 5</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05c.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs06.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Funkcje zaprzyjaŸnione
</H2>

<P>
Jak ju¿ mówiliœmy, wszystkie zmienne i funkcje umieszczone po s³owie <SPAN CLASS=K>private</SPAN> s¹ niedostêpne dla funkcji, nie bêd¹cych sk³adowymi klasy. W wiêkszoœci sytuacji jest to efekt bardzo po¿¹dany, o czym te¿ ju¿ mówiliœmy. Jednak czasami jest to bardzo niewygodne, bo okazuje siê, ¿e koniecznie potrzebujemy z takiej zewnêtrznej funkcji odwo³aæ siê do jakiejœ prywatnej sk³adowej. Mo¿na wtedy oczywiœcie przenieœæ tê sk³adow¹ do sekcji <SPAN CLASS=K>public</SPAN>, ale wtedy z kolei ktoœ niepowo³any mo¿e dobraæ siê do tej zmiennej i zrobiæ z ni¹ coœ, czego byœmy nie chcieli. Optymalnym rozwi¹zaniem jest zaprzyjaŸnienie zewnêtrznej funkcji, która ma operowaæ na "tajnych" danych klasy, z t¹ klas¹. ZaprzyjaŸnienie polega na umieszczeniu prototypu danej funkcji wewn¹trz klasy, poprzedzaj¹c j¹ s³owem <SPAN CLASS=K>friend</SPAN>. Oto przyk³ad takiego zaprzyjaŸnienia:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Klasa<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> dane[<SPAN CLASS=L>25</SPAN>];<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Reset();<BR>
&nbsp;<SPAN CLASS=K>friend void</SPAN> Ustaw(Klasa&, <SPAN CLASS=K>int</SPAN>);<BR>
}<BR>
<BR>
Klasa::Reset()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>25</SPAN>; i++)<BR>
&nbsp;&nbsp;dane[i] = <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Ustaw(Klasa& Obiekt, <SPAN CLASS=K>int</SPAN> Liczba)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>25</SPAN>; i++)<BR>
&nbsp;&nbsp;Obiekt.dane[i] = Liczba; <SPAN CLASS=C>//dostêp do "zabronionej" sk³adowej</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Odpowiednia deklaracja funkcji <SPAN CLASS=T>ustaw</SPAN> mówi klasie, ¿e funkcja ta jest oswojona i nie narobi kaszanki w prywatnych zmiennych klasy. Klasa ma wiêc ju¿ zaufanie do tej funkcji i pozwala jej na dostêp do sekcji <SPAN CLASS=K>private</SPAN>. W powy¿szym przyk³adzie warto zwróciæ uwagê na kilka rzeczy. Po pierwsze jest obojêtne, czy deklaracjê funkcji zaprzyjaŸnionej umieœcimy w sekcji <SPAN CLASS=K>private</SPAN>, czy <SPAN CLASS=K>public</SPAN>, a nawet zupe³nie poza tymi sekcjami - bêdzie i tak dzia³a³a identycznie, wa¿ne aby by³a wewn¹trz klasy. Po drugie - deklaracja funkcji <SPAN CLASS=T>ustaw</SPAN> zawiera s³owo <SPAN CLASS=K>friend</SPAN>, ale definicja - ju¿ nie. Funkcja <SPAN CLASS=K>ustaw</SPAN> jest najzwyklejsz¹ pod s³oñcem funkcj¹, tyle, ¿e klasa dostaje informacjê, ¿e jest ona zaufana, napisana przez tego samego programistê, który stworzy³ sam¹ klasê i ma pojêcie, które zmienne prywatne mo¿na sobie modyfikowaæ, a które nie.
</P>
<P>
Warto te¿ zauwa¿yæ, co mo¿e nie dla ka¿dego jest rzecz¹ oczywist¹, ¿e funkcja <SPAN CLASS=T>ustaw</SPAN>, jako nie bêd¹ca sk³adow¹ klasy, nie ma ukrytego wskaŸnika <SPAN CLASS=K>this</SPAN>. Dlatego te¿ w³aœnie przekazujemy referencjê do obiektu, do którego danych siê odwo³ujemy w tej fukcji, jako argument dla <SPAN CLASS=K>ustaw</SPAN>.
</P>

<H2>
Klasy zaprzyjaŸnione
</H2>

<P>
Doœæ czêsto zachodzi potrzeba, ¿eby jedna klasa mog³a swobodnie grzebaæ sobie w drugiej. Wtedy robimy podobnie, jak w przypadku zaprzyjaŸnionych funkcji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Przyjaciel<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//ró¿ne rzeczy ;-)</SPAN><BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Klasa<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public:<BR>
&nbsp;&nbsp;friend class</SPAN> Przyjaciel;<BR>
&nbsp;<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=C>//top secret - ale nie dla Przyjaciela :-)</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W tym przyk³adzie klasa <SPAN CLASS=T>Przyjaciel</SPAN> ma zagwarantowany dostêp do wszystkich zmiennych i funkcji w klasie <SPAN CLASS=T>Klasa</SPAN>. Wa¿ne jest to, by deklaracja klasy <SPAN CLASS=T>Przyjaciel</SPAN> znajdowa³a siê PRZED klas¹ <SPAN CLASS=T>Klasa</SPAN>.
</P>
<P>
W realu przyjaŸnie bywaj¹ doprawdy skomplikowane. Jeœli ktoœ uznaje nas za przyjaciela, to my jego automatycznie te¿. Co wiêcej, przyjaciele naszych przyjació³ s¹ równie¿ naszymi przyjació³mi. A to tylko pocz¹tek, bo gdyby by³o tak ³atwo, to na œwiecie nie by³oby wojen ;-). W œwiecie C++ sprawy maj¹ siê o wiele proœciej - i "mniej przyjaŸnie". Otó¿ <SPAN CLASS=T>Klasa</SPAN> uznaje klasê <SPAN CLASS=T>Przyjaciel</SPAN> za przyjaciela, ale ju¿ klasa <SPAN CLASS=T>Przyjaciel</SPAN> "nie lubi" klasy <SPAN CLASS=T>Klasa</SPAN>, ba! - w ogóle jej nie zna, poniewa¿ jej deklaracja wystêpuje przed deklaracj¹ klasy <SPAN CLASS=T>Klasa</SPAN>. A jak mo¿na siê przyjaŸniæ z nieznajomym?
</P>
<P>
Tymczasem taka odwzajemniona przyjaŸæ by³aby w pewnych sytuacjach bardzo korzystna. W gruncie rzeczy jedyn¹ przeszkod¹ jest w³aœnie to, ¿e jedna deklaracja klasy musi nastêpowaæ po drugiej - nie mo¿na zrobiæ dwóch deklaracji jednoczeœnie. Aby omin¹æ tê wredn¹ wadê jêzyka, jego autorzy pozwolili programistom na stosowanie takiej ma³ej sztuczki, jak¹ s¹ <SPAN CLASS=Wazne>zapowiedzi klas</SPAN>. Jest to jak gdyby deklaracja deklaracji klasy. Sk³ada siê toto wy³¹cznie ze s³owa <SPAN CLASS=K>class</SPAN>, nazwy klasy oraz oczywiœcie œrednika:
</P>

<P>
<SPAN CLASS=K>
class</SPAN><SPAN CLASS=T> Klasa;</SPAN>
</P>

<P>
Dla kompilatora taka instrukcja oznacza jedynie to, ¿e gdzieœ dalej w tym samym pliku mo¿e on odnaleŸæ pe³n¹ deklaracjê danej klasy. I to nam w zupe³noœci wystarczy, a¿eby zrobiæ wzajemn¹ przyjaŸñ dwóch klas:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Druga; <SPAN CLASS=C>//zapowiedŸ klasy Druga</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Pierwsza <SPAN CLASS=C>//deklaracja klasy Pierwsza</SPAN><BR>
{<BR>
&nbsp;<SPAN CLASS=K>friend class</SPAN> Druga; <SPAN CLASS=C>//teraz to mo¿liwe!</SPAN><BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> sekret1;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> test(Druga d)<BR>
&nbsp;{ d.sekret2 = <SPAN CLASS=L>5</SPAN>; } <SPAN CLASS=C>//proszê bardzo...</SPAN><BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Druga<SPAN CLASS=C> //deklaracja klasy Druga</SPAN><BR>
{<BR>
&nbsp;<SPAN CLASS=K>friend class</SPAN> Pierwsza;<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> sekret2;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> test(Pierwsza p) <BR>
&nbsp;{ p.sekret1 = <SPAN CLASS=L>10</SPAN>; }<SPAN CLASS=C> //¿aden problem!</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<H2>
Obiekty sta³e
</H2>

<P>
Obiekty, podobnie jak zmienne typów podstawowych, mog¹ zostaæ zadeklarowane z modyfikatorem const. Mo¿na wprawdzie pokusiæ siê o hipotezê, ¿e im bardziej skomplikowan¹ klasê zaprojektujemy, tym mniejsze bêdzie prawdopodobieñstwo, ¿e w ogóle bêdzie jakikolwiek sens istnienia sta³ego obiektu takiej klasy. My jednak zajmiemy siê na razie bardzo prost¹ klas¹, niech to bêdzie <SPAN CLASS=T>Punkt</SPAN> (ju¿ wczeœniej j¹ sobie zaprojektowaliœmy, teraz bierzemy jej uproszczon¹ wersjê):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Punkt<BR>
{<BR><SPAN CLASS=K>
private:<BR>
&nbsp;int</SPAN> x,y;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Punkt();<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Ustaw(<SPAN CLASS=K>int</SPAN> nx, <SPAN CLASS=K>int</SPAN> ny);<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Pisz();<BR>
};<BR>
<BR>
Punkt::Punkt()<BR>
{<BR>
&nbsp;x = <SPAN CLASS=L>0</SPAN>; y = <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Punkt::Ustaw(<SPAN CLASS=K>int</SPAN> nx, <SPAN CLASS=K>int</SPAN> ny)<BR>
{<BR>
&nbsp;x = nx; y = ny;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Punkt::Pisz()<BR>
{<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>'('</SPAN> &lt;&lt; x &lt;&lt; <SPAN CLASS=L>','</SPAN> &lt;&lt; y &lt;&lt; <SPAN CLASS=L>')'</SPAN> &lt;&lt; endl;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Napiszmy teraz krótki programik, który udowodni, ¿e trochê siê machnêliœmy pisz¹c tê banaln¹, zdawa³oby siê, klasê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>const</SPAN> Punkt P;<BR>
&nbsp;P.Ustaw(<SPAN CLASS=L>6,6</SPAN>);<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Co siê stanie? Oczywiœcie kompilator nie zgodzi siê na takie coœ; oœwiadczy kategorycznie, ¿e on tego kompilowa³ nie bêdzie, poniewa¿ wywo³anie metody <SPAN CLASS=T>Ustaw</SPAN> jest niedozwolone dla obiektu sta³ego. Co w tym z³ego? Otó¿ nic, bo tak w³aœnie powinno byæ. Metoda <SPAN CLASS=T>Ustaw</SPAN> zmienia stan obiektu, modyfikuje bowiem jego zmienne sk³adowe. Ale...
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>const</SPAN> Punkt P;<BR>
&nbsp;P.Pisz();<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
No w³aœnie. Tu ju¿ nie jest takie oczywiste, co schrzaniliœmy (metoda<SPAN CLASS=T> Pisz</SPAN> nie zmienia stanu obiektu, tylko go odczytuje), a mimo to kompilator nadal krzyczy. Okazuje siê, ¿e g³upek nie odró¿nia, czy dana funkcja rzeczywiœcie modyfikuje obiekt, czy te¿ nie. Idzie po najmniejszej linii oporu, uznaj¹c, ¿e dla obiektu, który jest <SPAN CLASS=T>const</SPAN>, nie mo¿na wywo³aæ w ogóle ¿adnej metody!
</P>
<P>
Ma siê rozumieæ, ¿e nie chcemy, aby dodanie jednego ma³ego <SPAN CLASS=K>const</SPAN> do deklaracji obiektu ca³kowicie likwidowa³o nam ca³¹ jego funkcjonalnoœæ. Przecie¿ wypisanie stanu obiektu powinno byæ mo¿liwe tak¿e wówczas, gdy jest on sta³y (co prawda wtedy nasz punkt bêdzie mia³ tylko jedn¹ mo¿liw¹ kombinacjê wspó³rzêdnych - <SPAN CLASS=L>0,0</SPAN> - ustawion¹ przez domyœlny konstruktor). Rozwi¹zaniem jest podowiedzenie kompilatorowi, które z metod mo¿na wywo³ywaæ równie¿ dla sta³ych obiektów. Robimy to, umieszczaj¹c s³owo <SPAN CLASS=K>const</SPAN> po nag³ówku metody.
</P>

<P class=UWAGA>
Dotyczy to zarówno deklaracji metody, jak i jej definicji. Dodanie <SPAN CLASS=K>const</SPAN> tylko w deklaracji (albo tylko w definicji) zostanie potraktowane przez kompilator jako niezgodnoœæ nag³ówków.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Punkt<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> x,y;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Punkt();<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Ustaw(<SPAN CLASS=K>int</SPAN> nx, <SPAN CLASS=K>int</SPAN> ny);<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Pisz() <SPAN CLASS=K>const</SPAN>; <SPAN CLASS=C>// *</SPAN><BR>
};<BR>
<BR>
<SPAN CLASS=C>//definicje konstuktora i Ustaw pomijamy...</SPAN><BR>
<BR>
<SPAN CLASS=K>void</SPAN> Punkt::Pisz()<SPAN CLASS=K> const</SPAN><SPAN CLASS=C> // *</SPAN><BR>
{<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>'('</SPAN> &lt;&lt; x &lt;&lt; <SPAN CLASS=L>','</SPAN> &lt;&lt; y &lt;&lt; <SPAN CLASS=L>')'</SPAN> &lt;&lt; endl;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy wypróbowaæ przyk³ady deklaracji sta³ego obiektu klasy <SPAN CLASS=T>Punkt</SPAN> ponownie. Zauwa¿ymy, ¿e tym razem da siê ju¿ skompilowaæ program, wywo³uj¹cy metodê <SPAN CLASS=T>Pisz</SPAN> dla sta³ego obiektu. Metody <SPAN CLASS=T>Ustaw</SPAN> oczywiœcie nadal nie bêdzie siê da³o wywo³aæ, poniewa¿ jej nie oznaczyliœmy s³owem <SPAN CLASS=K>const</SPAN>.
</P>
<P>
Ktoœ wœcibski móg³by jeszcze zapytaæ, co sta³oby siê w przypadku dodania <SPAN CLASS=K>const</SPAN> równie¿ i do metody <SPAN CLASS=T>Ustaw</SPAN>. Jest to jak najbardziej mo¿liwe, z tym ¿e w tak prostym akurat przypadku jak ten, kompilator sam prawdopodobnie zorientuje siê, ¿e chcemy go wyprowadziæ w pole. Jednak istniej¹ przypadki, gdy kompilator g³adko prze³knie próbê zmodyfikowania obiektu przez funkcjê, która  "oficjalnie" jest <SPAN CLASS=K>const</SPAN>. I w³aœnie ze wzglêdu na te przypadki istnieje koniecznoœæ dodawania <SPAN CLASS=K>const</SPAN> do niektórych metod klasy.
</P>
<P>
Przyk³adem zrobienia kompilatora w konia mo¿e byæ modyfikacja sk³adowych sta³ego obiektu klasy <SPAN CLASS=K>Punkt</SPAN> przy pomocy po³¹czonych si³ funkcji <SPAN CLASS=T>MoveMemory</SPAN> (WinAPI; mniej wiêcej odpowiednik <SPAN CLASS=T>memmov</SPAN> z biblioteki standardowej) oraz operatora <SPAN CLASS=K>const_cast</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>void</SPAN> Punkt::Ustaw(<SPAN CLASS=K>int</SPAN> nx, <SPAN CLASS=K>int</SPAN> ny) <SPAN CLASS=K>const</SPAN><BR>
{ <SPAN CLASS=C>//ta metoda to samo z³o!!! ;-)</SPAN><BR>
&nbsp;MoveMemory(<SPAN CLASS=K>const_cast</SPAN>&lt;<SPAN CLASS=K>int</SPAN>*&gt;(&x), &nx, <SPAN CLASS=K>sizeof</SPAN>(<SPAN CLASS=K>int</SPAN>));<BR>
&nbsp;MoveMemory(<SPAN CLASS=K>const_cast</SPAN>&lt;<SPAN CLASS=K>int</SPAN>*&gt;(&y), &ny, <SPAN CLASS=K>sizeof</SPAN>(<SPAN CLASS=K>int</SPAN>));<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Z t¹ wersj¹ metody <SPAN CLASS=T>Ustaw</SPAN> mo¿emy sobie spokojnie ustawiaæ wspó³rzêdne sta³ego obiektu klasy <SPAN CLASS=T>Punkt</SPAN> - kompilator nic nie zauwa¿y, a przy odrobinie szczêœcia mo¿e nawet program siê nie wykrzaczy ;-). Tak wiêc nie zawsze k³amstwo ma krótkie nogi. Niemniej jednak warto zapamiêtaæ: dzieci, nie róbcie tego w domu ;-).

</P>


<H2>
Statyczne elementy klas
</H2>

<P>
O zmiennych statycznych rozmawialiœmy ju¿ przy okazji omawiania funkcji. Tak wiêc ju¿ wiemy, ¿e zmienne takie ¿yj¹ tak d³ugo, jak ca³y program, nawet jeœli s¹ lokalne. Niemniej ich zasiêg ogranicza siê tylko do miejsca, gdzie zosta³y zadeklarowane, np. zmienna statyczna ma zasiêg funkcji, jeœli zadeklarujemy j¹ wewn¹trz cia³a tej funkcji lub zasiêg pêtli, jeœli jest zadeklarowana wewn¹trz pêtli.
</P>
<P>
Ze statycznymi zmiennymi sk³adowymi klas jest dosyæ podobnie, przynajmniej jeœli chodzi o czas ¿ycia. Jednak nie to jest ich g³ówn¹ cech¹, o czym zaraz siê przekonamy. Najpierw stwórzmy sobie tak¹ zmienn¹, ¿eby by³o na czym eksperymentowaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Przyklad<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;static int</SPAN> i; <SPAN CLASS=C>//deklaracja statycznej sk³adowej</SPAN><BR>
&nbsp;Przyklad() { cout &lt;&lt; <SPAN CLASS=L>"i = "</SPAN> &lt;&lt; i; }<BR>
};<BR>
<BR>
<SPAN CLASS=C>//definicja (!) statycznej sk³adowej</SPAN><BR>
<SPAN CLASS=K>int</SPAN> Przyklad::i = <SPAN CLASS=L>0</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Pierwsze spostrze¿enie mo¿e siê wydaæ nieco dziwne - statyczna sk³adowa wymaga definicji na zewn¹trz klasy! Co to w ogóle za pomys³ ¿eby definiowaæ ZMIENN¥? Za moment wszystko siê wyjaœni. Otó¿ spróbujmy teraz zadeklarowaæ jakiœ obiekt klasy <SPAN CLASS=T>Przyklad</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Przyklad test;<BR>
</TD></TR>
</TABLE>

<P>
Taka deklaracja wywo³a nam konstruktor naszej klasy, wiêc na ekranie powinna siê wypisaæ wartoœæ statycznej zmiennej <SPAN CLASS=T>i</SPAN>. No i faktycznie, wypisuje siê. Ile ona wynosi? Oczywiœcie <SPAN CLASS=L>0</SPAN>, bowiem tak¹ w³aœnie wartoœci¹ inicjalizowana jest ta zmienna w swojej definicji. Zauwa¿ - jest inicjalizowana ZANIM zostanie wywo³any konstruktor! St¹d mo¿na wysnuæ wniosek (dla bardziej zaawansowanych programistów oczywisty), ¿e statyczne sk³adowe nie nale¿¹ do ¿adnego obiektu swojej klasy, albowiem nie mo¿emy przecie¿ zainicjalizowaæ zmiennej sk³adowej obiektu, który jest dopiero w trakcie "budowy".
</P>

<P class=UWAGA>Statyczne zmienne sk³adowe klasy skojarzone s¹ z sam¹ klas¹, a nie z jej konkretnym obiektem. Innymi s³owy, wszystkie obiekty danej klasy "wspó³dziel¹" jeden "egzemplarz" takiej zmiennej.
</P>

<P>
Dalsze wnioski? Po pierwsze, jeœli mo¿na zainicjalizowaæ tak¹ sk³adow¹ nawet wówczas, gdy ¿aden obiekt danej klasy jeszcze nie istnieje, to mo¿na równie¿ wtedy dowolnie modyfikowaæ wartoœæ takiej zmiennej b¹dŸ odczytywaæ j¹ z dowolnego miejsca w programie - oczywiœcie o ile ta zmienna jest publiczna, bowiem statyczne sk³adowe podlegaj¹ pod tym wzglêdem takim samym regu³om, co zwyk³e sk³adowe (i to by by³ drugi wniosek). Trzecie spostrze¿enie - jeœli statyczne zmienne sk³adowe nie s¹ skojarzone z konkretnymi obiektami, to chc¹c uzyskaæ dostêp do nich z zewn¹trz klasy, musimy jawnie okreœliæ ich "miejsce pochodzenia", czyli nazwê klasy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Przyklad test;<BR>
Przyklad::i = <SPAN CLASS=L>666</SPAN>;<BR>
Przyklad test2;<BR>
</TD></TR>
</TABLE>

<P>
Powy¿szy przyk³adzik przy okazji demonstruje nam, ¿e statyczne sk³adowe nie zale¿¹ od konkretnych obiektów. Oto bowiem pierwsza deklaracja wypisze nam stan sk³adowej <SPAN CLASS=T>i</SPAN> tu¿ po jej inicjalizacji (czyli wartoœæ bêdzie równa <SPAN CLASS=L>0</SPAN>), zaœ druga - po "zwyk³ym" przypisaniu z zewn¹trz klasy (wartoœæ równa <SPAN CLASS=L>666</SPAN>).
</P>
<P>
Oprócz zmiennych sk³adowych, w klasach statyczne mog¹ byæ równie¿ funkcje sk³adowe. Oczywiœcie funkcje takie nie maj¹ przez ca³y czas tej samej wartoœci - sens ich deklarowania polega na tej drugiej, wa¿niejszej cesze - mo¿na je wywo³aæ niezale¿nie od istnienia jakichkolwiek obiektów danej klasy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Przyklad<BR>
{<BR>
<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;<SPAN CLASS=K>static int</SPAN> i;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;static void</SPAN> fun(<SPAN CLASS=K>int</SPAN> a);<BR>
&nbsp;<SPAN CLASS=K>static int</SPAN> test();<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> Przyklad::i = <SPAN CLASS=L>0</SPAN>;<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Przyklad::fun(<SPAN CLASS=K>int</SPAN> a)<BR>
{<BR>
&nbsp;i = a;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> Przyklad::test()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> i;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Przyklad::fun(<SPAN CLASS=L>21012</SPAN>);<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"i = "</SPAN> &lt;&lt; Przyklad::test() &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mamy tu dwie statyczne funkcje. Jak widaæ, ich deklaracja jest doœæ intuicyjna - podobnie jak ze zmiennymi, deklaracjê statycznej funkcji wystarczy poprzedziæ s³owem <SPAN CLASS=K>static</SPAN>. Z kolei definicja wygl¹da tak samo jak definicja niestatycznej funkcji (bez s³owa <SPAN CLASS=K>static</SPAN>) - tutaj te¿ mamy wiêc analogiê do statycznych zmiennych.
</P>
<P>
Twór, który nam powsta³, jest doœæ specyficzny. Jest to bowiem klasa pozbawiona jakichkolwiek elementów oprócz statycznych. Co ciekawe, zadeklarowanie obiektu takiej klasy jest mo¿liwe, choæ z obiektem takim oczywiœcie nie bêdzie mo¿na zbyt wiele zrobiæ ;-). Druga ciekawostka: operator <SPAN CLASS=K>sizeof</SPAN> dla takiej klasy zwróci <SPAN CLASS=L>1</SPAN>.
</P>
<P>
W funkcji <SPAN CLASS=T>main</SPAN> powy¿ej wykonujemy najpierw wywo³anie statycznej funkcji <SPAN CLASS=T>fun</SPAN>, która ustawia statyczn¹ zmienn¹ i na pewn¹ wartoœæ, a nastêpnie wartoœæ tê odczytujemy przy pomocy kolejnej statycznej funkcji <SPAN CLASS=T>test</SPAN> i wypisujemy na ekranie. Wszystkie te operacje odbywaj¹ siê przy udziale samej klasy, bez jakichkolwiek obiektów typu <SPAN CLASS=T>Przyklad</SPAN>.
</P>
<P>
Warto jeszcze wspomnieæ o kwestii, któr¹ ju¿ poruszy³em wczeœniej - statyczne funkcje sk³adowe NIE maj¹ wskaŸnika <SPAN CLASS=K>this</SPAN>. Jest to chyba oczywiste - na co by on wskazywa³, skoro funkcje takie nie s¹ skojarzone z ¿adnym obiektem klasy? Tak wiêc mo¿na ogólnie powiedzieæ, ¿e statyczne funkcje sk³adowe s¹ praktycznie normalnymi funkcjami o zasiêgu pliku, z t¹ ró¿nic¹, ¿e przy ich wywo³ywaniu musimy podawaæ nazwê klasy, ale za to mamy dostêp do wszystkich (publicznych i prywatnych) statycznych sk³adowych tej klasy (do niestatycznych te¿ mo¿emy mieæ, ale tylko poœrednio - przez odwo³anie do konkretnego obiektu).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05c.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs06.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</BODY>
</HTML>