<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - W³asne kontrolki, cz.1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitray.html">&lt;&lt; Tray</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apicc2.html">W³asne kontrolki, cz. 2 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>W³asne kontrolki</H2>

<P>
Kontrolki standardowe wraz z <SPAN CLASS=Inglisz>Common Controls</SPAN> to mo¿e niezbyt pokaŸny zbiorek, ale w zupe³noœci wystarczaj¹ do stworzenia wielu aplikacji. Jednak czêsto zdarza siê, ¿e chcielibyœmy w naszym programie czegoœ jeszcze - skoro inne programy to maj¹, to my te¿ mo¿emy ;-). Jednym ze sposobów rozszerzenia mo¿liwoœci naszych interfejsów graficznych (mo¿e nie najprostszym, ale za to daj¹cym najwiêcej satysfakcji) jest tworzenie w³asnych kontrolek. WinAPI daje tu kilka mo¿liwoœci:
</P>

<UL>
<LI>sub- i superclassing 
<LI>kontrolki rysowane przez rodzica (<SPAN CLASS=Inglisz>owner-drawn controls</SPAN>)
<LI>³¹czenie standardowych kontrolek
<LI>tworzenie w³asnych kontrolek od podstaw
</UL>

<P>
Pierwsz¹ technikê ju¿ omówiliœmy we wczeœniejszych odcinkach tego kursu. Pozosta³ymi zajmiemy siê tutaj.
</P>

<H2>
£¹czenie istniej¹cych kontrolek
</H2>

<P>
¯eby nie zaczynaæ z pustymi rêkami, warto czasem zastanowiæ siê, co w³aœciwie chcemy osi¹gn¹æ i co ju¿ zrobiono za nas. Jeœli na przyk³ad chcemy mieæ kontrolkê, która wygl¹da i dzia³a jak zwyk³y przycisk, ale obok niego wyœwietlana jest dodatkowo liczba "wciœniêæ", to najwygodniej bêdzie wykorzystaæ w tym celu po³¹czone si³y kontrolek <SPAN CLASS=L>BUTTON</SPAN> i <SPAN CLASS=L>STATIC</SPAN>.
</P>
<P>
Naszym celem jest stworzenie nowej kontrolki, czyli nowej klasy okien. Tak wiêc powinniœmy skorzystaæ z superclassingu. Klas¹ bazow¹ mo¿e byæ dowolna z predefiniowanych klas kontrolek, na przyk³ad <SPAN CLASS=L>STATIC</SPAN> (która zreszt¹ chyba najlepiej siê nadaje do tego celu). Pobieramy informacje o tej klasie i zmieniamy co trzeba:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WNDCLASS wc;<BR>
GetClassInfo(hThisInstance, <SPAN CLASS=L>"STATIC"</SPAN>, &wc);<BR>
<BR>
wc.lpszMenuName = NULL;<BR>
wc.lpszClassName = <SPAN CLASS=L>"Nasza kontrolka"</SPAN>;<BR>
wc.hInstance = hThisInstance;<BR>
g_OldControlProc = wc.lpfnWndProc;<BR>
wc.lpfnWndProc = ControlProc;<BR>
</TD></TR>
</TABLE>

<P>
Ustaliliœmy miêdzy innymi nazwê naszej nowej klasy (<SPAN CLASS=L>"Nasza kontrolka"</SPAN>) oraz wskaŸnik na now¹ procedurê okna. Ten ostatni jest oczywiœcie sednem ca³ej operacji tworzenia nowej kontrolki. WskaŸnik na star¹ procedurê zachowujemy w globalnej zmiennej <SPAN CLASS=T>g_OldControlProc</SPAN>. Pora na napisanie nowej procedury, czyli <SPAN CLASS=T>ControlProc</SPAN>. Co powinna ona robiæ? Przede wszystkim - wywo³ywaæ star¹ procedurê okna, tê z klasy <SPAN CLASS=L>STATIC</SPAN>. Szczegó³y omówiliœmy ju¿ przy superclassingu, wiêc ju¿ wiesz, o co chodzi.
</P>
<P>
Drug¹ wa¿n¹ rzecz¹, któr¹ bêdzie robiæ procedura <SPAN CLASS=T>ControlProc</SPAN>, jest stworzenie przycisku i etykietki (<SPAN CLASS=L>STATIC</SPAN>), na której bêdzie wyœwietlana liczba klikniêæ. Musz¹ one oczywiœcie byæ oknami potomnymi dla naszej nowej kontrolki i dlatego w³aœnie bêd¹ tworzone wewn¹trz jej procedury okna. Bêdziemy potrzebowaæ jakichœ identyfikatorów dla przycisku i dla etykietki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define IDC_BUTTON 1000<BR>
#define IDC_LABEL  1001<BR></SPAN>
</TD></TR>
</TABLE>

<P>
Pora napisaæ procedurê <SPAN CLASS=T>ControlProc</SPAN>. Tworzenie wspomnianych dwóch kontrolek potomnych umieszczamy w obs³udze komunikatu <SPAN CLASS=T>WM_CREATE</SPAN> - ¿eby zosta³y stworzone tu¿ po przyjœciu na œwiat swego okna-rodzica.
</P>
<P>
Warto wspomnieæ, ¿e nie bêdziemy siê musieli martwiæ o zniszczenie tych dwóch okien, które tworzymy w <SPAN CLASS=T>WM_CREATE</SPAN>. System zrobi to za nas, poniewa¿ bêd¹ to okna potomne. A oto i procedura, o której tyle mówimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK ControlProc(HWND hwnd, UINT mesg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(mesg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_CREATE:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;CreateWindowEx(<SPAN CLASS=L>0, "BUTTON", "Wciœnij mnie"</SPAN>, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>0, 0, 100, 30</SPAN>, hwnd, (HMENU)IDC_BUTTON, GetModuleHandle(NULL), NULL);<BR>
&nbsp;&nbsp;&nbsp;CreateWindowEx(<SPAN CLASS=L>0, "STATIC", "0",</SPAN> WS_CHILD|WS_VISIBLE|SS_CENTER, <SPAN CLASS=L>100, 0, 50, 30</SPAN>, hwnd, (HMENU)IDC_LABEL, GetModuleHandle(NULL), NULL);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> CallWindowProc(g_OldControlProc, hwnd, mesg, wParam, lParam);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Trudno mo¿e uwierzyæ, ale nasza kontrolka jest ju¿ gotowa. Wystarczy teraz tylko wywo³anie <SPAN CLASS=T>CreateWindowEx</SPAN> z nazw¹ klasy, któr¹ przed chwil¹ zarejestrowaliœmy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hControl = CreateWindowEx(<SPAN CLASS=L>0, "Nasza kontrolka"</SPAN>, NULL, WS_CHILD|WS_VISIBLE,<SPAN CLASS=L> 5, 5, 150, 30</SPAN>, hwnd, NULL, hThisInstance, NULL);<BR>
</TD></TR>
</TABLE>

<h2>
Dodatkowa funkcjonalnoœæ
</h2>

<P>
Ma³o siê napracowaliœmy, ale i ma³o w sumie osi¹gnêliœmy, poniewa¿ nasza kontrolka jeszcze nie dzia³a dok³adnie tak, jak sobie za³o¿yliœmy (a mianowicie nie liczy klikniêæ). I tu mamy nieco wiêkszy problem. ¯eby coœ liczyæ, musimy mieæ zmienn¹. Gdzie j¹ wpakowaæ? Moglibyœmy oczywiœcie,  zadeklarowaæ j¹ jako zmienn¹ globaln¹. Pamiêtajmy jednak, ¿e potencjalny u¿ytkownik mo¿e stworzyæ (a ¿e wredny jest, to i pewnie kiedyœ stworzy) kilka instancji naszej kontrolki, a przecie¿ ka¿da powinna sobie liczyæ klikniêcia osobno... Wygl¹da wiêc na to, ¿e jeœli chcemy przechowywaæ liczbê klikniêæ "na zewn¹trz" kontrolki, to musimy mieæ do tego celu dynamiczn¹ tablicê.
</P>
<P>
Mo¿emy te¿ przechowywaæ te dane "wewn¹trz". Bêdzie to o wiele bardziej eleganckie rozwi¹zanie, bo "prywatne" dane kontrolki powinny byæ oddzielone od reszty programu. Nie przypadkiem u¿y³em s³owa "prywatne" - gdyby WinAPI by³o obiektowe, to now¹ kontrolkê tworzylibyœmy jako klasê w sensie C++, a licznik klikniêæ umieœcilibyœmy w sekcji <SPAN CLASS=K>private</SPAN> tej klasy. Jednak marzenia na bok - WinAPI obiektowe nie jest i musimy siê mêczyæ w inny sposób :-) (chocia¿ oczywiœcie nikt ci nie zabroni opakowania tego, o czym tu mówimy, w klasy C++).
</P>
<P>
Zapewne od pierwszego odcinka kursu WinAPI zastanawiasz siê, po co te <SPAN CLASS=Inglisz>extra bytes</SPAN>, o które ci¹gle potykamy siê przy rejestracji klasy okna. Otó¿ jest to miejsce, w którym mo¿emy przechowywaæ dowolne dane. Coœ jakby stworzonego specjalnie dla naszego licznika klikniêæ :-). Najpierw musimy powiedzieæ systemowi, ile tych dodatkowych bajtów chcemy. Nasze ¿¹dania nie mog¹ byæ zbyt wygórowane, bo system mamy wyj¹tkowo sk¹py; sam po¿era ³apczywie RAM w ka¿dej dostêpnej iloœci, ale jedno okno mo¿e mieæ najwy¿ej <SPAN CLASS=L>40</SPAN> bajtów na w³asne potrzeby, w dodatku nie mo¿emy u¿yæ z tego ostatnich <SPAN CLASS=L>4</SPAN> bajtów, bo tak sobie ¿yczy Microsoft. Oczywiœcie jeœli nasza kontrolka wymaga wiêcej dodatkowej pamiêci, to mo¿emy j¹ sobie zaalokowaæ sami, a do owych <SPAN CLASS=L>40</SPAN> bajtów pamiêci okna wrzuciæ sam wskaŸnik. Do naszego zadania z liczeniem klikniêæ jednak <SPAN CLASS=L>40</SPAN> bajtów to bêdzie a¿ nadto ;-). Doœæ gadania - dopisujemy do rejestracji naszej klasy now¹ linijkê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
wc.cbWndExtra = <SPAN CLASS=K>sizeof</SPAN>(DWORD) + <SPAN CLASS=L>4</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Dziêki temu ka¿de okno naszej klasy bêdzie mia³o do dyspozycji tyle bajtów, ile wynosi rozmiar typu <SPAN CLASS=T>DWORD</SPAN> (czyli <SPAN CLASS=L>4</SPAN> bajty).
</P>

<P class=UWAGA>
Oprócz dodatkowej pamiêci dla poszczególnych okien klasy mo¿emy te¿ zarezerwowaæ dodatkowe bajty wspólne dla wszystkich okien tej klasy; w tym celu ustawiamy pole <SPAN CLASS=T>cbClsExtra</SPAN>.
</P>
<P>
Mamy ju¿ pamiêæ zarezerwowan¹, ale jak siê tam dostaæ? Proste - dziêki funkcji <SPAN CLASS=T>SetWindowLong</SPAN>. Dotychczas u¿ywaliœmy jej do zmiany ró¿nych parametrów okna, podaj¹c uchwyt tego okna, nazwê parametru, który chcemy zmieniæ (np. <SPAN CLASS=T>GWL_STYLE</SPAN>) oraz now¹ wartoœæ tego parametru. Tym razem zamiast nazwy parametru podajemy offset. Zamierzamy przechowywaæ <SPAN CLASS=L>4</SPAN> bajty licznika klikniêæ na samym pocz¹tku obszaru dodatkowej pamiêci okna, wiêc nasz offset wynosi <SPAN CLASS=L>0</SPAN>. Do dzie³a wiêc - najpierw zadbajmy o to, by podczas tworzenia naszej kontrolki licznik by³ zerowany:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//to oczywiœcie powinno siê znaleŸæ w ControlProc :-)</SPAN><BR>
<SPAN CLASS=K>case</SPAN> WM_CREATE:<BR>
{<BR>
&nbsp;CreateWindowEx(<SPAN CLASS=L>0, "BUTTON", "Wciœnij mnie"</SPAN>, WS_CHILD|WS_VISIBLE,<SPAN CLASS=L> 0, 0, 100, 30</SPAN>, hwnd, (HMENU)IDC_BUTTON, GetModuleHandle(NULL), NULL);<BR>
&nbsp;CreateWindowEx(<SPAN CLASS=L>0, "STATIC", "0"</SPAN>, WS_CHILD|WS_VISIBLE|SS_CENTER, <SPAN CLASS=L>100, 0, 50, 30</SPAN>, hwnd, (HMENU)IDC_LABEL, GetModuleHandle(NULL), NULL);<BR>
&nbsp;SetWindowLong(hwnd, <SPAN CLASS=L>0, 0</SPAN>); <SPAN CLASS=C>//inicjalizacja licznika klikniêæ</SPAN><BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Nastêpnie sprawimy, ¿e nasz licznik nareszcie zacznie dzia³aæ. Musimy w tym celu obs³u¿yæ komunikat <SPAN CLASS=T>WM_COMMAND</SPAN> (w procedurze <SPAN CLASS=T>ControlProc</SPAN>) oraz sprawdziæ, jakie wieœci niesie nam jego parametr <SPAN CLASS=T>wParam</SPAN>. Przypominam, ¿e <SPAN CLASS=T>HIWORD(wParam)</SPAN> zawiera kod powiadomienia (dla klikniêcia przycisku jest on równy <SPAN CLASS=T>BN_CLICKED</SPAN>), natomiast <SPAN CLASS=T>LOWORD(wParam)</SPAN> zawiera identyfikator kontrolki, któr¹ klikniêto (u nas powinien on byæ równy <SPAN CLASS=T>IDC_BUTTON</SPAN>). ¯eby zwiêkszyæ licznik o <SPAN CLASS=L>1</SPAN>, musimy najpierw pobraæ "star¹" jego wartoœæ poprzez <SPAN CLASS=T>GetWindowLong</span>, zwiêkszyæ j¹, a na koniec uaktualniæ wartoœæ przez <SPAN CLASS=T>SetWindowLong</SPAN> i wyœwietliæ. Piszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(LOWORD(wParam)==IDC_BUTTON && HIWORD(wParam)==BN_CLICKED)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;DWORD dwCounter = GetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;&nbsp;++dwCounter;<BR>
&nbsp;&nbsp;SetWindowLong(hwnd, <SPAN CLASS=L>0</SPAN>, (LONG)dwCounter);<BR>
&nbsp;&nbsp;SetDlgItemInt(hwnd, IDC_LABEL, (UINT)dwCounter, FALSE);<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;
</TD></TR>
</TABLE>

<P>
Gotowe. Licznik dzia³a. Mo¿emy teraz stworzyæ kilka naszych kontrolek jednoczeœnie i sprawdziæ, czy nasze wysi³ki siê op³aci³y:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND<BR>
hControl1 = CreateWindowEx(<SPAN CLASS=L>0, "Nasza kontrolka"</SPAN>, NULL, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>5, 5, 150, 30</SPAN>, hwnd, NULL, hThisInstance, NULL),<BR>
hControl2 = CreateWindowEx(<SPAN CLASS=L>0, "Nasza kontrolka"</SPAN>, NULL, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>5, 40, 150, 30</SPAN>, hwnd, NULL, hThisInstance, NULL),<BR>
hControl3 = CreateWindowEx(<SPAN CLASS=L>0, "Nasza kontrolka"</SPAN>, NULL, WS_CHILD|WS_VISIBLE, <SPAN CLASS=L>5, 75, 150, 30</SPAN>, hwnd, NULL, hThisInstance, NULL),<BR>
</TD></TR>
</TABLE>

<P>
Efekt powinien byæ (po paru klikniêciach na przyciski, rzecz jasna) nastêpuj¹cy:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/ctrl.gif" ALT="Nasze dzie³o, sztuk 3">
</P>

<P>
Aha - ktoœ móg³by siê czepiæ, ¿e nie sprawdzamy, czy u¿ytkownik nie przekrêci przypadkiem licznika, klikaj¹c zbyt wiele razy. Otó¿ szanse s¹ doprawdy znikome :-). Zak³adaj¹c, ¿e w ci¹gu <SPAN CLASS=L>1</SPAN> sekundy klikniemy <SPAN CLASS=L>4</SPAN> razy, czyni¹c to przez ca³¹ dobê (<SPAN CLASS=L>86400</SPAN> sekund) uzyskamy zaledwie <SPAN CLASS=L>345&nbsp;600</SPAN> klikniêæ (a nie s¹dzê, by siê komuœ chcia³o ;-)). ¯eby przepe³niæ zmienn¹ typu <SPAN CLASS=T>DWORD</SPAN>, musielibyœmy tak klikaæ przez oko³o <SPAN CLASS=L>12427</SPAN> dni (<SPAN CLASS=L>34</SPAN> lata) bez przerwy. Ale przecie¿ nie ma to jak poœwiêciæ pó³ ¿ycia s³usznej sprawie, prawda? ;-)
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitray.html">&lt;&lt; Tray</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apicc2.html">W³asne kontrolki, cz. 2 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

