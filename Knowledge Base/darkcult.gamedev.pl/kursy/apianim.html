<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Animacja</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apibmp.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidlg.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Animacja w WinAPI
</H1>

<P>
Czas tchn¹æ trochê ¿ycia w szary œwiat Okien. Na pocz¹tek zrobimy sobie kulkê, która lata po ca³ym oknie. Bêdziemy potrzebowaæ kilku zmiennych, w których zapamiêtamy: aktualn¹ pozycjê kulki (<SPAN CLASS=T>KulkaX</SPAN>, <SPAN CLASS=T>KulkaY</SPAN>) oraz prêdkoœæ kulki, czyli liczbê pikseli, o jak¹ siê ona przesuwa w ka¿dej klatce. Prêdkoœæ rozdzielimy sobie na prêdkoœæ w poziomie i prêdkoœæ w pionie, zaraz siê oka¿e po co. 
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WORD KulkaX=<SPAN CLASS=L>100</SPAN>, KulkaY=<SPAN CLASS=L>100</SPAN>;<BR>
SHORT SpeedX=<SPAN CLASS=L>2</SPAN>, SpeedY=<SPAN CLASS=L>2</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Potrzebujemy jeszcze globalnego uchwytu do g³ównego okna, coby da³o siê z niego skorzystaæ w funkcji rysuj¹cej kulkê. Przyda siê te¿ struktura typu <SPAN CLASS=T>RECT</SPAN>, do której pobierzemy wymiary naszego okna, korzystaj¹c z funkcji <SPAN CLASS=T>GetClientRect</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//w zasiêgu globalnym</SPAN><BR>
HWND g_hwnd;<BR>
<BR>
<SPAN CLASS=C>//w funkcji WinMain</SPAN><BR>
g_hwnd = hwnd;<BR>
<BR>
<SPAN CLASS=C>//gdziekolwiek</SPAN><BR>
RECT rcOkno;<BR>
GetClientRect(g_hwnd, &rcOkno);<BR>
</TD></TR>
</TABLE>

<P>
Nastêpnie robimy nowy uchwyt do bitmapy i wczytujemy bitmapê z nasz¹ kulk¹ z dysku, po czym pobieramy jej wymiary funkcj¹ <SPAN CLASS=T>GetObject</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmKulka;<BR>
hbmKulka = (HBITMAP)LoadImage(NULL, <SPAN CLASS=L>"kulka.bmp"</SPAN>, IMAGE_BITMAP, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, LR_LOADFROMFILE);<BR>
<BR>
BITMAP bmKulka;<BR>
GetObject(hbmKulka, sizeof(bmKulka), &bmKulka);<BR>
</TD></TR>
</TABLE>

<P>
¯eby zrobiæ u¿ytek z bitmapy, musimy j¹ przypisaæ do jakiegoœ kompatybilnego<SPAN CLASS=T> HDC</SPAN>. Tworzymy je funkcj¹ <SPAN CLASS=T>CreateCompatibleDC</SPAN>, jako parametr podaj¹c <SPAN CLASS=T>HDC</SPAN> naszego okna. Tworzymy te¿ uchwyt do domyœlnej bitmapy nowoutworzonego kontekstu, ¿eby nam siê ¿adne zasoby systemowe nie wymknê³y spod kontroli:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdc = GetDC(g_hwnd);<BR>
HDC hdcMem = CreateCompatibleDC(hdc);<BR>
HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmKulka);<BR>
ReleaseDC(g_hwnd, hdc);<BR>
</TD></TR>
</TABLE>

<P>
Wszystkie powy¿sze deklaracje zmiennych (mo¿e oprócz <SPAN CLASS=T>hdc</SPAN>, która w tym akurat miejscu pe³ni tylko rolê pomocnicz¹) umieszczamy w globalnym zasiêgu, poniewa¿ musimy mieæ do nich dostêp z funkcji rysuj¹cej kulkê, któr¹ zaraz sobie utworzymy.
</P>
<P>
Narysowaæ kulkê to ¿adna sztuka, ale ¿eby raczy³a ona ruszyæ zadek z miejsca, musimy mieæ jakieœ urz¹dzenie odmierzaj¹ce czas. W programistycznym ¿argonie nazywa siê takie urz¹dzenie <SPAN CLASS=Wazne>timerem</SPAN>. WinAPI posiada szereg rozwi¹zañ dla timerów, jedno gorsze od drugiego ;-). I na razie zajmiemy siê w³aœnie tym najgorszym, ale za to bardzo prostym, do naszych celów w zupe³noœci wystarczaj¹cym.
</P>
<P>
Ka¿dy timer (bo mo¿emy ich mieæ w programie wiele) powinien mieæ swój numer identyfikacyjny; nadajemy go sami. Najlepiej po prostu dawaæ kolejne liczby:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const</SPAN> WORD ID_TIMER = <SPAN CLASS=L>1</SPAN>;
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy ju¿ stworzyæ timera funkcj¹ <SPAN CLASS=T>SetTimer</SPAN>. Timer jest zwykle skojarzony z konkretnym okienkiem, dlatego te¿ podajemy uchwyt tego okienka jako argument dla funkcji <SPAN CLASS=T>SetTimer</SPAN>. Drugim argumentem jest numer identyfikacyjny, trzecim - tzw. <SPAN CLASS=Wazne>interwa³</SPAN> (o nim zaraz), ostatni argument najbezczelniej w œwiecie olewamy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(SetTimer(hwnd, ID_TIMER, <SPAN CLASS=L>100</SPAN>, NULL) == <SPAN CLASS=L>0</SPAN>)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Nie mo¿na utworzyæ timera!"</SPAN>, <SPAN CLASS=L>"Kurde"</SPAN>, MB_ICONSTOP);<BR>
</TD></TR>
</TABLE>

<P>
Od tej pory nasz timer odmierza czas... Co <SPAN CLASS=L>100</SPAN> milisekund (to jest w³aœnie ów interwa³, o którym wczeœniej wspomnia³em) do okienka o uchwycie <SPAN CLASS=T>hwnd</SPAN> jest wysy³any komunikat <SPAN CLASS=T>WM_TIMER</SPAN>. Wystarczy dodaæ obs³ugê tego komunikatu i ju¿ mamy (prawie) gotow¹ animacjê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_TIMER:<BR>
&nbsp;RysujKulke();<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Jeszcze tylko wyczarowaæ funkcjê <SPAN CLASS=T>RysujKulke</SPAN> i kulka skacze sobie radoœnie po ca³ym okienku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> RysujKulke()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//wylicz nowe parametry kulki</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(KulkaX&lt;=<SPAN CLASS=L>0</SPAN> || KulkaX&gt;=ptOkno.x) SpeedX = -SpeedX;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(KulkaY&lt;=<SPAN CLASS=L>0</SPAN> || KulkaY&gt;=ptOkno.y) SpeedY = -SpeedY;<BR>
&nbsp;KulkaX += SpeedX;<BR>
&nbsp;KulkaY += SpeedY;<BR>
&nbsp;<SPAN CLASS=C>//narysuj na nowej pozycji</SPAN><BR>
&nbsp;HDC hdc = GetDC(hwnd);<BR>
&nbsp;BitBlt(hdc, KulkaX, KulkaY, bmKulka.bmWidth, bmKulka.bmHeight, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
&nbsp;ReleaseDC(hwnd, hdc);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
W momencie, kiedy chcemy ju¿ zatrzymaæ nasz¹ animacjê albo po prostu koñczymy wykonywanie programu, musimy zniszczyæ niepotrzebnego timera:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
{<BR>
&nbsp;KillTimer(hwnd, ID_TIMER);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;
</TD></TR>
</TABLE>

<P>
Pamiêtamy równie¿ o zwolnieniu pozosta³ych zasobów, tzn. zniszczeniu pomocniczego kontekstu <SPAN CLASS=T>hdcMem</SPAN>, przywracaj¹c mu przedtem jego domyœln¹ bitmapê <SPAN CLASS=T>hbmOld</SPAN>.
</P>

<H2>
"CYWILIZUJEMY" NASZ¥ ANIMACJÊ
</H2>

<P>
A wiêc kulka lata po oknie i nawet zostawia za sob¹ piêkny œlad... No w³aœnie. Zapomnieliœmy, ¿e przed narysowaniem ka¿dej nowej klatki animacji trzeba zetrzeæ star¹! A w dodatku chcielibyœmy, aby t³o bitmapy z kulk¹ by³o przezroczyste... To pierwsze to ¿aden problem, mo¿emy zamazaæ "star¹" klatkê funkcj¹ <SPAN CLASS=T>FillRect</SPAN>. Funkcja ta pobiera wspó³rzêdne prostok¹ta, który zamazujemy, tak wiêc rezygnujemy z naszych zmiennych <SPAN CLASS=T>KulkaX</SPAN> i <SPAN CLASS=T>KulkaY</SPAN>, a wspó³rzêdne kulki (i jej wymiary, przy okazji) przechowywaæ sobie bêdziemy w strukturze typu<SPAN CLASS=T> RECT</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
RECT rcKulka;<BR>
SetRect(&rcKulka, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>5</SPAN>+bmKulka.bmWidth, <SPAN CLASS=L>5</SPAN>+bmKulka.bmHeight);<BR>
</TD></TR>
</TABLE>

<P>
Przy okazji dowiedzieliœmy siê, jak ustawiæ wszystkie wspó³rzêdne prostok¹ta <SPAN CLASS=T>RECT</SPAN> za jednym zamachem. Oczywiœcie wywo³anie funkcji <SPAN CLASS=T>SetRect</SPAN> musi siê znaleŸæ ZA wywo³aniem funkcji <SPAN CLASS=T>GetObject</SPAN>, która pobiera nam wymiary bitmapy z kulk¹, inaczej zmienne <SPAN CLASS=T>bmKulka.bmWidth</SPAN> i <SPAN CLASS=T>bmKulka.bmHeight</SPAN> bêd¹ zawieraæ nieprawid³owe wartoœci.
</P>
<P>
Struktura typu <SPAN CLASS=T>RECT</SPAN> posiada cztery pola: <SPAN CLASS=T>left, right, top, bottom</SPAN>. Tak wiêc musimy w naszym programie pozamieniaæ wszystkie <SPAN CLASS=T>KulkaX</SPAN> na <SPAN CLASS=T>rcKulka.left</SPAN>, wszystkie <SPAN CLASS=T>KulkaY</SPAN> na <SPAN CLASS=T>rcKulka.top</SPAN>, natomiast w miejscach, gdzie u¿ywamy szerokoœci i wysokoœci bitmapy pi³ki, wstawiamy odpowiednio: <SPAN CLASS=T>bmKulka.right</SPAN> i <SPAN CLASS=T>bmKulka.bottom</SPAN> (trochê "nielegalnie", o tym zaraz). Poza tym pola <SPAN CLASS=T>rcKulka.left</SPAN> i <SPAN CLASS=T>rcKulka.top</SPAN> bêd¹ siê musia³y zmieniaæ z ka¿d¹ klatk¹ animacji. To zmienianie mo¿emy sobie znowu za³atwiæ, korzystaj¹c z funkcji <SPAN CLASS=T>OffsetRect</SPAN>, która modyfikuje w³aœnie pola <SPAN CLASS=T>left</SPAN> i <SPAN CLASS=T>top</SPAN> wskazanego prostok¹ta. Czyli nasza nowa funkcja <SPAN CLASS=T>RysujKulke</SPAN> bêdzie mniej wiêcej taka:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> RysujKulke()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//pobierz HDC okna</SPAN><BR>
&nbsp;HDC hdc = GetDC(g_hwnd);<BR>
&nbsp;<SPAN CLASS=C>//zama¿ "star¹" kulkê</SPAN><BR>
&nbsp;FillRect(hdc, &rcTemp, (HBRUSH)GetStockObject(LTGRAY_BRUSH));<BR>
&nbsp;<SPAN CLASS=C>//wylicz nowe parametry kulki</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(rcKulka.left&lt;=<SPAN CLASS=L>0</SPAN> || rcKulka.right&gt;=rcOkno.right) SpeedX = -SpeedX;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(rcKulka.top&lt;=<SPAN CLASS=L>0</SPAN> || rcKulka.bottom&gt;=rcOkno.bottom) SpeedY = -SpeedY;<BR>
&nbsp;OffsetRect(&rcKulka, SpeedX, SpeedY);<BR>
&nbsp;<SPAN CLASS=C>//narysuj na nowej pozycji</SPAN><BR>
&nbsp;BitBlt(hdc, rcKulka.left, rcKulka.top, rcKulka.right-rcKulka.left, rcKulka.bottom-rcKulka.top, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
&nbsp;ReleaseDC(g_hwnd, hdc);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, u¿yliœmy funkcji <SPAN CLASS=T>GetStockObject</SPAN>, aby pobraæ systemowy pêdzel o kolorze szarym - takiego samego u¿ywa kod generowany przez Dev-C++ aby zamalowaæ g³ówne okno programu. Musieliœmy u¿yæ jawnej konwersji na typ <SPAN CLASS=T>HBRUSH</SPAN>, poniewa¿ <SPAN CLASS=T>GetStockObject</SPAN> zwraca uchwyty ró¿nego rodzaju, nie tylko <SPAN CLASS=T>HBRUSH</SPAN> (niektóre kompilatory ten fakt olewaj¹, te u¿ywane z Dev-C++ niestety nie).
</P>
<P>
No to pierwszy problem z g³owy, czas zaj¹æ siê przezroczystoœci¹ t³a. W czêœci poœwiêconej bitmapom poda³em wam przepis na funkcjê <SPAN CLASS=T>CreateBitmapMask</SPAN>, która tworzy maskê opieraj¹c siê o dan¹ bitmapê i kolor maski. Wykorzystamy teraz tê funkcjê, aby nie trzeba by³o robiæ maski "rêcznie":
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmMaska = CreateBitmapMask(hbmKulka, RGB(<SPAN CLASS=L>255,0,255</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
Jako kolor maski podaliœmy <SPAN CLASS=T>RGB(<SPAN CLASS=L>255,0,255</SPAN>)</SPAN>, czyli "magiczny ró¿", poniewa¿ tego w³aœnie koloru u¿ywa siê najczêœciej w celu maskowania. Teraz musimy znów wprowadziæ zmiany do funkcji <SPAN CLASS=T>RysujKulke</SPAN>, a mianowicie dorzuciæ do niej jedn¹ instrukcjê <SPAN CLASS=T>BitBlt</SPAN> oraz zmieniæ nieco poprzedni¹ - jeœli nie wiesz dlaczego, zajrzyj do odcinka poœwiêconego rysowaniu bitmap. Poniewa¿ zaœ stworzony przez nas pomocniczy kontekst <SPAN CLASS=T>hdcMem</SPAN> bêdzie teraz musia³ "obs³u¿yæ" dwie bitmapy (w³aœciw¹ kulkê i maskê) zamiast jednej, wiêc albo bêdziemy przypisywaæ do niego jedn¹ bitmapê, a raz drug¹, albo te¿ utworzyæ dla maski osobny kontekst. Wybieramy to pierwsze rozwi¹zanie, choæ wolniejsze jest, poniewa¿ nie chcemy siê pogubiæ w a¿ tylu kontekstach :-). Tak bêdzie teraz wygl¹da³a funkcja <SPAN CLASS=T>RysujKulke</SPAN> (podajê tylko czêœæ, która siê zmieni³a, miêdzy komentarzem "narysuj na nowej pozycji" a wywo³aniem <SPAN CLASS=T>ReleaseDC</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SelectObject(hdcMem, hbmMaska);<BR>
BitBlt(hdc, rcKulka.left, rcKulka.top, rcKulka.right-rcKulka.left, rcKulka.bottom-rcKulka.top, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCAND);<BR>
SelectObject(hdcMem, hbmKulka);<BR>
BitBlt(hdc, rcKulka.left, rcKulka.top, rcKulka.right-rcKulka.left, rcKulka.bottom-rcKulka.top, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCINVERT);<BR>
</TD></TR>
</TABLE>

<P>
To ju¿ w zasadzie wszystko, ale zanim uruchomimy kompilator, by podziwiaæ efekty, jeszcze grzecznie po sobie posprz¹tamy, ¿eby póŸniej nie zapomnieæ ;-). Musimy zwróciæ kontekstowi <SPAN CLASS=T>hdcMem</SPAN> jego bitmapê domyœln¹ (przechowywan¹ w <SPAN CLASS=T>hbmOld</SPAN>), usun¹æ ten kontekst, skasowaæ bitmapy z kulk¹ i z mask¹, no i oczywiœcie "zabiæ" timera. A wiêc obs³uga komunikatu <SPAN CLASS=T>WM_DESTROY</SPAN> powinna wygl¹daæ mniej wiêcej tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
{<BR>
&nbsp;KillTimer(hwnd, ID_TIMER);<BR>
&nbsp;SelectObject(hdcMem, hbmOld);<BR>
&nbsp;DeleteDC(hdcMem);<BR>
&nbsp;DeleteObject(hbmKulka);<BR>
&nbsp;DeleteObject(hbmMaska);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<H2>
PODWÓJNE BUFOROWANIE
</H2>

<P>
Kulka zasuwa po ekranie, ale robi to z widoczn¹ niechêci¹, wrêcz z obrzydzeniem; animacja co trochê paskudnie miga i w ogóle nie wygl¹da zachêcaj¹co. Trzeba zrobiæ podwójne buforowanie! Brzmi groŸnie, ale idea jest bardzo prosta. Do tej pory najpierw rysowaliœmy na ekranie szary prostok¹t, potem maskê, która równie¿ trafia³a prosto na ekran, a na tym dopiero "w³aœciw¹" kulkê, która l¹dowa³a na ekranie w u³amek sekundy póŸniej. W ten sposób czasami karta graficzna mog³a czasem nie zd¹¿yæ narysowaæ co trzeba przed odœwie¿eniem obrazu na monitorze i st¹d to dziwne miganie. Gdyby jednak utworzyæ pomocniczy bufor (kontekst + tymczasowa bitmapa), w nim "skleiæ" szary prostok¹t, maskê i bitmapê, a dopiero ca³y efekt wys³aæ na ekran, wówczas animacja by³aby du¿o p³ynniejsza. Spróbujmy wiêc:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcBufor;<BR>
HBITMAP hbmBuf, hbmOldBuf;<BR>
</TD></TR>
</TABLE>

<P>
To na razie tylko deklaracje; potrzebujemy jednego uchwytu do kontekstu oraz dwóch uchwytów do bitmap (jeden bêdzie pe³ni³ rolê tymczasowej bitmapy, do drugiego przypiszemy domyœln¹ bitmapê naszego bufora). Nastêpnie tworzymy bufor podobnie, jak tworzyliœmy kontekst <SPAN CLASS=T>hdcMem</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
hdcBufor = CreateCompatibleDC(hdc);<BR>
hbmBuf = CreateCompatibleBitmap(hdcBufor, rcOkno.right, rcOkno.bottom);<BR>
hbmOldBuf = (HBITMAP)SelectObject(hdcBufor, hbmBuf);<BR>
FillRect(hdcBufor, &rcOkno, (HBRUSH)GetStockObject(LTGRAY_BRUSH));<BR>
</TD></TR>
</TABLE>

<P>
Bitmapa, której u¿ywamy jako bufor z kontekstem <SPAN CLASS=T>hdcBufor</SPAN>, ma wymiary okienka. Oznacza to ni mniej ni wiêcej, ¿e ca³y obszar okna bêdzie rysowany od nowa. W ten sposób mo¿emy zmazaæ "star¹" klatkê animacji oraz narysowaæ now¹ za jednym zamachem. Oczywiœcie poci¹ga to za sob¹ pewne koszty; animacja bêdzie wolniejsza. Za to, dziêki podwójnemu buforowaniu, nie bêdzie nam denerwuj¹co migotaæ. Dalsze optymalizacje (a trzeba przede wszystkim zmniejszyæ powierzchniê odœwie¿anego obszaru) pozostawiam tobie.
</P>
<P>
Teraz zmieniamy po raz kolejny funkcjê <SPAN CLASS=T>RysujKulke</SPAN>. Obydwie instrukcje <SPAN CLASS=T>BitBlt</SPAN> zostaj¹ gdzie s¹, ale zmieniamy im docelowe <SPAN CLASS=T>HDC</SPAN>; tym razem nie blitujemy na ekran, tylko do bufora. No a poniewa¿ bufor ma wielkoœæ zaledwie fragmentu ca³ego okna, wiêc zmieniamy równie¿ docelowe wspó³rzêdne (na zera):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SelectObject(hdcMem, hbmMaska);<BR>
BitBlt(hdcBufor, rcKulka.left, rcKulka.top, rcKulka.right-rcKulka.left, rcKulka.bottom-rcKulka.top, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCAND);<BR>
SelectObject(hdcMem, hbmKulka);<BR>
BitBlt(hdcBufor, rcKulka.left, rcKulka.top, rcKulka.right-rcKulka.left, rcKulka.bottom-rcKulka.top, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCINVERT);<BR>
</TD></TR>
</TABLE>

<P>
Instrukcja <SPAN CLASS=T>FillRect</SPAN> teraz te¿ bêdzie malowa³a w buforze, a nie na ekranie, wiêc zmieniamy jej prostok¹t docelowy oraz uchwyt kontekstu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//zama¿ "star¹" kulkê</SPAN><BR>
FillRect(hdcBufor, &rcOkno, (HBRUSH)GetStockObject(LTGRAY_BRUSH));<BR>
</TD></TR>
</TABLE>

<P>
Nastêpnie po prostu posy³amy zawartoœæ bufora na ekran, dorzucaj¹c trzeci¹ instrukcjê <SPAN CLASS=T>BitBlt</SPAN>, tym razem z flag¹ <SPAN CLASS=T>SRCCOPY</SPAN>, poniewa¿ wszystkie "kombinacje" zosta³y ju¿ wykonane w buforze:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BitBlt(hdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, rcOkno.right, rcOkno.bottom, hdcBufor, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
</TD></TR>
</TABLE>

<P>
Nie zapominamy o dodatkowych obowi¹zkach porz¹dkowych: pod koniec programu buforowi przywracamy jego domyœln¹ bitmapê i usuwamy go. Niszczymy te¿ oczywiœcie bitmapê <SPAN CLASS=T>hbmBuf</SPAN>. Po tych zabiegach mo¿emy wreszcie wcisn¹æ F9 i rozkoszowaæ widokiem kulki mkn¹cej przez ekran... Z niezbyt imponuj¹c¹ prêdkoœci¹ mo¿e, ale bez "efektów ubocznych". Optymalizacje, jak ju¿ wspomnia³em, s¹ twoj¹ prac¹ domow¹, natomiast przyk³adowy program wraz z kodem Ÿród³owym znajdziesz w dziale Download.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apibmp.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidlg.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>

</HTML>