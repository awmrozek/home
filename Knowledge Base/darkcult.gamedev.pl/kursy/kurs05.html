<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs04.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05a.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Klasy
</H1>
<H2>
Trochê trucia o programowaniu obiektowym
</H2>

<P>
Có¿ to za czort - programowanie obiektowe? Otó¿ jakiœ czas temu ktoœ wpad³ na pomys³, ¿eby pisaæ programy trochê inaczej, ni¿ dotychczas. Ten ktoœ zauwa¿y³, ¿e w zasadzie wszelkie wysi³ki programistów sprowadzaj¹ siê do modelowania rzeczywiœci (za pomoc¹ kodu oczywiœcie), wiêc pisz¹c program nale¿y tê rzeczywistoœæ "odwzorowaæ" w komputerze tak¹, jaka ona jest, a nie jak w danym momencie programiœcie jest wygodniej.
</P>
<P>
Co to oznacza? Jeœli dla przyk³adu robimy sobie wirtualnego psa, który ma wykonywaæ sztuczki, to projektujemy go tak, ¿eby w³aœciciel nie musia³ zastanawiaæ siê, któr¹ ³ap¹ pies ma poruszyæ i w któr¹ stronê, ¿eby wykonaæ aport. Szczegó³y bêd¹ nale¿eæ do samego pieska, w³aœciciel bêdzie tylko rzuca³ przedmiot, który piesek ma przynieœæ. 
</P> 
<P>
Inna istotna sprawa: piesek winien byæ jak najbardziej uniwersalny. Nie ma wielkiego sensu projektowanie pieska, który bêdzie tylko aportowa³. Dobry piesek to taki, który potrafi te¿ gryŸæ akwizytorów, rozwi¹zywaæ krzy¿ówki i ³apaæ myszy. 
</P>
<P>
Takie rozwi¹zanie (czyli zastosowanie spojrzenia obiektowego na rzeczywistoœæ), choæ pozornie daje takie same efekty, jak programowanie proceduralne (czyli z wykorzystaniem funkcji w miejsce obiektów), okazuje siê znacznie prostsze w implementacji. Pozwala bowiem na wspomniane ju¿ modelowanie, czyli naœladowanie w programach istniej¹cych urz¹dzeñ, budowli, organizmów, itp. Dziêki temu programista nie gubi siê w kodzie, gdy¿ kod ten zachowuje siê podobnie, jak znane programiœcie elementy z ¿ycia codziennego (no dobra, to ³apanie myszy to jednak by³a przesada). A przy okazji w programie obiektowym znacznie ³atwiej namierzyæ i zlikwidowaæ wszelkie "buraki".
</P>

<H2>
"Niby-klasy", czyli struktury i unie
</H2>

<P>
Pierwszym krokiem stworzenia jakiegokolwiek obiektu jest nadanie mu pewnych <SPAN CLASS=Wazne>cech</SPAN>. Na przyk³ad pies mo¿e wabiæ siê Terminator, byæ kud³aty, posiadaæ metrowej d³ugoœci ogon, szeœæset pche³ oraz nie mieæ lewego oka. Wszystkie te informacje mo¿emy sobie zapisaæ w odpowiednich zmiennych. Imiê zapiszemy w zmiennej <SPAN CLASS=K>char*</SPAN>. Rodzaj sierœci, d³ugoœæ ogona i liczbê pche³ mo¿emy wrzuciæ do zmiennych typu <SPAN CLASS=K>int</SPAN>. Z kolei informacjê o posiadaniu (lub nie) oka zapamiêtamy sobie z zmiennej typu <SPAN CLASS=K>bool</SPAN>. Wszystkie te zmienne umieszczamy w jednym bloku - <SPAN CLASS=Wazne>strukturze</SPAN> i nazywamy tê strukturê <SPAN CLASS=T>Pies</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Pies<BR>
{<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> rodzaj_siersci, dlugosc_ogona, liczba_pchel;<BR>
&nbsp;<SPAN CLASS=K>bool</SPAN> lewe_oko, prawe_oko;<BR>
};<BR>
</TD></TR>
</TABLE>

<P class=UWAGA>
Deklaracja struktury (a tak¿e klasy i unii, jak zobaczymy póŸniej) musi koñczyæ siê œrednikiem.
</P>

<P>
Co mo¿emy zrobiæ ze struktur¹? Przede wszystkim ka¿da struktura tworzy <SPAN CLASS=Wazne>nowy typ danych</span>, a wiêc mo¿emy teraz deklarowaæ zmienne typu <SPAN CLASS=T>Pies</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Pies Pies1, Pies2;<BR>
</TD></TR>
</TABLE>

<P CLASS=UWAGA>
Zmienna <SPAN CLASS=T>Pies</SPAN> jest tutaj struktur¹, ale bardziej ogólnie nazywa siê j¹ klas¹. Natomiast zmienne <SPAN CLASS=T>Pies1</SPAN> i <SPAN CLASS=T>Pies2</SPAN> nazywa siê obiektami.
</P>

<P>
I tak oto powo³aliœmy do ¿ycia nasze pierwsze obiekty. Przez zlepienie zmiennych ró¿nego typu zarezerwowaliœmy miejsce, gdzie obiekty te bêd¹ przechowywa³y swoje cechy. Teraz mo¿emy ³atwo stworzyæ ca³¹ psi¹ hordê o ró¿nych cechach:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Pies1.imie = <SPAN CLASS=L>"Terminator"</SPAN>;<BR>
Pies1.rodzaj_siersci = <SPAN CLASS=L>0</SPAN>;<BR>
Pies1.dlugosc_ogona = <SPAN CLASS=L>100</SPAN>;<BR>
Pies1.liczba_pchel = <SPAN CLASS=L>600</SPAN>;<BR>
Pies1.prawe_oko = <SPAN CLASS=K>true</SPAN>;<BR>
Pies1.lewe_oko = <SPAN CLASS=K>false</SPAN>;<BR>
<BR>
Pies2.imie = <SPAN CLASS=L>"Burek"</SPAN>;<BR>
Pies2.rodzaj_siersci = <SPAN CLASS=L>1</SPAN>;<BR>
Pies2.dlugosc_ogona =<SPAN CLASS=L> 30</SPAN>;<BR>
Pies2.liczba_pchel = <SPAN CLASS=L>1375</SPAN>;<BR>
Pies2.prawe_oko = <SPAN CLASS=K>true</SPAN>;<BR>
Pies2.lewe_oko = <SPAN CLASS=K>true</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
W taki w³aœnie sposób - dziêki kropce - mo¿emy siê dostaæ do poszczególnych sk³adowych (pól) struktury. Oczywiœcie kropka s³u¿y nie tylko do zapisywania wartoœci w polach struktury, ale i do odczytywania tych wartoœci, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
cout &lt;&lt; <SPAN CLASS=L>"Moj pies wabi sie "</SPAN> &lt;&lt; Pies1.imie &lt;&lt; endl;
</TD></TR>
</TABLE>

<P>
Organizowanie powi¹zanych ze sob¹ danych w struktury nie tylko zbli¿a nasz programowy model do rzeczywistoœci, ale te¿ zwyczajnie u³atwia programowanie. Jeœli mamy dane w jednym miejscu, to mo¿emy:
</P>

<UL>
<LI>Szybciej zaalokowaæ dla nich pamiêæ
<LI>Szybciej i ³atwiej je wyzerowaæ, zainicjowaæ, skopiowaæ
<LI>Przekazaæ wszystkie dane za jednym zamachem jako parametr funkcji b¹dŸ wartoœæ zwracan¹
<LI>Zapisaæ dane w jednym rzucie do pliku
</UL>

<P>
...i jeszcze kilka innych przydatnych rzeczy. Jak wiêc widaæ, struktury s¹ rzecz¹ bardzo pomocn¹. 
Zobaczmy teraz na przyk³adzie, jak wygl¹da zwracanie przez funkcjê ca³ej struktury:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Pies ZmienPieska(<SPAN CLASS=K>int</SPAN> nowa_siersc, <SPAN CLASS=K>int</SPAN> nowy_ogon, <SPAN CLASS=K>int</SPAN> nowe_pchly, <SPAN CLASS=K>bool</SPAN> nowe_l_oko, <SPAN CLASS=K>bool</SPAN> nowe_p_oko)<BR>
{<BR>
&nbsp;Pies retval;<BR>
&nbsp;retval.rodzaj_siersci = nowa_siersc;<BR>
&nbsp;retval.dlugosc_ogona = nowy_ogon;<BR>
&nbsp;retval.liczba_pchel = nowe_pchly;<BR>
&nbsp;retval.prawe_oko = nowe_p_oko;<BR>
&nbsp;retval.lewe_oko = nowe_l_oko;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> retval;<BR>
}
</TD></TR>
</TABLE>

<P>
Powy¿sza funkcja najpierw deklaruje sobie lokaln¹ zmienn¹ <SPAN CLASS=T>retval</SPAN> typu <SPAN CLASS=T>Pies</SPAN>, po czym po kolei wype³nia jej pola wartoœciami poszczególnych argumentów. Wreszcie w ostatniej instrukcji - <SPAN CLASS=K>return</SPAN> <SPAN CLASS=T>retval</SPAN> - struktura <SPAN CLASS=T>retval</SPAN>, a dok³adniej jej zawartoœæ, jest w ca³oœci (wszystkie pola) zwracana "na zewn¹trz". Czyli jeœli napiszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Pies Pies1;<BR>
Pies1 = ZmienPieska(<SPAN CLASS=L>1, 40, 100</SPAN>,<SPAN CLASS=K> true, true</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
...to zawartoœæ lokalnej zmiennej <SPAN CLASS=T>retval</SPAN> z funkcji <SPAN CLASS=T>ZmienPieska</SPAN> zostanie skopiowana do zmiennej <SPAN CLASS=T>Pies1</SPAN>. Jak to siê dzieje, ¿e kompilator automatycznie potrafi kopiowaæ struktury w ca³oœci - o tym powiemy sobie póŸniej.
</P>

<P class=UWAGA>Przypominam, ¿e inicjalna zawartoœæ pól struktury, podobnie jak w przypadku "zwyk³ych" zmiennych, jest nieokreœlona (chyba, ¿e np. mamy do czynienia ze zmienn¹ globaln¹) i na wszelki wypadek warto wyzerowaæ pamiêæ zajmowan¹ przez strukturê przed jej u¿yciem.
</P>
<P>
Teraz trochê o <SPAN CLASS=Wazne>uniach</SPAN>. Có¿ to takiego? Otó¿ jest to taka "udziwniona" wersja struktur. Pod wzglêdem sk³adniowym wygl¹daj¹ tak samo jak struktury, ale zamiast s³ówka <SPAN CLASS=K>struct</SPAN> wystêpuje <SPAN CLASS=K>union</SPAN>. Dzia³aj¹ te¿ dok³adnie tak samo, ale tylko jedna jedyna sk³adowa unii mo¿e byæ aktywna w danym momencie. Innymi s³owy, jeœli przypiszemy do danej sk³adowej unii jak¹œ wartoœæ, to automatycznie wartoœci pozosta³ych sk³adowych s¹ niszczone, poniewa¿ znajduj¹ siê w tym samym miejscu w pamiêci. Dlatego te¿ pomimo teoretycznej mo¿liwoœci, ¿eby siê wtedy do nich odwo³aæ, czyniæ tego nie nale¿y, gdy¿ mia³oby to zapewne mocno nieciekawe nastêpstwa. Jak to wygl¹da w praktyce?
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>union</SPAN> Test<BR>
{<BR>
&nbsp;<SPAN CLASS=K>short int</SPAN> mala_liczba;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba;<BR>
&nbsp;<SPAN CLASS=K>long int</SPAN> duza_liczba;<BR>
};<BR>
<BR>
<SPAN CLASS=K>void</SPAN> main()<BR>
{<BR>
&nbsp;Test przyklad;<BR>
&nbsp;przyklad.duza_liczba = <SPAN CLASS=L>19000</SPAN>; <SPAN CLASS=C>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//aktywujemy sk³adow¹ duza_liczba</SPAN><BR>
&nbsp;przyklad.mala_liczba = <SPAN CLASS=L>6</SPAN>; <SPAN CLASS=C>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//aktywujemy sk³adow¹ mala_liczba</SPAN><BR>
&nbsp;cout &lt;&lt; przyklad.duza_liczba &lt;&lt; endl; <SPAN CLASS=C>//B£¥D!</SPAN><BR>
&nbsp;przyklad.duza_liczba = <SPAN CLASS=L>32000</SPAN>; <SPAN CLASS=C>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ponownie aktywujemy du¿¹_liczbê</SPAN><BR>
&nbsp;cout &lt;&lt; przyklad.duza_liczba &lt;&lt; endl; <SPAN CLASS=C>//aaa, teraz to co innego - wydrukuje 32000</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Unia typu <SPAN CLASS=T>Test</SPAN> zajmuje w pamiêci taki sam obszar, jak jej najwiêksza sk³adowa, czyli <SPAN CLASS=K>sizeof(long int)</SPAN>. Przypisanie <SPAN CLASS=T>przyklad.duza_liczba = </SPAN><SPAN CLASS=L>19000</SPAN> aktywuje nam sk³adow¹ <SPAN CLASS=T>duza_liczba</SPAN>, ale nastêpna instrukcja dezaktywuje nam j¹, aktywuj¹c w zamian sk³adow¹ <SPAN CLASS=T>mala_liczba</SPAN>. Dlatego kolejna instrukcja, czyli <SPAN CLASS=T>cout << przyklad.duza_liczba << endl</SPAN> nie wydrukuje nam liczby <SPAN CLASS=L>19000</SPAN>, lecz jak¹œ inn¹, poniewa¿ pierwsze dwa bajty obszaru, przydzielonego dla naszej unii zosta³y nadpisane wartoœci¹ typu <SPAN CLASS=K>short int</SPAN>, równ¹ <SPAN CLASS=L>6</SPAN>. Za to gdybyœmy w tym miejscu kazali wypisaæ wartoœæ sk³adowej <SPAN CLASS=T>mala_liczba</SPAN>, otrzymalibyœmy normalnie <SPAN CLASS=L>6</SPAN>. Nastêpnie ponownie wpisujemy do <SPAN CLASS=T>duza_liczba</SPAN> wartoœæ, wiêc teraz w³aœnie ta sk³adowa jest aktywna i ostatnia instrukcja programiku wypisze prawid³ow¹, aktualn¹ jej wartoœæ, czyli <SPAN CLASS=L>32000</SPAN>.
</P>
<P>
No dobrze, tylko po co te wszystkie utrudnienia? Muszê uczciwie przyznaæ, ¿e dot¹d nie uda³o mi siê wymyœliæ ¿adnego konkretnego zastosowania dla unii. Jedyne, co mi przychodzi do g³owy, to przypadek, kiedy mamy kilka ogromnych obiektów i musimy bardzo oszczêdzaæ pamiêæ, a nie korzystamy z tych obiektów jednoczeœnie. Wówczas wystarczy wrzuciæ te pojedyncze obiekty do unii i tak zaprojektowaæ program, ¿eby korzystaæ z nich nie trac¹c ¿adnych informacji w tych obiektach. W przypadku ma³ych, amatorskich programów, jakie zapewne bêdziesz pisa³ w najbli¿szym czasie, bêdzie to sytuacja raczej ekstremalna, ale wspominam o uniach, ¿ebyœ mia³ pojêcie, ¿e w ogóle coœ takiego istnieje ;-).
</P>

<P class=UWAGA>Ze wzglêdu na sw¹ naturê (wspó³dzielenie pamiêci przez poszczególne sk³adowe) unie maj¹ szereg ograniczeñ w stosunku do "normalnych" klas. S¹ to miêdzy innymi: brak mo¿liwoœci dziedziczenia, niemo¿noœæ zawierania statycznych sk³adowych, zakaz istnienia sk³adowych tworzonych przez jawny konstruktor lub niszczonych przez jawny destruktor. Poniewa¿ zastosowanie unii jest tak w¹skie, nie bêdziemy dok³adniej omawiaæ tych ograniczeñ.</P>

<H2>
Pola bitowe
</H2>

<P>
Podobno podczas drugiej wojny œwiatowej na niemieckich skrzynkach z amunicj¹ by³y napisy: "Munition nicht sparen!" (nie oszczêdzaæ). Zdaje siê, ¿e firmy soft³erowe (z Microsoftem na czele) w ostatnich czasach równie¿ stosuj¹ podobn¹ doktrynê, jeœli chodzi o wykorzystanie pamiêci operacyjnej. Do historii przesz³y ju¿ czasy, kiedy oszczêdza³o siê ka¿dy bajt. Mimo to ci¹gle zdarzaj¹ siê sytuacje, kiedy od ostro¿nego wydzielania pamiêci mo¿e sporo zale¿eæ, a ju¿ na pewno potencjalni u¿ytkownicy naszych programów przyjm¹ z wdziêcznoœci¹ wszelkie starania o zmiejszenie pamiêcio¿ernoœci tych ostatnich ;-).
</P>
<P>
Jednym z "narzêdzi" umo¿liwiaj¹cych owe starania s¹ w³aœnie pola bitowe. WeŸmy dla przyk³adu strukturê, która bêdzie nam zapamiêtywa³a bie¿¹c¹ datê - dzieñ, miesi¹c i rok. Dni w miesi¹cu mamy maksymalnie <SPAN CLASS=L>31</SPAN>, wiêc mo¿emy spokojnie u¿yæ typu <SPAN CLASS=K>char</SPAN>. Miesiêcy w roku jest tylko <SPAN CLASS=L>12</SPAN>, wiêc równie¿ zapamiêtamy je w zmiennej <SPAN CLASS=K>char</SPAN>. Natomiast do zapisania roku mo¿e byæ ju¿ potrzebna nieco wiêksza liczba (jeœli chcemy unikn¹æ atrakcji typu Problem Roku 2000 ;-)) - weŸmy sobie <SPAN CLASS=K>int</SPAN>, niech bêdzie on nawet <SPAN CLASS=K>signed</SPAN>, coby daty przed Chrystusem te¿ uwzglêdnia³. Powinno starczyæ na parê milionów lat ;-). Tak wiêc mamy strukturê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Data<BR>
{<BR>
&nbsp;<SPAN CLASS=K>unsigned char</SPAN> Dzien;<BR>
&nbsp;<SPAN CLASS=K>unsigned char</SPAN> Miesiac;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Rok;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W sumie struktura zajmuje <SPAN CLASS=L>4</SPAN> bajty, czyli <SPAN CLASS=L>32</SPAN> bity. Teraz moment na refleksje. Do zapamiêtania dnia (liczba z przedzia³u <SPAN CLASS=L>1-31</SPAN>) wystarczy w zupe³noœci <SPAN CLASS=L>5</SPAN> bitów, a my wykorzystujemy <SPAN CLASS=L>8</SPAN>. Na miesi¹c moglibyœmy u¿yæ jeszcze mniej, bo tylko <SPAN CLASS=L>4</SPAN> bity. Jeœli zaœ rok ograniczymy z <SPAN CLASS=L>32</SPAN> bitów do <SPAN CLASS=L>23</SPAN>, to te¿ nic siê nie stanie (liczba mo¿liwych do zapamiêtania lat spadnie nieco, ale pewnie i tak nikt nie do¿y³by roku, który nie zmieœci³by siê w <SPAN CLASS=L>23</SPAN> bitach ;-)). W sumie zaoszczêdzilibyœmy <SPAN CLASS=L>16</SPAN> bitów, czyli ca³e <SPAN CLASS=L>2</SPAN> bajty. WprowadŸmy ten niecny plan w ¿ycie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Data<BR>
{<BR>
&nbsp;<SPAN CLASS=K>unsigned char</SPAN> Dzien : <SPAN CLASS=L>5</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>unsigned char</SPAN> Miesiac : <SPAN CLASS=L>4</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Rok : <SPAN CLASS=L>23</SPAN>;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Teraz nasza struktura powinna zajmowaæ tylko <SPAN CLASS=L>32</SPAN> bity (zamiast <SPAN CLASS=L>48</SPAN>), ale jeœli sprawdzimy operatorkiem <SPAN CLASS=K>sizeof</SPAN>, to oka¿e siê, ¿e wcale tak nie jest. Problem w tym, ¿e mamy pola ró¿nych typów. A poniewa¿ i tak jawnie podajemy liczbê bitów pola, wiêc mo¿emy spokojnie pozamieniaæ wszystkie typy na <SPAN CLASS=K>int</SPAN> - nic nie stracimy, a nawet wrêcz przeciwnie.
</P>

<P class=UWAGA>Dozwolone typy pól bitowych to wy³¹cznie typy ca³kowite - <SPAN CLASS=K>char, int</SPAN> oraz wszelkie ich kombinacje. Dodatkowo mo¿na te¿ korzystaæ z typu <SPAN CLASS=K>enum</SPAN> (który, jak wiemy, praktycznie nie ró¿ni siê wiele od <SPAN CLASS=K>int</SPAN>).
</SPAN>
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Data<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Dzien : <SPAN CLASS=L>5</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Miesiac : <SPAN CLASS=L>4</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Rok : <SPAN CLASS=L>23</SPAN>;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Teraz <SPAN CLASS=K>sizeof</SPAN> pokazuje, ¿e rozmiar struktury <SPAN CLASS=T>Data</SPAN> wynosi zaledwie <SPAN CLASS=L>4</SPAN> bajty (<SPAN CLASS=L>32</SPAN> bity), mimo i¿ trzy sk³adowe <SPAN CLASS=K>int</SPAN> powinne zaj¹æ <SPAN CLASS=L>12</SPAN> bajtów. Oto zaleta stosowania pól bitowych. Poszczególne sk³adowe zosta³y "skompresowane". Nie zu¿yte bity z pola <SPAN CLASS=T>Dzien</SPAN> s¹ wykorzystywane do przechowywania bitów pola <SPAN CLASS=T>Miesiac</SPAN>, a dodatkowo równie¿ pola <SPAN CLASS=T>Rok</SPAN>. A wiêc trzy pola zmieœci³y siê nam na przestrzeni przeznaczonej dla jednego.
</P>
<P>
Wspomnê jeszcze o mo¿liwoœci deklarowania bezimiennych pól bitowych. Jeœli nie podamy nazwy pola, to oczywiœcie nie mo¿na do niego wpisaæ ¿adnej wartoœci, tak wiêc mog³oby siê na pierwszy rzut oka wydawaæ, ¿e nie ma sensu w ogóle deklarowanie takiego pola. Okazuje siê jednak, ¿e bezimienne pole równie¿ mo¿e byæ przydatne. Otó¿ jeœli wyst¹pi ono miêdzy dwoma "normalnymi" polami, to zapobiega przechowywaniu nastêpnego pola w pamiêci przeznaczonej dla pola poprzedniego. Dziêki temu mamy lepsz¹ kontrolê nad tym, które pola bêd¹ "kompresowane" a które nie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Data<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Dzien : <SPAN CLASS=L>5</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Miesiac : <SPAN CLASS=L>4</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> : <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//bezimienne pole - separator</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Rok : <SPAN CLASS=L>23</SPAN>;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W tym przypadku umieszczenie bezimiennego pola zapobiega wykorzystaniu ostatnich <SPAN CLASS=L>23</SPAN> bajtów z pierwszego <SPAN CLASS=K>int</SPAN>-a. Innymi s³owy: pierwsze <SPAN CLASS=L>9</SPAN> bajtów pierwszego <SPAN CLASS=K>int</SPAN>-a jest wykorzystywane przez pola <SPAN CLASS=T>Dzien</SPAN> i <SPAN CLASS=T>Miesiac</SPAN>, ale ju¿ pole<SPAN CLASS=T> Rok</SPAN> znajduje siê w nastêpnym <SPAN CLASS=K>int</SPAN>-cie. Czyli w sumie ca³oœæ zajmuje nie <SPAN CLASS=L>4</SPAN> bajty, lecz <SPAN CLASS=L>8</SPAN>. 
</P>


<h2>
Funkcje sk³adowe
</h2>

<P>
Doœæ straszenia bitami, przejdŸmy do rzeczy nieporównanie przydatniejszych. Oprócz pól, które s¹ zwyk³ymi zmiennymi, struktura mo¿e równie¿ zawieraæ <SPAN CLASS=Wazne>funkcje sk³adowe</SPAN> (zwane czasami <SPAN CLASS=Wazne>metodami</SPAN>). S³u¿¹ one przede wszystkim do wykonywania rozmaitych operacji na zmiennych sk³adowych (polach struktury). Ale po co umieszczaæ je wewn¹trz struktury? Czy nie mo¿na by po prostu zadeklarowaæ zwyk³¹ funkcjê, która wykonywa³aby to samo zadanie? Oczywiœcie, ¿e mo¿na. Ale to nie by³oby programowanie obiektowe... O tym zreszt¹ przekonasz siê sam w niedalekiej przysz³oœci.
</P>
<P>
¯eby jakoœ zobrazowaæ ten ogrom nowych rzeczy, o których zaraz bêdziemy mówiæ, wymyœlmy sobie jakiœ przyk³ad. Za³ó¿my, ¿e tworzymy grê o jakimœ nastêpcy Rambo, który po latach ratowania œwiata z r¹k szaleñców, kosmitów i innych z³ych istot postanowi³ dla odmiany zniszczyæ ten¿e œwiat ;-). Fabu³a nie jest oczywiœcie dla nas wa¿na - znacznie wiêksze znaczenie maj¹ takie drobiazgi, jak np. to, ¿e w celu zniszczenia œwiata nasz Rambo czy inny Supermen bêdzie potrzebowa³ jakiejœ spluwy, amunicji do niej, jakiegoœ wdzianka pancernego oraz co najmniej trzech ¿yæ (wszak jedno to za ma³o, ¿eby stawiæ czo³o wszystkim potencjalnym obroñcom œwiata ;-)). Te wszystkie dane (i nie tylko te) mo¿emy oczywiœcie przechowywaæ w strukturze:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Gracz<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Jak ju¿ wczeœniej wyczytaliœmy z tej œmiesznej ramki, inicjalne wartoœci tych wszystkich zmiennych sk³adowych s¹ losowe. Przyda³aby nam siê wiêc funkcja, która je wyzeruje na poczatku gry, albo jeszcze lepiej ustawi na jakieœ konkretne wartoœci domyœlne. Funkcja ta bêdzie zatem wykonywaæ operacjê na zmiennych sk³adowych struktury <SPAN CLASS=T>Gracz</SPAN>, nie przyda nam siê w programie do niczego innego, zatem powinna byæ funkcj¹ sk³adow¹ struktury <SPAN CLASS=T>Gracz</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> Gracz<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;&nbsp;Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;&nbsp;Pancerz =<SPAN CLASS=L> 0</SPAN>;<BR>
&nbsp;&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
&nbsp;}<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Tak wiêc funkcje sk³adowe nie ró¿ni¹ siê na oko niczym od "zwyk³ych" funkcji oprócz tego, ¿e w ca³oœci umieszczone s¹ wewn¹trz struktury... Czy aby? Czy nie ma ¿adnych ró¿nic? Oczywiœcie, ¿e s¹! Popatrz na poszczególne operacje przypisania - s¹ w nich tylko nazwy pól, nigdzie nie ma zaœ okreœlenia, ¿e te pola dotycz¹ struktury <SPAN CLASS=T>Gracz</SPAN>. Chyba nie wymaga to dok³adniejszego t³umaczenia - funkcja <SPAN CLASS=T>Resetuj</SPAN> znajduje siê wewn¹trz struktury, wiêc nie musimy do nazw pól dodawaæ nazwy struktury i kropki - kompilator sam "domyœli siê", ¿e chodzi o tê strukturê, wewn¹trz której jesteœmy. Oto i pierwsza wa¿na cecha funkcji sk³adowych. W jaki sposób jest to mo¿liwe - o tym pogadamy trochê póŸniej.
</P>
<P>
Wywo³ania funkcji sk³adowych nie ró¿ni¹ siê zbytnio od "zwyk³ych":
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz Gracz1;<BR>
Gracz1.Zycia = <SPAN CLASS=L>1</SPAN>;<BR>
Gracz1.Resetuj();<BR>
cout &lt;&lt; <SPAN CLASS=L>"Zycia gracza: "</SPAN> &lt;&lt; Gracz1.Zycia &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie wyœwietlona liczba ¿yæ wyniesie tutaj <SPAN CLASS=L>3</SPAN>, bo na tê wartoœæ ustawia j¹ metoda <SPAN CLASS=T>Resetuj</SPAN>.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs04.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05a.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</BODY>
</HTML>