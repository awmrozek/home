<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Grafika</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apifile.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apibmp.html">Nastêpna czêœæ kursu >></A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
3. GRAFIKA W WINAPI
</H1>

<H2>
3.1 Konteksty, zasoby, uchwyty...
</H2>

<P>
Co jak co, ale rysowanie w Windows przy pomocy WinAPI jest wyj¹tkowo przegiête. Porzuæ wszelkie nadzieje na to, aby np. liniê mo¿na by³o narysowaæ jednym rozkazem, tak jak to jest np. w Visual Basicu, a tak¿e w wiêkszoœci bibliotek graficznych pod DOS-a. Takie s¹ jednak wymogi nowoczesnych systemów operacyjnych... 
</P>
<P>
Jednak jest te¿ druga strona medalu. Pod takim DOS-em, ¿eby cokolwiek narysowaæ, musieliœmy wiedzieæ absolutnie wszystko o karcie graficznej, monitorze itp. W Windows nie musimy wiedzieæ prawie nic! System robi to wszystko za nas. Nie ma siê wiêc co zniechêcaæ, jedziemy z tym koksem.
</P>
<P>
Wszelkie operacje graficzne w Windowsach s¹ zwi¹zane z tzw. <SPAN CLASS=Wazne>kontekstem urz¹dzenia</SPAN> - po angielsku <SPAN CLASS=Wazne>Device Context</SPAN>, a w skrócie <SPAN CLASS=Wazne>DC</SPAN>. Cokolwiek byœmy chcieli narysowaæ, musimy podaæ uchwyt do kontekstu urz¹dzenia (<SPAN CLASS=Wazne>Handle to Device Context - HDC</SPAN>). Brzmi to trochê jak be³kot, wiêc odwo³uj¹c siê do intuicji: kontekst urz¹dzenia to zazwyczaj po prostu okno, w którym rysujemy. Od tej pory bêdê nazywa³ kontekst urz¹dzenia w skrócie: <SPAN CLASS=T>HDC</SPAN>.
</P>
<P>
To by³a pierwsza wa¿na sprawa, a druga to tak zwane <SPAN CLASS=Wazne>zasoby systemu</SPAN> - coœ takiego pewnie ci siê ju¿ obi³o o uszy, nieprawda¿? Pisz¹c jakikolwiek program dla Windows korzystamy z tych¿e zasobów i musimy uwa¿aæ, aby ich nie wyczerpaæ, gdy¿ to prowadzi w linii prostej do zwisów, wysypek, b³êdów krytycznych i innych weso³ych rzeczy. Dlatego te¿ schemat robienia czegokolwiek w WinAPI wygl¹da tak: pobierz zasoby - zrób coœ - oddaj zasoby. Robiliœmy tak ju¿ chocia¿by z naszym g³ównym okienkiem programu, natomiast przy rysowaniu jest to szczególnie wa¿ne i wyj¹tkowo czêsto siê korzysta z tego schematu.
</P>

<H2>
3.2 Rysujemy liniê
</H2>

<H3>
3.2.1 Pobieranie i zwalnianie kontekstu urz¹dzenia
</H3>

<P>
Nasze pierwsze, wielkie zadanie: narysowaæ liniê prost¹ o danym kolorze. Jak ju¿ wspomnia³em, bêdzie nam potrzebny uchwyt do kontekstu urz¹dzenia. Poniewa¿ nasz¹ urocz¹ linijkê chcemy narysowaæ w oknie, kontekstem urz¹dzenia bêdzie w³aœnie to okienko. Dysponujemy uchwytem do tego okienka, jednak to jeszcze nie jest to - uchwyt do okienka jest typu <SPAN CLASS=T>HWND</SPAN>, natomiast do kontekstu urz¹dzenia - typu <SPAN CLASS=T>HDC</SPAN>. Aby uzyskaæ <SPAN CLASS=T>HDC</SPAN> naszego okna, musimy skorzystaæ z funkcji <SPAN CLASS=T>GetDC</SPAN>:
<P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcOkno;<BR>
hdcOkno = GetDC(hwnd);<BR>
</TD></TR>
</TABLE>

<P>
Kiedy ju¿ skoñczymy rysowanie, bêdzie trzeba zwolniæ <SPAN CLASS=T>HDC</SPAN> naszego okna. Jeœli tego bowiem nie zrobimy, ¿adna inna aplikacja nie bêdzie mog³a nic na naszym okienku narysowaæ. Oczywiœcie, w wiêkszoœci przypadków nie zechcemy, by jakaœ tam obca aplikacja maza³a nam po okienku, no ale etykieta programistyczna obowi¹zuje :-). Korzystamy wiêc z funkcji <SPAN CLASS=T>ReleaseDC</SPAN>, przyjmuj¹cej jako argumenty: uchwyt okna (<SPAN CLASS=T>HWND</SPAN>) oraz uchwyt kontekstu (<SPAN CLASS=T>HDC</SPAN>):
<P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
ReleaseDC(hwnd, hdcOkno);<BR>
</TD></TR>
</TABLE>

<H3>
3.2.2 Ustawianie pozycji rysowania
</H3>

<P>
W WinAPI zwykle nie podajesz funkcjom rysuj¹cym, sk¹d maj¹ zacz¹æ rysowanie - zaczynaj¹ je od domyœlnego punktu, którym jest zazwyczaj ostatnio narysowany punkt. Taka sytuacja jest czasami bardzo wygodna, ale te¿ czasami chcielibyœmy wiedzieæ, sk¹d zaczynamy rysowanie :-). Trzeba wiêc przenieœæ ten domyœlny punkt startowy na odpowiednie miejsce. Mo¿esz to sobie wyobraziæ jako wielki pêdzel, który zawis³ nad ekranem w punkcie, w którym skoñczy³o siê ostatnio malowanie :-). ¯eby ponownie u¿yæ tego pêdzla, musimy go przesun¹æ tam, gdzie chcemy teraz rysowaæ. S³u¿y do tego funkcja PrzenieœPêdzel, tfu, <SPAN CLASS=T>MoveToEx</SPAN> :-). Jako parametry podajemy: <SPAN CLASS=T>HDC</SPAN>, nowe wspó³rzêdne, adres bufora, w którym zapamiêtane zostan¹ stare wspó³rzêdne (na wypadek, gdybyœmy kiedyœ jeszcze mieli z nich skorzystaæ). Bufor ten musi byæ typu <SPAN CLASS=T>POINT</SPAN>. 
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
POINT stary_punkt;<BR>
MoveToEx(hdcOkno, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>, &stary_punkt);<BR>
</TD></TR>
</TABLE>

<P>
Przenieœliœmy nasz pêdzel na pozycjê (<SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>). Poprzednia pozycja pêdzla zosta³a zapamiêtana w zmiennej <SPAN CLASS=T>stary_punkt</SPAN>. Po skoñczonym rysowaniu mo¿emy przenieœæ pêdzel z powrotem na star¹ pozycjê, ale nie bêdziemy siê a¿ tak fatygowaæ :-). 
</P>

<H3>
3.2.3 Funkcja LineTo
</H3>

<P>
Pora wreszcie narysowaæ nasz¹ liniê. Zatrudnimy w tym celu funkcjê <SPAN CLASS=T>LineTo</SPAN>, rysuj¹c¹ liniê od domyœlnej pozycji startowej do podanego punktu. Niestety, ktoœ skopa³ robotê i ostatni piksel nie jest rysowany, wiêc zawsze musimy podawaæ wiêksze wspó³rzêdne, ni¿ wskazuje intuicja. Wiocha, ale có¿ poradziæ... :-/
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LineTo(hdcOkno, <SPAN CLASS=L>21</SPAN>, <SPAN CLASS=L>10</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
No i jest linia - rozci¹ga siê od punktu (<SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>) a¿ do punktu (<SPAN CLASS=L>20</SPAN>, <SPAN CLASS=L>10</SPAN>) :-). Pewnie siê dziwisz, dlaczego poda³em <SPAN CLASS=L>10</SPAN>, a nie <SPAN CLASS=L>11</SPAN> (a mówi³em wczeœniej, ¿e wspó³rzêdne maj¹ byæ wiêksze). No i tutaj w³aœnie wychodzi niekompetencja cz³owieka odpowiedzialnego za stworzenie funkcji <SPAN CLASS=T>LineTo</SPAN> :-P. Jak wspomnia³em wy¿ej, ostatni piksel nie jest rysowany, wiêc gdybyœmy podali jako punkt koñcowy (<SPAN CLASS=L>21</SPAN>, <SPAN CLASS=L>11</SPAN>), to nie zosta³by narysowany punkt o wspó³rzêdnych (<SPAN CLASS=L>21</SPAN>, <SPAN CLASS=L>11</SPAN>), czyli rysowanie skoñczy³oby siê na (<SPAN CLASS=L>20</SPAN>, <SPAN CLASS=L>11</SPAN>). Trochê pokrêcone... Mówi³em, ¿e wiocha :-P.
</P>

<H3>
3.2.4 Tworzenie pióra
</H3>

<P>
Jeœli nie jesteœ akurat daltonist¹, a twój monitor dzia³a sprawnie i ma normalne ustawienia jasnoœci i kontrastu, to pewnie zauwa¿y³eœ, ¿e linia jest czarna :-). Co zrobiæ, aby by³a np. czerwona? Mo¿na poprzestawiaæ kabelki w monitorze, ale jeszcze lepiej po prostu powiedzieæ Windowsowi, ¿eby rysowa³ na czerwono, a nie na czarno. Mo¿esz jednak zapomnieæ o jakiejœ prostej funkcji typu SetColor. Twórcy Windowsa wykombinowali sobie, ¿eby jedn¹ funkcj¹ ustawiaæ nie tylko kolor, ale i wzór pióra, którym rysujemy. Nie wziêli chyba pod uwagê, ¿e cokolwiek rzadko korzysta siê z innych wzorów, ni¿ domyœlny, ale to ju¿ szczegó³ :-/. Linie rysuje siê piórem, dlatego musimy sobie takowe stworzyæ - pióro to inaczej obiekt typu <SPAN CLASS=T>HPEN</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HPEN CzerwonePioro;<BR>
CzerwonePioro = CreatePen(PS_SOLID, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x0000FF</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>CreatePen</SPAN>, czyli nasza podrêczna fabryka piór, ma trzy argumenty. Pierwszy z nich to styl pióra. Zazwyczaj chcemy rysowaæ linie proste, wtedy u¿ywamy (jak wy¿ej) <SPAN CLASS=T>PS_SOLID</SPAN>. Inne style pióra to np. <SPAN CLASS=T>PS_DOT</SPAN> (linia przerywana) lub <SPAN CLASS=T>PS_DASH</SPAN> (te¿ przerywana, ale d³u¿sze kreski). Drugi parametr to gruboœæ linii w pikselach. Wreszcie trzeci to kod koloru, jaki ma mieæ nasz pêdzel. Jest on podany w postaci szesnastkowej. Nie mo¿na by by³o w dziesi¹tkowej? Ano mo¿na by by³o, ale jeœli zrobimy to w hexach, ³atwiej bêdzie rozszyfrowaæ ten kolor, bowiem jest on w formacie <SPAN CLASS=Wazne>BBGGRR</SPAN>. Tak wiêc <SPAN CLASS=L>0x0000FF</SPAN> oznacza, ¿e bierzemy <SPAN CLASS=L>FF</SPAN> (czyli <SPAN CLASS=L>255</SPAN>) czerwonego, <SPAN CLASS=L>0</SPAN> zielonego i <SPAN CLASS=L>0</SPAN> niebieskiego koloru - w ten sposób powstaje kolor czerwony. Mo¿esz sprawdziæ w Paincie :-). Na tej samej zasadzie mo¿emy zrobiæ kolor zielony - <SPAN CLASS=L>0x00FF00</SPAN>, bia³y - <SPAN CLASS=L>0xFFFFFF</SPAN>, szary - <SPAN CLASS=L>0x808080</SPAN> itp.
</P>

<H3>
3.2.5 Wybór pióra
</H3>

<P>
Mamy ju¿ stworzony pêdzel, ale to dopiero po³owa sukcesu :-). Bo widzisz, jeœli artysta grafik ma w pude³ku choæby i piêædziesi¹t piór, to i tak nic nie narysuje, dopóki nie weŸmie jednego do rêki :-). Aby wzi¹æ pióro w ³apê, u¿ywamy funkcji <SPAN CLASS=T>SelectObject</SPAN>, s³u¿¹cej do przypisywania danemu kontekstowi danego obiektu GDI:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SelectObject(hdcOkno, CzerwonePioro);<BR>
</TD></TR>
</TABLE>

<P>
...i ju¿ od tej pory wszystko, co narysujemy na <SPAN CLASS=T>hdcOkno</SPAN>, bêdzie narysowane na czerwono :-). Oczywiœcie chodzi o te fragmenty rysunku, do których u¿ywa siê pióra, czyli o wszelkie kontury. Ale to nie wszystko. Przecie¿ ¿eby wzi¹æ pióro, musimy mieæ woln¹ rêkê, natomiast windowsowy malarz zawsze trzyma jakieœ pióro w ³apie! Ju¿ sprawdziliœmy w praktyce, ¿e wczeœniej trzyma³ czarne, wiêc musimy je najpierw gdzieœ wyrzuciæ :-). Tworzymy wiêc nowe pude³ko na to "stare", czarne pióro:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HPEN Pudelko; <SPAN CLASS=C>// :-)</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>SelectObject</SPAN> zwraca nam obiekt danego typu, który wczeœniej by³ przypisany do danego <SPAN CLASS=T>HDC</SPAN>. Na przyk³ad jeœli u¿yjemy <SPAN CLASS=T>SelectObject</SPAN> do przypisania do okienka nowego, czerwonego pióra, funkcja zwróci uchwyt do starego (czarnego) pióra. £apiemy wiêc stare pióro za ten uchwyt i wrzucamy do naszego pude³ka :-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Pudelko = (HPEN)SelectObject(hdcOkno, CzerwonePioro);<BR>
</TD></TR>
</TABLE>

<P>
Musieliœmy tu dokonaæ konwersji do typu <SPAN CLASS=T>HPEN</SPAN>, poniewa¿ funkcja <SPAN CLASS=T>SelectObject</SPAN> operuje na ró¿nych typach obiektów, nie tylko <SPAN CLASS=T>HPEN</SPAN>.
</P>

<H3>
3.2.6 Niszczenie pióra
</H3>

<P>
Po co malarzowi zu¿yte pióro? Tylko miejsce zajmuje w pracowni. A wiêc skoro skoñczyliœmy rysowanie, musimy zniszczyæ stworzone pióra na amen :-). Wprawdzie windowsowe pióra nie zu¿ywaj¹ siê, ale zasoby systemowe - owszem, tak. Dlatego pod koniec procedury rysuj¹cej warto zrobiæ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DeleteObject(CzerwonePioro);<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie nie wolno nam niszczyæ pióra, który jeszcze jest w rêce malarza, gdy¿ mog³oby to malarzowi wielce zaszkodziæ :-). Pióro trzeba najpierw wyrzuciæ. Poniewa¿ zaœ windowsowy malarz musi ci¹gle trzymaæ jakieœ piórko w rêce, dajemy mu to czarne, które wczeœniej wrzuciliœmy do pude³ka:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SelectObject(hdcOkno, Pudelko);<BR>
DeleteObject(CzerwonePioro);<BR>
</TD></TR>
</TABLE>

<H3>
3.2.7 Kompletny schemat rysowania linii
</H3>

<P>
No to zbierzmy wszystko do kupy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcOkno = GetDC(hwnd);<BR>
HPEN CzerwonePioro, Pudelko;<BR>
POINT stary;<BR>
CzerwonePioro = CreatePen(PS_SOLID, <SPAN CLASS=T>1</SPAN>, <SPAN CLASS=L>0x0000FF</SPAN>);<BR>
Pudelko = (HPEN)SelectObject(hdcOkno, CzerwonePioro);<BR>
MoveToEx(hdcOkno, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>, &stary);<BR>
LineTo(hDC, <SPAN CLASS=L>21</SPAN>, <SPAN CLASS=L>10</SPAN>);<BR>
SelectObject(hdcOkno, Pudelko);<BR>
DeleteObject(CzerwonePioro);<BR>
ReleaseDC(hwnd, hdcOkno);<BR>
</TD></TR>
</TABLE>

<P>
Uff, jest tego trochê... Tyle zachodu, ¿eby jedn¹ krótk¹ liniê narysowaæ! Ale za to jeœli teraz bêdziemy chcieli dorysowaæ drug¹ liniê, wystarczy dorzuciæ dodatkow¹ instrukcjê <SPAN CLASS=T>LineTo</SPAN>. Oczywiœcie, jeœli zamarzymy sobie, ¿e druga linia ma byæ zielona, trzeba bêdzie stworzyæ dodatkowe, zielone pióro:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcOkno = GetDC(hwnd);<BR>
HPEN PioroCzerw, PioroZiel, Pudelko;<BR>
POINT stary;<BR>
PioroCzerw = CreatePen(PS_SOLID, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x0000FF</SPAN>);<BR>
PioroZiel = CreatePen(PS_SOLID, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x00FF00</SPAN>);<BR>
Pudelko = (HPEN)SelectObject(hdcOkno, PioroCzerw);<BR>
MoveToEx(hdcOkno, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>, &stary);<BR>
LineTo(hDC, <SPAN CLASS=L>21</SPAN>, <SPAN CLASS=L>10</SPAN>);<BR>
SelectObject(hdcOkno, PioroZiel);<BR>
LineTo(hDC, <SPAN CLASS=L>31</SPAN>, <SPAN CLASS=L>10</SPAN>);<BR>
SelectObject(hdcOkno, Pudelko);<BR>
DeleteObject(PioroCzerw);<BR>
DeleteObject(PioroZiel);<BR>
ReleaseDC(hwnd, hdcOkno);<BR>
</TD></TR>
</TABLE>

<P>
Zauwa¿, ¿e przypisanie zielonego pióra nie wymaga ju¿ "wyrzucania do pude³ka" czerwonego. Nie mia³oby to wiêkszego sensu, bowiem uchwyt do czerwonego pióra ju¿ przecie¿ mamy. Tylko kiedy wybieramy piórko po raz pierwszy, musimy uzyskaæ uchwyt do domyœlnego "starego" (czarnego) pióra, które u¿ywane by³o wczeœniej, zanim nasza aplikacja zosta³a uruchomiona.
</P>
<P>
Linia zielona zostanie narysowana od punktu, na którym skoñczyliœmy rysowanie czerwonej, do punktu (<SPAN CLASS=L>30</SPAN>,<SPAN CLASS=L>10</SPAN>). Jeœli chcemy zacz¹æ rysowanie zielonej z innego punktu, musimy dopisaæ dodatkow¹ instrukcjê <SPAN CLASS=T>MoveToEx</SPAN>.
</P>
<P>
Aha, jeszcze jedno. Powinno to byæ oczywiste, ale rysowaæ mo¿emy tylko po istniej¹cym i widzialnym oknie, a wiêc powy¿szy kod umieszczamy PO instrukcjach <SPAN CLASS=T>CreateWindowEx</SPAN> (tworz¹cej nasze okno) i <SPAN CLASS=T>ShowWindow</SPAN> (czyni¹cej je widzialnym). Nie próbuj te¿ wstawiaæ tego kodu w inne funkcje, ni¿ <SPAN CLASS=T>WinMain</SPAN> (bo nasz <SPAN CLASS=T>hwnd</SPAN> jest tam niewidoczny, chyba ¿e stworzysz specjaln¹ oddzieln¹ zmienn¹ typu <SPAN CLASS=T>HWND</SPAN>), a zw³aszcza nie próbuj dodawaæ kodu w takiej postaci do obs³ugi komunikatu <SPAN CLASS=T>WM_PAINT</SPAN> (dlaczego - o tym kiedy indziej).
</P>

<H3>
3.2.8 £atwiejsze definiowanie kolorów
</H3>

<P>
Podawanie numerów kolorów w postaci szesnastkowej jest ca³kiem niez³ym sposobem, jeœli umiemy w locie przeliczaæ liczby z systemu dziesi¹tkowego. Jeœli akurat nie umiemy, a nie mamy pod rêk¹ odpowiedniego programiku (albo nam siê nie chce go w³¹czaæ), mo¿na jeszcze skorzystaæ z makra <SPAN CLASS=T>RGB</SPAN> do utworzenia ¿¹danego koloru. <SPAN CLASS=T>RGB</SPAN> ma trzy argumenty, oznaczaj¹ce iloœæ sk³adnika czerwonego, zielonego i niebieskiego, jaki u¿ywamy do stworzenia naszego nowego koloru. I tak na przyk³ad <SPAN CLASS=T>RGB(<SPAN CLASS=L>255</SPAN>,&nbsp;<SPAN CLASS=L>255</SPAN>,&nbsp;<SPAN CLASS=L>255</SPAN>)</SPAN> zwraca nam kolor bia³y, a <SPAN CLASS=T>RGB(<SPAN CLASS=L>0</SPAN>,&nbsp;<SPAN CLASS=L>0</SPAN>,&nbsp;<SPAN CLASS=L>0</SPAN>)</SPAN> - czarny. Zwracana wartoœæ jest typu <SPAN CLASS=T>COLORREF</SPAN>. Oto przyk³ad tworzenia zielonego pióra za pomoc¹ <SPAN CLASS=T>RGB</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
PioroZiel = CreatePen(PS_SOLID, <SPAN CLASS=L>1</SPAN>, RGB(<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>255</SPAN>, <SPAN CLASS=L>0</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
Mamy jeszcze dodatkowe trzy makra, dziêki którym z konkretnego koloru mo¿emy "wyci¹gn¹æ", ile jest w nim czerwonego, zielonego i niebieskiego sk³adnika. S¹ to odpowiednio: <SPAN CLASS=T>GetRValue</SPAN>, <SPAN CLASS=T>GetGValue</SPAN>, <SPAN CLASS=T>GetBValue</SPAN>.
</P>

<H2>
3.3 Figury geometryczne
</H2>

<P>
Dysponuj¹c funkcj¹ rysuj¹c¹ linie, mo¿emy sobie stworzyæ np. prostok¹t, jednak by³oby to Ÿdziebko niewygodne :-). Po co siê mêczyæ, WinAPI ma ca³y zestaw funkcji do rysowania figur...
</P>

<H3>
3.3.1 Prostok¹ty
</H3>

<P>
Funkcja <SPAN CLASS=T>Rectangle</SPAN> s³u¿y do rysowania prostok¹tów, jak sama nazwa wskazuje :-). Ramka takiego prostok¹ta jest rysowana aktualnym piórem (podobnie jak linie w poprzednim rozdziale), a reszta - wype³niana za pomoc¹ aktualnego pêdzla (brush). Narysujemy sobie œliczny, zielony kwadracik z czerwon¹, przerywan¹ ramk¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcOkno = GetDC(hwnd);<BR>
HBRUSH PedzelZiel, Pudelko;<BR>
HPEN OlowekCzerw, Piornik;<BR>
PedzelZiel = CreateSolidBrush(<SPAN CLASS=L>0x00FF00</SPAN>);<BR>
OlowekCzerw = CreatePen(PS_DOT, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x0000FF</SPAN>);<BR>
Pudelko = (HBRUSH)SelectObject(hdcOkno, PedzelZiel);<BR>
Piornik = (HPEN)SelectObject(hdcOkno, OlowekCzerw);<BR>
Rectangle(hdcOkno, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>100</SPAN>);<BR>
SelectObject(hdcOkno, Pudelko);<BR>
SelectObject(hdcOkno, Piornik);<BR>
DeleteObject(OlowekCzerw);<BR>
DeleteObject(PedzelZiel);<BR>
ReleaseDC(hwnd, hdcOkno);<BR>
</TD></TR>
</TABLE>

<P>
Poniewa¿ chcemy narysowaæ kwadracik dok³adnie wype³niony kolorem zielonym, u¿yliœmy funkcji <SPAN CLASS=T>CreateSolidBrush</SPAN>. Dziêki temu nasz pêdzelek rysuje na ca³ym podanym obszarze bez odrywania siê od powierzchni :-). Gdybyœmy chcieli tym pêdzelkiem wymalowaæ kwadracik zakreskowany, skorzystamy z funkcji CreateHatchBrush, natomiast jeœli bêdziemy chcieli narysowaæ prostok¹t w ciapki, i to w³aœnie takie ciapki, jakie wczeœniej sobie opracowaliœmy, u¿yjemy funkcji <SPAN CLASS=T>CreatePatternBrush</SPAN>, podaj¹c jej jako argument uchwyt do bitmapy z ciapkami :-). Na razie jednak chcemy zwyk³e, pe³ne t³o, wiêc piszemy <SPAN CLASS=T>CreateSolidBrush</SPAN>.
</P>
<P>
Zauwa¿, ¿e funkcja <SPAN CLASS=T>Rectangle</SPAN> pobiera równie¿ wspó³rzêdne punktu, od którego zaczynamy rysowaæ nasz prostok¹t, a wiêc nie rysujemy od ostatniej, domyœlnej pozycji. Poza tym ta ostatnia pozycja po narysowaniu prostok¹ta nie zmienia siê, wiêc przy rysowaniu prostok¹tów u¿ywanie <SPAN CLASS=T>MoveToEx</SPAN> jest bez sensu.
<P>

<H3>
3.3.2 Ko³a i elipsy
</H3>

<P>
Dziêki funkcji <SPAN CLASS=T>Ellipse</SPAN> mo¿emy sobie, jak sama nazwa znów wskazuje, namalowaæ elipsê. Rysowanie odbywa siê (tak jak w przypadku prostok¹ta) przy u¿yciu aktualnie wybranego pióra (obwódka) i pêdzla (wype³nianie wnêtrza figury). Parametry funkcji to: uchwyt okna oraz kolejne cztery wspó³rzêdne prostok¹ta, opisanego na elipsie, któr¹ chcemy narysowaæ. Oczywiœcie, jeœli podane wspó³rzêdne bêd¹ opisywaæ kwadrat, narysowana elipsa bêdzie ko³em, i o to nam zreszt¹ najczêœciej chodzi: 
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcOkno = GetDC(hwnd);<BR>
HBRUSH PedzelZiel, Pudelko;<BR>
HPEN OlowekCzerw, Piornik;<BR>
PedzelZiel = CreateSolidBrush(<SPAN CLASS=L>0x00FF00</SPAN>);<BR>
OlowekCzerw = CreatePen(PS_DOT, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x0000FF</SPAN>);<BR>
Pudelko = (HBRUSH)SelectObject(hdcOkno, PedzelZiel);<BR>
Piornik = (HPEN)SelectObject(hdcOkno, OlowekCzerw);<BR>
Ellipse(hdcOkno, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>10</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>100</SPAN>);<BR>
SelectObject(hdcOkno, Pudelko);<BR>
SelectObject(hdcOkno, Piornik);<BR>
DeleteObject(OlowekCzerw);<BR>
DeleteObject(PedzelZiel);<BR>
ReleaseDC(hwnd, hdcOkno);<BR>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="..\gfx\apigfx1.gif" ALT="Fajne kó³ko?">
</P>

<H3>
3.3.3 Wielok¹ty
</H3>

<P>
Warto by jeszcze wiedzieæ, jak siê rysuje wielok¹ty. Jeœli zale¿y nam tylko na niewype³nionych wielok¹tach (same kontury), to mo¿emy skorzystaæ z funkcji <SPAN CLASS=T>Polyline</SPAN>. Jeœli zaœ u¿yjemy funkcji <SPAN CLASS=T>Polygon</SPAN>, to figura powsta³a przez po³¹czenie podanych przez nas punktów zostanie dodatkowo wype³niona przy pomocy aktualnego pêdzla. Obydwie te funkcje wymagaj¹ podania tablicy punktów (wierzcho³ków wielok¹ta). Musi to byæ talica o elementach typu <SPAN CLASS=T>POINT</SPAN>. Struktura <SPAN CLASS=T>POINT</SPAN> jest wyj¹tkowo prosta, ma tylko dwie sk³adowe: <SPAN CLASS=T>x</SPAN> i <SPAN CLASS=T>y</SPAN>. Jako jeden z argumentów funkcji <SPAN CLASS=T>Polygon</SPAN> (i <SPAN CLASS=T>Polyline</SPAN>) podajemy te¿ liczbê wierzcho³ków, które bierzemy pod uwagê (zazwyczaj jest to po prostu liczba elementów tablicy). Poni¿szy przyk³ad pokazuje, jak narysowaæ tak¹ œmieszn¹ gwiazdkê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//Robimy tablicê wspó³rzêdnych wierzcho³ków</SPAN><BR>
POINT Wierzch[<SPAN CLASS=L>5</SPAN>];<BR>
Wierzch[<SPAN CLASS=L>0</SPAN>].x = <SPAN CLASS=L>50</SPAN>; Wierzch[<SPAN CLASS=L>0</SPAN>].y = <SPAN CLASS=L>0</SPAN>;<BR>
Wierzch[<SPAN CLASS=L>1</SPAN>].x = <SPAN CLASS=L>25</SPAN>;  Wierzch[<SPAN CLASS=L>1</SPAN>].y = <SPAN CLASS=L>100</SPAN>;<BR>
Wierzch[<SPAN CLASS=L>2</SPAN>].x = <SPAN CLASS=L>100</SPAN>; Wierzch[<SPAN CLASS=L>2</SPAN>].y = <SPAN CLASS=L>50</SPAN>;<BR>
Wierzch[<SPAN CLASS=L>3</SPAN>].x = <SPAN CLASS=L>0</SPAN>; Wierzch[<SPAN CLASS=L>3</SPAN>].y = <SPAN CLASS=L>50</SPAN>;<BR>
Wierzch[<SPAN CLASS=L>4</SPAN>].x = <SPAN CLASS=L>75</SPAN>; Wierzch[<SPAN CLASS=L>4</SPAN>].y = <SPAN CLASS=L>100</SPAN>;<BR>
<BR>
<SPAN CLASS=C>//Przygotowujemy wszystko do rysowania</SPAN><BR>
HDC hdc = GetDC(hwnd);<BR>
HBRUSH Pedzel, Pudelko;<BR>
HPEN Pioro, Piornik;<BR>
Pedzel = CreateSolidBrush(<SPAN CLASS=L>0x00FFFF</SPAN>);<BR>
Pioro = CreatePen(PS_SOLID, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>0x000000</SPAN>);<BR>
Pudelko = (HBRUSH)SelectObject(hdc, Pedzel);<BR>
Piornik = (HPEN)SelectObject(hdc, Pioro);<BR>
<BR>
<SPAN CLASS=C>//Wywalamy nasz¹ gwiazdê na ekran</SPAN><BR>
Polygon(hdc, Wierzch, <SPAN CLASS=L>5</SPAN>);<BR>
<BR>
<SPAN CLASS=C>//...i sprz¹tamy po sobie</SPAN><BR>
SelectObject(hdc, Pudelko);<BR>
SelectObject(hdc, Piornik);<BR>
DeleteObject(Pioro);<BR>
DeleteObject(Pedzel);<BR>
ReleaseDC(hwnd, hdc);<BR>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="..\gfx\apigfx2.gif" ALT="Dosyæ niezgrabne, ale te¿ fajne ;-)">
</P>

<P>
Dobra, tyle funkcji rysuj¹cych figury starczy na pocz¹tek. Pozosta³e, jeœli bêdziesz ich potrzebowa³, mo¿esz sobie znaleŸæ np. w MSDN. 
</P>

<H3>
3.3.4 Pojedyncze punkty
</H3>

<P>
Jeœli chcemy narysowaæ coœ bardziej skomplikowanego, ni¿ tylko prosta figura, bêdziemy potrzebowali funkcji, ustawiaj¹cej kolor pojedynczego pixela. Nazywa siê ona <SPAN CLASS=T>SetPixel</SPAN>, a jej parametry to: <SPAN CLASS=T>HDC</SPAN>, wspó³rzêdne <SPAN CLASS=T>x</SPAN> i <SPAN CLASS=T>y</SPAN>, kolor. Wykorzystuj¹c tê funkcjê mo¿emy sobie np. narysowaæ graffiti przy pomocy spray'u ;-). Póki co jednak, warto by ten spray najpierw wypróbowaæ, wiêc narysujemy sobie nim tylko zwyk³e kó³ko. Aby kszta³t naszej nasprayowanej figury przypomina³ ko³o, wykorzystamy równanie ko³a, znane wiêkszoœci z was z matematyki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdlib.h&gt;</SPAN><BR>
<BR>
HDC hdc = GetDC(hwnd);<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> y=<SPAN CLASS=L>0</SPAN>; y&lt;<SPAN CLASS=L>150</SPAN>; y++)<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>0</SPAN>; x&lt;<SPAN CLASS=L>150</SPAN>; x++)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>((x-<SPAN CLASS=L>75</SPAN>)*(x-<SPAN CLASS=L>75</SPAN>)+(y-<SPAN CLASS=L>75</SPAN>)*(y-<SPAN CLASS=L>75</SPAN>)<<SPAN CLASS=L>75</SPAN>*<SPAN CLASS=L>75</SPAN> && rand()%<SPAN CLASS=L>2</SPAN>==<SPAN CLASS=L>1</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;SetPixel(hdc, x, y, <SPAN CLASS=L>0x000000FF</SPAN>);<BR>
ReleaseDC(hwnd, hdc);<BR>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="..\gfx\apigfx3.gif" ALT="Graffiti w WinAPI ;-)">
</P>

<P>
W przyk³adziku tym bierzemy sobie po kolei wszystkie punkty z kwadratu <SPAN CLASS=L>150</SPAN>x<SPAN CLASS=L>150</SPAN> pikseli, sprawdzamy czy dany punkt le¿y wewn¹trz ko³a i z prawdopodobieñstwem <SPAN CLASS=L>1:2</SPAN> (jeœli funkcja <SPAN CLASS=T>rand</SPAN> zwróci <SPAN CLASS=L>1</SPAN>) malujemy piksela na czerwono.
</P>
<P>
Kolorowanie ka¿dego z pikseli osobno daje nam wiele innych mo¿liwoœci, np. tak¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdc = GetDC(hwnd);<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> y=<SPAN CLASS=L>0</SPAN>; y&lt;<SPAN CLASS=L>150</SPAN>; y++)<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>0</SPAN>; x&lt;<SPAN CLASS=L>150</SPAN>; x++)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>((x-<SPAN CLASS=L>75</SPAN>)*(x-<SPAN CLASS=L>75</SPAN>)+(y-<SPAN CLASS=L>75</SPAN>)*(y-<SPAN CLASS=L>75</SPAN>)<<SPAN CLASS=L>75</SPAN>*<SPAN CLASS=L>75</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;SetPixel(hdc, x, y, RGB(x,<SPAN CLASS=L>0</SPAN>,<SPAN CLASS=L>200</SPAN>-x));<BR>
ReleaseDC(hwnd, hdc);<BR>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="..\gfx\apigfx4.gif" ALT="Niczego sobie to kó³eczko...">
</P>

<P>
Uzyskaliœmy w ten sposób efekt przejœcia od jednego koloru do drugiego. Gdybyœmy w makrze <SPAN CLASS=T>RGB</SPAN> podali zmienn¹ <SPAN CLASS=T>y</SPAN> zamiast <SPAN CLASS=T>x</SPAN>, to uzyskalibyœmy takie samo przejœcie, tylko w pionie. Oczywiœcie efekt taki dla obszarów wiêkszych ni¿ <SPAN CLASS=L>255</SPAN> pikseli trochê trudniej zaprogramowaæ, a jeszcze trudniej jeœli chcemy uzyskaæ przejœcie miêdzy dwoma konkretnymi kolorami, dowolnie wybranymi z palety, ale wszystko jest do zrobienia jeœli siê trochê pomyœli ;-).
</P>
<P>
I to wszystko jeœli chodzi o rysowanie najprostszych kszta³tów...
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apifile.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apibmp.html">Nastêpna czêœæ kursu >></A>
</TD>
</TR>
</TABLE>

</HTML>
