<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Bitmapy</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apigraf.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apianim.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
4. Bitmapy w WinAPI
</H1>

<P>
Funkcje rysuj¹ce WinAPI przydaj¹ siê, kiedy trzeba dorysowaæ gdzieœ jak¹œ liniê rozdzielaj¹c¹ dwie grupy kontrolek albo coœ w tym rodzaju. Trudno jednak przy ich pomocy stworzyæ np. grê (chocia¿ nie jest to niemo¿liwe, czego dowodem mój WinRobak - znajdziesz go w dziale Download). Do takich celów przydadz¹ nam siê "zewnêtrzne" pliki graficzne, czyli grafika, któr¹ przygotowaliœmy sobie wczeœniej i zapisaliœmy w jakimœ pliku. Na dobry pocz¹tek najlepiej zaznajomiæ siê z najprostszym z mo¿liwych i najpopularniejszym formatem graficznym - standardow¹ bitmap¹ Windows, czyli BMP. Spróbujmy obrazek z takiego pliku wyœwietliæ na ekranie.
</P>

<H2>
4.1 £adowanie bitmapy z pliku
</H2>

<P>
Za³ó¿my, ¿e mamy ju¿ jakiœ obrazek w pliku BMP, stworzony np. w programiku Paint. ¯eby go u¿yæ,  musimy go wprzódy skopiowaæ do pamiêci. Bitmapami przechowywanymi w pamiêci manipulujemy, korzystaj¹c z uchwytów typu <SPAN CLASS=T>HBITMAP</SPAN>, a ¿eby wczytaæ bitmapê i uzyskaæ do niej taki uchwyt, stosujemy funkcyjkê <SPAN CLASS=T>LoadImage</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmObraz;<BR>
hbmObraz = (HBITMAP)LoadImage(NULL, <SPAN CLASS=L>"c:\\sciezka\\plik.bmp"</SPAN>, IMAGE_BITMAP, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, LR_LOADFROMFILE);<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, lista argumentów jest doœæ d³uga, ale wiêkszoœæ to taki pic na wodê - wa¿na jest w sumie tylko œcie¿ka dostêpu do pliku BMP. Pierwszy argument pomijamy, wykorzystuje siê go tylko przy wczytywaniu bitmap z pliku wykonywalnego naszego programu. Trzeci argument dla bitmap BMP  powinien wynosiæ <SPAN CLASS=T>IMAGE_BITMAP</SPAN> (zaœ dla kursorów i ikon odpowiednio <SPAN CLASS=T>IMAGE_CURSOR</SPAN> lub <SPAN CLASS=T>IMAGE_ICON</SPAN>), ostatni argument to flagi, w wiêkszoœci przypadków wpisujemy tam <SPAN CLASS=T>LR_LOADFROMFILE</SPAN>. Argumenty, które w naszym przyk³adzie s¹ równe <SPAN CLASS=L>0</SPAN> to wymiary obrazka - zera oznaczaj¹ wczytanie domyœlnych wymiarów z pliku BMP.
</P>

<P>
Jeœli mamy nasz¹ bitmapê wyœwietliæ na ekranie monitora, to musimy j¹ skopiowaæ na <SPAN CLASS=T>HDC</SPAN> okna. WinAPI posiada tak¹ jedn¹ fajn¹ funkcjê, <SPAN CLASS=T>BitBlt</SPAN> - potrafi ona przenosiæ bitmapy z kontekstu na kontekst. Ba, tylko sk¹d wytrzasn¹æ kontekst, z którego kopiujemy nasz¹ bitmapkê, bo uzyskanie tego drugiego <SPAN CLASS=T>HDC</SPAN>, od okna, nie jest zbyt wielkim problemem? Ano, mo¿emy sobie taki kontekst sami stworzyæ, po czym przypisaæ mu wczytan¹ w³aœnie z pliku bitmapê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HDC hdcNowy = CreateCompatibleDC(hdc);<BR>
SelectObject(hdcNowy, hbmObraz);<BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>CreateCompatibleDC</SPAN>, jak sama nazwa wskazuje, tworzy <SPAN CLASS=T>HDC</SPAN> kompatybilny z podanym. W wiêkszoœci przypadków nie musimy nawet podawaæ tego <SPAN CLASS=T>hdc</SPAN> jako argumentu; wtedy funkcja utworzy <SPAN CLASS=T>HDC</SPAN> kompatybilne z "bie¿¹cym ekranem aplikacji" (cokolwiek by ten cytat z MSDN nie znaczy³, podanie <SPAN CLASS=T>NULL</SPAN> zamiast argumentu zazwyczaj daje po¿¹dane efekty).
</P>
<P>
Jest jeszcze ma³y haczyk. Ka¿dy <SPAN CLASS=T>HDC</SPAN> ma przypisan¹ domyœln¹ bitmapê, któr¹ póŸniej dobrze jest mu "oddaæ". Wielu programistów z czystego lenistwa upraszcza sobie proces pisania aplikacji, no i póŸniej ludzie skar¿¹ siê na Billa, ¿e Windows siê zawiesza... A Bill, chocia¿ czystego sumienia niew¹tpliwie nie ma, to jednak pewnie nie jest te¿ winien nawet po³owy zarzucanych mu rzeczy :-). Tak czy siak, my sobie elegancko zapamiêtamy domyœln¹ bitmapê i póŸniej j¹ zwrócimy tu¿ przed skasowaniem naszego <SPAN CLASS=T>HDC</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmOld = (HBITMAP)SelectObject(hdcNowy, hbmObraz);<BR>
<SPAN CLASS=C>//...<BR>
//coœ tam<BR>
//...<BR></SPAN>
SelectObject(hdcNowy, hbmOld);<BR>
DeleteDC(hdcNowy);<BR>
</TD></TR>
</TABLE>

<H2>
4.2 Funkcja BitBlt w natarciu
</H2>

<P>
Mamy bitmapê w pamiêci, mamy <SPAN CLASS=T>HDC</SPAN> - bazê wypadow¹ dla owej bitmapy, pora rozpocz¹æ akcjê o kryptonimie "Rysowanie Bitmapy". Wspomnia³em wczeœniej o funkcji <SPAN CLASS=T>BitBlt</SPAN> (skrót od "bit block transfer"). Ma ona doœæ d³ugi wykaz argumentów - a¿ 9, ale szybko je pewnie zapamiêtasz, bo jest to jedna z "najpopularniejszych" funkcji w ca³ym WinAPI. <SPAN CLASS=T>BitBlt</SPAN> s³u¿y do kopiowania bitmap (ca³ych lub tylko fragmentów) pomiêdzy dwoma kontekstami, przy czym dodatkowo mo¿e wykonywaæ na nich <SPAN CLASS=Wazne>operacje rastrowe</SPAN>, a wiêc mo¿na j¹ wykorzystaæ tak¿e do rysowania <SPAN CLASS=Wazne>maski</SPAN> (o tym póŸniej). Oto  sk³adnia i znaczenie kolejnych argumentów:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: BitBlt(<I>hdcDest, nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, dwRop</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hdcDest</I></TD><TD CLASS=ARGLIST>HDC docelowe (np. HDC okna, na którym rysujemy)</TD></TR>
<TR><TD CLASS=ARGLIST><I>nXDest, nYDest</I></TD><TD CLASS=ARGLIST>Wspó³rzêdne docelowe</TD></TR>
<TR><TD CLASS=ARGLIST><I>nWidth, nHeight</I></TD><TD CLASS=ARGLIST>Wymiary obrazka</TD></TR>
<TR><TD CLASS=ARGLIST><I>hdcSrc</I></TD><TD CLASS=ARGLIST>HDC Ÿród³owe</TD></TR>
<TR><TD CLASS=ARGLIST><I>nXSrc, nYSrc</I></TD><TD CLASS=ARGLIST>Wspó³rzêdne Ÿród³owe (zazwyczaj równe 0)</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwRop</I></TD><TD CLASS=ARGLIST>Kod operacji rastrowej</TD></TR>
</TABLE>

<P>
Chyba nie trzeba tu nic omawiaæ, za wyj¹tkiem ostatniego argumentu. Kod operacji rastrowej okreœla transformacjê, jak¹ wykonujemy na bitach bitmapy. Oto najczêœciej stosowane operacje:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST>SRCCOPY</TD><TD CLASS=ARGLIST>po prostu kopiuje bity, nie wykonuj¹c na nich ¿adneej operacji (najczêœciej stosowane)</TD></TR>
<TR><TD CLASS=ARGLIST>SRCINVERT</TD><TD CLASS=ARGLIST>odwraca bity przy u¿yciu operatora XOR</TD></TR>
<TR><TD CLASS=ARGLIST>SRCPAINT</TD><TD CLASS=ARGLIST>tworzy kombinacjê bitów przy u¿yciu operatora OR</TD></TR>
<TR><TD CLASS=ARGLIST>SRCAND</TD><TD CLASS=ARGLIST>tworzy kombinacjê bitów przy u¿yciu operatora AND</TD></TR>
</TABLE>

<P>
Wci¹¿ nie wiesz, o co chodzi z tymi operacjami rastrowymi? Nic nie szkodzi, nie musisz ;-). Zazwyczaj bêdziemy korzystaæ z najprostszego SRCCOPY, dopiero kiedy dojdziemy do masek, wykorzystamy równie¿ pozosta³e trzy rodzaje operacji.
</P>
<P>
Zanim u¿yjemy funkcji <SPAN CLASS=T>BitBlt</SPAN> do narysowania bitmapy na naszym okienku, pozostaje tylko jeszcze pobraæ jej wymiary, bo przecie¿ musimy je podaæ jako argumenty do <SPAN CLASS=T>BitBlt</SPAN>. Za³ó¿my, ¿e nie znamy wymiarów obrazka, wiêc pos³u¿ymy siê celu ich zdobycia funkcj¹ o ma³o trafnej nazwie <SPAN CLASS=T>GetObject</SPAN>. Ma³o trafnej, bo w istocie nie pobiera ona ¿adnego obiektu, a jedynie informacje o nim. Dla œcis³oœci w dodatku - stosuje siê j¹ tylko do obiektów graficznych. Funkcja <SPAN CLASS=T>GetObject</SPAN> pobiera uchwyt do obiektu, o którym chcemy uzyskaæ informacje, rozmiar (w bajtach) struktury, do której trafi¹ te informacje (oczywiœcie musimy tê strukturê najpierw utworzyæ) oraz adres tej struktury. W naszym przypadku struktura ta musi byæ typu <SPAN CLASS=T>BITMAP</SPAN> (nie myliæ z <SPAN CLASS=T>HBITMAP</SPAN>!):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BITMAP bmInfo;<BR>
GetObject(hmbObraz, sizeof(bmInfo), &bmInfo);<BR>
</TD></TR>
</TABLE>

<P>
Dziêki takiemu zabiegowi mamy wymiary naszego obrazka w polach <SPAN CLASS=T>bmInfo.bmWidth</SPAN> oraz <SPAN CLASS=T>bmInfo.bmHeight</SPAN>. Mo¿emy wiêc rysowaæ wreszcie bitmapê! Zak³adamy, ¿e zmienna <SPAN CLASS=T>hwnd</SPAN> zawiera uchwyt naszego g³ównego okna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
hdc = GetDC(hwnd);<BR>
BitBlt(hdc, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, bmInfo.bmWidth, bmInfo.bmHeight, hdcNowy, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
ReleaseDC(hwnd, hdc);<BR>
</TD></TR>
</TABLE>

<P>
I to wszystko! Mamy nasz obrazek na ekranie... 
</P>

<H2>
4.3 Porz¹dki
</H2>

<P>
¯eby nie zaœmieciæ systemu na œmieræ, kasujemy lub zwalniamy wszystko, coœmy potworzyli lub pobrali. Zaczynamy od zwolnienia <SPAN CLASS=T>HDC</SPAN> okna, po którym rysujemy (patrz przyk³ad powy¿ej) i usuniêcia bitmapy. Potem wywalamy w cholerê niepotrzebny ju¿ tymczasowy <SPAN CLASS=T>HDC</SPAN> - zauwa¿, ¿e usuwa siê go poleceniem <SPAN CLASS=T>DeleteDC</SPAN>, a nie <SPAN CLASS=T>ReleaseDC</SPAN> - to drugie stosuje siê tylko w przypadku <SPAN CLASS=T>HDC</SPAN> pobranego, to pierwsze - wobec <SPAN CLASS=T>HDC</SPAN> utworzonego przez u¿ytkownika funkcj¹ <SPAN CLASS=T>CreateCompatibleDC</SPAN>. Zanim wywo³amy <SPAN CLASS=T>DeleteDC</SPAN>, przywracamy mu jego domyœln¹ bitmapê, tak jak pokaza³em trochê wczeœniej. Na wszelki wypadek dorzucam przyk³ad poprawnego zwalniania zasobów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DeleteObject(hbmObraz); <SPAN CLASS=C>//kasowanie bitmapy</SPAN><BR>
SelectObject(hdcNowy, hbmOld); <SPAN CLASS=C>//przywróæ bitmapê domyœln¹</SPAN><BR>
DeleteDC(hdcNowy); <SPAN CLASS=C>//usuñ kontekst razem z jego domyœln¹ bitmap¹</SPAN><BR>
</TD></TR>
</TABLE>

<H2>
4.4 Przezroczyste bitmapy
</H2>

<P>
A co, jeœli chcemy narysowaæ jedn¹ bitmapê na drugiej, tak ¿eby ta na wierzchu mia³a przezroczyste t³o? Przy wykorzystaniu "go³ego" API nie jest to proste zadanie, ale nie przekracza bynajmniej naszych skromnych mo¿liwoœci. Potrzebujemy przede wszystkim tzw. maski, czyli oddzielnej, monochromatycznej (czarno-bia³ej) bitmapy, która jest bia³a we wszystkich miejscach, które chcemy by by³y przezroczyste, a czarna we wszystkich innych miejscach. Na razie musimy sobie tak¹ maskê utworzyæ sami. Oto ma³y przyk³adzik bitmapy i dorobionej do niej maski (tutaj s¹ w jednym pliku, a praktyce musz¹ byæ oddzielnie):
</P>
<P ALIGN=CENTER><IMG SRC="../gfx/mask.gif" ALT="Bitmapa i jej maska"></P>
<P>
Oczywiœcie wczytywanie bitmapy maski - nazwijmy sobie uchwyt do niej <SPAN CLASS=T>hbmMaska</SPAN> - pomijamy. Ta kolorowa bitmapa z obrazkiem, która ma mieæ przezroczyste t³o, równie¿ musi byæ utworzona w specjalny sposób, a mianowicie wszystkie piksele, które maj¹ byæ przezroczyste, rysujemy w niej na czarno - tak jak na rysunku powy¿ej. 
</P>
<P>
Jeœli obie bitmapy s¹ ju¿ gotowe, przystêpujemy do ich rysowania. Klucz do sukcesu to podwójne wywo³anie <SPAN CLASS=T>BitBlt</SPAN> z odpowiednimi kodami operacji - najpierw dla maski, potem dla w³aœciwego obrazka. Wykorzystamy do tego nasz tymczasowy <SPAN CLASS=T>HDC</SPAN>, czyli <SPAN CLASS=T>hdcNowy</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SelectObject(hdcNowy, hbmMaska);<BR>
BitBlt(hdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bmInfo.bmWidth, bmInfo.bmHeight, hdcNowy, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCAND);<BR>
SelectObject(hdcNowy, hbmObraz);<BR>
BitBlt(hdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bmInfo.bmWidth, bmInfo.bmHeight, hdcNowy, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCPAINT);<BR>
</TD></TR>
</TABLE>

<P>
Szczerze mówi¹c, nigdy jakoœ nie korci³o mnie, ¿eby zrozumieæ tajniki rz¹dz¹ce operacjami rastrowymi, wiêc nie mam bladego pojêcia, dlaczego powy¿szy kod dzia³a, jak Pan Bóg przykaza³ :-). Najwa¿niejsze, ¿e mimo wszystko dzia³a ;-).
</P>

<H2>
4.5 Procedura tworzenia maski
</H2>

<P>
"Rêczne" tworzenie masek jest ¿mudne, sprzyja pomy³kom, a przy tym jest raczej bezsensowne, skoro komputer mo¿e sobie tak¹ maskê stworzyæ sam. Wystarczy, ¿e we w³aœciwym obrazku zamalujemy przezroczyste miejsca specjalnym, tylko w tym celu u¿ytym kolorem, a komputer póŸniej znajdzie te miejsca i na tej podstawie sporz¹dzi maskê.
</P>
<P>
Oto procedura tworz¹ca maskê dla podanej bitmapy i podanego "przezroczystego" koloru. Skopiowa³em j¹ ze strony www.winprog.org (mam nadziejê, ¿e autor siê nie pogniewa) i raczej nie bêdê siê mêczy³ t³umaczeniem jej dzia³ania, które zreszt¹ jest doœæ proste:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP CreateBitmapMask(HBITMAP hbmColour, COLORREF crTransparent)<BR>
{<BR>
&nbsp;HDC hdcMem, hdcMem2;<BR>
&nbsp;HBITMAP hbmMask, hbmOld, hbmOld2;<BR>
&nbsp;BITMAP bm;<BR>
<BR> 
&nbsp;GetObject(hbmColour, sizeof(BITMAP), &bm);<BR>
&nbsp;hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, <SPAN CLASS=L>1</SPAN>, <SPAN CLASS=L>1</SPAN>, NULL);<BR>
<BR>
&nbsp;hdcMem = CreateCompatibleDC(NULL);<BR>
&nbsp;hdcMem2 = CreateCompatibleDC(NULL);<BR>
<BR>
&nbsp;hbmOld = (HBITMAP)SelectObject(hdcMem, hbmColour);<BR>
&nbsp;hbmOld2 = (HBITMAP)SelectObject(hdcMem2, hbmMask);<BR>
<BR>
&nbsp;SetBkColor(hdcMem, crTransparent);<BR>
<BR>
&nbsp;BitBlt(hdcMem2, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bm.bmWidth, bm.bmHeight, hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCCOPY);<BR>
&nbsp;BitBlt(hdcMem, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bm.bmWidth, bm.bmHeight, hdcMem2, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCINVERT);<BR>
<BR>
&nbsp;SelectObject(hdcMem, hbmOld);<BR>
&nbsp;SelectObject(hdcMem2, hbmOld2);<BR>
&nbsp;DeleteDC(hdcMem);<BR>
&nbsp;DeleteDC(hdcMem2);<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> hbmMask;<BR>
}<BR>
</TD></TR>
</TABLE>

<H2>
4.6 Kompletny program 
</H2>

<P>
Jako podsumowanie wyœwietlimy sobie przezroczyst¹ bitmapê - zak³adamy, ¿e znajduje siê ona w pliku <SPAN CLASS=Wazne>obrazek.bmp</SPAN> i ¿e jej t³o jest jasnozielone. Do stworzenia maski wykorzystamy funkcjê z poprzedniego rozdzia³u:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmObraz, hbmOld, hbmMaska;<BR>
hbmObraz = (HBITMAP)LoadImage(NULL, "obrazek.bmp", IMAGE_BITMAP, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, LR_LOADFROMFILE);<BR>
hbmMaska = CreateBitmapMask(hbmObraz, RGB(<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>255</SPAN>, <SPAN CLASS=L>0</SPAN>));<BR>
HDC hdcOkno = GetDC(hwnd), hdcNowy = CreateCompatibleDC(hdc);<BR>
BITMAP bmInfo;<BR>
GetObject(hbmObraz, sizeof(bmInfo), &bmInfo);<BR>
hbmOld = (HBITMAP)SelectObject(hdcNowy, hbmMaska);<BR>
BitBlt(hdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bmInfo.bmWidth, bmInfo.bmHeight, hdcNowy, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCAND);<BR>
SelectObject(hdcNowy, hbmObraz);<BR>
BitBlt(hdc, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, bmInfo.bmWidth, bmInfo.bmHeight, hdcNowy, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>, SRCPAINT);<BR>
ReleaseDC(hwnd, hdc);<BR>
SelectObject(hdcNowy, hbmOld);<BR>
DeleteDC(hdcNowy);<BR>
DeleteObject(hbmMaska);<BR>
DeleteObject(hbmObraz);<BR>
</TD></TR>
</TABLE>

<H2>
4.7 Odœwie¿anie zawartoœci okienka
</H2>

<P>
Grafika, któr¹ do tej pory umiemy narysowaæ na oknie, nie jest zbyt trwa³a. Wystarczy zminimalizowaæ nasze okienko, a wszystkie arcydzie³a znikn¹ bezpowrotnie :-/. Co gorsza, nawet jeœli na wierzch naszego okna wyskoczy jakiœ g³upi komunikat, to zama¿e on tê czêœæ naszego rysunku, któr¹ zakrywa³. Tego oczywiœcie nie chcemy, a jedynym sposobem ¿eby tych przykrych rzeczy unikn¹æ jest w³aœciwe obs³u¿enie komunikatu <SPAN CLASS=T>WM_PAINT</SPAN>, który jest wysy³any przez okienko za ka¿dym razem, gdy to wykryje, ¿e ktoœ perfidnie zamaza³ jego zawartoœæ.
</P>
<P>
Wydawaæ by siê mog³o, ¿e nic prostszego - wystarczy wrzuciæ kod odpowiedzialny za rysowanie do miejsca, gdzie obs³ugiwany jest komunikat <SPAN CLASS=T>WM_PAINT</SPAN>. Ale nic z tego! To znaczy owszem, tak w³aœnie uczynimy, ale bêdziemy te¿ musieli ten kod odpowiednio zmodyfikowaæ. Napisane jest bowiem w Piœmie (czyli w dokumentacji do API ;-) ): w <SPAN CLASS=T>WM_PAINT</SPAN> bêdziesz wywo³ywa³ funkcjê <SPAN CLASS=T>BeginPaint</SPAN>!
</P>
<P>
Odœwie¿anie okna ró¿ni siê nieco od innych graficznych czynnoœci, dlatego te¿ trzeba je specjalnie oznakowaæ. S³u¿y do tego wspomniana funkcja <SPAN CLASS=T>BeginPaint</SPAN> (któr¹ oznaczamy poczatek procedury rysuj¹cej) oraz <SPAN CLASS=T>EndPaint</SPAN> (zgadnij ;-)). <SPAN CLASS=T>BeginPaint</SPAN> zwraca na przy okazji <SPAN CLASS=T>HDC</SPAN> naszego okna, wiêc nie musimy go pobieraæ przy u¿yciu <SPAN CLASS=T>GetDC</SPAN>. Ponadto <SPAN CLASS=T>BeginPaint</SPAN> wymaga podania adesu specjalnej struktury typu <SPAN CLASS=T>PAINTSTRUCT</SPAN>. Nie musimy jej wykorzystywaæ, ale adres musi byæ, wiêc i tworzymy tak¹ strukturê:
<P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_PAINT:<BR>
{<BR>
&nbsp;PAINTSTRUCT ps; <SPAN CLASS=C>//deklaracja struktury</SPAN><BR>
&nbsp;HDC hdc = BeginPaint(hwnd, &ps);<BR>
&nbsp;<SPAN CLASS=C>//...<BR>
&nbsp;//instukcje rysuj¹ce coœ na oknie<BR>
&nbsp;//...</SPAN><BR>
&nbsp;EndPaint(hwnd, &ps); <SPAN CLASS=C>//zwalniamy hdc</SPAN><BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Wszystkie instrukcje, które rysuj¹ nasz obrazek na oknie, musz¹ siê znaleŸæ pomiêdzy <SPAN CLASS=T>BeginPaint</SPAN> a <SPAN CLASS=T>EndPaint</SPAN>. Jeœli tak zrobimy, nic ju¿ nie zniszczy naszych wiekopomnych dzie³ sztuki malarskiej, chyba ¿e my sami ;-).
<P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apigraf.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apianim.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>

</HTML>