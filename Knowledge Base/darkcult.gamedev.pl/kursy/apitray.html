<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Tray</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitree.html">&lt;&lt; TreeView</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool3.html">W³asne kontrolki, cz. 1 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<P>
Na pasku zadañ Windowsa jest taki fajny obszar, zwany obszarem statusu (a popularnie - tray'em). Znajduj¹ siê tam najczêœciej ikonki programów dzia³aj¹cych w tle. Pewnie nieraz zastanawia³o ciê, jak siê dobraæ do tego miejsca:
</P>

<P align=center>
<img src="../gfx/tray1.gif" alt="To jest w³aœnie tray">
</P>

<P>
Dziêki temu artyku³owi stanie siê to proste ;-). Wszelkie zadania zwi¹zane z ikonkami w tray'u (dodawanie, modyfikowanie, usuwanie) wykonuje funkcja <SPAN CLASS=T>Shell_NotifyIcon</SPAN>. Jej sk³adnia jest bardzo prosta, pobiera ona tylko rodzaj operacji do wykonania oraz adres struktury typu <SPAN CLASS=T>NOTIFYICONDATA</SPAN>. Struktura ta zawiera wszystkie niezbêdne informacje o ikonce. W plikach nag³ówkowych naszego SDK zadeklarowana ona jest nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>typedef struct</SPAN> _NOTIFYICONDATA<BR> 
{<BR>
&nbsp;DWORD cbSize;<BR>
&nbsp;HWND hWnd;<BR>
&nbsp;UINT uID;<BR>
&nbsp;UINT uFlags;<BR>
&nbsp;UINT uCallbackMessage;<BR>
&nbsp;HICON hIcon;<BR>
&nbsp;<SPAN CLASS=K>char</SPAN> szTip[<SPAN CLASS=L>64</SPAN>];<BR>
} NOTIFYICONDATA, *PNOTIFYICONDATA;<BR>
</TD></TR>
</TABLE>
 
<P>
Przeznaczenia wiêkszoœci tych pól nietrudno siê domyœliæ. Podobnie jak w przypadku innych struktur charakterystycznych dla WinAPI, pole <SPAN CLASS=T>cbSize</SPAN> nale¿y ustawiæ na rozmiar struktury, pobrany operatorem <SPAN CLASS=K>sizeof</SPAN>. Jako <SPAN CLASS=T>hWnd</SPAN> podajemy uchwyt okna, które bêdzie otrzymywa³o komunikaty zwi¹zane z ikonk¹ - zazwyczaj jest to g³ówne okno naszego programu. Pole <SPAN CLASS=T>uID</SPAN> to identyfikator ikonki, zaœ <SPAN CLASS=T>uFlags</SPAN> bêdzie okreœla³o, które z pozosta³ych trzech pól struktury s¹ w danym momencie aktywne.
</P>
<P>
Bierzmy siê zatem do dzie³a, czyli do umieszczenia ikony naszego programu na tray'u. Najpierw, jak zwykle, wype³nimy strukturê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPSTR sTip = <SPAN CLASS=L>"Moja w³asna ikonka"</SPAN>;<BR>
NOTIFYICONDATA nid;<BR>
<BR>
nid.cbSize = <SPAN CLASS=K>sizeof</SPAN>(NOTIFYICONDATA);<BR>
nid.hWnd = hwnd;<BR>
nid.uID = ID_TRAY1;<BR>
nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;<BR>
nid.uCallbackMessage = CMSG_TRAY1;<BR>
nid.hIcon = LoadIcon(NULL, IDI_APPLICATION);<BR>
lstrcpy(nid.szTip, sTip);<BR>
</TD></TR>
</TABLE>

<P>
Teraz niezbêdne wyjaœnienia. U¿yliœmy wszystkich trzech mo¿liwych flag, ¿eby za jednym zamachem ustawiæ ikonkê, tooltipa (czyli napis, który siê wyœwietla po najechaniu na ikonkê mysz¹) oraz kod specjalnego komunikatu (o nim póŸniej). Oczywiœcie sta³e <SPAN CLASS=T>ID_TRAY1</SPAN> oraz <SPAN CLASS=T>CMSG_TRAY1</SPAN> musimy sobie sami zdefiniowaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define ID_TRAY1   601<BR>
#define CMSG_TRAY1 0x8001<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Twórcy Windowsa nie byliby sob¹, gdyby od czasu do czasu nie zrobili programistom jakiegoœ kawa³u, i oto mamy go - pole <SPAN CLASS=T>szTip</SPAN> nie jest wskaŸnikiem (jak w przypadku wiêkszoœci tego typu pól w WinAPI), lecz tablic¹ o sta³ym rozmiarze<SPAN CLASS=L>64</SPAN> znaków, dlatego wype³niamy j¹ przy pomocy funkcji <SPAN CLASS=T>lstrcpy</SPAN>.
</P>
<P>
Wreszcie ostatnia rzecz: zak³adam, ¿e powy¿sza struktura bêdzie wype³niana ju¿ PO utworzeniu g³ównego okna programu, o uchwycie <SPAN CLASS=T>hwnd</SPAN>. Zak³adam równie¿, ¿e <SPAN CLASS=T>wincl</SPAN> to nazwa struktury typu <SPAN CLASS=T>WNDCLASSEX</SPAN>, która by³a u¿yta do rejestracji klasy okna i zawiera poprawny uchwyt do ikony.
</P>
<P>
Po tych przygotowaniach mo¿emy wreszcie dodaæ ikonê do obszaru statusu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BOOL r;<BR>
r = Shell_NotifyIcon(NIM_ADD, &nid);<BR>
<SPAN CLASS=K>if</SPAN>(!r) MessageBox(hwnd, <SPAN CLASS=L>"No niestety, z ikonki nici...", "£eeee..."</SPAN>, MB_ICONEXCLAMATION);<BR>
</TD></TR>
</TABLE>

<P>
Wszystko piêknie, ikonka widnieje sobie na tray'u:
</P>

<P align=center>
<img  src="../gfx/tray2.gif" alt="Hmm, powiedzmy, ¿e siê uda³o :-P">
</P>

<P>
Trochê nam siê co prawda pokaszani³a ta ikona, ale dziêki temu mamy nauczkê na przysz³oœæ: jeden z kolorów jest najwyraŸniej u¿ywany jako kolor maski, wiêc nale¿y siê liczyæ z tym, ¿e na tray'u nie bêdzie go widaæ.
</P>
<P>
Poza tym drobiazgiem wszystko jest jednak OK. Zadbajmy jeszcze o to (programiœci lubi¹ sobie o tym zapominaæ), ¿eby nasza ikonka samoczynnie usuwa³a siê w momencie zniszczenia g³ównego okna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
{<BR>
&nbsp;NOTIFYICONDATA nid;<BR>
&nbsp;nid.cbSize = <SPAN CLASS=K>sizeof</SPAN>(NOTIFYICONDATA);<BR>
&nbsp;nid.hWnd = hwnd;<BR>
&nbsp;nid.uID = ID_TRAY1;<BR>
&nbsp;nid.uFlags = <SPAN CLASS=L>0</SPAN>;<BR>
<BR>
&nbsp;Shell_NotifyIcon(NIM_DELETE, &nid);<BR>
<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie w przypadku usuwania ikony nie musimy zawracaæ sobie g³owy polami <SPAN CLASS=T>hIcon, uCallbackMessage </SPAN>i<SPAN CLASS=T> szTip</SPAN>, dlatego te¿ ustawiliœmy <SPAN CLASS=T>uFlags</SPAN> na <SPAN CLASS=L>0</SPAN>. Teraz ikonka bêdzie znika³a po wyjœciu z programu (wczeœniej dzia³o siê to dopiero po najechaniu na ni¹ mysz¹).
</P>

<h2>
KOMUNIKATY
</h2>

<P>
Teraz pora zaj¹æ siê praktyczniejszym wykorzystaniem takich ikonek. Jak wiadomo, zwykle klikniêcie prawym przyciskiem myszy na takiej ikonce rozwija menu kontekstowe, z którego mo¿na wybraæ pewne opcje programu (np. w WinAmp-ie mo¿na w ten sposób w³¹czyæ lub zatrzymaæ odtwarzanie, zmieniaæ skórki i wtyczki oraz wiele innych rzeczy). Zwykle te¿ pojedyncze klikniêcie lewym przyciskiem przywo³uje program na pierwszy plan (jeœli wczeœniej dzia³a³ on w tle). My zrobimy sobie to ostatnie; sprawimy, ¿e po zminimalizowaniu naszego g³ównego okienka bêdzie ono znika³o z g³ównego obszaru paska zadañ i pojawia³o siê w tray'u.
</P>
<P>
Przede wszystkim musimy teraz sprawiæ, ¿eby po zrzuceniu do paska zadañ okienko znika³o z niego. Pomo¿e nam w tym znana nam dobrze funkcja <SPAN CLASS=T>ShowWindow</SPAN>. Umieœcimy j¹ w czêœci kodu odpowiedzialnej za obs³ugê komunikatu <SPAN CLASS=T>WM_SIZE</SPAN>. Tam bêdziemy sprwdzaæ, czy okienko jest minimalizowane (wtedy wywo³amy <SPAN CLASS=T>ShowWindow</SPAN> z parametrem <SPAN CLASS=T>SW_HIDE</SPAN>), czy nie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_SIZE:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wParam == SIZE_MINIMIZED)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;ShowWindow(hwnd, SW_HIDE);<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// 1</SPAN><BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;ShowWindow(hwnd, SW_SHOW);<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// 2</SPAN><BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
W miejscach oznaczonych komentarzami wstawiamy ponadto: <SPAN CLASS=L>1</SPAN>) kod dodaj¹cy ikonkê do tray'a, <SPAN CLASS=L>2</SPAN>) kod usuwaj¹cy tê ikonkê. Warto zwróciæ uwagê, ¿e kod usuwaj¹cy ikonkê z tray'a powinien wyst¹piæ zarówno w powy¿szym, oznaczonym miejscu, jak i tam, gdzie wstawialiœmy go wczeœniej, czyli w obs³udze komunikatu <SPAN CLASS=T>WM_DESTROY</SPAN>, przy czym w tym drugim miejscu musimy teraz sprawdziæ, czy okno jest zminimalizowane (bo tylko wtedy bêdzie sens usuwania ikony). Tak wiêc komunikat <SPAN CLASS=T>WM_DESTROY</SPAN> bêdziemy teraz obs³ugiwaæ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(IsIconic(hwnd))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// <-- tutaj wklej kod usuwaj¹cy ikonê z tray'a</SPAN><BR>
&nbsp;}<BR>
<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>
 
<P>
Nowoœci¹ jest funkcja <SPAN CLASS=T>IsIconic</SPAN>, która sprawdza, czy okno jest zminimalizowane - tylko wówczas pokazywana jest w naszym programie ikonka na tray'u. Równie dobrze moglibyœmy w tym przypadku u¿yæ funkcji <SPAN CLASS=T>IsWindowVisible</SPAN>.
</P>
<P>
Teraz pora na pozosta³¹ czêœæ zadania - obs³u¿enie klikniêcia na ikonce. Do tej pory bowiem po zminimalizowaniu naszego okna nie da³o siê ju¿ bez stosowania tzw. cudów przywróciæ do normalnego stanu - mogliœmy jedynie wcisn¹æ Ctrl+Alt+Del i wykopaæ program z pamiêci si³¹. Teraz sprawimy, by klikniêcie na ikonê sprowadza³o okno z powrotem na pulpit.
</P>
<P>
Wykorzystamy w tym celu zdefiniowany przez nas komunikat <SPAN CLASS=T>CMSG_TRAY1</SPAN>. Dlaczego nadaliœmy jej akurat tak¹ wartoœæ? ¯eby nasz komunikat da³o siê odró¿niæ od tych systemowych - wszystkie numery od <SPAN CLASS=L>0x8000</SPAN> do <SPAN CLASS=L>0xBFFF</SPAN> s¹ do dyspozycji u¿ytkownika jako "prywatne" komunikaty do u¿ytku wewn¹trz danej aplikacji.
</P>
<P>
Pozostaje nam teraz jedynie obs³u¿enie klikniêcia na naszej ikonce. Parametr <SPAN CLASS=T>wParam</SPAN> komunikatu <SPAN CLASS=T>CMSG_TRAY1</SPAN> bêdzie zawiera³ identyfikator ikonki (w naszym przypadku <SPAN CLASS=T>ID_TRAY1</SPAN>), natomiast <SPAN CLASS=T>lParam</SPAN> - rodzaj komunikatu (w przypadku klikniêcia lewym przyciskiem - np. <SPAN CLASS=T>WM_LBUTTONDOWN</SPAN>). Obs³uga mo¿e wygl¹daæ jakoœ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> CMSG_TRAY1:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wParam == ID_TRAY1)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(lParam == WM_LBUTTONDOWN)<BR>
&nbsp;&nbsp;&nbsp;ShowWindow(hwnd, SW_RESTORE);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;
</TD></TR>
</TABLE>

<P>
Wa¿ne jest tutaj sprawdzenie, od której ikonki pochodzi komunikat (jeœli dodaliœmy kilka ikon; od "obcych" ikon komunikaty nie przychodz¹) oraz jakie zdarzenie nam oznajmia. Szczególnie na to drugie nale¿y zwróciæ uwagê; gdybyœmy nie sprawdzili wartoœci <SPAN CLASS=T>lParam</SPAN>, to nasze okno pojawia³oby siê nawet po samym najechaniu mysz¹ na ikonê (co jest efektem raczej niepo¿¹danym).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitree.html">&lt;&lt; TreeView</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool3.html">W³asne kontrolki, cz. 1 &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

