<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Podstawy WinAPI</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN><A HREF="../winapi.html"><< Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apictrl.html">Nastêpna czêœæ kursu  >></A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Podstawy WinAPI
</H1>

<P>
Ze znajomoœci¹ "go³ego" C++ mo¿emy w praktyce zrobiæ bardzo niewiele. Rozszerzaj¹c tê wiedzê o standardow¹ bibliotekê C++ mo¿emy ju¿ pisaæ programy pod DOS-a. Ale w dzisiejszych czasach nie przyda nam siê to zbytnio. Podstaw¹ jest Windows, najlepiej XP. Wszystkie systemy Windows, niezale¿nie od wersji, korzystaj¹ z interfejsu programowania, znanego pod nazw¹ <SPAN CLASS=Wazne>WinAPI</SPAN> (Windows Application Programming Interface). W tym kursie zajmiemy siê programowaniem pod Okienka od wersji 95 wzwy¿.
</P>

<H2>
Tworzymy okienko
</H2>

<P>
Naszym pierwszym wielkim wyzwaniem bêdzie stworzenie i narysowanie zwyk³ego okienka. Wielkim, bo nie jest to kwestia jednej instrukcji, jak byæ mo¿e sobie wyobra¿asz. Trochê trzeba siê bêdzie nagimnastykowaæ... Najpierw musimy stworzyæ i zarejestrowaæ klasê okna, nastêpnie stworzyæ samo okno, potem wyœwietliæ je i wreszcie stworzyæ tak zwan¹ pêtlê komunikatów.
</P>
<P>
Zacznijmy od stworzenia nowego projektu. Zak³adam, ¿e korzystasz z Dev-C++. W starszych wersjach Deva by³ odrêbny typ projektu - "WinMain project", obecnie jest tylko "Windows Application". Jeœli go wybierzemy, to uzyskamy gotowy szablon windowsowego programu, który bêdzie potrafi³ wszystko, co opiszemy sobie za chwilê w tej czêœci kursu. Ale jeœli przeskoczymy ten etap teraz, to póŸniej nic a nic nie zakumamy z nastêpnych zagadnieñ, wiêc zalecam na razie przeczytaæ tê czêœæ, póŸniej przeczytaæ jeszcze raz i jeszcze raz, a¿ wreszcie coœ zaczniemy ³apaæ ;-).
</P>
<P>
Tak wiêc wybieramy typ projektu "Empty Project" i wchodzimy sobie od razu do opcji projektu. W pierwszej zak³adce ("General") szukamy ramki "Type" i wybieramy "Win32 GUI". W tej wersji Dev-C++ (kiedy piszê te s³owa, aktualna wersja to 4.9.9.2) na tym koñczy siê ustawianie opcji i mo¿emy od razu przejœæ do w³aœciwego kodzenia.
<P>

<H3>
Funkcja WinMain
</H3>

<P>
<SPAN CLASS=T>WinMain</SPAN> jest to windowsowy odpowiednik <SPAN CLASS=T>main</SPAN>, jak siê zapewne domyœlasz. Jej budowa jest nastêpuj¹ca:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <SPAN CLASS=K>int</SPAN> nCmdShow)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Plik <SPAN CLASS=C>windows.h</SPAN> (razem z innymi powi¹zanymi z nim nag³ówkami) zawiera dos³ownie wszystko, co bêdzie nam potrzebne w kursie WinAPI i bêdziemy go zawsze do³¹czaæ, kiedy zechcemy napisaæ cokolwiek pod windowsa. O funkcji <SPAN CLASS=T>WinMain</SPAN> trochê ju¿ mówi³em, ale wypada³oby dok³adniej opisaæ jej argumenty. Parametr <SPAN CLASS=T>hInstance</SPAN> to <SPAN CLASS=Wazne>uchwyt</SPAN> naszej aplikacji. T³umacz¹c na ludzki jêzyk: numer jej wyst¹pienia (<SPAN CLASS=Inglisz>instance</SPAN>). Oznacza to, ¿e jeœli uruchomimy np. Notatnik, a nastêpnie nie zamykaj¹c go otworzymy Notatnik jeszcze raz, to pierwsze okno Notatnika bêdzie mia³o inny numer identyfikacyjny, ni¿ drugie.
</P>

<P CLASS=UWAGA>
W WinAPI typy danych zaczynaj¹ce siê przedrostkiem H oznaczaj¹ uchwyty. Zmienne takie s³u¿¹ do indentyfikowania rozmaitych obiektów. Obiektem takim mo¿e byæ te¿ menu (typ uchwytu - HMENU), czcionka (typ uchwytu - HFONT), okno (typ uchwytu - HWND), blok pamiêci (typ uchwytu - HGLOBAL lub HLOCAL) i wiele, wiele innych. 
</P>

<P>
Argument <SPAN CLASS=T>hPrevInstance</SPAN> powinien zawieraæ uchwyt poprzedniego wyst¹pienia aplikacji, ale w Windows 95 wynosi on zawsze <SPAN CLASS=T>NULL</SPAN>.
</P>

<P CLASS=UWAGA>
Specjalna wartoœæ NULL jest po prostu równa zero. Zwykle wykorzystuje siê j¹ do oznaczenia, ¿e wskaŸnik lub uchwyt jest pusty.
</P>

<P>
Argument <SPAN CLASS=T>lpCmdLine</SPAN> zawiera liniê poleceñ, z jakiej zosta³ uruchomiony nasz program. Jest to niestety pojedynczy string, tak wiêc trzeba go bêdzie pociachaæ, jeœli zechcemy wyci¹gn¹æ z niego konkretne parametry dla programu i nie ma takiego luksusu, jak w "zwyk³ej" <SPAN CLASS=T>main</SPAN>.
</P>

<P CLASS=UWAGA>
Typ LPSTR to po prostu synonim typu char*. Ogólnie wszystkie typy z przedrostkiem P lub LP oznaczaj¹ w WinAPI wskaŸniki.
</P>

<P>
Wreszcie <SPAN CLASS=T>nCmdShow</SPAN> okreœla, jaki powinien byæ stan okna naszego programu. Powinniœmy podaæ ten argument dalej, do funkcji <SPAN CLASS=T>ShowWindow</SPAN> pokazuj¹cej okno - o tym póŸniej.
</P>
<P>
Có¿ jeszcze mo¿e byæ tajemniczego w powy¿szym kodzie? Instrukcji <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN> chyba nie trzeba omawiaæ; mo¿e najwy¿ej dziwnie wygl¹da to <SPAN CLASS=T>WINAPI</SPAN> w deklaracji <SPAN CLASS=T>WinMain</SPAN>. Okreœla ono tzw. konwencjê wywo³ywania funkcji, ale o tym na razie nie musisz nic wiedzieæ :-).
</P>

<H3>
Funkcja MessageBox
</H3>

<P>
Kod powy¿ej oczywiœcie nie robi nic konkretnego, podobnie jak pusta funkcja <SPAN CLASS=T>main</SPAN> w programie konsolowym. Ale mo¿emy sobie coœ dodaæ. Okna naszej aplikacji jeszcze nie mamy, ale mo¿emy sobie wywaliæ na ekran jakiœ fajny komunikat. Robimy to funkcj¹ <SPAN CLASS=T>MessageBox</SPAN>.
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: MessageBox(<I>hWnd, lpText, lpCaption, uType</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hWnd</I></TD><TD CLASS=ARGLIST>uchwyt okna, które jest w³aœcicielem komunikatu. Jeœli okna akurat nie mamy, dajemy tu <SPAN CLASS=T>NULL</SPAN>, co oznacza "bezpañski" komunikat</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpText</I></TD><TD CLASS=ARGLIST>po prostu tekst komunikatu, który wyœwietlamy</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpCaption</I></TD><TD CLASS=ARGLIST>tytu³ okienka komunikatu. Jeœli damy <SPAN CLASS=T>NULL</SPAN>, zostanie wybrany tytu³ domyœlny <SPAN CLASS=L>"Error"</SPAN></TD></TR>
<TR><TD CLASS=ARGLIST><I>uType</I></TD><TD CLASS=ARGLIST>kombinacja stylów okienka komunikatu</TD></TR>
</TABLE>

<P>
A oto i style, okreœlaj¹ce przyciski, jakie bêd¹ widoczne w okienku komunikatu:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><B>MB_ABORTRETRYIGNORE</B></TD><TD CLASS=ARGLIST>przyciski Abort, Retry i Ignore (w polskiej wersji systemu bêd¹ oczywiœcie mia³y inne nazwy)</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_OK</B></TD><TD CLASS=ARGLIST>tylko przycisk OK</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_OKCANCEL</B></TD><TD CLASS=ARGLIST>przyciski OK i Anuluj</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_RETRYCANCEL</B></TD><TD CLASS=ARGLIST>przyciski Ponów i Anuluj</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_YESNO</B></TD><TD CLASS=ARGLIST>przyciski Tak i Nie</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_YESNOCANCEL</B></TD><TD CLASS=ARGLIST>przyciski Tak, Nie i Anuluj</TD></TR>
</TABLE>

<P>
Jeœli nie wybierzesz ¿adnego z tych przycisków, domyœlnie zostanie wybrany <SPAN CLASS=T>MB_OK</SPAN>. Dostêpne ikonki to:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><B>MB_ICONEXCLAMATION lub MB_ICONWARNING</B></TD><TD CLASS=ARGLIST>wykrzyknik</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_ICONINFORMATION, MB_ICONASTERISK</B></TD><TD CLASS=ARGLIST>literka 'i' w kó³eczku (informacja)</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_ICONQUESTION</B></TD><TD CLASS=ARGLIST>znak zapytania</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_ICONSTOP lub MB_ICONERROR lub MB_ICONHAND</B></TD><TD CLASS=ARGLIST>b³¹d krytyczny (znak stopu)</TD></TR>
</TABLE>

<P>
Jeœli nie wybierzesz ¿adnej z tych ikon, komunikat bêdzie bez ikony :-). ¯eby wskazaæ, który przycisk jest domyœlny (z grub¹, czarn¹ ramk¹ dooko³a), dodajesz jeden ze stylów: <SPAN CLASS=T>MB_DEFBUTTON1</SPAN>, <SPAN CLASS=T>MB_DEFBUTTON2</SPAN>, <SPAN CLASS=T>MB_DEFBUTTON3</SPAN>, <SPAN CLASS=T>MB_DEFBUTTON4</SPAN>. Domyœlnie wybierany jest <SPAN CLASS=T>MB_DEFBUTTON1</SPAN>.
</P>
<P>
Mo¿esz okreœliæ <SPAN CLASS=Wazne>modalnoœæ</SPAN> komunikatu:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>

<TR><TD CLASS=ARGLIST><B>MB_APPMODAL</B></TD><TD CLASS=ARGLIST>u¿ytkownik mo¿e kontynuowaæ pracê w danej aplikacji dopiero po zareagowaniu na komunikat (czyli wciœniêciu jednego z przycisków). Jeœli tego nie uczyni, próba zrobienia czegokolwiek w tej aplikacji skoñczy siê pikniêciem (straszne, nieprawda¿? :-) ).</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_SYSTEMMODAL</B></TD><TD CLASS=ARGLIST>jak wy¿ej, tylko ¿e komunikat jest wyœwietlany zawsze na wierzchu WSZYSTKICH okien, jakie s¹ otworzone w systemie. Nale¿y stosowaæ taki styl do zg³aszania Bardzo Powa¿nych B³êdów, które jeœli siê zignoruje, system mo¿e przestaæ normalnie pracowaæ (np. dysk siê pali :-) ).</TD></TR>
<TR><TD CLASS=ARGLIST><B>MB_TASKMODAL</B></TD><TD CLASS=ARGLIST>dzia³a tak samo, jak <SPAN CLASS=T>MB_APPMODAL</SPAN>, tylko ¿e jeœli nie podasz parametru <SPAN CLASS=T>hWnd</SPAN>, to i tak aplikacja przerwie pracê a¿ do reakcji u¿ytkownika na komunikat. U¿ywaj tego wtedy, gdy nie masz g³ównego okna w swojej aplikacji, ale musisz uniemo¿liwiæ dalsz¹ pracê aplikacji a¿ do odpowiedzi u¿ytkownika na komunikat.</TD></TR>
</TABLE>

<P>
Istnieje jeszcze kilka mo¿liwych stylów, ale nie bêd¹ nam one na razie potrzebne. Zreszt¹ po³owy z wymienionych te¿ nie bêdziesz pewnie zbyt czêstwo u¿ywa³ :-). Warto je jednak znaæ. Resztê doczytasz sobie w innych Ÿród³ach, jak mawiaj¹ profesorowie :-).
</P>

<P>
Funkcja <SPAN CLASS=T>MessageBox</SPAN> mo¿e zwróciæ nastêpuj¹ce wartoœci:
</P>

<SPAN CLASS=L>0</SPAN> - jeœli funkcja z jakichœ przyczyn nawali (np. brak pamiêci)<BR>
<SPAN CLASS=T>IDABORT</SPAN> - wybrano przycisk Przerwij<BR>
<SPAN CLASS=T>IDCANCEL</SPAN> - wybrano Anuluj<BR>
<SPAN CLASS=T>IDRETRY</SPAN> - wybrano Ponów<BR>
<SPAN CLASS=T>IDIGNORE</SPAN> - zgadnij :-)<BR>
<SPAN CLASS=T>IDNO</SPAN> - zgadnij :-)<BR>
<SPAN CLASS=T>IDYES</SPAN> - zgadnij :-)<BR>
<SPAN CLASS=T>IDOK</SPAN> - zgadnij :-)<BR>

<P>
Czêsto nie musimy w ogóle sprawdzaæ, co <SPAN CLASS=T>MessageBox</SPAN> zwraca (np. gdy mamy tylko jeden przycisk :-) ). Tak te¿ bêdzie w naszym przyk³adziku, który po prostu wyœwietla wiadomoœæ. Poni¿szy kod wpisujemy oczywiœcie wewn¹trz funkcji <SPAN CLASS=T>WinMain</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <SPAN CLASS=K>int</SPAN> nCmdShow)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"To jest wiadomoœæ."</SPAN>, <SPAN CLASS=L>"Wiadomoœæ"</SPAN>, MB_ICONINFORMATION | MB_OKCANCEL);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Komunikat z tego przyk³adu bêdzie mia³ przyciski OK i Anuluj, ale nie sprawdzamy, który z nich zosta³ naciœniêty. Mog³em nie dodaæ ¿adnego przycisku, wtedy by³by tylko OK, ale chcia³em pokazaæ, jak siê ³¹czy poszczególne style (operatorek <SPAN CLASS=Wazne>OR</SPAN>, rzecz jasna, aczkolwiek zwyk³e dodawanie <SPAN CLASS=T>+</SPAN> te¿ mo¿e byæ).
</P>

<H3>
Klasa okna
</H3>

<P>
Jak ju¿ wpomnia³em, ¿eby stworzyæ okienko aplikacji, takie z prawdziwego zdarzenia, musimy najpierw zarejestrowaæ jego <SPAN CLASS=Wazne>klasê</SPAN>. W tym celu wype³niamy pola struktury <SPAN CLASS=T>WNDCLASSEX</SPAN>. Jest to doœæ spora struktura - moglibyœmy skorzystaæ z prostszej, <SPAN CLASS=T>WNDCLASS</SPAN>, ale tamta nie ma pola na ma³¹ ikonkê, a my bardzo chcemy mieæ ma³¹ ikonkê w programie (proszê nie biæ :-)). Oto co wpisujemy w kolejne pola:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sk³adowa</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>cbSize</I></TD><TD CLASS=ARGLIST>rozmiar struktury w bajtach. Nale¿y tu wpisaæ <SPAN CLASS=K>sizeof</SPAN><SPAN CLASS=T>(WINDOWCLASSEX)</SPAN>.</TD></TR>
<TR><TD CLASS=ARGLIST><I>style</I></TD><TD CLASS=ARGLIST>nazwa mówi za siebie - style klasy. Dodam tylko, ¿e NIE jest to to samo, co style okna, którymi zajmiemy siê póŸniej. Tak wiêc wystarczy daæ tu <SPAN CLASS=L>0</SPAN>.</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpfnWndProc</I></TD><TD CLASS=ARGLIST>wskaŸnik do procedury obs³uguj¹cej okno (o tym póŸniej, na razie wpisujemy <SPAN CLASS=T>WndProc</SPAN>)</TD></TR>
<TR><TD CLASS=ARGLIST><I>cbClsExtra, cbWndExtra</I></TD><TD CLASS=ARGLIST>dodatkowe bajty pamiêci dla klasy (mo¿na ustawiæ na <SPAN CLASS=L>0</SPAN>)</TD></TR>
<TR><TD CLASS=ARGLIST><I>hInstance</I></TD><TD CLASS=ARGLIST>identyfikator aplikacji, która ma byæ w³aœcicielem okna (zazwyczaj pierwszy parametr naszej funkcji <SPAN CLASS=T>WinMain</SPAN>)</TD></TR>
<TR><TD CLASS=ARGLIST><I>hIcon</I></TD><TD CLASS=ARGLIST>Ikonka okna. Dok³adniej: du¿a ikonka, widaæ j¹ kiedy naciœniesz Alt-Tab. £adujemy j¹ poleceniem <SPAN CLASS=T>LoadIcon(NULL, IDI_APPLICATION)</SPAN>, które wybierze nam domyœln¹ ikonkê aplikacji.</TD></TR>
<TR><TD CLASS=ARGLIST><I>hCursor</I></TD><TD CLASS=ARGLIST>Kursor myszki. Analogicznie, jak dla ikonki, korzystamy z <SPAN CLASS=T>LoadCursor(NULL, IDC_ARROW)</SPAN>, co zaowocuje pojawieniem siê naszym okienku œlicznej strza³eczki :-).</TD></TR>
<TR><TD CLASS=ARGLIST><I>hbrBackground</I></TD><TD CLASS=ARGLIST>T³o naszego okienka, czyli jego kolor i wzór. Wybieramy domyœlne, czyli zwykle szare t³o - <SPAN CLASS=T>(HBRUSH)(COLOR_WINDOW+<SPAN CLASS=L>1</SPAN>)</SPAN>. Wiêcej o uchwycie <SPAN CLASS=T>HBRUSH</SPAN> poczytasz w rozdziale poœwiêconym grafice w WinAPI.</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpszMenuName</I></TD><TD CLASS=ARGLIST>Nazwa identyfikuj¹ca menu naszego okna w pliku zasobów. Na razie nie mamy ¿adnego menu, wiêc mo¿emy daæ <SPAN CLASS=T>NULL</SPAN>.</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpszClassName</I></TD><TD CLASS=ARGLIST>Nazwa klasy, któr¹ tworzymy. Mo¿esz wpisaæ, co chcesz (prawie ;-)).</TD></TR>
<TR><TD CLASS=ARGLIST><I>hIconSm</I></TD><TD CLASS=ARGLIST>Ma³a ikonka naszej aplikacji. Widaæ j¹ w rogu naszego okienka oraz na pasku zadañ. Dajemy tutaj to samo, co w przypadku du¿ej ikony.</TD></TR>
</TABLE>

<P>
A wiêc ogólnie nasze wype³nianie struktury, której nadaliœmy malownicz¹ nazwê <SPAN CLASS=T>wc</SPAN> (niby od <SPAN CLASS=Inglisz>window class</SPAN>) bêdzie wygl¹da³o jakoœ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>LPSTR</SPAN> NazwaKlasy = <SPAN CLASS=L>"Klasa Okienka"</SPAN>;<BR>
<BR>
WNDCLASSEX wc;<BR>
<BR>
wc.cbSize        = <SPAN CLASS=K>sizeof</SPAN>(WNDCLASSEX);<BR>
wc.style         = <SPAN CLASS=L>0</SPAN>;<BR>
wc.lpfnWndProc   = WndProc;<BR>
wc.cbClsExtra    = <SPAN CLASS=L>0</SPAN>;<BR>
wc.cbWndExtra    = <SPAN CLASS=L>0</SPAN>;<BR>
wc.hInstance     = hInstance;<BR>
wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);<BR>
wc.hCursor       = LoadCursor(NULL, IDC_ARROW);<BR>
wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+<SPAN CLASS=L>1</SPAN>);<BR>
wc.lpszMenuName  = NULL;<BR>
wc.lpszClassName = NazwaKlasy;<BR>
wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);<BR>
</TD></TR>
</TABLE>

<P>
Skoro wype³niliœmy ju¿ nasz formularz rejestracyjny, pozostaje tylko wys³aæ go do Wysokiej Komisji Rejestruj¹cej Klasy :-) i modliæ siê o pozytywne rozpatrzenie proœby. Nale¿y równie¿ liczyæ siê z mo¿liwoœci¹ odmowy rejestracji (co w praktyce siê nie zdarza, Komisyja ³askawa jest, ale programistyczny savoir vivre wymaga przewidywania absolutnie ka¿dej sytuacji) - wtedy nie pozostanie nam nic innego, jak tylko wywaliæ nieprzyjemny komunikat i zakoñczyæ program:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(!RegisterClassEx(&wc))<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Wysoka Komisja odmawia rejestracji tego okna!"</SPAN>, <SPAN CLASS=L>"Niestety..."</SPAN>, MB_ICONEXCLAMATION | MB_OK);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Je¿eli jednak komisja w postaci funkcji <SPAN CLASS=T>RegisterClassEx</SPAN> wyrazi³a zgodê, zwracaj¹c wartoœæ niezerow¹, to mo¿emy œmia³o przyst¹piæ do kroku nastêpnego, a mianowicie budowy naszego okienka. Do tego zaœ s³u¿y funkcja <SPAN CLASS=T>CreateWindowEx</SPAN>. Oto jakie s¹ sk³adniki ka¿dego szanuj¹cego siê okna:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: CreateWindowEx(<I>dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>dwExStyle</I></TD><TD CLASS=ARGLIST>Rozszerzone parametry stylu okna. Damy sobie <SPAN CLASS=T>WS_EX_WINDOWEDGE</SPAN>, czyli "trójwymiarow¹" ramkê</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpClassName</I></TD><TD CLASS=ARGLIST>Nazwa klasy okna, któr¹ w³aœnie zarejestrowaliœmy</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpWindowName</I></TD><TD CLASS=ARGLIST>Napis na pasku tytu³owym okienka</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwStyle</I></TD><TD CLASS=ARGLIST>"Zwyk³e" style okienka (szczegó³y dalej)</TD></TR>
<TR><TD CLASS=ARGLIST><I>x, y</I></TD><TD CLASS=ARGLIST>Pozycja okna. Mo¿na ustawiæ na <SPAN CLASS=T>CW_USEDEFAULT</SPAN>, czyli na domyœln¹ pozycjê</TD></TR>
<TR><TD CLASS=ARGLIST><I>nWidth, nHeight</I></TD><TD CLASS=ARGLIST>Wymiary okienka. Wpisz, ile chcesz. Tylko nie chciej za du¿o albo za ma³o :-)</TD></TR>
<TR><TD CLASS=ARGLIST><I>hWndParent</I></TD><TD CLASS=ARGLIST>Uchwyt okna rodzicielskiego (nadrzêdnego). Zwykle takowe nie istnieje, wiêc dajemy <SPAN CLASS=T>NULL</SPAN></TD></TR> 
<TR><TD CLASS=ARGLIST><I>hMenu</I></TD><TD CLASS=ARGLIST>Uchwyt menu dla naszego okna. Na razie ¿adnego nie mamy, wiêc <SPAN CLASS=T>NULL</SPAN></TD></TR> 
<TR><TD CLASS=ARGLIST><I>hInstance</I></TD><TD CLASS=ARGLIST>Uchwyt aplikacji, której przypisujemy okienko. Dajemy parametr <SPAN CLASS=T>hInstance</SPAN>, otrzymany od systemu jako argument dla <SPAN CLASS=T>WinMain</SPAN></TD></TR> 
<TR><TD CLASS=ARGLIST><I>lpParam</I></TD><TD CLASS=ARGLIST>wpisz <SPAN CLASS=T>NULL</SPAN> i nie dociekaj, co to :-). Teoretycznie jest to wskaŸnik do dodatkowych parametrów</TD></TR> 
</TABLE>

<P>
Najczêœciej u¿ywane style okienka, podawane jako <SPAN CLASS=T>dwStyle</SPAN>, to:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><B>WS_BORDER</B></TD><TD CLASS=ARGLIST>Cienka ramka</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_CAPTION</B></TD><TD CLASS=ARGLIST>Okreœla, ¿e okno ma mieæ pasek tytu³owy (automatycznie dodaje te¿ <SPAN CLASS=T>WS_BORDER</SPAN>)</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_CHILD</B></TD><TD CLASS=ARGLIST>Tworzy okienko potomne (tego na razie nie robimy), nie mo¿e byæ u¿yte z <SPAN CLASS=T>WS_POPUP</SPAN></TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_DISABLED</B></TD><TD CLASS=ARGLIST>Okienko bêdzie wy³¹czone zaraz po utworzeniu (inwalida od urodzenia? :-) )</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_DLGFRAME</B></TD><TD CLASS=ARGLIST>Okienko z ramk¹ stosowan¹ do dialogów</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_HSCROLL</B></TD><TD CLASS=ARGLIST>Okienko z poziomym paskiem do przesuwania</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_MAXIMIZE</B></TD><TD CLASS=ARGLIST>Okienko po utworzeniu bêdzie zmaksymalizowane</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_MAXIMIZEBOX</B></TD><TD CLASS=ARGLIST>Dodaje przycisk "Maksymalizuj" w prawym górnym rogu (musisz po³¹czyæ z <SPAN CLASS=T>WS_SYSMENU</SPAN>, ¿eby dzia³a³o)</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_MINIMIZE</B></TD><TD CLASS=ARGLIST>Okienko startuje na pasku zadañ</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_MINIMIZEBOX</B></TD><TD CLASS=ARGLIST>Dodaje przycisk "Minimalizuj" (musisz po³¹czyæ z <SPAN CLASS=T>WS_SYSMENU</SPAN>)</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_OVERLAPPED</B></TD><TD CLASS=ARGLIST>Zwyk³e okienko z paskiem tytu³owym i z ramk¹</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_OVERLAPPEDWINDOW</B></TD><TD CLASS=ARGLIST>Po³¹czenie stylów <SPAN CLASS=T>WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX</SPAN> i <SPAN CLASS=T>WS_MAXIMIZEBOX</SPAN></TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_POPUP</B></TD><TD CLASS=ARGLIST>Zwyk³y szary prostok¹t...</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_POPUPWINDOW</B></TD><TD CLASS=ARGLIST>Po³¹czenie stylów <SPAN CLASS=T>WS_OVERLAPPED</SPAN> i <SPAN CLASS=T>WS_SYSMENU</SPAN>, z tym ¿e dopóki nie dodasz <SPAN CLASS=T>WS_CAPTION</SPAN>, menu okienka nie bêdzie widoczne</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_SIZEBOX</B></TD><TD CLASS=ARGLIST>Okienko, które mo¿e zmieniaæ rozmiar</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_SYSMENU</B></TD><TD CLASS=ARGLIST>Tworzy menu dla okienka (ikonka w lewym górnym rogu), dzia³a tylko z <SPAN CLASS=T>WS_CAPTION</SPAN></TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_TABSTOP</B></TD><TD CLASS=ARGLIST>U¿ytkownik mo¿e siê prze³¹czaæ pomiêdzy kontrolkami w okienku klawiszem TAB</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_VISIBLE</B></TD><TD CLASS=ARGLIST>Sprawia, ¿e okno jest widzialne</TD></TR>
<TR><TD CLASS=ARGLIST><B>WS_VSCROLL</B></TD><TD CLASS=ARGLIST>Dodaje pionowy pasek przesuwu do okna</TD></TR>
</TABLE>

<P>
Przyjrzyj siê kilku przyk³adom zastosowania powy¿szych stylów:
</P>

<P ALIGN=CENTER>
<IMG SRC="..\gfx\wstyle.gif" ALT="Galeria okienek ;-)">
</P>

<P>
Wiemy ju¿ prawie wszystko na temat budowy okienka, a wiêc - do dzie³a. Wywo³ujemy <SPAN CLASS=T>CreateWindowEx</SPAN>, która przy odrobinie szczêœcia powinna nam zwróciæ uchwyt do nowego okna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hwnd;<BR>
<BR>
hwnd = CreateWindowEx(WS_EX_CLIENTEDGE, NazwaKlasy, <SPAN CLASS=L>"Oto okienko"</SPAN>, WS_OVERLAPPEDWINDOW,
       CW_USEDEFAULT, CW_USEDEFAULT, <SPAN CLASS=L>240</SPAN>, <SPAN CLASS=L>120</SPAN>, NULL, NULL, hInstance, NULL);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(hwnd==NULL)<BR>
{<BR>
&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Okno odmówi³o przyjœcia na œwiat!"</SPAN>, <SPAN CLASS=L>"Ale kicha..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Okno wreszcie gotowe! Jedyne, co nam pozosta³o, to uczyniæ je widocznym. A tym zajmie siê funkcja <SPAN CLASS=T>ShowWindow</SPAN>, oraz <SPAN CLASS=T>UpdateWindow</SPAN> (ta ostatnia ¿eby upewniæ siê, ¿e okno zosta³o poprawnie narysowane):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
ShowWindow(hwnd, nCmdShow);<BR>
UpdateWindow(hwnd);<BR>
</TD></TR>
</TABLE>

<P>
Jak zapewne pamiêtasz, parametr <SPAN CLASS=T>nCmdShow</SPAN> wziêliœmy od funkcji <SPAN CLASS=T>WinMain</SPAN>, ta zaœ otrzyma³a go od systemu, a konkretnie od u¿ytkownika, który we w³aœciwoœciach skrótu mo¿e okreœliæ, czy program ma byæ uruchamiany w okienku normalnym, zmaksymalizowanym itp. Oczywiœcie, mo¿esz zamiast przypisywania tego parametru daæ cokolwiek innego, wtedy u¿ytkownik nie bêdzie mia³ po prostu wp³ywu na to, jak okno bêdzie wygl¹da³o tu¿ po uruchomieniu programu.
</P>

<H3>
Pêtla komunikatów
</H3>

<P>
Pewnie nie jesteœ zachwycony, ¿e nasz program mimo tylu zaklêæ nadal nie dzia³a jak nale¿y (o ile mia³eœ odwagê go skompilowaæ na tym etapie - ja bym nie mia³ ;-)). No có¿, brakuje jeszcze najwa¿niejszego - <SPAN CLASS=Wazne>pêtli komunikatów</SPAN>. Jest to najzwyklejsza w œwiecie pêtla, która ma za zadanie przechwytywaæ wszelkie komunikaty, jakie system wyœle do naszej aplikacji. Takim komunikatem mo¿e byæ klikniêcie mysz¹, wciœniêcie jakiegoœ klawisza albo zamkniêcie okna. Wszystko zale¿y od tego, jakie konkretnie komunikaty chcemy przechwytywaæ.
</P>
<P>
Najpierw musimy sobie stworzyæ globaln¹ (na zewn¹trz <SPAN CLASS=T>WinMain</SPAN>) zmienn¹ do przechowywania komunikatów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
MSG Komunikat;<BR>
</TD></TR>
</TABLE>
<P>
Nastêpnie robimy wspomnian¹ pêtelkê (to ju¿ wewn¹trz <SPAN CLASS=T>WinMain</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>while</SPAN>(GetMessage(&Komunikat, NULL, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>))<BR>
{<BR>
&nbsp;TranslateMessage(&Komunikat);<BR>
&nbsp;DispatchMessage(&Komunikat);<BR>
}<BR>
<SPAN CLASS=K>return</SPAN> Komunikat.wParam;<BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>GetMessage</SPAN>, jak sama nazwa wskazuje, pobiera kolejne wiadomoœci od systemu, a dok³adniej z tzw. <SPAN CLASS=Wazne>kolejki wiadomoœci</SPAN> (<SPAN CLASS=Inglisz>message queue</SPAN>). Jeœli robimy jak¹œ czynnoœæ, która wi¹¿e siê z powstaniem jakiejœ wiadomoœci, np. poruszamy mysz¹, wiadomoœæ posy³ana jest do tej kolejki, sk¹d zabiera j¹ <SPAN CLASS=T>GetMessage</SPAN>. Je¿eli kolejka w danym momencie jest pusta, to <SPAN CLASS=T>GetMessage</SPAN> czeka na pierwsz¹ lepsz¹ wiadomoœæ, blokuj¹c dalsze wykonywanie programu. Mo¿e to brzmieæ groŸnie, ale w okienkowym systemie jest akurat bardzo po¿¹dane. 
</P>
<P>
Funkcja <SPAN CLASS=T>TranslateMessage</SPAN> wykonuje kilka drobnych operacji z wykorzystaniem naszego komunikatu - szczegó³y nie s¹ nam do niczego potrzebne. <SPAN CLASS=T>DispatchMessage</SPAN> wysy³a komunikat do w³aœciwego miejsca przeznaczenia - tutaj jest nim nasze okno. Przy tak prostym programie nie musisz podawaæ, do którego okna ma trafiæ komunikat - system "sam siê domyœli".
</P>

<H3>
Obs³uga komunikatów
</H3>

<P>
Wewn¹trz <SPAN CLASS=T>WinMain</SPAN> mamy ju¿ wszystko, czego nam do szczêœcia trzeba. Ale rejestruj¹c klasê naszego okienka podaliœmy nazwê funkcji, która jeszcze nie istnieje i któr¹ sami musimy napisaæ. Mowa o <SPAN CLASS=T>WndProc</SPAN> (nazwê wymyœlasz sam, nie jest ona istotna). To w³aœnie ta funkcja zajmie siê w³aœciw¹ obs³ug¹ komunikatów systemu, czyli np. reakcj¹ na wciskanie ró¿nych klawiszy. Dodajemy tê funkcjê zaraz za <SPAN CLASS=T>WinMain</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(msg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_CLOSE:<BR>
&nbsp;&nbsp;&nbsp;DestroyWindow(hwnd);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;case WM_DESTROY:<BR>
&nbsp;&nbsp;&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> DefWindowProc(hwnd, msg, wParam, lParam);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeden z argumentów funkcji <SPAN CLASS=T>WndProc</SPAN> to <SPAN CLASS=T>msg</SPAN> - jest to kod komunikatu, który w danej chwili funkcja ma obs³u¿yæ. ¯eby nasze okno w ogóle siê pokaza³o, <SPAN CLASS=T>WndProc</SPAN> nie musi obs³ugiwaæ ¿adnego komunikatu. My chcemy jednak, aby nasze œliczne okienko da³o siê czasami zamkn¹æ, dlatego dodaliœmy reakcjê na komunikat <SPAN CLASS=T>WM_CLOSE</SPAN>. Reakcja to wywo³anie funkcji niszcz¹cej nasze okno. Przy niszczeniu okna system wysy³a do aplikacji komunikat <SPAN CLASS=T>WM_DESTROY</SPAN>, który równie¿ obs³u¿ymy - wysy³aj¹c z kolei do systemu komunikat, ¿e chcemy ju¿ zakoñczyæ dzia³anie naszej aplikacji - <SPAN CLASS=T>PostQuitMessage</SPAN> (nie ma okna - nie ma aplikacji).
</P>
<P>
Pozosta³e komunikaty (np. klikniêcie mysz¹) nas nic nie obchodz¹, wiêc odsy³amy je dalej - do funkcji <SPAN CLASS=T>DefWindowProc</SPAN>, która zajmie siê ich domyœln¹ obs³ug¹. To wszystko, <SPAN CLASS=T>WndProc</SPAN> powinna zwróciæ jeszcze <SPAN CLASS=L>0</SPAN>.
</P>

<H3>
Wielki finisz!
</H3>

<P>
No, nareszcie - mamy nasze okienko! Trzeba siê by³o nieŸle nagimnastykowaæ, ale to wszystko to by³a w sumie najtrudniejsza czêœæ programowania w WinAPI. Od tej pory pozwolimy, aby DevC++ generowa³ za nas ten ca³y szkielet programu, a my tylko ewentualnie bêdziemy go modyfikowaæ do w³asnych, niecnych celów ;-). 
</P>
<P>
Na zakoñczenie tej czêœci przedstawiam (na wszelki wypadek) ca³y omówiony kod w jednym kawa³ku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;windows.h&gt;</SPAN><BR>
<BR>
LPSTR NazwaKlasy = <SPAN CLASS=L>"Klasa Okienka"</SPAN>;<BR>
MSG Komunikat;<BR>
<BR>
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);<BR>
<BR>
<SPAN CLASS=K>int</SPAN> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <SPAN CLASS=K>int</SPAN> nCmdShow)<BR>
{<BR>

<BR>
<SPAN CLASS=C>//WYPE£NIANIE STRUKTURY</SPAN><BR>
&nbsp;WNDCLASSEX wc;<BR>
<BR>
&nbsp;wc.cbSize        = <SPAN CLASS=K>sizeof</SPAN>(WNDCLASSEX);<BR>
&nbsp;wc.style         = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;wc.lpfnWndProc   = WndProc;<BR>
&nbsp;wc.cbClsExtra    = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;wc.cbWndExtra    = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;wc.hInstance     = hInstance;<BR>
&nbsp;wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);<BR>
&nbsp;wc.hCursor       = LoadCursor(NULL, IDC_ARROW);<BR>
&nbsp;wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+<SPAN CLASS=L>1</SPAN>);<BR>
&nbsp;wc.lpszMenuName  = NULL;<BR>
&nbsp;wc.lpszClassName = NazwaKlasy;<BR>
&nbsp;wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);<BR>
<BR>
<SPAN CLASS=C>//REJESTROWANIE KLASY OKNA</SPAN><BR>

&nbsp;<SPAN CLASS=K>if</SPAN>(!RegisterClassEx(&wc))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Wysoka Komisja odmawia rejestracji tego okna!"</SPAN>, <SPAN CLASS=L>"Niestety..."</SPAN>, MB_ICONEXCLAMATION | MB_OK);<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=K>1</SPAN>;<BR>
&nbsp;}<BR>
<BR>
<SPAN CLASS=C>//TWORZENIE OKNA</SPAN><BR>
&nbsp;HWND hwnd;<BR>
<BR>
&nbsp;hwnd = CreateWindowEx(WS_EX_CLIENTEDGE, NazwaKlasy, <SPAN CLASS=L>"Oto okienko"</SPAN>, WS_OVERLAPPEDWINDOW,
       CW_USEDEFAULT, CW_USEDEFAULT, <SPAN CLASS=L>240</SPAN>, <SPAN CLASS=L>120</SPAN>, NULL, NULL, hInstance, NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(hwnd==NULL)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;MessageBox(NULL, <SPAN CLASS=L>"Okno odmówi³o przyjœcia na œwiat!"</SPAN>, <SPAN CLASS=L>"Ale kicha..."</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp}<BR>
<BR>
&nbsp;ShowWindow(hwnd, nCmdShow);<SPAN CLASS=C> //Poka¿ okienko...</SPAN><BR> 
&nbsp;UpdateWindow(hwnd);<BR>
<BR>
<SPAN CLASS=C>//Pêtla komunikatów</SPAN><BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(GetMessage(&Komunikat, NULL, <SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>0</SPAN>))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;TranslateMessage(&Komunikat);<BR>
&nbsp;&nbsp;DispatchMessage(&Komunikat);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> Komunikat.wParam;<BR>
}<BR>
<BR>
<SPAN CLASS=C>//OBS£UGA ZDARZEÑ</SPAN><BR>
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(msg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_CLOSE:<BR>
&nbsp;&nbsp;&nbsp;DestroyWindow(hwnd);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;case WM_DESTROY:<BR>
&nbsp;&nbsp;&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> DefWindowProc(hwnd, msg, wParam, lParam);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN><A HREF="../winapi.html"><< Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apictrl.html">Nastêpna czêœæ kursu  >></A>
</TD>
</TR>
</TABLE>

</BODY>
</HTML>