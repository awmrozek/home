<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, wskaŸniki, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs03.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs04.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
3.4 Nieprzewidywalne tablice, czyli dynamiczna alokacja
</H2>

Bawiliœmy siê ju¿ tablicami, pewnie zd¹¿yliœcie ju¿ zadaæ sobie pytanie, czy nie mo¿na by by³o zmieniaæ rozmiaru tablic ju¿ gdzieœ w kodzie programu, nie tylko w deklaracji. Mo¿e siê bowiem gdzieœ w tym kodzie okazaæ, ¿e chcemy sobie dopisaæ jakiœ element do tablicy, a tu siê nagle okazuje, ¿e tablica jest ju¿ pe³na i nie da rady nic wiêcej do niej ju¿ wcisn¹æ. Jak rozszerzyæ tablicê?
<BR><BR>
W jêzyku C istnia³a funkcja <SPAN CLASS=T>malloc</SPAN>, która s³u¿y³a do dynamicznej alokacji pamiêci; w C++ jest ona równie¿, ale jest te¿ operator <SPAN CLASS=K>new</SPAN>, który pozwala nam dokonaæ tego samego w nieco prostszy sposób. Najwidoczniejsza zaleta korzystania z <SPAN CLASS=K>new</SPAN> (w porównaniu do <SPAN CLASS=T>malloc</SPAN>-a) jest taka, ¿e nie musimy siê bawiæ w konwersje typów; <SPAN CLASS=K>new</SPAN> jest operatorem przeci¹¿onym i dzia³a sprawnie ze wszystkimi podstawowymi typami, a tak¿e z typami zdefiniowanymi przez u¿ytkownika (choæ tutaj jest ju¿ ma³o wydajny i dobrze jest go przeci¹¿yæ na w³asn¹ rêkê, ale nie wybiegajmy zanadto w przysz³oœæ).
<BR><BR>
Dzia³anie <SPAN CLASS=K>new</SPAN> mo¿na opisaæ krótko: rezerwuje (czyli alokuje) on obszar pamiêci dla podanej liczby elementów podanego typu, po czym zwraca wskaŸnik do œwie¿o zaalokowanego obszaru:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>* tab_dyn = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>600</SPAN>];<BR>
</TD></TR>
</TABLE>
<BR>

Powy¿szy przyk³ad pokazuje dynamiczn¹ alokacjê tablicy <SPAN CLASS=L>600</SPAN> elementów typu <SPAN CLASS=K>int</SPAN>. W przyk³adzie tym operator <SPAN CLASS=K>new</SPAN> przeszukuje najpierw nasz RAM, a¿ znajdzie niezajêty obszar <SPAN CLASS=L>4*600=2400</SPAN> bajtów. Gdy to siê ju¿ stanie, zwraca nam wskaŸnik do tego obszaru, który jest zapisywany do <SPAN CLASS=T>tab_dyn</SPAN>. Od tej pory <SPAN CLASS=T>tab_dyn</SPAN> wskazuje na nowo zaalokowany obszar. Zauwa¿, ¿e obszar ten nie posiada ¿adnej nazwy, mo¿emy do niego odwo³ywaæ siê tylko przez wskaŸniki. Pamiêtamy jednak o mechanizmie zamiany nazwy tablicy na wskaŸnik do jej pierwszego elementu; dzia³a on te¿ w drug¹ stronê, a wiêc wskaŸnik, który wskazuje na pierwszy element naszego nowo alokowanego obszaru, jest jednoczeœnie nazw¹ dynamicznej tablicy:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
tab_dyn[<SPAN CLASS=L>0</SPAN>] = <SPAN CLASS=L>10</SPAN>;          <SPAN CLASS=C>//wpisujemy dziesi¹tkê</SPAN><BR>
tab_dyn[<SPAN CLASS=L>7</SPAN>] = *tab_dyn;    <SPAN CLASS=C>//dziesi¹tka wêdruje dalej</SPAN><BR>
tab_dyn[<SPAN CLASS=L>200</SPAN>] = tab_dyn[<SPAN CLASS=L>7</SPAN>] <SPAN CLASS=C>//i jeszcze dalej</SPAN><BR>
</TD></TR>
</TABLE>
<BR>


Co stanie siê, jeœli <SPAN CLASS=K>new</SPAN> nie znajdzie <SPAN CLASS=L>2400</SPAN> wolnych bajtów? Wprawdzie to niedu¿o, jak na dzisiejsze czasy, ale mo¿e siê zdarzyæ, ¿e pamiêæ jest bardzo zapchana albo pofragmentowana (patrz rysunek ni¿ej). Wówczas nic siê nie zaalokuje (z pustego i <SPAN CLASS=K>new</SPAN> nie naleje ;-) ), co oznajmi nam, zwracaj¹c <SPAN CLASS=T>NULL</SPAN>. Tak wiêc przed brakami w RAM-ie mo¿emy siê zabezpieczyæ nastêpuj¹co:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>* tab = <SPAN CLASS=K>new long double</SPAN>[<SPAN CLASS=L>1000000</SPAN>];<BR>
<SPAN CLASS=K>if</SPAN>(tab==NULL) <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>; <SPAN CLASS=C>//brak pamiêci, wyjdŸ z programu</SPAN><BR>
</TD></TR>
</TABLE>
<BR>

Wspomnia³em o fragmentacji pamiêci. Spójrz na ten rysunek - wyobraŸ sobie, ¿e jest to ca³a pamiêæ naszego komputera:

<P ALIGN=CENTER>
<IMG SRC="../gfx/frag.gif" ALT="Fragmentacja pamiêci">
</P>

Te œliczne b³êkitne kwadraciki, pouk³adane w rzêdach, oznaczaj¹ wolne miejsce (ka¿dy kwadracik to <SPAN CLASS=L>2</SPAN> bajty). Czerwone kwadraciki to bajty zajête. W poni¿szym przyk³adzie bêdziemy próbowaæ alokacji <SPAN CLASS=L>2</SPAN> elementów typu <SPAN CLASS=K>int</SPAN>, czyli <SPAN CLASS=L>8</SPAN> bajtów. A tu zonk - nigdzie nie ma oœmiu b³êkitnych kwadracików pod rz¹d! Ogólna liczba wolnych bajtów na rysunku wynosi a¿ <SPAN CLASS=L>37</SPAN>  (jeœli siê nie mylê :-)), czyli o wiele wiêcej, ni¿ nam trzeba, ale nie le¿¹ one obok siebie, wiêc nie mo¿na z nich zrobiæ tablicy. To jest w³aœnie fragmentacja pamiêci. Oczywiœcie defragmentacja bêdzie polega³a na takim posortowaniu zawartoœci pamiêci, ¿eby bajty zajête le¿a³y obok siebie, a wolne - w innym miejscu, ale te¿ obok siebie. Ale to ju¿ zadanie systemu operacyjnego oraz odpowiednich programów do optymalizacji RAM-u. Nam jako programistom pozostaje tylko siê modliæ, aby takie sytuacje siê nie zdarza³y ;-). A oto nasza nieudana próba alokacji:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>* tab = <SPAN CLASS=K>new int</SPAN>[<SPAN CLASS=L>2</SPAN>];<BR>
<SPAN CLASS=K>if</SPAN>(tab==NULL) <SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>1</SPAN>;<BR>
<SPAN CLASS=C>//dalsze instrukcje</SPAN><BR>
</TD></TR>
</TABLE>
<BR>

Jeœli pamiêæ w tym przypadku wygl¹da³aby tak, jak na rysunku, to <SPAN CLASS=K>new</SPAN> zwróci nam <SPAN CLASS=T>NULL</SPAN> i program zostanie zakoñczony z kodem b³êdu <SPAN CLASS=L>1</SPAN>. 
<BR><BR>
Zaleca siê, ¿eby zawsze sprawdzaæ powodzenie dynamicznej alokacji, ale jeœli wiemy, ¿e zaalokujemy tylko kilka bajtów, to sprawdzanie nie ma praktycznie sensu - jeœli w pamiêci nie ma nawet tych kilku wolnych bajtów, to program i tak siê zawiesi ;-).
<BR><BR>
Nic nie stoi na przeszkodzie, aby dynamicznie alokowaæ nie ca³e tablice, lecz pojedyñcze zmienne, np:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>* z = <SPAN CLASS=K>new int</SPAN>;<BR>
*z = <SPAN CLASS=L>10</SPAN>;<BR>
</TD></TR>
</TABLE>
<BR>

tylko trochê nie ma to sensu w przypadku takich kilkubajtowych mikrusów. Za to mo¿e siê przydaæ, jak ju¿ bêdziemy tworzyæ w³asne typy danych. Ale nic siê nie bój, to jeszcze nie teraz ;-).
<BR><BR>
Z dynamicznie alokowan¹ pamiêci¹ jest jak z zarezerwowanym pokojem w hotelu: po skorzystaniu trzeba go zwolniæ. W przypadku hotelu trzeba oddaæ klucz i ju¿ hotel mo¿e przyjmowaæ nastêpnego turystê do tego pokoju. ¯eby oddaæ systemowi klucz do niepotrzebnego nam ju¿ obszaru pamiêci, piszemy coœ w stylu:

<BR><BR>
<SPAN CLASS=K>delete</SPAN><SPAN CLASS=T> z;</SPAN>
<BR><BR>

lub w przypadku ca³ych tablic:

<BR><BR>
<SPAN CLASS=K>delete[]</SPAN><SPAN CLASS=T> tab_dyn;</SPAN>
<BR><BR>

Pamiêtaj, ¿eby nie odwo³ywaæ siê do zwolnionego ju¿ przez <SPAN CLASS=K>delete</SPAN> adresu tablicy. To by by³o tak, jakbyœ wtargn¹³ si³¹ do pokoju hotelowego, za który jeszcze nie zap³aci³eœ i to bez wiedzy portiera. Pó³ biedy, jeœli nikt tam siê jeszcze nie zd¹¿y³ wprowadziæ, ale po oddaniu klucza nigdy nie wiesz, czy ktoœ zd¹¿y³, czy nie. Trudno te¿ wyobraziæ sobie sytuacjê, ¿eby zwróciæ dwa razy ten sam klucz, wiêc nie stosuj <SPAN CLASS=K>delete</SPAN> do ju¿ zwolnionego obszaru (inaczej bêdzie bardzo niedobrze). To wa¿ne, bo tego rodzaju b³êdy zwykle nie powoduj¹ wykrzaczenia siê naszego programu, a jeœli program z b³êdami pozornie dobrze dzia³a, to mo¿emy o b³êdzie siê w ogóle nie dowiedzieæ, a wyjdzie on na wierzch akurat w najmniej odpowiednim momencie i co gorsza wtedy nie bêdziemy wiedzieli, co siê w³aœciwie dzieje.
<BR><BR>
Zwróæ uwagê na to, ¿e <SPAN CLASS=K>delete</SPAN> wbrew ewentualnym pozorom nie usuwa w ¿aden sposób wskaŸnika do zwalnianego obszaru; tylko oznajmia systemowi, ¿e obszar jest wolny. Co wiêcej, w wiêkszoœci kompilatorów wskaŸnik nie jest zerowany, wiêc wskazuje dalej na pamiêæ, do której jednak nie mamy ju¿ ¿adnych praw. Dlatego jeœli po zastosowaniu <SPAN CLASS=K>delete</SPAN> program ma jeszcze coœ zrobiæ, warto ustawiæ ten wskaŸnik na <SPAN CLASS=T>NULL</SPAN>. Wtedy w razie próby wtargniêcia do niezarezerwowanego pokoju nie zostaniemy wykopani przez ochroniarzy, bo nie bêdziemy nawet potrafili odnaleŸæ tego pokoju ;-). Innymi s³owy, dostaniemy komunikat o próbie dostêpu do nieistniej¹cego adresu zamiast b³êdu ochrony pamiêci, co ³atwiej nas naprowadzi na lukê w naszym programie.

<H2>
3.6 Zróbmy to w innym wymiarze
</H2>

Umiemy ju¿ alokowaæ dynamicznie pamiêæ dla tablic. Zauwa¿ jednak, ¿e by³y to tablice jednowymiarowe. Pewnie siê zastanawiasz, jak zrobiæ to samo z wielowymiarowymi. C++ nie zezwala bowiem na to, by zaalokowaæ jednowymiarow¹ tablicê, a potem odwo³ywaæ siê do niej jak do wielowymiarowej (a szkoda, przyda³aby siê taka mo¿liwoœæ). Oczywiœcie mo¿emy sobie to zrobiæ sami, ale wtedy za ka¿dym razem, gdy bêdziemy siê chcieli odwo³ywaæ do jakiegoœ elementu takiej tablicy, trzeba bêdzie przeliczaæ indeksy dwuwymiarowe na jednowymiarowe i na odwrót. Zreszt¹ i tak to kiedyœ zrobimy, jak ju¿ wyt³umaczymy sobie, czym s¹ klasy ;-).
<BR><BR>
Konstrukcja dwuwymiarowej dynamicznej tablicy z prawdziwego zdarzenia jest zupe³nie inna, ni¿ tablicy jednowymiarowej. Sk³ada siê ona z wielu jednowymiarowych tablic oraz jednowymiarowej tablicy wskaŸników do tych tablic:

<P ALIGN=CENTER>
<IMG SRC="../gfx/tab2d.gif" ALT="Schemat tablicy dwuwymiarowej">
</P>

Takie rozwi¹zanie oprócz ewidentnej wady (jest doœæ skomplikowane) ma wiele zalet. Po pierwsze, dziêki temu mo¿emy alokowaæ ca³kiem du¿¹ tablicê nawet wtedy, gdy pamiêæ jest pofragmentowana, bowiem poszczególne jednowymiarowe tablice wchodz¹ce w sk³ad naszej tablicy dwuwymiarowej mog¹ siê znajdowaæ w zupe³nie ró¿nych miejscach w pamiêci. Po drugie, spoœród naszych sk³adowych tablic jednowymiarowych ka¿da mo¿e mieæ inny rozmiar (tak jest np. na powy¿szym rysunku).
<BR><BR>
Na razie jednak stworzymy sobie "normaln¹" dwuwymiarow¹ tablicê. Kolejne sk³adowe tablice jednowymiarowe alokujemy w pêtli <SPAN CLASS=K>for</SPAN>:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>* jw;<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;liczba_wierszy; i++)<BR>
&nbsp;jw = <SPAN CLASS=K>new int</SPAN>[liczba_kolumn];<BR>
</TD></TR>
</TABLE>
<BR>

Praktycznie to ju¿ jest nasza ca³a tablica dwuwymiarowa, ale poniewa¿ mieliœmy kilka alokacji, a nie jedn¹, to nie wiemy, czy np. pamiêæ zarezerwowana dla drugiego wiersza le¿y dok³adnie za pamiêci¹ dla pierwszego wiersza. Potrzebujemy wiêc wspomnianej ju¿ tablicy wskaŸników, do których zapiszemy adresy ka¿dego z alokowanych wierszy:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>** tab = <SPAN CLASS=K>new int</SPAN>*[liczba_wierszy];<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;liczba_wierszy; i++)<BR>
&nbsp;tab[i] = <SPAN CLASS=K>new int</SPAN>[liczba_kolumn];<BR>
</TD></TR>
</TABLE>
<BR>

No i wszystko gra - mamy dwuwymiarow¹ tablicê <SPAN CLASS=T>tab</SPAN>. Pewnie wydaje ci siê dziwne, ¿e napisaliœmy <SPAN CLASS=K>int</SPAN><SPAN CLASS=T>** tab</SPAN> z dwiema gwiazdkami, ale tak ma byæ - <SPAN CLASS=T>tab</SPAN> jest tablic¹ wskaŸników do tablic, czyli wskaŸnikiem do wskaŸnika - bo jak ju¿ wiemy, nazwa tablicy jest przekszta³cana na wskaŸnik do pierwszego jej elementu. Dla ³atwiejszego zapamiêtania mo¿emy sobie powiedzieæ, ¿e operator <SPAN CLASS=K>new</SPAN> "zabiera" jedn¹ gwiazdkê i "przerabia" j¹ na jeden wymiar tablicy. Dziêki takiemu trochê dzieciêcemu t³umaczeniu nie pogubisz siê przy alokowaniu tablic trzy-, cztero- i wiêcej wymiarowych.
<BR><BR>
Oto i kompletny program, alokuj¹cy tablicê dwuwymiarow¹ (macierz) o rozmiarach podanych przez u¿ytkownika, wpisuj¹cy do ka¿dego jej elementu numer kolumny, w której ten element siê znajduje, wypisuj¹cy to na ekranie i po zakoñczeniu zwalniaj¹cy alokowan¹ pamiêæ:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> rx,ry,**tab;<BR>
<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê wierszy: "</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%i"</SPAN>, &ry);<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê kolumn: "</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%i"</SPAN>, &rx);<BR>
<BR>
&nbsp;tab = <SPAN CLASS=K>new int</SPAN>* [ry]; <SPAN CLASS=C>//alokacja pamiêci</SPAN><BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;ry) tab[i] = <SPAN CLASS=K>new int</SPAN>[rx];<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> y=<SPAN CLASS=L>0</SPAN>; y&lt;ry; y++) <SPAN CLASS=C>//wype³nianie tablicy</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>0</SPAN>; x&lt;rx; x++)<BR>
&nbsp;&nbsp;&nbsp;tab[y][x] = x;<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> y=<SPAN CLASS=L>0</SPAN>; y&lt;ry; y++) <SPAN CLASS=C>//wypisanie zawartoœci na ekranie</SPAN><BR>
&nbsp;{<BR>  
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>0</SPAN>; y&lt;rx; x++) printf(<SPAN CLASS=L>"%3i"</SPAN>, tab[y][x]);<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"\n"</SPAN>); <SPAN CLASS=C>//na zakoñczenie ka¿dego wiersza</SPAN><BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;ry; i++) <SPAN CLASS=C>//zwolnienie pamiêci</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>delete[]</SPAN> tab[i];<BR>
&nbsp;<SPAN CLASS=K>delete[]</SPAN> tab;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Program nie jest doskona³y; nie sprawdza, czy u¿ytkownik faktycznie wpisa³ liczbê (czyli np. wpisanie <SPAN CLASS=L>0</SPAN> spowoduje wykrzaczenie siê programu), ani czy alokacja pamiêci siê powiod³a. Jednak takie drobiazgi mo¿esz sobie dodaæ sam - pomin¹³em je, ¿eby nie zaciemnia³y nam programu. Zwróæ uwagê na instrukcje zwalniaj¹ce zaalokowan¹ pamiêæ na koñcu programu. Zwalniamy w kolejnoœci odwrotnej do tej, w jakiej j¹ alokowaliœmy. Gdybyœmy najpierw zwolnili tablicê wskaŸników, to nie moglibyœmy trafiæ do poszczególnych tablic jednowymiarowych, tworz¹cych wiersze naszej tablicy. Co by by³o, gdyby p³atny zabójca zgubi³ gdzieœ adresy swoich ofiar? Marnowa³by naboje, próbuj¹c wykonywaæ zlecenie w ciemno? ;-)

<BR><BR>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs03.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs04.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>