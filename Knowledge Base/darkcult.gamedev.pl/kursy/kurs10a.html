<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Wyj¹tki, cz.2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs10.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs11.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Wyj¹tek jako obiekt
</h2>

<P>
Na pocz¹tku tej czêœci kursu powiedzieliœmy sobie, ¿e jedn¹ z najwa¿niejszych funkcji spe³nianych przez system wyj¹tków jest dostarczanie informacji o okolicznoœciach wyst¹pienia wyj¹tku (np. rodzaj b³êdu, numer linii w kodzie). Zmienne skalarne, takie jak <SPAN CLASS=K>int, float</SPAN> czy nawet <SPAN CLASS=K>__int64</SPAN> nie s¹ w stanie przekazaæ zbyt wielu takich informacji. Dlatego warto stworzyæ sobie specjaln¹ strukturê, której pola bêd¹ dostarczaæ kompletnej informacji, jakiej wymagamy do obs³u¿enia wyj¹tku (zazwyczaj bêdzie to informacja, któr¹ u¿ytkownik-tester przekazuje programiœcie, ¿eby ten ostatni wiedzia³, na czym polega b³¹d w jego oprogramowaniu i gdzie w kodzie Ÿród³owym nale¿y go szukaæ).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>struct</SPAN> tEXCEPTION<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> ErrCode, LineNumber;<BR>
&nbsp;string FileName;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Tutaj mamy bardzo prost¹ strukturê, ale dziêki niej mo¿emy ju¿ przekazaæ ca³kiem sporo informacji o danym wyj¹tku; kod b³êdu, numer linii kodu i nazwa pliku Ÿród³owego zazwyczaj w zupe³noœci wystarcz¹ do zorientowania siê, gdzie tkwi b³¹d i na czym on polega.
</P>
<P>
Jednak takie proste za³atwienie sprawy ma kilka powa¿nych wad. Po pierwsze, brakuje nam tutaj konstruktora, który pozwoli³by na wygodn¹ inicjalizacjê wszystkich pól struktury. Po drugie, nie ma enkapsulacji zmiennych z informacjami o wyj¹tku. Po trzecie, nie ma metod, które pozwala³yby coœ zrobiæ ze zg³oszonym wyj¹tkiem (choæby wyœwietliæ komunikat o nim). Po czwarte wreszcie, brak mo¿liwoœci dziedziczenia po takiej strukturze (o tym pomówimy w nastêpnym rozdziale).
</P>
<P>
Te wszystkie wady sugeruj¹, ¿eby zrobiæ z wyj¹tku ca³¹ klasê. Mog³aby ona wygl¹daæ np. tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> cEXCEPTION<BR>
{<SPAN CLASS=K><BR>
protected:</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> ErrCode, LineNumber;<BR>
&nbsp;string FileName;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;cEXCEPTION(<SPAN CLASS=K>int</SPAN> code, <SPAN CLASS=K>int</SPAN> line, string file);<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Msg();<BR>
};<BR>
<BR>
cEXCEPTION::cEXCEPTION(<SPAN CLASS=K>int</SPAN> code, <SPAN CLASS=K>int</SPAN> line, string file)<BR>
{<BR>
&nbsp;ErrCode = code;<BR>
&nbsp;LineNumber = line;<BR>
&nbsp;FileName = file;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> cEXCEPTION::Msg()<BR>
{<BR>
&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Wystapil wyjatek"</SPAN> &lt;&lt; endl;<BR>
&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Numer bledu: "</SPAN> &lt;&lt; ErrCode &lt;&lt; endl;<BR>
&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Plik: "</SPAN> &lt;&lt; FileName &lt;&lt; endl;<BR>
&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Linia: "</SPAN> &lt;&lt; LineNumber &lt;&lt; endl;<BR>
}
</TD></TR>
</TABLE>

<P>
Teraz wystarczy tylko zdefiniowaæ sobie jakieœ sta³e, którymi bêdziemy oznaczaæ ró¿ne rodzaje b³êdów, np. <SPAN CLASS=L>1001</SPAN> - brak pamiêci, <SPAN CLASS=L>1002</SPAN> - b³¹d wejœcia/wyjœcia itp.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const int</SPAN> ERR_MEMORY = <SPAN CLASS=L>1001</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> ERR_IO &nbsp;&nbsp;&nbsp; = <SPAN CLASS=L>1002</SPAN>;<BR>
...<BR>
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy ju¿ rzucaæ wyj¹tki, przekazuj¹c pe³n¹ informacjê o nich za poœrednictwem klasy <SPAN CLASS=T>cEXCEPTION</SPAN>, natomiast w bloku <SPAN CLASS=K>catch</SPAN> mo¿emy zrobiæ u¿ytek z tych informacji, np. wyœwietlaj¹c komunikat o b³êdzie za pomoc¹ prostego wywo³ania metody <SPAN CLASS=T>Msg</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>try</SPAN><BR>
{<BR>
&nbsp;wsk = <SPAN CLASS=K>new</SPAN> Tablica[<SPAN CLASS=L>10000</SPAN>];<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wsk == NULL) <SPAN CLASS=K>throw</SPAN> cEXCEPTION(ERR_MEMORY, __LINE__, __FILE__);<BR>
}<BR>
<BR>
<SPAN CLASS=K>catch</SPAN>(cEXCEPTION Wyjatek)<BR>
{<BR>
&nbsp;Wyjatek.Msg();<BR>
&nbsp;terminate();<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
U¿yliœmy tutaj bardzo przydatnych makr <SPAN CLASS=T>__LINE__ </SPAN>i <SPAN CLASS=T>__FILE__</SPAN>. W ich miejsce preprocesor wstawia odpowiednio: numer aktualnej linii kodu, w której znajduje siê dane makro oraz nazwê pliku Ÿród³owego. Aby by³o jeszcze wygodniej (oraz estetyczniej), mo¿emy napisaæ sobie kolejne makro, które ukryje te dwa makra:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define MY_EXCEPTION(c) cEXCEPTION(c, __LINE__, __FILE__)</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Teraz rzucenie wyj¹tku bêdzie wygl¹daæ po prostu tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(wsk == NULL) <SPAN CLASS=K>throw</SPAN> MY_EXCEPTION(ERR_MEMORY);<BR>
</TD></TR>
</TABLE>

<P>
Zalety tych rozwi¹zañ widaæ na pierwszy rzut oka; w momencie wykrycia sytuacji wyj¹tkowej po prostu zg³aszamy ten fakt z podaniem kodu b³êdu, w momencie z³apania tego wyj¹tku ¿¹damy wyœwietlenia komunikatu. O resztê (czyli m.in. o przekazanie informacji o numerze linii i nazwie pliku) martwi siê nasza klasa <SPAN CLASS=T>cEXCEPTION</SPAN>.
</P>

<h2>
Hierarchia wyj¹tków
</h2>

<P>
Jak ju¿ wspomnia³em, klasa w rodzaju <SPAN CLASS=T>cEXCEPTION</SPAN> mo¿e staæ siê klas¹ bazow¹ dla szeregu innych klas wyj¹tków. 
</P>
<P>
Co zyskujemy, tworz¹c klasy dziedzicz¹ce po klasie wyj¹tku? Z grubsza to samo, co stosuj¹c dziedziczenie w ka¿dym innym celu: otrzymamy obiekty, które maj¹ kilka cech wspólnych oraz kilka indywidualnych. Bardziej konkretnie - otrzymamy mo¿liwoœæ reagowania na ró¿ne rodzaje wyj¹tków w ró¿ny sposób, ale przy zachowaniu pewnych cech wspólnych dla wszystkich rodzajów wyj¹tków.
</P>
<P>
Przyk³ad: tworzymy sobie klasê <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>, która bêdzie oznacza³a jakiœ drobny wyj¹tek, który niekoniecznie musi uniemo¿liwiaæ dalsz¹ pracê z programem. Innymi s³owy, nawet jeœli wyj¹tek <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> wyst¹pi, to program wci¹¿ bêdzie dzia³a³, co najwy¿ej wyœwietli komunikat, ¿e ostatnio podjêta przez u¿ytkownika akcja (np. próba otwarcia jakiegoœ pliku) nie powiod³a siê. Do dzie³a zatem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> cSMALL_EXCEPT : <SPAN CLASS=K>public</SPAN> cEXCEPTION;<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;cSMALL_EXCEPT(<SPAN CLASS=K>int</SPAN> code, <SPAN CLASS=K>int</SPAN> line, string file) : cEXCEPTION(code, line, file) {};<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Nie napracowaliœmy siê zbytnio: nowa klasa <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> jest w gruncie rzeczy kopi¹ swojej klasy bazowej. Nawet konstruktora nie chcia³o nam siê pisaæ od nowa, skorzystaliœmy sobie z listy inicjalizacyjnej. Mamy wiêc dwie podobnie dzia³aj¹ce klasy. Po co nam one? Otó¿ w³aœnie po to, by w blokach <SPAN CLASS=K>catch</SPAN> móc odró¿niæ, czy rzucony wyj¹tek nale¿y do rodzaju tych "groŸnych", na które zareagowaæ mo¿na tylko zakoñczeniem programu, czy te¿ do tych "lajtowych", które mo¿emy spokojnie zignorowaæ (ale w obu przypadkach wyœwietlamy informacjê o wyj¹tku). Teraz mo¿emy dodaæ drugi blok <SPAN CLASS=K>catch</SPAN>:
</P>


<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>catch</SPAN>(cSMALL_EXCEPT Wyjatek)<BR>
{<BR>
&nbsp;Wyjatek.Msg();<BR>
}<BR>
<BR>
<SPAN CLASS=K>catch</SPAN>(cEXCEPTION Wyjatek) <SPAN CLASS=C>// "stary" catch zostawiamy bez zmian</SPAN><BR>
{<BR>
&nbsp;Wyjatek.Msg();<BR>
&nbsp;terminate();<BR>
}<BR>
</TD></TR>
</TABLE>


<P>
Odt¹d reakcj¹ na wyj¹tki typu <SPAN CLASS=T>cEXCEPTION</SPAN> jest wyœwietlenie komunikatu o b³êdzie i zakoñczenie programu, a na wyj¹tki <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> - tylko wyœwietlenie komunikatu (oczywiœcie, sterowanie zostaje przekazane do bloku <SPAN CLASS=K>catch</SPAN>, wiêc jeœli za tym blokiem nic ju¿ nie ma, to program i tak siê zakoñczy - o tym póŸniej).
</P>

<P>
Dobrze jest pamiêtaæ, ¿e w przypadku hierarchii klas wyj¹tków najpierw umieszczamy zawsze blok <SPAN CLASS=K>catch</SPAN> ³api¹cy wyj¹tki klas pochodnych, a dopiero na koñcu blok <SPAN CLASS=K>catch</SPAN> ³api¹cy wyj¹tki klas bazowych (czyli w³aœnie tak, jak powy¿ej). Jeœli zrobimy jeden za drugim najpierw <SPAN CLASS=K>catch</SPAN> dla klasy bazowej, a potem dla pochodnej, a gdzieœ w bloku <SPAN CLASS=K>try</SPAN> jest rzucenie wyj¹tku klasy pochodnej, to prawdopodobnie kompilator wyrzuci nam warninga.
</P>


<P class=UWAGA>
Kolejnoœæ bloków <SPAN CLASS=K>catch</SPAN> MA znaczenie!
</P>




<h2>
Propagacja wyj¹tków
</h2>

<P>
Mechanizmy, o których sobie do tej pory powiedzieliœmy, same w sobie s¹ w praktyce ma³o przydatne (tak przynajmniej mog³oby siê nam wydawaæ w tym momencie). WyobraŸmy sobie na przyk³ad, ¿e jedynym rodzajem wyj¹tku przewidzianym w naszym programie jest b³¹d alokacji pamiêci. Sytuacja jest wiêc pozornie niezbyt skomplikowana. Có¿ jednak z tego, skoro wyj¹tek taki mo¿e wyst¹piæ w wielu ró¿nych miejscach w programie? Za³ó¿my, ¿e mamy trzy funkcje, z których ka¿da alokuje pamiêæ dla ró¿nego rodzaju struktur danych:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> alokuj_obiekt(<SPAN CLASS=K>float</SPAN>* wsk)<BR>
{<BR>
&nbsp;wsk = <SPAN CLASS=K>new float</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> alokuj_tablice(<SPAN CLASS=K>int</SPAN> rozmiar, <SPAN CLASS=K>float</SPAN>* wsk)<BR>
{<BR>
&nbsp;wsk = <SPAN CLASS=K>new float</SPAN>[rozmiar]; <BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> alokuj_tablice_2d(<SPAN CLASS=K>int</SPAN> rozmiar_x, <SPAN CLASS=K>int</SPAN> rozmiar_y, <SPAN CLASS=K>float</SPAN>* wsk)<BR>
{<BR>
&nbsp;wsk = <SPAN CLASS=K>new float</SPAN>*[rozmiar_y];<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;rozmiar_y; ++i)<BR>
&nbsp;&nbsp;wsk = <SPAN CLASS=K>new float</SPAN>[rozmiar_x];<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Gdybyœmy chcieli teraz wprowadziæ tu obs³ugê wyj¹tków, to musielibyœmy najpierw cia³o ka¿dej funkcji "otuliæ" blokiem <SPAN CLASS=K>try</SPAN>, nastêpnie dorzuciæ do niego blok <SPAN CLASS=K>catch</SPAN>. Zawartoœæ bloku <SPAN CLASS=K>catch</SPAN> w ka¿dej z trzech funkcji by³aby identyczna: by³oby to wyœwietlenie komunikatu o b³êdzie i zakoñczenie programu. Nawet jeœli skorzystalibyœmy z naszej klasy <SPAN CLASS=T>cEXCEPTION</SPAN>, to i tak by³oby z tym mnóstwo niepotrzebnej pisaniny. W dodatku nie by³oby spe³nione jedno z za³o¿eñ dla mechanizmu obs³ugi wyj¹tków, o których mówiliœmy na pocz¹tku tej czêœci kursu: przekazanie sterowania do odpowiedniego miejsca w kodzie, zajmuj¹cego siê obs³ug¹ danego rodzaju wyj¹tków. Tutaj trzy identyczne rodzaje wyj¹tków by³yby obs³ugiwane oddzielnie...
</P>
<P>
Na szczêœcie nic takiego nie musimy robiæ, poniewa¿ mechanizm obs³ugi wyj¹tków w C++ ma wbudowane tzw. <SPAN CLASS=Wazne>odwijanie stosu</SPAN>. W szczegó³y techniczne zag³êbiaæ siê tu nie bêdziemy; niech wystaczy, ¿e polega to na poszukiwaniu bloku <SPAN CLASS=K>catch</SPAN> poza funkcj¹, w której rzucono wyj¹tek. Tak wiêc jeœli bloku <SPAN CLASS=K>catch</SPAN> w funkcji <SPAN CLASS=T>A</SPAN> nie bêdzie w ogóle, to wyj¹tek poleci sobie dalej, do funkcji <SPAN CLASS=T>B</SPAN>, z której wywo³ano <SPAN CLASS=T>A</SPAN>. Z kolei jeœli funkcja <SPAN CLASS=T>B</SPAN> nie bêdzie zawiera³a odpowiadaj¹cego bloku <SPAN CLASS=K>catch</SPAN>, wyj¹tek powêdruje do klasy <SPAN CLASS=T>C</SPAN>, z której wywo³ano <SPAN CLASS=T>B</SPAN>. Brzmi to zapewne doœæ zawile, wiêc lepiej zilustrujmy to przyk³adem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> C()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>try</SPAN> <BR>
&nbsp;{<BR>
&nbsp;&nbsp;B();<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>int</SPAN> parametr)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Wyjatek dotarl wreszcie do bloku catch."</SPAN> &lt;&lt; endl;<BR>
&nbsp;}<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> B()<BR>
{<BR>
&nbsp;A();<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> A()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>throw</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;C();<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Program jest prosty; zaczyna siê od wywo³ania funkcji <SPAN CLASS=T>C</SPAN>, która wywo³uje funkcjê <SPAN CLASS=T>B</SPAN>, a ta z kolei wywo³uje <SPAN CLASS=T>A</SPAN>. Tak wiêc stos mo¿na sobie tu wyobraziæ tak:
</P>

<P>
A<BR>
B<BR>
C<BR>
main<BR>
</P>

<P>
 Wewn¹trz funkcji <SPAN CLASS=T>A</SPAN> zg³aszany jest wyj¹tek. Poniewa¿ funkcja <SPAN CLASS=T>A</SPAN> nie posiada ¿adnego bloku <SPAN CLASS=K>catch</SPAN>, zdejmujemy <SPAN CLASS=T>A</SPAN> ze stosu i przeszukujemy funkcjê, która jest na jego wierzchu (teraz jest to <SPAN CLASS=T>B</SPAN>). Tam te¿ nie ma <SPAN CLASS=K>catch</SPAN>, wiêc wywalamy <SPAN CLASS=T>B</SPAN> ze szczytu i sprawdzamy <SPAN CLASS=T>C</SPAN>. Tutaj wreszcie jest <SPAN CLASS=K>catch</SPAN> i nawet pasuje do typu rzuconego wyj¹tku. Tak wiêc wchodzimy do tego <SPAN CLASS=K>catch</SPAN>.
</P>
<P>
Wracaj¹c do naszego wczeœniejszego przyk³adu - gdzie tutaj umieœciæ konstrukcjê <SPAN CLASS=K>try-catch</SPAN>? Oczywiœcie w funkcji, która wywo³uje zarówno <SPAN CLASS=T>alokuj_obiekt, alokuj_tablice</SPAN> i <SPAN CLASS=T>alokuj_tablice_2d</SPAN>. Jeœli nie mamy pewnoœci, jaka to funkcja, to najlepiej wstawiæ <SPAN CLASS=K>try-catch </SPAN>wewn¹trz funkcji <SPAN CLASS=T>main</SPAN> - przecie¿ stamt¹d wszystko siê zaczyna, wiêc te¿ i tam skoñczy siê zawsze odwijanie stosu :-). Tak wiêc jedziemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;alokuj_obiekt(wsk_obiekt);<BR>
&nbsp;&nbsp;alokuj_tablice(tab1);<BR>
&nbsp;&nbsp;alokuj_tablice_2d(tab2);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(cEXCEPTION Wyjatek)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Wyjatek.Msg();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_FAILURE;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_SUCCESS;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Sytuacja jest tu ju¿ ca³kiem klarowna: bez wzglêdu na to, w której z wywo³ywanych funkcji alokuj¹cych zostanie rzucony wyj¹tek, trafi on do bloku <SPAN CLASS=K>catch</SPAN> znajduj¹cego siê w funkcji <SPAN CLASS=T>main</SPAN>. 
</P>

<h2>
Wyj¹tki w praktyce
</h2>

<P>
Schemat opisany pod koniec poprzedniego rozdzia³u (umieszczanie ca³ej zawartoœci funkcji <SPAN CLASS=T>main</SPAN> lub <SPAN CLASS=T>WinMain</SPAN> w bloku <SPAN CLASS=K>try</SPAN> i wykorzystanie odwijania stosu) ma jedn¹ niepodwa¿aln¹ zaletê, a jest to prostota. Ma te¿ i wadê. Otó¿ model taki sprawdza siê tylko w przypadku, gdy ka¿dy przewidziany przez nas wyj¹tek ma byæ na tyle powa¿ny, ¿e kontynuowanie pracy programu staje siê niemo¿liwe. Zauwa¿ bowiem, ¿e gdy praktycznie ca³y nasz program jest objêty blokiem <SPAN CLASS=K>try</SPAN>, to ka¿dy zg³oszony wyj¹tek powoduje zakoñczenie programu (po opuszczeniu bloku <SPAN CLASS=K>try</SPAN> nie pozostaje ju¿ wiêcej instrukcji do wykonania, nawet jeœli usuniemy <SPAN CLASS=K>return</SPAN> z bloku <SPAN CLASS=K>catch</SPAN>).
</P>
<P>
Oczywiœcie zawsze mo¿emy stworzyæ sobie funkcjê (np. <SPAN CLASS=T>main2</SPAN>), w której umieœcimy wszystko to, co by³o w <SPAN CLASS=T>main</SPAN> i wywo³ywaæ tê funkcjê z bloku <SPAN CLASS=K>try</SPAN>. Nastêpnie wprowadziæ drug¹ klasê wyj¹tku, która bêdzie oznacza³a taki wyj¹tek, który nie powoduje wyjœcia z programu (np. <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>). Reakcj¹ na wyj¹tek <SPAN CLASS=T>cEXCEPTION</SPAN> bêdzie, tak jak wczeœniej, wyjœcie z programu, natomiast na <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> - ponowne wywo³anie funkcji <SPAN CLASS=T>main2</SPAN>, co w naszych zamierzeniach ma byæ "przejœciem do porz¹dku dziennego nad wyj¹tekiem", czyli kontynuacj¹ normalnego dzia³ania programu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> main2()<BR>
{<BR>
&nbsp;alokuj_obiekt(wsk_obiekt);<BR>
&nbsp;alokuj_tablice(tab1);<BR>
&nbsp;alokuj_tablice_2d(tab2);<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;main2();<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(cSMALL_EXCEPT Wyjatek)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Wyjatek.Msg();<BR>
&nbsp;&nbsp;main2();<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(cEXCEPTION Wyjatek)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Wyjatek.Msg();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_FAILURE;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_SUCCESS;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Taki kod to fatalny b³¹d programistyczny. Dlaczego? Owszem, skompiluje siê on, a nawet zadzia³a zgodnie z oczekiwaniami... przynajmniej do czasu. Jeœli gdzieœ w funkcji <SPAN CLASS=T>main2</SPAN> zostanie zg³oszony wyj¹tek typu <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>, to zostanie on przechwycony we w³aœciwym bloku <SPAN CLASS=K>catch</SPAN>, a nastêpnie z powrotem wejdziemy w <SPAN CLASS=T>main2</SPAN>. I có¿ wtedy? S¹ dwie mo¿liwoœci:
</P>

<UL>
<LI>sytuacja powtórzy siê, czyli ten sam wyj¹tek zostanie zg³oszony ponownie (jak wiemy, doprowadzi to do natychmiastowego zakoñczenia programu, poniewa¿ <SPAN CLASS=T>main2 </SPAN>zosta³a wywo³ana z bloku <SPAN CLASS=K>catch</SPAN>, czyli wci¹¿ jesteœmy w trakcie obs³ugi poprzedniego wyj¹tku)
<LI>tym razem wszystko przebiegnie normalnie, tj. nie bêdzie zg³oszony ¿aden wyj¹tek a¿ do momentu, gdy u¿ytkownik sam wy³¹czy program
</UL>

<P>
Oczywiœcie jako programiœci nie mo¿emy przewidzieæ, który z tych scenariuszy siê ziœci. Powinniœmy byæ pesymistami i za³o¿yæ, ¿e bardzo prawdopodobny jest scenariusz nr 1. A jest on doœæ katastrofalny w skutkach, gdy¿ raczej nie chcemy, by nasze programy w sytuacjach wyj¹tkowych ot tak po prostu siê wy³¹cza³y (dlatego w³aœnie zreszt¹ w ogóle zajmujemy siê systemem wyj¹tków).
</P>
<P>
Co robiæ? Po pierwsze, zapamiêtujemy:
</P>
<P class=UWAGA>
Nie ³udŸ siê nadziej¹, ¿e jeden blok try, obejmuj¹cy wszystkie instrukcje w funkcji main za³atwi sprawê - chyba ¿e chcesz, ¿eby ka¿dy wyj¹tek koñczy³ siê wyjœciem z programu.
</P>
<P>
Po drugie, rozwijamy nasz¹ koncepcjê. Jeœli jeden blok <SPAN CLASS=K>try</SPAN> nie wystarcza, to trzeba ich wprowadziæ wiêcej. Mo¿emy tu wykorzystaæ mo¿liwoœæ zagnie¿d¿ania tych¿e bloków. W tym równie¿ "niejawnego" zagnie¿d¿ania, tj. zostawiamy jeden "g³ówny" blok <SPAN CLASS=K>try</SPAN> w funkcji <SPAN CLASS=T>main</SPAN>, a pozosta³e ("podrzêdne") umieszczamy w funkcjach wywo³ywanych w "g³ównym" bloku <SPAN CLASS=K>try</SPAN>.
</P>
<P>
Oczywiœcie nie od rzeczy bêdzie to zilustrowaæ przyk³adzikiem. Niemal ka¿da aplikacja otwiera jakieœ pliki. Jedne s¹ do jej dzia³ania niezbêdne (np. biblioteki DLL) i w przypadku niemo¿noœci otwarcia lub odczytania takiego pliku nie ma sensu w ogóle kontynuowaæ dzia³ania programu (czêsto jest to zreszt¹ po prostu niemo¿liwe). Inne pliki mog¹ byæ bardzo wa¿ne dla pracy z aplikacj¹, ale nie A¯ TAK wa¿ne, ¿eby ca³kiem wy³¹czyæ program, kiedy plików tych nie da siê wczytaæ. Na przyk³ad: mamy edytor tekstu, w którym nie da siê otworzyæ pewnego dokumentu - nie mo¿emy byæ a¿ tak radykalni, by z tego powodu rzucaæ "bezpowrotny" wyj¹tek! Trzeba daæ u¿ytkownikowi szansê, by spróbowa³ jeszcze raz - mo¿e plik "siê naprawi", mo¿e u¿ytkownik zadowoli siê jakimœ innym dokumentem... ;-)
</P>
<P>
Tak wiêc ustalamy, ¿e gdy coœ z³ego dzieje siê z plikiem, który mia³ byæ odczytany, to rzucamy "nieszkodliwy" wyj¹tek <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>, natomiast "zwyk³y"<SPAN CLASS=T> cEXCEPTION </SPAN>zostawiamy dla sytuacji naprawdê krytycznych, kiedy praca programu jako ca³oœci nie jest mo¿liwa. Do operacji I/O na pliku wykorzystamy tutaj funkcje WinAPI:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> CzytajPlik(string NazwaPliku)<BR>
{<BR>
&nbsp;HANDLE hPlik;<BR>
&nbsp;DWORD dwRet, dwBuf, dwRead;<BR>
&nbsp;BYTE* Dane;<BR>
<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//otwarcie pliku</SPAN><BR>
&nbsp;&nbsp;hPlik = CreateFile(NazwaPliku.c_str(), GENERIC_READ, <SPAN CLASS=L>0</SPAN>, NULL, OPEN_EXISTING, <SPAN CLASS=L>0</SPAN>, NULL);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(hPlik == INVALID_HANDLE_VALUE)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>throw</SPAN> cSMALL_EXCEPT(ERR_FILEOPEN);<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//odczytaj z pliku rozmiar bufora</SPAN><BR>
&nbsp;&nbsp;dwRet = ReadFile(hPlik, &dwBuf, <SPAN CLASS=K>sizeof</SPAN>(DWORD), &dwRead, NULL);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(!dwRet || dwRead &lt; <SPAN CLASS=K>sizeof</SPAN>(DWORD))<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>throw</SPAN> cSMALL_EXCEPT(ERR_FILEREAD);<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//alokuj pamiêæ dla bufora</SPAN><BR>
&nbsp;&nbsp;Dane = (BYTE*)GlobalAlloc(GMEM_FIXED, dwBuf);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(Dane == NULL)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>throw</SPAN> cEXCEPTION(ERR_MEMORY);<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//czytaj dane do bufora</SPAN><BR>
&nbsp;&nbsp;dwRet = ReadFile(hPlik, Dane, dwBuf, &dwRead, NULL);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(!dwRet || dwRead &lt; dwBuf)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>throw</SPAN> cSMALL_EXCEPT(ERR_FILEREAD);<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//zamknij plik</SPAN><BR>
&nbsp;&nbsp;CloseHandle(hPlik);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(cSMALL_EXCEPT Wyjatek)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;MessageBox(hwnd, (<SPAN CLASS=L>"Nie mo¿na odczytaæ pliku "</SPAN> + NazwaPliku).c_str(), NULL, MB_ICONEXCLAMATION); <BR>
&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, przy czytaniu danych z pliku mo¿e siê zdarzyæ wiele niemi³ych rzeczy. Ich nastêpstwem jest niemo¿noœæ wczytania danych, dlatego te¿ rzucamy "tylko" <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>, by taki wyj¹tek powodowa³ wprawdzie wyœwietlenie komunikatu o b³êdzie, ale pozwala³ na dalsze u¿ytkowanie programu. Dlatego zastosowaliœmy "lokalny" blok <SPAN CLASS=K>catch</SPAN>, który zajmuje siê wyœwietleniem komunikatu . Gdy u¿ytkownik przeczyta sobie ten komunikat, sterowanie zostaje przekazane dalej, po czym u¿ytkownik mo¿e kontynuowaæ pracê (i ewentualnie wœciekaæ siê, ¿e nie mo¿e otworzyæ pliku, ale to ju¿ nie nasza wina ;-)).
</P>
<P>
Przytoczymy sobie jeszcze wygl¹d funkcji <SPAN CLASS=T>main</SPAN> dla powy¿szego przyk³adu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> CzytajPlik(string NazwaPliku); <SPAN CLASS=C>//deklaracja</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;CzytajPlik(<SPAN CLASS=L>"test.dat"</SPAN>);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(cEXCEPTION Wyjatek)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Wyjatek.Msg();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_FAILURE;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> EXIT_SUCCESS;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Ten blok <SPAN CLASS=K>try-catch</SPAN> zajmuje siê tylko ³apaniem "powa¿nych" wyj¹tków i nie zwraca uwagi na takie drobiazgi, jak <SPAN CLASS=T>cSMALL_EXCEPT</SPAN>. To tak jak dyrektor w firmie, którego nie interesuje, ¿e szeregowy pracownik ogl¹da strony porno, zamiast wykonywaæ swoje zadania - to jest sprawa kierowników ni¿szego szczebla ;-). Dopiero jak kierownik sam coœ przeskrobie, mo¿e to mieæ negatywny wp³yw na funkcjonowanie ca³ej firmy i wtedy dyrektor musi osobiœcie wkroczyæ do akcji ;-).
</P>
<P>
Tak wiêc wynika st¹d nauka, ¿e <SPAN CLASS=K>catch</SPAN> w funkcji main mo¿e s³u¿yæ TYLKO do obs³ugi bardzo powa¿nych b³êdów, które uniemo¿liwiaj¹ pracê ca³ego programu, natomiast "l¿ejsze" wyj¹tki (bêd¹ce zazwyczaj raczej win¹ u¿ytkownika, ni¿ nasz¹) - w g³êbi kodu (o ile kod posiada jak¹œ g³êbiê - ale chyba wiadomo, o co chodzi).
</P>
<P>
Warto na koniec zauwa¿yæ, ¿e rzucenie wyj¹tku <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> w miejscu, gdzie nie bêdzie go móg³ z³apaæ "lokalny" blok <SPAN CLASS=K>catch</SPAN> mia³oby jeszcze gorsze efekty, ni¿ rzucenie <SPAN CLASS=T>cEXCEPTION</SPAN>, gdyby ten pierwszy nie dziedziczy³ po tym drugim. Mielibyœmy bowiem wtedy niez³apany wyj¹tek, a jak siê koñczy niez³apanie wyj¹tku - wiemy. Poniewa¿ jednak <SPAN CLASS=T>cSMALL_EXCEPT</SPAN> jest w³aœnie klas¹ pochodn¹, to <SPAN CLASS=K>catch</SPAN> w funkcji <SPAN CLASS=T>main</SPAN> bêdzie ³apaæ równie¿ i takie wyj¹tki, z tym, ¿e zostan¹ one potraktowane jak <SPAN CLASS=T>cEXCEPTION</SPAN>. Mamy wiêc kolejny dowód na to, ¿e tworzenie hierarchii klas wyj¹tków mo¿e byæ dobrym pomys³em.
</P>

<h2>
Podsumowanie
</h2>

<P>
Spodziewam siê, ¿e przynajmniej czêœæ czytelników mo¿e mieæ teraz w g³owie niez³y mêtlik. Czy te wyj¹tki s¹ naprawdê przydatne, czy to tylko taki bajer? Czy op³aca siê uczyæ ich stosowania? Czy nale¿y wprowadzaæ obs³ugê wyj¹tków do ju¿ gotowego kodu?
</P>
<P>
Przede wszystkim warto zdawaæ sobie sprawê, ¿e wyj¹tki nie s¹ naprawdê niezbêdne. Mo¿na napisaæ ka¿dy program bez u¿ywania s³ówek <SPAN CLASS=K>try, throw</SPAN> i <SPAN CLASS=K>catch</SPAN>, zapewniaj¹c obs³ugê sytuacji wyj¹tkowych tzw. metodami tradycyjnymi (czyli wszystkimi, które stosowano przed "wynalezieniem" <SPAN CLASS=K>try/throw/catch</SPAN> :-)). Jeœli zrobi siê to z g³ow¹, mechanizm taki mo¿e byæ nawet równie efektywny, zw³aszcza dla ma³ych projektów (generalnie wyj¹tki wprowadzono g³ównie z myœl¹ o "profesjonalnych" projektach, które bywaj¹ naprawdê bycze i gdzie nawet niewielkie opóŸnienie w kodzeniu mo¿e siê zakoñczyæ czyimœ bankructwem ;-)).
</P>
<P>
Z drugiej strony nikt nie zamierza zabroniæ autorowi projektu ma³ego i amatorskiego korzystania z wyj¹tków. Dlatego te¿ powinieneœ kierowaæ siê przede wszystkim w³asnym wyczuciem. Jeœli wydaje ci siê, ¿e nie bardzo kumasz ten temat, to mo¿esz go sobie na razie odpuœciæ i stosowaæ nadal wspomniane ju¿ tradycyjne metody radzenia sobie z b³êdami. Jeœli robisz ma³y program i chcesz siê pobawiæ wyj¹tkami dla celów edukacyjnych - proszê bardzo. Jeœli robisz ma³y program i zale¿y ci przede wszystkim na czasie - uwa¿aj, zaimplementowanie w pe³ni funkcjonalnej hierarchii wyj¹tków prawdopodobnie zajmie ci wiêcej tego czasu, ni¿ w ten sposób oszczêdzisz. Jeœli robisz du¿y program i zale¿y ci na czasie (a zale¿y ci zawsze, kiedy robisz du¿y program ;-)), to warto przyjrzeæ siê wyj¹tkom. Jeœli masz du¿y program z "tradycyjn¹" obs³ug¹ wyj¹tków i dzia³a on zadowalaj¹co - prawdopodobnie szkoda zachodu, by wprowadzaæ "nowoczesn¹" obs³ugê.
</P>
<P>
Bez wzglêdu na to, czy w danym projekcie postanowisz u¿ywaæ wyj¹tków czy te¿ nie, tradycyjnie ¿yczê, by wiedza zawarta w tym odcinku kursu jak najrzadziej ci siê przydawa³a ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs10.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs11.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>