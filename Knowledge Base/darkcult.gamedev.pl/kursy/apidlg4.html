<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Predefiniowane dialogi</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apidlg3.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidlg5.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Dialog wyboru koloru
</h2>

<P>
Wiêc chodŸ, pomaluj mój œwiat na ¿ó³to i na niebieeeesko! No dobra, ale najpierw przyda³oby siê wybraæ te kolory, bo inaczej pomalujemy œwiat na czarno, a przecie¿ nie jesteœmy ¿adnymi wrednymi satanistami (bez wzglêdu na to, co sugeruje nazwa tej strony ;-)) i kolorki lubimy. Dialog, jaki sobie tym razem wyczarujemy, wygl¹da nastêpuj¹co:
</P>

<P align=center>
<img src="../gfx/colordlg.gif" alt="Kolorowo, a¿ siê niedobrze robi ;-)">
</P>

<P>
Czarowanie rozpoczniemy, jak siê pewnie domyœlasz, od przedstawienia nowej struktury. Bêdzie to struktura typu <SPAN CLASS=T>CHOOSECOLOR</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>typedef struct</SPAN><BR>
 {   <SPAN CLASS=C>// cc</SPAN><BR> 
&nbsp;   DWORD        lStructSize;<BR>
&nbsp;   HWND         hwndOwner;<BR>
&nbsp;   HWND         hInstance;<BR> 
&nbsp;   COLORREF     rgbResult;<BR>
&nbsp;   COLORREF*    lpCustColors;<BR>
&nbsp;   DWORD        Flags;<BR>
&nbsp;   LPARAM       lCustData;<BR> 
&nbsp;   LPCCHOOKPROC lpfnHook;<BR>
&nbsp;   LPCTSTR      lpTemplateName;<BR>
} CHOOSECOLOR; 
</TD></TR>
</TABLE>


<P>
Jak widzisz, w porównaniu z <SPAN CLASS=T>OPENFILENAME</SPAN> nie ma siê czego baæ :-). Zreszt¹ znów mo¿emy bezczelnie pomin¹æ kilka pól, które na razie nam siê nie przydadz¹. Dwa pierwsze pola ju¿ znasz, takie same by³y w strukturze <SPAN CLASS=T>OPENFILENAME</SPAN>. Znaczenia czwartego i pi¹tego siê pewnie domyœlasz - tak, tu bêdzie przechowywany rezultat dialogu.
</P>
<P>
Zwróæ uwagê na pole <SPAN CLASS=T>lpCustColors</SPAN>. Powinien on wskazywaæ na tablicê <SPAN CLASS=L>16</SPAN> kolorów. Musimy j¹ sobie sami stworzyæ. Jak widaæ, na dialogu wyboru koloru mamy <SPAN CLASS=L>48</SPAN> predefiniowanych (standardowych) kolorów - tych zmieniaæ nie mo¿emy, mo¿na je tylko wybraæ, oraz <SPAN CLASS=L>16</SPAN> kolorów niestandardowych, definiowanych przez u¿ytkownika. To w³aœnie na nie jest ta tablica. Jeœli jej nie utworzymy, dialog nie bêdzie mia³ gdzie przechowywaæ danych o tych kolorach.
</P>
<P>
Tablicê, wskazywan¹ przez <SPAN CLASS=T>lpCustColors</SPAN> dobrze jest zainicjalizowaæ, albo przynajmniej wyzerowaæ funkcj¹ <SPAN CLASS=T>ZeroMemory</SPAN>. Jeœli tego nie zrobimy, to nic z³ego siê nie stanie, po prostu dialog bêdzie wyœwietla³ <SPAN CLASS=L>16</SPAN> przypadkowych kolorów.
</P>
<P>
Nie pozostaje nic innego, jak tylko wype³niæ strukturê i wywo³aæ dialog na scenê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CHOOSECOLOR ccl;<BR>
COLORREF TabKol[<SPAN CLASS=L>16</SPAN>];<BR>
BOOL bResult;<BR>
<BR>
ZeroMemory(&ccl, <SPAN CLASS=K>sizeof</SPAN>(CHOOSECOLOR));<BR>
ccl.lStructSize = <SPAN CLASS=K>sizeof</SPAN>(CHOOSECOLOR);<BR>
ccl.hwndOwner = hwnd;<BR>
ccl.lpCustColors = TabKol;<BR>
ccl.Flags = CC_ANYCOLOR;<BR>
bResult = ChooseColor(&ccl);<BR>
</TD></TR>
</TABLE>

<P>
Jeœli wszystko pójdzie zgodnie z planem, to funkcja <SPAN CLASS=T>ChooseColor</SPAN> zwróci <SPAN CLASS=T>TRUE</SPAN>. W przeciwnym wypadku bêdziemy musieli wywo³aæ specjaln¹ funkcjê <SPAN CLASS=T>CommDlgExtendedError</SPAN> w celu sprawdzenia, jaki konkretnie b³¹d wyst¹pi³. Jeœli <SPAN CLASS=T>ChooseColor</SPAN> zwróci <SPAN CLASS=T>FALSE</SPAN>, ale <SPAN CLASS=T>CommDlgExtendedError</SPAN> zwróci <SPAN CLASS=L>0</SPAN>, bêdzie to oznacza³o, ¿e ¿adnego b³êdu nie by³o, tylko u¿ytkownik wcisn¹³ przycisk Anuluj:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD dwErr;<BR>
bResult = ChooseColor(&ccl);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(bResult)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wybrano nowy kolor", "test"</SPAN>, MB_ICONINFORMATION);<BR>
<SPAN CLASS=K>else</SPAN><BR>
{<BR>
&nbsp;dwErr = CommDlgExtendedError();<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(!dwErr)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Anulowano wybór koloru", "test"</SPAN>, MB_ICONEXCLAMATION);<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wyst¹pi³ jakowyœ b³¹d", "test"</SPAN>, MB_ICONSTOP);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Ten przyk³ad ilustruje tylko samo wywo³anie dialogu, nie robi nic z wybranym kolorem (który zwracany jest w polu <SPAN CLASS=T>rgbResult</SPAN>, jak nietrudno siê domyœliæ) ani nawet nie sprawdza, czy u¿ytkownik wybra³ w ogóle jakiœ kolor. To wszystko pozostawiam tobie do samodzielnych eksperymentów.
</P>


<h2>
Dialog wyboru czcionki
</h2>

<P>
Z wyborem czcionek sprawa ma siê podobnie. Tym razem struktura nazywa siê <SPAN CLASS=T>CHOOSEFONT</SPAN>, a funkcja otwieraj¹ca dialog - <SPAN CLASS=T>ChooseFont</SPAN>. Mamy te¿ i flagi - w wiêkszoœci oznaczaj¹ one rodzaje czcionek, jakie maj¹ byæ dostêpne do wyboru:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>typedef struct</SPAN><BR> { <SPAN CLASS=C>   // cf</SPAN><BR> 
&nbsp;DWORD        lStructSize;<BR>
&nbsp;HWND         hwndOwner;<BR>
&nbsp;HDC          hDC;<BR>
&nbsp;LPLOGFONT    lpLogFont;<BR>
&nbsp;INT          iPointSize;<BR>
&nbsp;DWORD        Flags;<BR>
&nbsp;DWORD        rgbColors;<BR> 
&nbsp;LPARAM       lCustData;<BR>
&nbsp;LPCFHOOKPROC lpfnHook;<BR>
&nbsp;LPCTSTR      lpTemplateName;<BR>
&nbsp;HINSTANCE    hInstance;<BR>
&nbsp;LPTSTR       lpszStyle;<BR>
&nbsp;WORD         nFontType;<BR>
&nbsp;WORD         ___MISSING_ALIGNMENT__;<BR>
&nbsp;INT          nSizeMin;<BR>
&nbsp;INT          nSizeMax;<BR>
} CHOOSEFONT;<BR>
</TD></TR>
</TABLE>

<P>
Trochê tego wiêcej ni¿ ostatnio, ale nie marudzimy i zabieramy siê do roboty:
</P>


<TABLE BORDER WIDTH=100%>
<TR><TD>
CHOOSEFONT cfnt;<BR>
LOGFONT lf;<BR>
<BR>
ZeroMemory(&cfnt, <SPAN CLASS=K>sizeof</SPAN>(CHOOSEFONT));<BR>
cfnt.lStructSize = <SPAN CLASS=K>sizeof</SPAN>(CHOOSEFONT);<BR>
cfnt.hwndOwner = hwnd;<BR>
cfnt.Flags = CF_EFFECTS | CF_FORCEFONTEXIST | CF_SCREENFONTS;<BR>
cfnt.lpLogFont = &lf;<BR>
</TD></TR>
</TABLE>

<P>
Podobnie jak w przypadku dialogu z kolorkami, tutaj równie¿ potrzebujemy w³asnej zmiennej, tym razem typu <SPAN CLASS=T>LOGFONT</SPAN>. WskaŸnik do niej musimy przekazaæ w polu <SPAN CLASS=T>lpLogFont</SPAN> (ostatnia linijka przyk³adu). Jest to bardzo wa¿ne, gdy¿ inaczej dialog nie bêdzie mia³ gdzie zapamiêtaæ wybranej czcionki. Gdybyœmy dorzucili do flag <SPAN CLASS=T>CF_INITTOLOGFONTSTRUCT</SPAN>, a zmienna <SPAN CLASS=T>lf</SPAN> zawiera³aby ju¿ prawid³owy opis czcionki, to dialog przyj¹³by tê czcionkê za domyœln¹.
</P>

<P align=center>
<img src="../gfx/fontdlg.gif" alt="Dialog wyboru czcionki">
</P>

<P>
U¿yliœmy trzech flag, jak widaæ. Pierwsza, <SPAN CLASS=T>CF_EFFECTS</SPAN>, oznacza ¿e dialog powinien umo¿liwiaæ wybór efektów dla czcionki. Te efekty to: podkreœlenie, przekreœlenie oraz kolor. Nie s¹ to zbyt potrzebne rzeczy, ale domyœlnie s¹ ukryte, co paskudnie wygl¹da.
</P>
<P>
Flaga <SPAN CLASS=T>CF_FORCEFONTEXIST</SPAN> oznacza, ¿e u¿ytkownik musi wybraæ istniej¹c¹ czcionkê. Jeœli menda wpisze z³oœliwie coœ dziwnego w pole z nazw¹ czcionki, a ta flaga jest ustawiona, to system ochrzani u¿ytkownika za pisanie g³upot ;-).
</P>
<P>
No i wreszcie <SPAN CLASS=T>CF_SCREENFONTS</SPAN> mówi systemowi, ¿e ma nam wyœwietliæ tylko czcionki ekranowe. Gdyby by³a taka potrzeba, moglibyœmy wyœwietliæ tylko czcionki drukarki (flaga <SPAN CLASS=T>CF_PRINTERFONTS</SPAN>) albo i jedne, i drugie (flaga <SPAN CLASS=T>CF_BOTH</SPAN>). Jeœli natomiast nie damy ¿adnej z wymienionych w tym akapicie trzech flag, to dostaniemy uroczy (i absurdalny) komunikat, ¿e nie zainstalowano ¿adnych czcionek w systemie, a nastêpnie funkcja <SPAN CLASS=T>ChooseFont</SPAN> zwróci <SPAN CLASS=T>FALSE</SPAN>, co oznacza b³¹d.
</P>
<P>
Jeœli jednak do takiej nieweso³ej sytuacji nie dosz³o, to <SPAN CLASS=T>ChooseFont</SPAN> zwraca <SPAN CLASS=T>TRUE</SPAN> i wówczas mo¿emy skorzystaæ z kilku nastêpnych pól naszej struktury <SPAN CLASS=T>CHOOSEFONT</SPAN>, a¿eby uzyskaæ informacje o wybranej przez u¿ytkownika czcionce. Pole <SPAN CLASS=T>iPointSize</SPAN> bêdzie wówczas zawiera³o wybrany rozmiar czcionki, <SPAN CLASS=T>rgbColors</SPAN> - jej kolor, <SPAN CLASS=T>nFontType</SPAN> - typ czcionki (zawiera informacjê o pogrubieniu / pochyleniu czcionki, o tym czy jest to czcionka ekranowa czy te¿ czcionka drukarki itp.). No i najwa¿niejsze pole - <SPAN CLASS=T>lpLogFont</SPAN> bêdzie zawiera³o wskaŸnik do struktury <SPAN CLASS=T>LOGFONT</SPAN>, opisuj¹cej wybran¹ czcionkê.
</P>
<P>
Pozostaje pytanie, jak wykorzystaæ informacje zawarte w <SPAN CLASS=T>LOGFONT</SPAN>... Wiemy bowiem, ¿e aby wybraæ czcionkê dla danego kontekstu, podajemu uchwyt do niej (typu <SPAN CLASS=T>HFONT</SPAN>). Na szczêœcie uzyskanie uchwytu na podstawie struktury <SPAN CLASS=T>LOGFONT</SPAN> nie jest to zbyt skomplikowane. S³u¿y do tego funkcja <SPAN CLASS=T>CreateFontIndirect</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HFONT hfnMyFont;<BR>
hfnMyFont = CreateFontIndirect(cfnt.lpLogFont);<BR>
<SPAN CLASS=K>if</SPAN>(hfnMyFont == NULL)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wredna czciona nie chce siê utworzyæ..."</SPAN>, NULL, MB_ICONEXCLAMATION);<BR>
</TD></TR>
</TABLE>

<P>
Pora na krótki przyk³ad zastosowania. Za³ó¿my, ¿e mamy EDIT-a o globalnym uchwycie <SPAN CLASS=T>g_hEdit</SPAN>, przycisk (o uchwycie <SPAN CLASS=T>g_hButton</SPAN>) do otwierania dialogu wyboru czcionki oraz globalny uchwyt <SPAN CLASS=T>g_hfnNowy</SPAN> typu <SPAN CLASS=T>HFONT</SPAN> (domyœlnie ustawiony na <SPAN CLASS=T>NULL</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>( (HWND)lParam != g_hButton ) <SPAN CLASS=K>break</SPAN>;<BR>
<BR>
&nbsp;CHOOSEFONT cfnt;<BR>
&nbsp;LOGFONT lf;<BR>
&nbsp;ZeroMemory(&cfnt, <SPAN CLASS=K>sizeof</SPAN>(CHOOSEFONT));<BR>
&nbsp;cfnt.lStructSize = <SPAN CLASS=K>sizeof</SPAN>(CHOOSEFONT);<BR>
&nbsp;cfnt.hwndOwner = hwnd;<BR>
&nbsp;cfnt.Flags = CF_EFFECTS | CF_FORCEFONTEXIST | CF_SCREENFONTS;<BR>
&nbsp;cfnt.lpLogFont = &lf;<BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(!ChooseFont(&cfnt))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;DWORD dwErr = CommDlgExtendedError();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(dwErr) MessageBox(hwnd, <SPAN CLASS=L>"Straszliwy b³¹d dialogu!"</SPAN>, NULL, MB_ICONEXCLAMATION);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(g_hfnNowy != NULL)<BR>
&nbsp;&nbsp;&nbsp;DeleteObject(g_hfnNowy);<BR>
&nbsp;&nbsp;g_hfnNowy = CreateFontIndirect(cfnt.lpLogFont);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(hfnNowy != NULL)<BR>
&nbsp;&nbsp;&nbsp;SendMessage(g_hEdit, WM_SETFONT, (WPARAM)hfnNowy, MAKELPARAM(TRUE,<SPAN CLASS=L>0</SPAN>));<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
<SPAN CLASS=K>case</SPAN> WM_DESTROY:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(g_hfnNowy != NULL) DeleteObject(g_hfnNowy);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>


</TD></TR>
</TABLE>

<P>
Jak ³atwo siê przekonaæ (a dla niektórych wystarczy nawet spojrzeæ ;-)), powy¿szy kod sprawia, ¿e naciœniêcie przycisku otwiera dialog wyboru czcionki, a w przypadku gdyby u¿ytkownik by³ na tyle mi³y i wybra³ jak¹œ, to czcionka ta zostanie ustawiona dla pola tekstowego.
</P>

<P>
Do ustawienia czcionki dla okna (tutaj dla pola tekstowego) pos³u¿yliœmy siê komunikatem WM_SETFONT. Jego parametry to: uchwyt czcionki oraz flaga oznaczaj¹ca, czy po zmianie czcionki okno (kontrolka) ma byæ odœwie¿one (u nas jak najbardziej <SPAN CLASS=T>TRUE</SPAN>).
</P>


<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apidlg3.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidlg5.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>