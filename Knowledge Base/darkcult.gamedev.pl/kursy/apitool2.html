<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Toolbary</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitool.html">&lt;&lt; Toolbary, cz.1</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool3.html">Toolbary, cz.3</A> &gt;&gt; &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Wizualne bajery
</H1>

<h2>
P³askie toolbary
</h2>

<P>
Pewnie nie jesteœ zachwycony dotychczasowymi efektami? Toolbary w "profesjonalnych" aplikacjach wygl¹da³y jakoœ inaczej, no nie? Zgadza siê, w dzisiejszych czasach modne s¹ p³askie przyciski na toolbarach, trójwymiarowe nie s¹ ju¿ trendi ;-P. Zrobienie "p³askiego" toolbaru jest wrecz banalne, wystarczy dodaæ do stylów toolbaru sta³¹ <SPAN CLASS=T>TBSTYLE_FLAT</SPAN>. Wypuszcza ona powietrze z tych paskudnych, nadêtych przycisków i ju¿ wygl¹daj¹ one ca³kiem przyzwoicie:
</P>

<P align=center>
<img src="../gfx/toolbarf.gif" alt="P³aski jak decha - i tak ma byæ">
</P>

<P>
Niestety, w Dev-ie jest drobna przeszkoda, która mo¿e nieco utrudniæ ustawienie wspomnianego stylu. Mianowicie plik nag³ówkowy <SPAN CLASS=C>commctrl.h</SPAN> z tego pakietu jest kompletnie skopany i praktycznie nie da siê go u¿ywaæ bez wprowadzenia do niego kilku w³asnorêcznych modyfikacji. Nie ma siê co ³amaæ, mo¿na dodaæ na poczatku programu jakieœ zaklêcie w rodzaju:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#ifndef</SPAN> TBSTYLE_FLAT<BR>
<SPAN CLASS=C>#define</SPAN> TBSTYLE_FLAT <SPAN CLASS=L>2048</SPAN><BR>
<SPAN CLASS=C>#endif</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Poniewa¿ jednak nie jest to jedyna sta³a, której brakuje lub która jest Ÿle zdefiniowana, musimy przerobiæ ca³y nag³ówek. Nie martw siê, nie bêdziesz musia³ siê tym na razie mêczyæ - w dziale Download znajdziesz spakowany nag³ówek w wersji poprawionej przeze mnie. Nadal nie jest on do koñca sprawny, ale przynajmniej wszystkie rzeczy opisane w tym kursie bêdziesz móg³ skompilowaæ bez problemów.
</P>
<P>
Wracaj¹c do toolbaru... Istnieje mo¿liwoœæ utworzenia przezroczystego toolbaru, tj. samych przycisków, bez t³a. Tym razem ilustracji nie bêdzie, gdy¿ na szarym okienku taki toolbar wygl¹da dok³adnie tak samo, jak zwyk³y, ale gdybyœ kiedyœ robi³ program z piêknym bitmapowym t³em, mo¿e ci siê ten przezroczysty toolbarek przydaæ ;-). Wystarczy zamiast <SPAN CLASS=T>TBSTYLE_FLAT</SPAN> daæ <SPAN CLASS=T>TBSTYLE_TRANSPARENT</SPAN>.
</P>

<H2>
Ramka
</H2>

<P>
Toolbar doœæ paskudnie wygl¹da, jeœli pozbawiony jest ramki. Mo¿esz j¹ dodaæ, ustawiaj¹c mu styl <SPAN CLASS=T>WS_BORDER</SPAN>. Powy¿szy screen przedstawia w³aœnie toolbar z ramk¹.
</P>

<h2>
Ikony + tekst
</H2>

<P>
Przedstawiony powy¿ej toolbar wyœwietla same ikony, ale w wiêkszoœci wspó³czesnych aplikacji (w tym Dev-C++) mo¿esz siê spotkaæ równie¿ z przyciskami sk³adaj¹cymi siê i z tekstu, i z ikony. Zmajstrowanie takiego cuda nie jest szczególnie trudne. Wystarczy dodaæ odpowiednie napisy do wewnêtrznej listy stringów toolbaru, wysy³aj¹c komunikat <SPAN CLASS=T>TB_ADDSTRING</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hToolbar, TB_ADDSTRING, <SPAN CLASS=L>0</SPAN>, (LPARAM)<SPAN CLASS=L>"Nowy\0Otwórz\0Zapisz\0-\0Koniec\0"</SPAN>);
</TD></TR>
</TABLE>

<P>
Jak widaæ, poszczególne napisy musz¹ byæ rozdzielone znakami zerowymi, a na ich koñcu powinien znajdowaæ siê podwójny znak zerowy (tutaj widaæ tylko jeden, zgadnij dlaczego ;-)). Napisy te przekazujemy w parametrze <SPAN CLASS=T>lParam</SPAN>. Mo¿na równie¿ wykorzystaæ napisy zawarte w pliku zasobów, wtedy parametr <SPAN CLASS=T>wParam</SPAN> okreœla uchwyt programu, a <SPAN CLASS=T>lParam</SPAN> - identyfikator napisu w pliku. Teraz musimy jeszcze oczywiœcie poprzydzielaæ indeksy napisów na œwie¿o utworzonej liœcie odpowiednim przyciskom (czyli wype³niæ pole <SPAN CLASS=T>iString</SPAN>), co jednak w naszym przyk³adzie ju¿ zapobiegawczo zrobiliœmy na samym pocz¹tku ;-).
</P>
<P align=center>
<img src="../gfx/toolbar5.gif" alt="Ikonki z tekstem">
</P>
<P>
Istnieje mo¿liwoœæ przypisywania pojedynczych stringów do przycisku bez koniecznoœci dodawania ich do wewnêtrznej listy. Wystarczy zrobiæ takie ma³e "oszustwo" i podaæ adres bufora ze stringiem, zamiast indeksu do <SPAN CLASS=T>iString</SPAN>, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPSTR buf = (LPSTR)GlobalAlloc(GMEM_FIXED, <SPAN CLASS=L>100</SPAN>);<BR>
LoadString(hThisInstance, IDS_NAPIS, buf, <SPAN CLASS=L>100</SPAN>);<BR>
tbb[<SPAN CLASS=L>0</SPAN>].iString = (<SPAN CLASS=K>int</SPAN>)buf;<BR>
</TD></TR>
</TABLE>

<P>
Ta metoda oczywiœcie pozwala tylko na dodawanie nowych przycisków. Co zrobiæ, jeœli chcemy zmieniæ napis ju¿ istniej¹cego przycisku? Otó¿ nowsze wersje biblioteki daj¹ nam w prezencie przydatny komunikat <SPAN CLASS=T>TB_SETBUTTONINFO</SPAN>. Pozwala on zmieniæ atrybuty przycisku w dowolnym momencie. Niestety, korzysta on z nieco innej struktury, ni¿ dotychczas omawiana <SPAN CLASS=T>TBBUTTON</SPAN>. Zmiana etykiety przycisku przy pomocy tego komunikatu bêdzie wygl¹da³a tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBBUTTONINFO tbbi;<BR>
ZeroMemory(&tbbi, <SPAN CLASS=K>sizeof</SPAN>(tbbi));<BR>
<BR>
tbbi.cbSize = <SPAN CLASS=K>sizeof</SPAN>(tbbi);<BR>
tbbi.dwMask = TBIF_TEXT;<BR>
tbbi.pszText = <SPAN CLASS=L>"To ju¿ jest koniec"</SPAN>;<BR>
<BR>
SendMessage(hToolbar, TB_SETBUTTONINFO, TOOL_KONIEC, (LPARAM)&tbbi); <BR>
</TD></TR>
</TABLE>

<P>
W sumie nie ma tutaj co omawiaæ; przerabialiœmy podobne rzeczy ju¿ tysi¹ce razy. Pole <SPAN CLASS=T>dwMask</SPAN> okreœla, których z pozosta³ych pól struktury u¿ywamy. Potrzebujemy tylko ustawiæ pole <SPAN CLASS=T>pszText</SPAN>, wiêc do <SPAN CLASS=T>dwMask</SPAN> wpisujemy sta³¹ <SPAN CLASS=T>TBIF_TEXT</SPAN>. W samym komunikacie <SPAN CLASS=T>TB_SETBUTTONINFO</SPAN> przekazujemy wskaŸnik do struktury jako <SPAN CLASS=T>lParam</SPAN>, oraz identyfikator zmienianego przycisku jako <SPAN CLASS=T>wParam</SPAN>. My zmieniamy przycisk <SPAN CLASS=T>TOOL_KONIEC</SPAN>. Oczywiœcie tak d³ugi tekst, jak tutaj podaliœmy, nie zmieœci siê na przycisku, wiêc bêdziemy musieli go jeszcze rozszerzyæ (ustawiaj¹c dodatkowo pole <SPAN CLASS=T>cx</SPAN> struktury <SPAN CLASS=T>TBBUTTONINFO</SPAN>), ale to ju¿ twoja praca domowa  (albo zajrzyj na koniec tej strony ;-) ).
</P>

<P>
Mo¿esz równie¿ sprawiæ, ¿eby tekst wyœwietlany by³ nie pod spodem, ale obok ikony. Odpowiada za to styl <SPAN CLASS=T>TBSTYLE_LIST</SPAN>.
</P>

<P align=center>
<img src="../gfx/toolbar4.gif" alt="Tekst obok obrazka"
</P>


<h2>
Przycisk + rozwijalna lista
</h2>

<P>
Wiele programów (np. Internet Explorer) ma takie fajne przyciski ze strza³eczk¹ obok. Jeœli j¹ nacisn¹æ, pojawia siê dodatkowe menu. My te¿ mo¿emy sobie taki przycisk zrobiæ, a co. Niech bêdzie to przycisk Importuj (jeœli nie wiesz o co chodzi - zajrzyj do odcinka o menu). Bêdzie on rozwija³ to samo podmenu, które pojawia siê po najechaniu na pozycjê menu <SPAN CLASS=L>"Importuj"</SPAN>.
</P>
<P>
Przede wszystkim potrzebny nam przycisk ze stylem <SPAN CLASS=T>TBSTYLE_DROPDOWN</SPAN> (lub <SPAN CLASS=T>BTNS_DROPDOWN</SPAN>, dla wy¿szych wersji biblioteki). Tak wiêc wype³nianie odpowiedniego pola struktury <SPAN CLASS=T>TBBUTTON</SPAN> (ca³oœci nie podajê, bo ju¿ to przerabialiœmy ;-)) powinno wygl¹daæ mniej wiêcej w ten sposób:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
tbb[<SPAN CLASS=L>1</SPAN>].fsStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN;<BR>
</TD></TR>
</TABLE>

<P>
Samo to szczêœcia nam nie da, bo trzeba jeszcze wyprodukowaæ strza³kê. W tym celu musimy ustawiæ rozszerzony styl <SPAN CLASS=T>TBSTYLE_EX_DRAWDDARROWS</SPAN>. Niestety, nie jest to takie proste jak w przypadku "zwyk³ych" stylów - robi siê to przez oddzielny komunikat, <SPAN CLASS=T>TB_SETEXTENDEDSTYLE</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hToolbar, TB_SETEXTENDEDSTYLE, <SPAN CLASS=L>0</SPAN>, TBSTYLE_EX_DRAWDDARROWS);
</TD></TR>
</TABLE>

<P>
Dziêki temu eksperymentowi powinniœmy ju¿ otrzymaæ gotowy przycisk ze strza³k¹. Teraz trzeba tak pokombinowaæ, ¿eby po klikniêciu na strza³kê pojawia³o siê menu. Tutaj czeka nas d³u¿sza gimnastyka. Zak³adamy, ¿e g³ówne menu programu ju¿ mamy gotowe (ze wspomnianego odcinka kursu...), wiêc mo¿emy skorzystaæ z funkcji <SPAN CLASS=T>GetSubMenu</SPAN>, aby pobraæ uchwyt do tego fragmentu menu, który nas interesuje, a nastêpnie wyœwietliæ je za pomoc¹ <SPAN CLASS=T>TrackPopupMenu</SPAN>.
</P>
<P>
Jak wykryæ, ¿e naciœniêto strza³kê obok przycisku, a nie sam przycisk? Otó¿ wysy³ane jest wówczas powiadomienie <SPAN CLASS=T>TBN_DROPDOWN</SPAN>. <SPAN CLASS=Wazne>Powiadomienie</SPAN>, a nie komunikat! I tutaj przyda³aby siê ma³a dygresja na temat powiadomieñ. Ka¿de powiadomienie wysy³ane jest jako komunikat <SPAN CLASS=T>WM_NOTIFY</SPAN>. ¯eby rozró¿niæ, jakie konkretnie jest to powiadomienie (jest ich wiele rodzajów, podobnie jak ze "zwyk³ymi" komunikatami) i od jakiej kontrolki pochodzi, musimy siê bli¿ej zainteresowaæ parametrem <SPAN CLASS=T>lParam</SPAN> komunikatu <SPAN CLASS=T>WM_NOTIFY</SPAN>. Jest w nim przekazywany wskaŸnik do struktury, która zawiera wszystkie potrzebne nam informacje. Typ struktury zale¿y od rodzaju powiadomienia, np. w przypadku toolbaru bêdzie to struktura <SPAN CLASS=T>NMTOOLBAR</SPAN>. Generalnie obs³uga powiadomieñ mo¿e wygl¹daæ mniej wiêcej tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
case WM_NOTIFY:<BR>
{<BR>
&nbsp;LPNMHDR lpn = (LPNMHDR)lParam;<BR>
&nbsp;LPNMTOOLBAR lpnTB = (LPNMTOOLBAR)lParam;<BR>
<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(lpn->code)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TBN_DROPDOWN:<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN> FALSE;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//obs³uga innych powiadomieñ<BR>
&nbsp;&nbsp;&nbsp;//...</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>default: break;</SPAN><BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Typ <SPAN CLASS=T>LPNMTOOLBAR</SPAN> to wskaŸnik na strukturê typu <SPAN CLASS=T>NMTOOLBAR</SPAN>. Jedno z pól tej struktury (a konkretnie jej pierwsze pole) jest typu <SPAN CLASS=T>NMHDR</SPAN> (skrót od <SPAN CLASS=Inglisz>Notification Message Header</SPAN>). Pe³ni ona rolê nag³ówka powiadomienia. Pole <SPAN CLASS=T>code</SPAN> tej struktury zawiera kod powiadomienia i w naszym przypadku powinno byæ równe <SPAN CLASS=T>TBN_DROPDOWN</SPAN>. Na razie nie bêdziemy obs³ugiwali innych powiadomieñ. Moglibyœmy jeszcze wykorzystaæ pola <SPAN CLASS=T>hwndFrom</SPAN> i <SPAN CLASS=T>idFrom</SPAN> struktury <SPAN CLASS=T>NMHDR</SPAN>, ¿eby sprawdziæ, czy powiadomienie faktycznie pochodzi od toolbaru, ale odpuœæmy sobie takie detale ;-).
</P>
<P>
Pewnie siê zastanawiasz, dlaczego jeden parametr <SPAN CLASS=T>lParam</SPAN> przekonwertowaliœmy na dwa rodzaje struktur i czy to przypadkiem nie pomy³ka. Bynajmniej. WskaŸnik zawarty w  <SPAN CLASS=T>lParam</SPAN> wskazuje na strukturê typu <SPAN CLASS=T>NMTOOLBAR</SPAN>, ale na samym poczatku tej struktury znajduje siê (jak ju¿ wspomnieliœmy) nag³ówek typu <SPAN CLASS=T>NMHDR</SPAN>, wiêc mo¿emy wskaŸnik ten przerobiæ na <SPAN CLASS=T>LPNMHDR</SPAN>. Robimy to dla czystej wygody, dziêki temu piszemy po prostu <SPAN CLASS=T>lpn->code</SPAN> zamiast <SPAN CLASS=T>lpnTB->hdr.code</SPAN>, co przy pisaniu bardziej skomplikowanej obs³ugi powiadomieæ mo¿e siê okazaæ b³ogos³awionym rozwi¹zaniem ;-).
<P>
<P>
Zajmijmy siê teraz wyœwietlaniem naszego menu. Najpierw pobieramy i zapamiêtujemy w jakiejœ zmiennej uchwyt do podmenu Importuj (pamiêtaj¹c o tym, ¿eby sobie takie menu utworzyæ wczeœniej w pliku zasobów):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HMENU hPopupMenu;<BR>
hPopupMenu = GetSubMenu(hMenu, <SPAN CLASS=L>0</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Mamy ju¿ odpowiedni uchwyt, pozostaje siê tylko zastanowiæ, w którym miejscu wyœwietliæ. Najlepiej by³oby tu¿ pod przyciskiem. Tak wiêc musimy pobraæ wspó³rzêdne tego¿ przycisku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
RECT rc;<BR>
SendMessage(lpn->hwndFrom, TB_GETITEMRECT, (WPARAM)lpnTB->iItem, (LPARAM)&rc);<BR>
</TD></TR>
</TABLE>

<P>
Otrzymane wspó³rzêdne s¹ wzglêdne - punkt (<SPAN CLASS=L>0,0</SPAN>) to lewy górny róg obszaru klienta. Musimy je zatem przekonwertowaæ na wspó³rzêdne ekranowe. Robiliœmy to ju¿ we wczeœniejszych odcinkach kursu z punktami, ale teraz mamy ca³y prostok¹t, wiêc najproœciej bêdzie u¿yæ funkcji <SPAN CLASS=T>MapWindowPoints</SPAN> (która potrafi konwertowaæ ca³¹ tablicê punktów na raz, a przecie¿ prostok¹t to w³aœnie tablica 2 punktów). Nie bêdziemy jej dok³adniej omawiaæ, zobaczymy tylko gotowy przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
MapWindowPoints(lpn->hwndFrom, HWND_DESKTOP, (LPPOINT)&rc, <SPAN CLASS=L>2</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Teraz tylko wyœwietliæ menu. Mo¿emy to zrobiæ funkcj¹ <SPAN CLASS=T>TrackPopupMenu</SPAN> albo <SPAN CLASS=T>TrackPopupMenuEx</SPAN>. Poniewa¿ zaœ lubimy wyzwania... No dobra, nie bij, ta druga funkcja ma pewn¹ zaletê - mo¿emy jej podaæ obszar ekranu, którego menu nie powinno przys³oniæ. Jak siê pewnie domyœlasz, obszarem tym bêdzie nasz przycisk. W dodatku <SPAN CLASS=T>TrackPopupMenuEx</SPAN> przyjmuje mniej argumentów (!).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TPMPARAMS tpm;<BR>
<BR>
tpm.cbSize = <SPAN CLASS=K>sizeof</SPAN>(TPMPARAMS);<BR>
tpm.rcExclude = rc;<BR>
<BR>
TrackPopupMenuEx(hPopupMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL, rc.left, rc.bottom, hwnd, &tpm);<BR>
</TD></TR>
</TABLE>

<P>
Jak widzimy, funkcja korzysta z nowej struktury (hurrra :-]) - <SPAN CLASS=T>TPMPARAMS</SPAN>, okreœlaj¹cej rozszerzone parametry. W³aœnie do tej struktury wpisujemy wspó³rzêdne naszego prostok¹ta. Oprócz tego wyœwietlamy menu w ten sposób, ¿e jego lewy górny róg bêdzie siê znajdowa³ tu¿ pod przyciskiem. W porównaniu do <SPAN CLASS=T>TrackPopupMenu</SPAN>, w "wersji rozszerzonej" mo¿emy jeszcze u¿yæ (i u¿ywamy ;-) ) dodatkowej flagi - <SPAN CLASS=T>TBM_VERTICAL</SPAN>, która podpowiada systemowi, co zrobiæ w sytuacji, gdyby zabrak³o miejsca na ekranie do wyœwietlenia menu.
</P>

<P align=center>
<img src="../gfx/toolbard.gif" alt="Przycisk ze strza³k¹ ;-)"
</P>


<h2>
Hot-tracking
</h2>

<P>
Có¿ to znowu za czort? Ano, <SPAN CLASS=Inglisz>hot-tracking</SPAN> oznacza podœwietlanie (lub oznaczanie w innych sposób) kontrolek, na które najedziemy mysz¹. Co prawda w naszym toolbarze mamy to ju¿ zaimplementowane automatycznie (odk¹d go sp³aszczyliœmy ;-) ), ale teraz dowiemy siê jeszcze, co zrobiæ by dodatkowo po najechaniu zmienia³a siê bitmapa przycisku.
</P>
<P>
Toolbar mo¿e miec przypisane trzy listy obrazków. Jedna z nich odpowiada za domyœlny wygl¹d ikon, druga - za wygl¹d ikon, na które najechano strza³k¹, trzecia - za wygl¹d nieaktywnych (wy³¹czonych) przycisków. Do przypisywania toolbarowi tych list s³u¿¹ specjalne komunikaty, odpowiednio: <SPAN CLASS=T>TB_SETIMAGELIST, TB_SETHOTIMAGELIST, TB_SETDISABLEDIMAGELIST</SPAN>. W parametrze <SPAN CLASS=T>lParam</SPAN> tych komunikatów powinniœmy przekazaæ uchwyt do listy obrazków.
</P>
<P>
Zanim zastanowimy siê, jak uzyskaæ ten uchwyt, musimy dokonaæ drobnego spostrze¿enia: toolbar mo¿e mieæ a¿ trzy listy obrazków na raz, ale ka¿dy przycisk mo¿e mieæ przypisany tylko jeden indeks bitmapy w danym momencie. Oznacza to, ¿e nie mo¿emy robiæ hot-trackingu wybiórczo - albo wszystkie przyciski na toolbarze go obs³uguj¹, albo ¿aden. Jeœli zdecydujemy siê na to pierwsze, to musimy zrobiæ po dwie (lub trzy) bitmapy dla ka¿dego przycisku, tak aby ikony odpowiednich przycisków znajdowa³y siê w obu (lub trzech) bitmapach w TEJ SAMEJ KOLEJNOŒCI, a nastêpnie dodaæ te bitmapy do dwóch (trzech) list i przypisaæ listy do toolbaru.
</P>
<P>
Jak tworzymy listê obrazków? Mamy do tego funkcjê <SPAN CLASS=T>ImageList_Create</SPAN>. Bli¿szego omawiania nie bêdzie; zbyt leniwy jestem na to ;-). Pierwsze dwa argumenty to wymiary pojedynczej ikony, a trzeci oznacza g³êbokoœæ koloru (wspólna dla ca³ej listy), np. <SPAN CLASS=T>ILC_COLOR8, ILC_COLOR24</SPAN>. Pozosta³e argumenty nie maj¹ dla nas wiêkszego znaczenia. Zwracana wartoœæ jest typu <SPAN CLASS=T>HIMAGELIST</SPAN>, wiêc powinniœmy sobie wczeœniej utworzyæ zmienn¹ tego typu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HIMAGELIST himlDef, himlHot;<BR>
himlDef = ImageList_Create(<SPAN CLASS=L>16,16</SPAN>,ILC_COLOR24,<SPAN CLASS=L>0,1</SPAN>);<BR>
himlHot = ImageList_Create(<SPAN CLASS=L>16,16</SPAN>,ILC_COLOR24,<SPAN CLASS=L>0,1</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Wczytywaæ bitmapy ju¿ dawno umiemy (prawda?), wiêc nie bêdziemy siê powtarzaæ; zak³adamy, ¿e mamy ju¿ gotowe uchwyty do bitmap <SPAN CLASS=T>hbmDef</SPAN> i <SPAN CLASS=T>hbmHot</SPAN>, które mo¿emy teraz dodaæ do odpowiednich list. Bitmapa o uchwycie <SPAN CLASS=T>hbmDef</SPAN> powinna zawieraæ czarno-bia³e obrazki, <SPAN CLASS=T>hbmHot</SPAN> - w kolorze. Do dodawania s³u¿y funkcja <SPAN CLASS=T>ImageList_Add</SPAN>, ale jeszcze lepiej jest u¿yæ <SPAN CLASS=T>ImageList_AddMasked</SPAN>, która przy okazji wykona za nas "usuwanie" niepotrzebnego t³a z bitmapy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
ImageList_AddMasked(himlDef, hbmDef, RGB(<SPAN CLASS=L>192,192,192</SPAN>));<BR>
ImageList_AddMasked(himlHot, hbmHot, RGB(<SPAN CLASS=L>192,192,192</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy za pomoc¹ wspomnianych ju¿ wy¿ej komunikatów przypisaæ stworzone i wype³nione przed chwil¹ listy obrazków do odpowiednich toolbarów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hToolbar, TB_SETIMAGELIST, <SPAN CLASS=L>0</SPAN>, (LPARAM)himlDef);<BR>
SendMessage(hToolbar, TB_SETHOTIMAGELIST, <SPAN CLASS=L>0</SPAN>, (LPARAM)himlHot);<BR>
</TD></TR>
</TABLE>

<P>
Zak³adaj¹c, ¿e ju¿ wczeœniej ponadawaliœmy przyciskom odpowiednie indeksy, otrzymujemy toolbar z czarno-bia³ymi przyciskami, które dopiero po "podœwietleniu" staj¹ siê kolorowe:
</P>

<P align=center>
<img src="../gfx/toolbar8.gif" alt="Wiêc chodŸ, pomaluj mi œwiaaat... ;-)"
</P>

<P class=UWAGA>
Nie zapomnij o zwolnieniu zasobów. Listy obrazków niszczymy za pomoc¹ <B>ImageList_Destroy</B>, podaj¹c jako argument uchwyt do niszczonej listy. Bitmapy, przypominam, usuwamy za pomoc¹ <B>DeleteObject</B>.
</P>


<h2>
Tooltipy
</h2>

<P>
Podpowiedzi, wskazówki, z angielska <SPAN CLASS=Inglisz>tooltips</SPAN>, to te œmieszne etykietki, zwykle na ¿ó³tym tle, które pojawiaj¹ siê po najechaniu kursorem myszy na jakiœ istotny element interfejsu i zatrzymaniu go przez jakiœ czas (zwykle oko³o sekundy). S¹ one przydatne w przypadku ka¿dej kontrolki, ale najwiêksze chyba znaczenie maj¹ w³aœnie przy toolbarach, których przyciski czêsto nie posiadaj¹ widocznych podpisów, a nie zawsze przecie¿ ikonka potrafi nam zasugerowaæ dok³adne znaczenie danego przycisku ;-).
</P>
<P CLASS=UWAGA>
Zanim zaczniesz siê biedziæ nad tooltipami, ponadawaj przyciskom unikalne identyfikatory (idCommand), w przeciwnym razie tooltipy bêd¹ b³êdnie wyœwietlane.
</P>
<P>
Najprostszym sposobem na ustawienie tooltipów jest... ustawienie tekstu na przycisku, co ju¿ zrobiliœmy. Jeœli ustawimy tekst, ale jednoczeœnie go ukryjemy, to bêdzie on wyœwietlany jako tooltip. Tylko jak to zrobiæ? Jedna z metod (chyba najprostsza) to ustawienie toolbarowi stylów  <SPAN CLASS=T>TBSTYLE_TOOLTIP</SPAN> i <SPAN CLASS=T>TBSTYLE_LIST</SPAN> (koniecznie obydwa!). Ponadto ustawiamy jeszcze rozszerzony styl <SPAN CLASS=T>TBSTYLE_EX_MIXEDBUTTONS</SPAN> (ten ostatni oczywiœcie przez wys³anie odpowiedniego komunikatu - patrz wy¿ej).
</P>
<P>
Jeœli toolbar ma ustawiony styl <SPAN CLASS=T>TBSTYLE_EX_MIXEDBUTTONS</SPAN>, to tekst na przyciskach nie jest wyœwietlany jako etykieta (chyba, ¿e dany przycisk ma ustawiony styl <SPAN CLASS=T>BTNS_SHOWTEXT</SPAN>), a najwy¿ej jako tooltip:
</P>

<P align=center>
<img src="../gfx/toolbar6.gif" alt="To jest w³aœnie tooltip ;-)"
</P>

<P>
A co zrobiæ, ¿eby wyœwietliæ w tooltipie inny tekst, ni¿ etykieta przycisku? To ju¿ wymaga nieco wiêcej zachodu. Trzeba odpowiedzieæ na powiadomienie <SPAN CLASS=T>TTN_GETDISPINFO</SPAN>, które wysy³ane jest przez toolbar do okna rodzicielskiego. W parametrze <SPAN CLASS=T>lParam</SPAN> dostajemy wtedy wskaŸnik do struktury typu <SPAN CLASS=T>TOOLTIPTEXT</SPAN>, która zawiera nag³ówek (typu <SPAN CLASS=T>NMHDR</SPAN>, oczywiœcie), pozwalaj¹cy nam zorientowaæ siê, którego dok³adnie przycisku dotyczy dane powiadomienie. W strukturze tej wystêpuje równie¿ pole <SPAN CLASS=T>lpszText</SPAN>, do którego musimy wpisaæ tekst tooltipa. Oto przyk³ad odpowiedzi na to powiadomienie, w której to odpowiedzi ustawiamy tekst dwóch z naszych przycisków:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> TTN_GETDISPINFO:<BR>
{<BR>
&nbsp;LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)lParam;<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(lpttt->hdr.idFrom)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TOOL_NOWY:<BR>
&nbsp;&nbsp;&nbsp;lpttt->lpszText = <SPAN CLASS=L>"Tworzy nowy plik"</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TOOL_OTWORZ:<BR>
&nbsp;&nbsp;&nbsp;lpttt->lpszText =<SPAN CLASS=L> "Otwiera istniej¹cy plik"</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Dziêki tej pisaninie mo¿emy wyœwietlaæ w tooltipach co chcemy, a etykiety zostawiæ w spokoju. Wtedy mo¿liwe jest ustawienie krótkich etykiet typu Nowy, Zapisz itp., oraz nieco d³u¿szych tooltipów, dok³adniej objaœniaj¹cych funkcjê danego przycisku:
</P>

<P align=center>
<img src="../gfx/toolbar7.gif" alt="D³uuugi tooltip ;-)"
</P>

<h2>
Kontrolki na toolbarze
</h2>

<P>
Na koniec dowiemy siê, jak wstawiæ do toolbaru inn¹ kontrolkê. Mog³eœ siê z tym spotkaæ np. w edytorach tekstu, gdzie na toolbarach jest zwykle ComboBox z wyborem czcionek; zaraz zajmiemy siê wstawieniem takiego w³aœnie ComboBoxa (ale bez czcionek ;-)).
</P>
<P>
Najpierw trzeba na toolbarze zrobiæ trochê miejsca. Mo¿emy wstawiæ do niego nowy separator i rozszerzyæ go do tylu pikseli, ile ma mieæ nasz ComboBox. Separator ten nie bêdzie i tak widoczny zza ComboBoxa. Zdefiniujemy te¿ sobie identyfikator dla tego separatora, a tak¿e dla ComboBoxa. No to do dzie³a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#define <SPAN CLASS=T>TOOL_PLACEHOLDER</SPAN> <SPAN CLASS=L>7</SPAN><BR>
#define <SPAN CLASS=T>IDC_COMBOBOX</SPAN>     <SPAN CLASS=L>501</SPAN></SPAN><BR>
<BR>
HWND g_hCombo;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> szerokosc = <SPAN CLASS=L>100</SPAN>;<BR>
TBBUTTON tbb3[<SPAN CLASS=L>1</SPAN>];<BR>
<BR>
ZeroMemory(tbb3, <SPAN CLASS=K>sizeof</SPAN>(tbb3));<BR>
tbb3[<SPAN CLASS=L>0</SPAN>].idCommand = TOOL_PLACEHOLDER;<BR>
tbb3[<SPAN CLASS=L>0</SPAN>].fsState = TBSTATE_ENABLED;<BR>
tbb3[<SPAN CLASS=L>0</SPAN>].fsStyle = TBSTYLE_SEP;<BR>
<BR>
SendMessage(hToolbar, TB_ADDBUTTONS, <SPAN CLASS=L>1</SPAN>, (LPARAM)&tbb3);<BR>
</TD></TR>
</TABLE>

<P>
"Separator" ju¿ jest, ale ma za ma³e wymiary - kontrolka nam siê nie zmieœci. Trzeba rozszerzyæ. Wykorzystamy omówion¹ niedawno strukturê <SPAN CLASS=T>TBBUTTONINFO</SPAN>, by dzie³a tego dokonaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBBUTTONINFO tbbi;<BR>
ZeroMemory(&tbbi, <SPAN CLASS=K>sizeof</SPAN>(tbbi));<BR>
<BR>
tbbi.cbSize = <SPAN CLASS=K>sizeof</SPAN>(tbbi);<BR>
tbbi.dwMask = TBIF_SIZE;<BR>
tbbi.cx = szerokosc;<BR>
<BR>
SendMessage(hToolbar, TB_SETBUTTONINFO, TOOL_PLACEHOLDER, (LPARAM)&tbbi);<BR>
</TD></TR>
</TABLE>

<P>
Potrzebujemy teraz wymiarów rozci¹gniêtego w³aœnie "separatora". Pobierzemy je znanym ju¿ komunikatem <SPAN CLASS=T>TB_GETITEMRECT</SPAN> i wykorzystamy do stworzenia ComboBoxa. Aby ComboBox zosta³ utworzony na toolbarze, toolbar musi byæ rodzicem ComboBoxa. Jednak na razie jako uchwyt rodzica podamy <SPAN CLASS=T>hwnd</SPAN>, czyli nasze g³ówne okno - dlaczego, zaraz siê wyjaœni.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
RECT rc;<BR>
SendMessage(hToolbar, TB_GETITEMRECT, TOOL_PLACEHOLDER, (LPARAM)&rc);<BR>
<BR>
g_hCombo = CreateWindowEx(<SPAN CLASS=L>0L, "COMBOBOX"</SPAN>, NULL,<BR>
&nbsp;WS_CHILD | WS_BORDER | WS_VISIBLE | CBS_DROPDOWN,<BR>
&nbsp;rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,<BR>
&nbsp;hwnd, (HMENU)IDC_COMBOBOX, hThisInstance, <SPAN CLASS=L>0</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
ComboBox ju¿ gotowy, ale aby pojawi³ siê na toolbarze, musimy mu jeszcze zmieniæ rodzica. Proces adopcyjny jest bardzo prosty i nie bêdziemy musieli nawet biegaæ po s¹dach, wystarczy wywo³aæ <SPAN CLASS=T>SetParent</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SetParent(g_hCombo, hToolbar);<BR>
</TD></TR>
</TABLE>

<P>
Dlaczego stworzyliœmy bachora, a potem przenieœliœmy go do rodziny zastêpczej? Nie wygodniej by by³o od razu utworzyæ go z rodzicem hToolbar? Otó¿ na pewno by³oby mniej roboty, ale wtedy drañ wysy³a³by wszystkie komunikaty do toolbaru, a nie do okna g³ównego, czyli bez zastosowania subclassingu by³yby one dla nas nieprzydatne (nie moglibyœmy obs³ugiwaæ zdarzeñ zwi¹zanych z ComboBoxem). Tymczasem dziêki tej sztuczce wszystko gra jak w zegarku:
</P>

<P align=center>
<img src="../gfx/toolbar9.gif" alt="ComboBox wpakowany na toolbar">
</P>


<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitool.html">&lt;&lt; Toolbary, cz.1</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitool3.html">Toolbary, cz.3</A> &gt;&gt; &nbsp;
</TD>
</TR>
</TABLE>