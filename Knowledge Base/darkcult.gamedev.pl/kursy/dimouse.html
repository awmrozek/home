<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Mysz w DirectInput</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw04.html">&lt;&lt; Utrata powierzchni</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h1>
Mysz
</h1>

<P>
DirectInput, jak prawdopodobnie wiesz, jest czêœci¹ pakietu DirectX odpowiedzialn¹ za urz¹dzenia wejœciowe, a konkretnie: mysz, klawiaturê oraz joystick. "Radosny patyk" jakoœ nie zdoby³ sobie popularnoœci na pecetach, tote¿ nie bêdê go omawia³ na mojej stronie (chocia¿, paradoksalnie, pierwotnie DirectInput powsta³ specjalnie z myœl¹ o d¿ojstikach w³aœnie). Natomiast kwesti¹ obs³ugi myszy i klawiatury owszem, bêdziemy siê zajmowaæ.
</P>
<P>
Po co w ogóle zawracaæ sobie g³owê jakimiœ wyszukanymi technikami, skoro mysz i klawiaturê mo¿na po prostu obs³ugiwaæ przez "go³e" WinAPI? To dobre pytanie, poniewa¿ wiele gier, zw³aszcza tych prostych, rzeczywiœcie równie mo¿na zrealizowaæ bez ¿adnego DirectInput. Jednak gdy robimy coœ "powa¿niejszego", np. klon Mortal Kombat, gdzie co efektowniejsze ciosy wymagaj¹ wciœniêcia po³owy przycisków na klawiaturze jednoczeœnie, albo taki Quake, gdzie o u³amek sekundy spóŸnieniona reakcja myszy mo¿e zawa¿yæ na wyniku meczu... Wówczas sam WinAPI przestaje wystarczaæ.
</P>
<P>
W tej czêœci kursu zajmiemy siê obs³ug¹ myszy. DirectInput daje nam dwie metody odczytywania stanu gryzonia: bezpoœredni oraz buforowany. Bezpoœredni jest du¿o prostszy, wiêc pójdzie na pierwszy ogieñ.
</P>

<h2>
Inicjalizacja DirectInput
</h2>

<P>
Tak jak w przypadku ka¿dego elementu pakietu DirectX, pracê zaczynamy od utworzenia obiektu g³ównego. Oczywiœcie aby to uczyniæ, najpierw nale¿y do³¹czyæ odpowiednie biblioteki i nag³ówki. Te biblioteki to: <SPAN CLASS=C>libdinput.a, libdinput8.a</SPAN> i <SPAN CLASS=C>libdxguid.a</SPAN> (dla Dev-C++) lub <SPAN CLASS=C>dinput.lib, dxguid.lib</SPAN> i <SPAN CLASS=C>dxerr.lib</SPAN> (MS Visual C++).
</P>
<P>
Przypomnê jeszcze, ¿e w kursie bêdziemy korzystali z DirectInput w wersji 8.0, natomiast jeœli chcesz koniecznie u¿yæ starszej wersji, musisz na poczatku programu umieœciæ dyrektywê w rodzaju:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#define DIRECTINPUT_VERSION 0x0700 //dla DirectInput 7
</SPAN>
</TD></TR>
</TABLE>

<P>
Oczywiœcie jeœli decydujesz siê na to, musisz równie¿ pousuwaæ wszelkie '8' w poni¿szym przyk³adowym kodzie :-).
</P>
<P>
Teraz pora utworzyæ wreszcie obiekt g³ówny. Oprócz niego tworzymy jeszcze obiekt, reprezentuj¹cy mysz oraz ustalamy dla tego ostatniego format danych i tryb wspó³pracy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPDIRECTINPUT8 lpDI;<BR>
DirectInput8Create(hAppInstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (LPVOID*)&lpDI, NULL);<BR>
<BR>
<SPAN CLASS=C>
// Obiekt g³ówny dla DirectInput 7.0 i starszych:<BR>
// LPDIRECTINPUT lpDI;<BR>
// DirectInputCreate(hAppInstance, DIRECTINPUT_VERSION, &lpDI, NULL);<BR>
</SPAN>
<BR>
LPDIRECTINPUTDEVICE8 lpMouse;<BR>
lpDI->CreateDevice(GUID_SysMouse, &lpMouse, NULL);<BR>
lpMouse->SetDataFormat(&c_dfDIMouse);<BR>
lpMouse->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_FOREGROUND);<BR>
</TD></TR>
</TABLE>

<P>
Tworzenie obiektu g³ównego ju¿ przerabialiœmy przy okazji DirectDraw; tutaj wygl¹da to doœæ podobnie, z tym ¿e dodatkowo podajemy jeszcze uchwyt do instancji naszej aplikacji (<SPAN CLASS=T>hAppInstance</SPAN>) oraz sta³e z wersj¹ DirectInput.
</P>
<P>
Metoda <SPAN CLASS=T>CreateDevice</SPAN>, oprócz myszy, tworzy równie¿ obiekty zwi¹zane z klawiatur¹ lub d¿ojstikiem, dlatego musimy zawczasu powiadomiæ j¹, ¿e chodzi nam w³aœnie o mysz - taka jest rola sta³ej <SPAN CLASS=T>GUID_SysMouse</SPAN>.
</P>

<P>
Ustalenie formatu danych jest proste, gdy¿ mo¿emy skorzystaæ z formatów predefiniowanych przez Microsoft dla ka¿dego urz¹dzenia - te "myszkowe" znajduj¹ siê w sta³ych <SPAN CLASS=T>c_dfDIMouse</SPAN> i <SPAN CLASS=T>c_dfDIMouse2</SPAN> - do wyboru. Mo¿emy równie¿ zdefiniowaæ sobie w³asny format danych, ale po co siê przemêczaæ ;-).
</P>
<P>
Wybór trybu wspó³pracy, ponownie, mieliœmy równie¿ w DirectDraw. Tutaj nie wywo³ujemy jednak <SPAN CLASS=T>SetCooperativeLevel</SPAN> na rzecz obiektu g³ównego, lecz obiektu reprezentuj¹cego konkretne urz¹dzenie (mysz, klawiatura), poniewa¿ dla ka¿dego z tych urz¹dzeñ mo¿e zostaæ wybrany inny tryb. Najlepiej jest tu wybraæ po³¹czenie flag <SPAN CLASS=T>DISCL_EXCLUSIVE</SPAN> i <SPAN CLASS=T>DISCL_FOREGROUND</SPAN>, które idealnie pasuj¹ do gier dzia³aj¹cych na pe³nym ekranie w trybie wy³¹cznoœci, zawsze na pierwszym planie. W ten sposób zastrzegamy, ¿e mysz nale¿y tylko i wy³¹cznie do naszej aplikacji od momentu jej zainicjalizowania a¿ do zakoñczenia.
</P>
<P>
Gdybyœmy robili grê dzia³aj¹c¹ w okienku, to prawdopodobnie chcielibyœmy, ¿eby inne aplikacje równie¿ mog³y od czasu do czasu "po¿yczyæ" sobie myszkê, wtedy dalibyœmy <SPAN CLASS=T>DISCL_NONEXCLUSIVE</SPAN>, co oznacza³oby, ¿e inne aplikacje równie¿ mog¹ z myszy korzystaæ. Z kolei ró¿nica miêdzy <SPAN CLASS=T>DISCL_BACKGROUND</SPAN> i <SPAN CLASS=T>DISCL_FOREGROUND</SPAN> jest taka, ¿e ten pierwszy pozwala na przechwycenie myszy nawet wtedy, gdy nasze okno jest nieaktywne, zaœ ten drugi - wrêcz przeciwnie. Pamiêtaj, ¿e MUSISZ wybraæ jedn¹ (i tylko jedn¹) z flag: <SPAN CLASS=T>DISCL_BACKGROUND</SPAN> i <SPAN CLASS=T>DISCL_FOREGROUND</SPAN>, a tak¿e jedn¹ i tylko jedn¹ z flag <SPAN CLASS=T>DISCL_EXCLUSIVE</SPAN> i <SPAN CLASS=T>DISCL_NONEXCLUSIVE</SPAN>.
</P>
<P>
Jest jeszcze jedna flaga - <SPAN CLASS=T>DISCL_NOWINKEY</SPAN>. Jak sama nazwa wskazuje, zapobiega ona otwarciu windowsowego Menu Start przez wciœniêcie klawisza z logo Windows, dziêki czemu otrzymujemy pewnoœæ, ¿e u¿ytkownik nie opuœci naszej aplikacji w najmniej odpowiednim momencie ;-).
</P>
<P>
Pamiêtaj, ¿e w miejsce <SPAN CLASS=T>hWnd</SPAN> wstawiæ musisz uchwyt do swojego okna g³ównego.
</P>

<h2>
Tryb bezpoœredni
</h2>

<P>
Pora dowiedzieæ siê, jak odczytywaæ stan myszy. Jak ju¿ sobie wspomnieliœmy, mo¿emy to najproœciej zrobiæ w trybie bezpoœrednim. Polega on na tym, ¿e po prostu mamy nasz¹ myszê ca³y czas "na oku" (odczytujemy jej stan na bie¿¹co, w ka¿dej iteracji pêtli komunikatów). Oczywiœcie w tym celu nale¿y przebudowaæ pêtlê komunikatów do postaci "for games and multimedia" :-). A wiêc coœ w rodzaju:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>while</SPAN>(msg.message != WM_QUIT)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(PeekMessage(&msg, NULL, <SPAN CLASS=L>0, 0</SPAN>, PM_REMOVE))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;TranslateMessage(&msg);<BR>
&nbsp;&nbsp;DispatchMessage(&msg);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;ObslugaMyszy();<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// tutaj zwykle znajduje siê kod, przygotowuj¹cy<BR>
&nbsp;&nbsp;// kolejn¹ klatkê</SPAN><BR>
&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Co bêdzie w funkcji <SPAN CLASS=T>ObslugaMyszy</SPAN>? Oczywiœcie wspomniane przed chwil¹ odczytanie stanu myszy. S³u¿y do tego funkcja <SPAN CLASS=T>GetDeviceState</SPAN>, która pobiera wskaŸnik do struktury. Jak dot¹d "w u¿yciu" s¹ dwa rodzaje struktur wspó³pracuj¹cych z <SPAN CLASS=T>GetDeviceState</SPAN>, s¹ to: <SPAN CLASS=T>DIMOUSESTATE</SPAN> i <SPAN CLASS=T>DIMOUSESTATE2</SPAN>. Pierwsza z nich zadeklarowana jest w pliku <SPAN CLASS=C>dinput.h</SPAN> nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
typedef struct _DIMOUSESTATE {<BR>
&nbsp;LONG lX;<BR>
&nbsp;LONG lY;<BR>
&nbsp;LONG lZ;<BR>
&nbsp;BYTE rgbButtons[<SPAN CLASS=L>4</SPAN>];<BR>
} DIMOUSESTATE, *LPDIMOUSESTATE;<BR>
</TD></TR>
</TABLE>

<P>
Natomiast <SPAN CLASS=T>DIMOUSESTATE2</SPAN> wygl¹da identycznie, z tym ¿e tablica <SPAN CLASS=T>rgbButtons</SPAN> ma <SPAN CLASS=L>8</SPAN> elementów zamiast <SPAN CLASS=L>4</SPAN>. Tak wiêc struktury DIMOUSESTATE u¿ywaæ musimy tylko wtedy, gdy przewidujemy, ¿e mysz mo¿e mieæ  wiêcej, ni¿ cztery przyciski. Takiej jeszcze nie widzia³em (moja ma cztery przyciski i dwa scrollery, a i tak uwa¿am j¹ za wypasion¹ ;-)), wiêc w przyk³adach bêdê stosowa³ "zwyk³e" <SPAN CLASS=T>DIMOUSESTATE</SPAN>. Na wszelki wypadek wspominam jednak, ¿e struktura <SPAN CLASS=T>DIMOUSESTATE2</SPAN> dostêpna jest tylko w DirectInput 7.0 i nowszych.
</P>
<P>
Skoro kwestia struktur zosta³a z grubsza wyjaœniona, mo¿emy wzi¹æ siê za napisanie naszej funkcji <SPAN CLASS=T>ObslugaMyszy</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> ObslugaMyszy()<BR>
{<BR>
&nbsp;DIMOUSESTATE dims;<BR>
<BR>
&nbsp;lpMouse->GetDeviceState(<SPAN CLASS=K>sizeof</SPAN>(DIMOUSESTATE), (LPVOID)&dims);<BR>
<BR>
&nbsp;<SPAN CLASS=C>// jakieœ tam instrukcje wykorzystuj¹ce dane o myszy</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Wyjaœnienia wymagaj¹ dwie rzeczy. Po pierwsze, poniewa¿ podany przez nas wskaŸnik mo¿e wskazywaæ na dwa rodzaje struktur, wiêc musimy podaæ rozmiar u¿ytej struktury, ¿eby funkcja <SPAN CLASS=T>GetDeviceState</SPAN> wiedzia³a, o który typ struktury chodzi. Druga sprawa: podawany wskaŸnik musimy przekonwertowaæ jawnie do <SPAN CLASS=T>LPVOID</SPAN> (czyli praktycznie <SPAN CLASS=K>void*</SPAN>), poniewa¿ oprócz myszy, <SPAN CLASS=T>GetDeviceState</SPAN> mo¿e wspó³pracowaæ równie¿ z klawiatur¹ i d¿ojstikiem, a przeci¹¿ona nie jest.
</P>
<P>
Teraz wszystkie niezbêdne informacje mamy w naszej strukturze. Tablica <SPAN CLASS=T>rgbButtons</SPAN> zawiera stany przycisków myszy w momencie wywo³ania <SPAN CLASS=T>GetDeviceState</SPAN>, zaœ pola <SPAN CLASS=T>lX, lY</SPAN> i <SPAN CLASS=T>lZ</SPAN> mówi¹ nam, o ile jednostek przesunê³a siê ka¿da rolka myszy. Ka¿da normalna mysz posiada poziom¹, pionow¹ i ukoœn¹ rolkê, ale z regu³y tylko te dwie pierwsze zbieraj¹ informacje o ruchu myszy, natomiast ukoœna rolka w wiêkszoœci popularnych modeli myszek s³u¿y tylko do podtrzymywania kulki i nie jest po³¹czona z ¿adnymi detektorami ruchu, dlatego te¿ pole <SPAN CLASS=T>lZ</SPAN> jest zwykle równe <SPAN CLASS=L>0</SPAN>. Tak wiêc jeœli u¿ytkownik przesunie mysz o <SPAN CLASS=L>5</SPAN> pikseli w górê i <SPAN CLASS=L>8</SPAN> pikseli w prawo, to pole <SPAN CLASS=T>lX</SPAN> bêdzie równe <SPAN CLASS=L>8</SPAN>, <SPAN CLASS=T>lY</SPAN> bêdzie równe <SPAN CLASS=L>-5</SPAN>, a <SPAN CLASS=T>lZ</SPAN> bêdzie równe <SPAN CLASS=L>0</SPAN>.
</P>
<P>
Z przyciskami myszy jest nieco wiêkszy problem, gdy¿ DirectInput ustawia tylko jeden bit (pierwszy od lewej, czyli najbardziej znacz¹cy bit) odpowiedniego elementu tablicy <SPAN CLASS=T>rgbButtons</SPAN>. W³aœciwie to moglibyœmy przed u¿yciem wyzerowaæ strukturê <SPAN CLASS=T>dims</SPAN>, a potem traktowaæ elementy <SPAN CLASS=T>rgbButtons</SPAN> jako zmienne typu<SPAN CLASS=T> BOOL</SPAN>, ale jeœli chcemy byæ w 100% poprawni, to powinniœmy pisaæ np. tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(dims.rgbButtons[<SPAN CLASS=L>0</SPAN>] & <SPAN CLASS=L>0x80</SPAN>) OnMouseButton1();
</TD></TR>
</TABLE>

<P>
...jeœli chcemy obs³u¿yæ klikniêcie lewym przyciskiem myszy. Warto sobie w tym celu zdefiniowaæ takie fajne makro:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#define KEYDOWN(array,key) (array[key] & 0x80)
</SPAN>
</TD></TR>
</TABLE>

<P>
Dziêki niemu sprawdzanie wciœniêcia przycisków myszy (a tak¿e tych na klawiaturze) stanie siê proste i bardziej eleganckie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(KEDOWN(dims.rgbButtons, <SPAN CLASS=L>0</SPAN>) OnMouseButton1();
</TD></TR>
</TABLE>

<P>
Dobrze te¿ by³oby zadeklarowaæ jakieœ sta³e dla przycisków myszy, np.:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const int</SPAN> LEFT_BUTTON = <SPAN CLASS=L>0</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> RIGHT_BUTTON = <SPAN CLASS=L>1</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> MIDDLE_BUTTON = <SPAN CLASS=L>2</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Zwróæ uwagê na kolejnoœæ przycisków; o ile z tymi dodatkowymi, wybajerzonymi, mo¿e byæ rozmaicie (zale¿nie od sterowników), to lewy, prawy i œrodkowy zawsze powinne mieæ w³aœnie takie indeksy, jak tutaj.
</P>
<P>
Trzeba wiedzieæ jeszcze o jednej rzeczy. Otó¿, podobnie jak w DirectDraw z powierzchniami, tak i tutaj nasza w³adza nad myszk¹ w pewnym momencie mo¿e nam zostaæ odebrana. Jeœli wybraliœmy tryb <SPAN CLASS=T>DISCL_EXCLUSIVE</SPAN>, to praktycznie jesteœmy przed takim wypadkiem zabezpieczeni, a jeœli nie - musimy sobie jakoœ poradziæ z problemem.
</P>
<P>
Sposób jest prosty i analogicznie do powierzchni DirectDraw (znowu) sprowadza siê on do wywo³ania jednej funkcji - <SPAN CLASS=T>Acquire</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpMouse->Acquire();<BR>
</TD></TR>
</TABLE>

<P>
Po takim zabiegu mamy ju¿ pewnoœæ, ¿e mysz nam nie "ucieknie". W gruncie rzeczy mo¿emy wywo³ywaæ <SPAN CLASS=T>Acquire</SPAN> przed ka¿dym wywo³aniem <SPAN CLASS=T>GetDeviceState</SPAN>, jednak w niektórych przypadkach mo¿e siê okazaæ, ¿e tracimy zbyt du¿o czasu procesora na <SPAN CLASS=T>Acquire</SPAN>, a przecie¿ sytuacje, kiedy jego wywo³ywanie jest naprawdê konieczne, nale¿¹ raczej do rzadkoœci. Tak wiêc jeœli bardzo zale¿y nam na szybkoœci, mo¿emy zapamiêtaæ wartoœæ zwrócon¹ przez <SPAN CLASS=T>GetDeviceState</SPAN>. Jeœli system znienacka odebra³ nam w³adzê nad myszk¹, to <SPAN CLASS=T>GetDeviceState</SPAN> zwróci wartoœæ <SPAN CLASS=T>DIERR_INPUTLOST</SPAN>. W innych nieciekawych przypadkach mo¿e równie¿ zwróciæ inne wartoœci, tak wiêc najlepiej bêdzie napisaæ funkcjê <SPAN CLASS=T>ObslugaMyszy</SPAN> w taki mniej wiêcej sposób:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> ObslugaMyszy()<BR>
{<BR>
&nbsp;DIMOUSESTATE dims;<BR>
&nbsp;HRESULT r;<BR>
<BR>
&nbsp;r = lpMouse->GetDeviceState(<SPAN CLASS=K>sizeof</SPAN>(DIMOUSESTATE), (LPVOID)&dims);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(r != DI_OK)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;lpMouse->Acquire();<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//teraz powtarzamy zabawê ;-)</SPAN><BR>
&nbsp;&nbsp;r = lpMouse->GetDeviceState(<SPAN CLASS=K>sizeof</SPAN>(DIMOUSESTATE), (LPVOID)&dims);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(r != DI_OK) <SPAN CLASS=C>//no, teraz to ju¿ nic nie pomo¿e</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>return</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>// jakieœ tam instrukcje wykorzystuj¹ce dane o myszy</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Warto wiedzieæ, ¿e w sporadycznych przypadkach funkcja mo¿e zwróciæ równie¿ E_PENDING, co oznacza³oby, ¿e dane s¹ w³aœnie w trakcie pobierania. Niekoniecznie musi to oznaczaæ b³¹d, prawdopodobnie w takim przypadku nale¿y po prostu powtórzyæ ¿¹danie nieco póŸniej. 
</P>
<P>
Na koniec zosta³o nam tradycyjne sprz¹tanie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(lpDI != NULL)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpMouse != NULL)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;lpMouse->Unacquire();<BR>
&nbsp;&nbsp;lpMouse->Release();<BR>
&nbsp;&nbsp;lpMouse = NULL;<BR>
&nbsp;}<BR>
&nbsp;lpDI->Release();<BR>
&nbsp;lpDI = NULL;<BR>
}<BR>
</TD></TR>
</TABLE>

<h2>
Tryb buforowany
</h2>

<P>
Jeœli metoda bezpoœrednia z jakichœ powodów nie nadaje siê do naszych celów (np. chcemy mieæ 100% pewnoœci, ¿e ¿adne "myszkowe" zdarzenie nam nie umknie), pozostaje skorzystaæ z trybu buforowanego. Polega on na tym, ¿e wszystkie informacje o ruchach i o przyciskach myszy zapisywane s¹ w buforze i pozostaj¹ tam a¿ do momentu, gdy je odczytamy. Przypomina to wiêc windowsow¹ pêtlê komunikatów, z tym ¿e bufor DirectInput jest oczywiœcie wydajniejszy - choæby dlatego, ¿e znajd¹ siê w nim tylko te komunikaty, które nas rzeczywiœcie interesuj¹, podczas gdy pêtla komunikatów okna przyjmuje teoretycznie kilkaset ró¿nych komunikatów.
</P>
<P>
Przede wszystkim powinniœmy zawrzeæ znajomoœæ ze struktur¹ (która to ju¿ z kolei...) o nazwie <SPAN CLASS=T>DIPROPDWORD</SPAN>. Doœæ nietypowa ta struktura, bowiem sk³ada siê tylko z nag³ówka (stanowi¹cego zreszt¹ kolejny typ struktury) oraz jednej zmiennej typu <SPAN CLASS=T>DWORD</SPAN>. Zmienna ta, domyœliæ siê nietrudno, ma kluczowe znaczenie i w tym przypadku oznaczaæ bêdzie rozmiar bufora. Z nag³ówkiem (typu <SPAN CLASS=T>DIPROPHEADER</SPAN>, w skrócie <SPAN CLASS=T>diph</SPAN>) sprawa jest bardziej skomplikowana - musimy tu wype³niæ cztery rzeczy: rozmiar ca³ej struktury typu <SPAN CLASS=T>DIPROPDWORD</SPAN>, rozmiar nag³ówka, identyfikator obiektu (ignorujemy) oraz sposób interpretacji owego identyfikatora (tu dajemy zawsze <SPAN CLASS=T>DIPH_DEVICE</SPAN>). A wiêc:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DIPROPDWORD dipdw;<BR>
dipdw.diph.dwSize = <SPAN CLASS=K>sizeof</SPAN>(DIPROPDWORD);<BR>
dipdw.diph.dwHeaderSize = <SPAN CLASS=K>sizeof</SPAN>(DIPROPHEADER);<BR>
dipdw.diph.dwObj = <SPAN CLASS=L>0</SPAN>; <BR>
dipdw.diph.dwHow = DIPH_DEVICE;<BR>
dipdw.dwData =<SPAN CLASS=L> 4</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Omawiaæ tutaj nie ma co, poza ostatni¹ linijk¹: tutaj w³aœnie ustawiamy rozmiar bufora (u nas wynosi on <SPAN CLASS=L>4</SPAN>). Nieg³upim pomys³em by³oby zadeklarowaæ jak¹œ sta³¹ w tym celu, ale ja jestem na to zbyt leniwy ;-).
</P>
<P>
Krokiem nastêpnym bêdzie powiadomienie DirectInput-a, ¿e od tej pory ma do dyspozycji bufor:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpMouse->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph);<BR>
</TD></TR>
</TABLE>

<P>
Dla przyzwoitoœci nale¿a³oby mo¿e sprawdziæ, co zwróci³a metoda <SPAN CLASS=T>SetProperty</SPAN>, ale znów mi siê nie chce bawiæ w szczegó³y ;-). Przeskakujemy wiêc do kolejnego etapu, którym jest pobranie interesuj¹cych nas danych z bufora. Zajmuje siê tym metoda <SPAN CLASS=T>GetDeviceData</SPAN>. Zanim jednak bêdziemy mogli dane pobraæ, wpierw musimy mieæ dok¹d. W tym celu deklarujemy strukturê (nie bijcie) typu <SPAN CLASS=T>DIDEVICEOBJECTDATA</SPAN>. Potrzebujemy te¿ zmiennej typu <SPAN CLASS=T>DWORD</SPAN>, do której wpiszemy liczbê zdarzeñ pobieranych z bufora (po wywo³aniu ta sama zmienna bêdzie zawieraæ liczbê zdarzeñ faktycznie pobranych, poniewa¿ w teorii te dwie wartoœci mog¹ byæ ró¿ne):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DIDEVICEOBJECTDATA didod; <SPAN CLASS=C>//co za nazwa... ;-)</SPAN><BR>
DWORD dwItems = <SPAN CLASS=L>1</SPAN>; <SPAN CLASS=C>//pobieramy tylko 1 zdarzenie za ka¿dym razem</SPAN><BR>
<BR>
lpMouse->Acquire();<BR>
lpMouse->GetDeviceData(<SPAN CLASS=K>sizeof</SPAN>(DIDEVICEOBJECTDATA), &didod, &dwItems, <SPAN CLASS=L>0</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Ostatni argument mo¿e byæ równy <SPAN CLASS=L>0</SPAN> lub te¿ <SPAN CLASS=T>DIGDD_PEEK</SPAN>. W pierwszym przypadku dane odczytane z bufora s¹ równoczeœnie z niego usuwane, w drugim przypadku - przeciwnie (porównaj z pêtl¹ komunikatów okna).
</P>
<P>
W tym miejscu warto zastanowiæ siê, jak czêsto bêdziemy pobieraæ dane z bufora. Zale¿y to oczywiœcie tylko od twoich aktualnych potrzeb. Nic nie stoi na przeszkodzie, by zrealizowaæ to podobnie do pobierania danych w trybie bezpoœrednim, czyli w œciœle okreœlonych, regularnych odstêpach czasowych, np. co <SPAN CLASS=L>5</SPAN> milisekund. Mo¿esz pobieraæ elementy (zdarzenia) z bufora pojedynczo (jak w przyk³adzie powy¿ej), albo po kilka na raz (maksymalna liczba elementów ograniczona jest przez rozmiar bufora). Pamiêtaj przy tym jednak, ¿e po ka¿dym pobraniu powinieneœ sprawdziæ, jaka liczba elementów zosta³a rzeczywiœcie pobrana, np.:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const</SPAN> DWORD ITEMS_AT_ONCE = <SPAN CLASS=L>4</SPAN>;<BR>
DIDEVICEOBJECTDATA didod[ITEMS_AT_ONCE];<BR>
DWORD dwItems = ITEMS_AT_ONCE;<BR>
<BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;lpMouse->Acquire();<BR>
&nbsp;lpMouse->GetDeviceData(<SPAN CLASS=K>sizeof</SPAN>(DIDEVICEOBJECTDATA), didod, &dwItems, <SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>(dwItems == ITEMS_AT_ONCE);<BR>
</TD></TR>
</TABLE>

<P>
Pêtla powy¿sza bêdzie siê wykonywa³a dopóty, a¿ liczba elementów pobranych nie spadnie poni¿ej sta³ej <SPAN CLASS=T>ITEMS_AT_ONCE</SPAN>, co powinno nast¹piæ tylko wtedy, gdy po prostu wszystkie elementy zostan¹ ju¿ zabrane z bufora.
</P>
<P>
Jeœli pobraliœmy z bufora ju¿ wszystko, co nas interesuje, a mimo to coœ w nim jeszcze zosta³o, mo¿emy siê takich niechcianych zdarzeñ ³atwo pozbyæ - wystarczy wywo³aæ <SPAN CLASS=T>GetDeviceData</SPAN> z drugim argumentem ustawionym na <SPAN CLASS=T>NULL</SPAN> oraz trzecim na adres zmiennej zawieraj¹cej sta³¹ <SPAN CLASS=T>INFINITE</SPAN>. Po takim zabiegu bufor zostanie opró¿niony:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
dwItems = INFINITE;<BR>
lpMouse->GetDeviceData(<SPAN CLASS=K>sizeof</SPAN>(DIDEVICEOBJECTDATA), NULL, &dwItems, <SPAN CLASS=L>0</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
No dobra, ale co w³aœciwie mo¿na zrobiæ z danymi, które w³aœnie pobraliœmy z bufora? Mamy tablicê elementów typu <SPAN CLASS=T>DIDEVICEOBJECTDATA</SPAN>, ka¿dy taki element odpowiada jednemu "myszkowemu" zdarzeniu, np. ruch w poziomie, ruch w pionie, wciœniêcie przycisku. Przede wszystkim powinniœmy sprawdziæ, jaka wartoœæ znajduje siê w polu <SPAN CLASS=T>dwOfs</SPAN>, czyli z jakiego rodzaju zdarzeniem mamy akurat do czynienia. I tak sta³a <SPAN CLASS=T>DIMOFS_X</SPAN> oznacza przesuniêcie myszy w poziomie, <SPAN CLASS=T>DIMOFS_Y</SPAN> - w pionie, <SPAN CLASS=T>DIMOFS_BUTTON0</SPAN> - wciœniêcie (lub zwolnienie) lewego przycisku, <SPAN CLASS=T>DIMOFS_BUTTON1</SPAN> - prawego przycisku itd.
</P>
<P>
Gdy ju¿ wiemy, jakie zdarzenie jest opisane w strukturze <SPAN CLASS=T>DIDEVICEOBJECTDATA</SPAN>, pozostaje odczytaæ w³aœciwe dane, znajduj¹ce siê w polu <SPAN CLASS=T>dwData</SPAN>. W przypadku poruszenia myszk¹ bêdzie to liczba jednostek, o jak¹ siê mysz przesunê³a (mo¿e to byæ wartoœæ wzglêdna lub bezwzglêdna, zale¿y jak ustawiliœmy urz¹dzenie), w przypadku przycisku - flaga wskazuj¹ca, czy przycisk zosta³ wciœniêty czy zwolniony (rolê tej flagi pe³ni najbardziej znacz¹cy bit pierwszego bajtu pola).
</P>
<P>
Warto zwróciæ uwagê na pole <SPAN CLASS=T>dwTimeStamp</SPAN>. Zapisywany jest w nim dok³adny czas (w milisekundach), kiedy wygenerowane zosta³o dane zdarzenie. Dziêki temu mo¿emy sprawdziæ, czy zdarzenie siê nie "przeterminowa³o" po zbyt d³ugim okresie le¿enia w buforze ;-) (mo¿e siê np. zdarzyæ, ¿e jakiœ ruch mysz¹ trafi do bufora, ale nie zostanie obs³u¿ony, bo tym samym czasie u¿ytkownik prze³¹czy siê na inne okno, a po ³adnych kilku minutach wróci do naszej aplikacji). Czas ten z grubsza zgadza siê z tym pobranym za pomoc¹ funkcji <SPAN CLASS=T>GetTickCount</SPAN>. Z grubsza, poniewa¿ wartoœæ w polu <SPAN CLASS=T>dwTimeStamp</SPAN> jest dok³adna co do 1 milisekundy, natomiast <SPAN CLASS=T>GetTickCount</SPAN> - niezupe³nie. W poni¿szym przyk³adzie zak³adamy jednak, ¿e te kilka, a nawet kilkadziesi¹t milisekund nie robi nam ró¿nicy ;-).
</P>
<P>
Tak wiêc dobrnêliœmy szczêœliwie do koñca i mo¿emy wreszcie napisaæ kompletn¹ buforowan¹ wersjê funkcji <SPAN CLASS=T>ObslugaMyszy</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> ObslugaMyszy()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>const</SPAN> DWORD ITEMS_AT_ONCE = <SPAN CLASS=L>4</SPAN>;<BR>
&nbsp;DIDEVICEOBJECTDATA didod[ITEMS_AT_ONCE];<BR>
&nbsp;DWORD dwItems = ITEMS_AT_ONCE;<BR>
&nbsp;DWORD dwCurrentTime;<BR>
<BR>
&nbsp;<SPAN CLASS=C>//pobierz kolejne 4 zdarzenia (lub mniej)</SPAN><BR>
&nbsp;<SPAN CLASS=K>do</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;lpMouse->Acquire();<BR>
&nbsp;&nbsp;lpMouse->GetDeviceData(<SPAN CLASS=K>sizeof</SPAN>(DIDEVICEOBJECTDATA), didod, &dwItems, <SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(dwItems == ITEMS_AT_ONCE);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//obs³u¿ te zdarzenia</SPAN><BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(DWORD i=<SPAN CLASS=L>0</SPAN>; i&lt;dwItems; ++i)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>switch</SPAN>(didod[i].dwOfs)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> DIMOFS_X:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;user_ruszyl_mysz_w_poziomie(didod[i].dwData);<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break;<BR>
&nbsp;&nbsp;&nbsp;case</SPAN> DIMOFS_Y:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;user_ruszyl_mysz_w_pionie(didod[i].dwData);<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break;<BR>
&nbsp;&nbsp;&nbsp;case</SPAN> DIMOFS_BUTTON0:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(didod[i].dwData & <SPAN CLASS=L>0x80</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_wcisnal_lewy_przycisk();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_puscil_lewy_przycisk();<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie to jest tylko przyk³ad. Nie musisz (a nawet nie powinieneœ) deklarowaæ funkcji w stylu <SPAN CLASS=T>user_wcisnal_lewy_przycisk</SPAN> (zbyt du¿y narzut czasowy na wywo³aniu). Mo¿esz pobieraæ z bufora tyle zdarzeñ na raz, ile chcesz. Mo¿esz te¿ dorzuciæ kod sprawdzaj¹cy, czy zdarzenia s¹ aktualne (<SPAN CLASS=T>dwTimeStamp</SPAN>) i opró¿niaj¹cy co jakiœ czas bufor. Nie istnieje ¿aden wzór procedury <span class=T>ObslugaMyszy</span>, pasuj¹cy do wszystkich sytuacji. Zreszt¹  po to w³aœnie jest DirectX, ¿eby móc dostosowywaæ kod do aktualnych potrzeb, a nie korzystaæ z uniwersalnych rozwi¹zañ.
</P>
<P>
Skoro zrobiliœmy ju¿ wszystko, co mieliœmy do zrobienia, zwalniamy wszelkie obiekty DirectInput tak samo, jak to robiliœmy w trybie bezpoœrednim.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw04.html">&lt;&lt; Utrata powierzchni</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TD>
</TR>
</TABLE>

</HTML>