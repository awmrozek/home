<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Utrata powierzchni</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw03.html">&lt;&lt; Bezpoœredni dostêp...</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="dimouse.html">Mysz w DirectInput &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Utrata powierzchni
</h2>

<P>
DirectDraw miewa czasem nieprzyjazne odruchy. Mog³oby siê na przyk³ad wydawaæ, ¿e skoro mamy ju¿ zaalokowane wszystkie powierzchnie, to mo¿emy ich sobie spokojnie u¿ywaæ a¿ do momentu, kiedy je sobie sami zwolnimy. Nic bardziej b³êdnego - w pewnych sytuacjach nasz kochany dajrekt mo¿e nam po prostu znienacka odebraæ nasze powierzchnie!
</P>
<P>
Tak, jest to wredne, pod³e i niesprawiedliwe. Ale trzeba jakoœ siê z tym pogodziæ ;-). Na szczêœcie sytuacje takie s¹ doœæ œciœle okreœlone, a w dodatku przywrócenie utraconych powierzchni jest stosunkowo proste. Zobaczmy wiêc, jak sprawy wygl¹daj¹ w praktyce.
</P>
<P>
Za³ó¿my, ¿e napisaliœmy program, wyœwietlaj¹cy na ekranie nieruchome, ale za to kolorowe kó³eczko (tak siê sk³ada, ¿e faktycznie to uczyniliœmy w poprzedniej czêœci kursu). Mo¿liwe przypadki utraty powierzchni dla takiego programu (oraz wiêkszoœci innych) to: zmiana trybu graficznego oraz minimalizacja okna aplikacji do ikony na pasku zadañ. Trybu graficznego zbyt czêsto siê nie zmienia, a jeœli ju¿, to raczej na samym pocz¹tku dzia³ania programu, jeszcze zanim w ogóle utworzymy powierzchnie. Tak wiêc tym przypadkiem nie bêdziemy siê zajmowaæ.
</P>
<P>
Gorzej, jeœli nasze okno zostanie zminimalizowane. Musimy bowiem najpierw zastanowiæ siê, jak w ogóle wykryæ ten fakt w programie. Do dyspozycji mamy kilka komunikatów, które s¹ w takiej sytuacji wysy³ane; najbardziej odpowiedni wydaje siê komunikat <SPAN CLASS=T>WM_SIZE</SPAN>, który system wysy³a zarówno podczas minimalizowania okna, jak i przywracania go do normalnych wymiarów. Z drugiej strony jeszcze wygodniej by³oby u¿yæ <SPAN CLASS=T>WM_PAINT</SPAN>, poniewa¿ przy okazji zapewnimy sobie odpornoœæ na wrednych userów, próbuj¹cych w jakiœ sposób zamazaæ nasze œliczne kó³ko (co mo¿e nast¹piæ np. wówczas, gdy wyœwietlimy wiadomoœæ za pomoc¹ <SPAN CLASS=T>MessageBox</SPAN>, a u¿ytkownik programu z³oœliwie zacznie przenosiæ okienko z t¹ wiadomoœci¹ po ca³ym ekranie). Spróbujmy wiêc najpierw odrysowaæ nasze kó³ko w standardowy sposób:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_PAINT:<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//typowe dla obs³ugi WM_PAINT...</SPAN><BR>
&nbsp;PAINTSTRUCT ps;<BR>
&nbsp;BeginPaint(hwnd, &ps);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//pobieramy wskaŸnik do danych powierzchni</SPAN><BR>
&nbsp;DDSURFACEDESC ddsd;<BR>
&nbsp;ZeroMemory(&ddsd, <SPAN CLASS=K>sizeof</SPAN>(ddsd));<BR>
&nbsp;ddsd.dwSize = <SPAN CLASS=K>sizeof</SPAN>(ddsd);<BR>
&nbsp;HRESULT ret = lpEkran->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(ret != DD_OK) <SPAN CLASS=K>return</SPAN> FALSE;<BR>
<BR>
&nbsp;<SPAN CLASS=K>const</SPAN> WORD sx = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. x</SPAN><BR>
&nbsp;<SPAN CLASS=K>const</SPAN> WORD sy = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. y</SPAN><BR>
&nbsp;<SPAN CLASS=K>const</SPAN> WORD r = <SPAN CLASS=L>100</SPAN>;  <SPAN CLASS=C>// promieñ ko³a</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=C>//rysujemy kó³ko</SPAN><BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(WORD y=<SPAN CLASS=L>0</SPAN>; y&lt;<SPAN CLASS=L>200</SPAN>; ++y)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(WORD x=<SPAN CLASS=L>0</SPAN>; x&lt;<SPAN CLASS=L>200</SPAN>; ++x)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>( (x-sx)*(x-sx)+(y-sy)*(y-sy) <= r*r )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;((DWORD*)ddsd.lpSurface)[ddsd.dwWidth * y + x] = Kolor32(<SPAN CLASS=L>255</SPAN>-x, y, <SPAN CLASS=L>255</SPAN>-y);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//odblokowujemy powierzchniê</SPAN><BR>
&nbsp;lpEkran->Unlock(NULL);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//sygnalizujemy koniec rysowania</SPAN><BR>
&nbsp;EndPaint(hwnd, &ps);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Efekty tej jak¿e ciê¿kiej pracy s¹ znikome; mimo i¿ obs³u¿yliœmy - najzupe³niej poprawnie, jak mog³o by siê wydawaæ, komunikat <SPAN CLASS=T>WM_PAINT</SPAN>, to po prze³¹czeniu okna za pomoc¹ Alt+Tab i powrocie do niego nadal widzimy tylko puste okno, bez kó³eczka. To jest w³aœnie spowodowane utrat¹ powierzchni.
</P>
<P>
Co robimy? Najpierw sprawdzamy, czy powierzchnia faktycznie zosta³a utracona - zajmie siê tym metoda <SPAN CLASS=T>IsLost</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HRESULT stracona = lpEkran->IsLost();<BR>
</TD></TR>
</TABLE>

<P>
Wbrew ewentualnym pozorom, <SPAN CLASS=T>IsLost</SPAN> nie zwraca <SPAN CLASS=T>TRUE</SPAN> lub <SPAN CLASS=T>FALSE</SPAN>, tylko wartoœæ typu <SPAN CLASS=T>HRESULT</SPAN> (tak jak inne metody z DirectDraw zreszt¹). Wartoœci¹ t¹ mo¿e byæ <SPAN CLASS=T>DD_OK</SPAN> (co oznacza, ¿e powierzchnia nie zosta³a utracona, czyli bez dalszych ceregieli mo¿emy jej normalnie u¿ywaæ) lub te¿ (co znacznie bardziej w tym przypadku prawdopodobne) <SPAN CLASS=T>DDERR_SURFACELOST</SPAN>, co oznacza... zgadnij co. Mog¹ te¿ byæ zwrócone inne wartoœci (np. w przypadku nieprawid³owych parametrów), ale to raczej rzadko siê zdarza i nie musimy siê tym a¿ tak bardzo przejmowaæ ;-). Jeœli zaœ <SPAN CLASS=T>IsLost</SPAN> zwróci³a <SPAN CLASS=T>DDERR_SURFACELOST</SPAN>, to nie pozostaje nam nic innego, jak tylko przywdziaæ hartown¹ zbroicê, dosi¹œæ bia³ego rumaka i wyruszyæ na poszukiwania straconej powierzchni.
</P>
<P>
Nie napalajmy siê jednak na jak¹œ wiêksz¹ wyprawê wojenn¹, albowiem przywrócenie utraconej powierzchni jest równie proste, jak zarzucenie prowadzonemu na œmieræ rycerzowi chusty na ³eb i oznajmienie "mój ci on!". Otó¿ wystarczy wywo³aæ metodê <SPAN CLASS=T>Restore</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HRESULT stracona = lpEkran->IsLost();<BR>
<SPAN CLASS=K>if</SPAN>(stracona == DDERR_SURFACELOST)<BR>
&nbsp;lpEkran->Restore();<BR>
</TD></TR>
</TABLE>

<P>
Dla porz¹dku moglibyœmy jeszcze sprawdziæ, co ciekawego zróci nam ta <SPAN CLASS=T>Restore</SPAN>, bowiem mo¿e to byæ coœ innego, ni¿ <SPAN CLASS=T>DD_OK</SPAN>. Jednym z najczêœciej pope³nianych b³êdów jest próba przywrócenia powierzchni utworzonej niejawnie (np. tylnego bufora w ³añcuchu powierzchni) - wtedy zwracana jest wartoœæ <SPAN CLASS=T>DDERR_IMPLICITLYCREATED</SPAN>.
</P>
<P>
Jeœli powy¿szy kod do³¹czymy do "jeszcze bardziej powy¿szej" obs³ugi <SPAN CLASS=T>WM_PAINT</SPAN>, to wreszcie zobaczymy to, co chcemy ujrzeæ; pomimo chwilowego prze³¹czenia na inn¹ aplikacjê (co powoduje utratê naszych powierzchni) kó³eczko nadal ¿yje i ma siê dobrze ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_PAINT:<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//typowe dla obs³ugi WM_PAINT...</SPAN><BR>
&nbsp;PAINTSTRUCT ps;<BR>
&nbsp;BeginPaint(hwnd, &ps);<BR>
<BR>

&nbsp;HRESULT stracona = lpEkran->IsLost(), r = DD_OK;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(stracona == DDERR_SURFACELOST)<BR>
&nbsp;&nbsp;r = lpEkran->Restore();<BR>
<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(r == DD_OK)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//pobieramy wskaŸnik do danych powierzchni</SPAN><BR>
&nbsp;&nbsp;DDSURFACEDESC ddsd;<BR>
&nbsp;&nbsp;ZeroMemory(&ddsd, <SPAN CLASS=K>sizeof</SPAN>(ddsd));<BR>
&nbsp;&nbsp;ddsd.dwSize = <SPAN CLASS=K>sizeof</SPAN>(ddsd);<BR>
&nbsp;&nbsp;HRESULT ret = lpEkran->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(ret != DD_OK) <SPAN CLASS=K>return</SPAN> FALSE;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>const</SPAN> WORD sx = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. x</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>const</SPAN> WORD sy = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. y</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>const</SPAN> WORD r = <SPAN CLASS=L>100</SPAN>;  <SPAN CLASS=C>// promieñ ko³a</SPAN><BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//rysujemy kó³ko</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(WORD y=<SPAN CLASS=L>0</SPAN>; y&lt;<SPAN CLASS=L>200</SPAN>; ++y)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(WORD x=<SPAN CLASS=L>0</SPAN>; x&lt;<SPAN CLASS=L>200</SPAN>; ++x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>( (x-sx)*(x-sx)+(y-sy)*(y-sy) <= r*r )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((DWORD*)ddsd.lpSurface)[ddsd.dwWidth * y + x] = Kolor32(<SPAN CLASS=L>255</SPAN>-x, y, <SPAN CLASS=L>255</SPAN>-y);<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//odblokowujemy powierzchniê</SPAN><BR>
&nbsp;&nbsp;lpEkran->Unlock(NULL);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>//sygnalizujemy koniec rysowania</SPAN><BR>
&nbsp;EndPaint(hwnd, &ps);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Warto wspomnieæ, ¿e istnieje jeszcze metoda <SPAN CLASS=T>RestoreAllSurfaces</SPAN>, która - nietrudno siê domyœliæ - postara siê przywróciæ wszystkie nasze powierzchnie. Oczywiœcie jest to metoda g³ównego obiektu DirectDraw, nie powierzchni.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw03.html">&lt;&lt; Bezpoœredni dostêp...</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="dimouse.html">Mysz w DirectInput &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</HTML>