<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Stringi</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN><A HREF="../cpp.html">&lt;&lt; Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Stringi</H1>

<P>
Ju¿ od samego pocz¹tku amator-programista potrzebuje pilnie zmiennych, w których da³oby siê przechowywaæ napisy. Jêzyki wy¿szego poziomu (wy¿szego w stosunku do C++), takie jak Pascal czy Basic maj¹ to rozwi¹zane bardzo ³adnie, operacje tak powszechne jak ³¹czenie stringów, porównywanie, wyszukiwanie ci¹gów znaków czy formatowanie liczb realizuje siê w tych jêzykach bardzo ³atwo i przyjemnie. W porównaniu, praca ze stringami w jêzyku C by³a mêczarni¹. £añcuch by³ tam zwyk³¹ tablic¹ elementów typu <SPAN CLASS=K>char</SPAN>, przy czym ostatni element tej tablicy musia³ zawsze mieæ wartoœæ <SPAN CLASS=L>0</SPAN> (co oznacza koniec napisu). Wi¹za³y siê z tym wszelkie przyjemnoœci typu alokacja pamiêci czy koniecznoœæ ci¹g³ego wyliczania, gdzie znajdzie siê terminalny znak <SPAN CLASS=L>0</SPAN>.
</P>
<P>
Oczywiœcie programistom nie w smak by³o tak niewygodne rozwi¹zanie, dlatego powsta³o wiele rozmaitych bibliotek, u³atwiaj¹cych korzystanie ze stringów. Podczas tworzenia jêzyka C++ postanowiono naprawiæ tê niedogodnoœæ i dlatego Standardow¹ Bibliotekê C++ wyposa¿ono w koñcu w klasê <SPAN CLASS=T>string</SPAN> (znan¹ szerzej jako <SPAN CLASS=T>std::string</SPAN>), która pozwala u¿ywaæ stringów niemal tak samo ³atwo, jak na przyk³ad w Pascalu.
</P>
<P>
Niestety, ze wzglêdu na konstrukcjê samego jêzyka C++ nie jest mo¿liwe ca³kowite zapomnienie o tych wrednych tablicach znaków, wywodz¹cych siê z C. G³ówn¹ przeszkod¹ jest sposób traktowania przez kompilator tekstu w cudzys³owie, który interpretowany jest zawsze jako <SPAN CLASS=K>const char*</SPAN>. Mo¿emy co prawda zainicjalizowaæ zmienn¹ typu <SPAN CLASS=T>string</SPAN> takim ³añcuchem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s = <SPAN CLASS=L>"Napis"</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
...ale nie mo¿emy dwóch takich ³añcuchów skleiæ ze sob¹ operatorem <SPAN CLASS=T>+</SPAN>, np.:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN> *n1, = <SPAN CLASS=L>"Pierwszy"</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*n2 = <SPAN CLASS=L>"Drugi"</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*n3;<BR>
<BR>
n3 = n1 + n2; <SPAN CLASS=C>//b³¹d!</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Powy¿sza operacja traktowana jest niestety jako dodawanie numerycznej wartoœci wskaŸników - czyli kompletny bezsens, prowadz¹cy najprawdopodobniej do naruszenia zasad dostêpu do pamiêci, czyli wykrzaczenia siê programu.
</P>
<P>
Drugim istotnym powodem, dla którego warto wiedzieæ wszystko o stringach "w stylu C", jest smutny  (?) fakt, ¿e panuj¹cym niepodzielnie na rynku systemem operacyjnym jest wci¹¿ Windows, a WinAPI przeznaczone jest dla przestarza³ego C, nie dla C++, wiêc jego funkcje "nie znaj¹" klasy <SPAN CLASS=T>std::string</SPAN>.
</P>
<P>
Nie bêdê dalej przed³u¿a³ tego i tak zbyt obszernego wstêpu; powiem jedynie, ¿e nie powinieneœ siê zra¿aæ do tablic znaków, nawet jeœli zachwycisz siê wygod¹, jak¹ daje opisana w tym artykule klasa <SPAN CLASS=T>string</SPAN>.
</P>

<h2>
Klasa std::string
</h2>

<P>
Jak ju¿ sobie powiedzieliœmy na pocz¹tku, nowe standardy C++ zawieraj¹ w pe³ni funkcjonaln¹ klasê <SPAN CLASS=T>string</SPAN>, która niezmiernie u³atwia ¿ycie programistom. Klasa ta znana jest w³aœciwie jako <SPAN CLASS=T>std::string</SPAN> (dla odró¿nienia od wielu innych klas o tej samej lub podobnej nazwie, wystêpuj¹cych na przyk³ad w VCL), jednak ja nie lubiê tej konwencji (to¿ to a¿ piêæ znaków wiêcej! ;-)) i dlatego dalej w tym kursie bêdziemy j¹ nazywaæ po prostu <SPAN CLASS=T>string</SPAN>.
</P>
<P>
Co zrobiæ, aby móc u¿ywaæ tej klasy? To bardzo proste, wystarczy wrzuciæ na pocz¹tek naszego programu nastêpuj¹c¹ linijkê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;string&gt</SPAN>
</TD></TR>
</TABLE>

<P>
Nie nale¿y myliæ nag³ówka <SPAN CLASS=C>&lt;string&gt;</SPAN> z <SPAN CLASS=C>&lt;string.h&gt;</SPAN> - ten drugi zawiera deklaracje funkcji do obs³ugi stringów w stylu C oraz funkcji do niskopoziomowych operacji na pamiêci i nie ma nic wspólnego z klas¹ <SPAN CLASS=T>string</SPAN>.
</P>

<P>
Teraz krótko - jak pozbyæ siê tego denerwuj¹cego przedrostka <SPAN CLASS=T>std::</SPAN> w naszym programie? To równie¿ nie jest zbyt skomplikowane - musimy do³¹czyæ do programu tak¹ dyrektywê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>using namespace</SPAN> std;
</TD></TR>
</TABLE>

<P>
Od tej pory przestrzeñ nazw <SPAN CLASS=T>std</SPAN> jest "domyœln¹" przestrzeni¹ i mo¿emy u¿ywaæ przynale¿¹cych do niej nazw z niejawnym odwo³aniem do tej przestrzeni (za co bogom niech bêd¹ dziêki).
</P>

<h2>
Konstruktory
</h2>

<P>
Skoro mamy ju¿ dostêp do klasy <SPAN CLASS=T>string</SPAN>, zabierzmy siê za jej praktyczne wykorzystanie. Na pocz¹tek - kompletny kod Ÿród³owy deklaruj¹cy stringa i wypisuj¹cy go na ekranie, ¿eby potem nikt nie mówi³, ¿e nie wie, gdzie powstawiaæ te wszystkie dyrektywy i inne include'y:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;cstdlib&gt;<BR>
#include &lt;string&gt;<BR>
#include &lt;iostream&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>using namespace</SPAN> std;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;string s1 = <SPAN CLASS=L>"Napis"</SPAN>;<BR>
<BR>
&nbsp;cout &lt;&lt; s1 &lt;&lt; endl;<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mamy tu zwyk³¹ inicjalizacjê zmiennej typu <SPAN CLASS=T>string</SPAN> - ani ona specjalnie zaskakuj¹ca, ani skomplikowana, wiêc jedziemy dalej. Druga wersja konstruktora przyjmuje dwa argumenty i pozwala tworzyæ stringa wype³nionego dowoln¹ liczb¹ podanych znaków:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s(<SPAN CLASS=L>3, '*'</SPAN>); <SPAN CLASS=C>//czyli "***"</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Z kolei nastêpuj¹ca postaæ pozwala zainicjalizowaæ stringa innym, uciêtym napisem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s(<SPAN CLASS=L>"kotlet z kota", 3</SPAN>); <SPAN CLASS=C>//czyli "kot"</SPAN><BR>
</TD></TR>
</TABLE>

<h2>
£¹czenie
</h2>

<P>
 Stringi mo¿emy ze sob¹ ³¹czyæ operatorem <SPAN CLASS=T>+</SPAN>, przypisywaæ im wartoœæ w dowolnym momencie, a tak¿e zerowaæ (przypisywaæ im ³añcuch zerowej d³ugoœci), a wszystko to mo¿na ³atwo wypisaæ na ekranie przy pomocy strumieni:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string a,c,d;<BR>
<SPAN CLASS=K>char*</SPAN> b = <SPAN CLASS=L>" ma kota."</SPAN>;<BR>
a = <SPAN CLASS=L>"Ala"</SPAN>;<BR>
c = <SPAN CLASS=L>"Kot ma to"</SPAN>;<BR>
d = <SPAN CLASS=L>" gdzieœ."</SPAN><BR>
<BR>
cout &lt;&lt; a + b &lt;&lt; <SPAN CLASS=L>' '</SPAN> &lt;&lt; c + d &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<h2>
Konwersja do const char* i d³ugoœæ
</h2>

<P>
Bardzo czêsto chcemy zamieniæ zmienn¹ typu string na stringa "w stylu C", czyli na <SPAN CLASS=K>const char*</SPAN>. Jest to przydatne zw³aszcza przy pracy z WinAPI. Niestety, nie zdefiniowano operatora takiej konwersji, wiêc mo¿na j¹ wykonywaæ tylko jawnie, przy pomocy metody <SPAN CLASS=T>c_str</SPAN>. Zwraca ona sta³y wskaŸnik na wewnêtrzny bufor obiektu typu <SPAN CLASS=T>string</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s = <SPAN CLASS=L>"To jest zdanie."</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"D³ugoœæ s wynosi "</SPAN> &lt;&lt; strlen(s.c_str()) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
W tym przyk³adzie u¿yliœmy metody <SPAN CLASS=T>c_str</SPAN>, aby móc wykorzystaæ funkcjê<SPAN CLASS=T> strlen</SPAN> do pobrania d³ugoœci stringa. Funkcja <SPAN CLASS=T>strlen</SPAN> pochodzi jednak jeszcze z jêzyka C i operuje tylko na stringach typu <SPAN CLASS=K>const char*</SPAN>, dlatego u¿yliœmy metody <SPAN CLASS=T>c_str</SPAN> do uzyskania tego wymaganego wskaŸnika.
</P>
<P>
Tê sam¹ czynnoœæ moglibyœmy wykonaæ przy pomocy jednej z metod klasy <SPAN CLASS=T>string</SPAN>, a konkretnie - <SPAN CLASS=T>length</SPAN> (albo <SPAN CLASS=T>size</SPAN> - tutaj to synonimy):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s = <SPAN CLASS=L>"To jest zdanie."</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"D³ugoœæ s wynosi "</SPAN> &lt;&lt; s.length() &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<h2>
Porównywanie
</h2>
<P>
Stringi mo¿na te¿ ³atwo porównywaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string haslo=<SPAN CLASS=L>"12345"</SPAN>, podane;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Podaj has³o: "</SPAN>;<BR>
cin &gt;&gt; podane;<BR>
cout &lt;&lt; endl;<BR>
<SPAN CLASS=K>if</SPAN>(haslo == podane)<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Has³o OK."</SPAN> &lt;&lt; endl;<BR>
<SPAN CLASS=K>if</SPAN>(haslo != podane)<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Prawdopodobnie jesteœ hakerem, idŸ sobie."</SPAN> &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
W powy¿szym przyk³adzie oczywiœcie ³adniej by wygl¹da³o, gdybyœmy sprawdzali poprawnoœæ has³a przy pomocy konstrukcji <SPAN CLASS=K>if-else</SPAN>, zamiast dwóch <SPAN CLASS=K>if</SPAN>-ów, ale chcia³em pokazaæ, ¿e oprócz <SPAN CLASS=T>==</SPAN> klasa <SPAN CLASS=T>string</SPAN> ma równie¿ zdefiniowany operator <SPAN CLASS=T>!=</SPAN> ;-).
</P>
<P>
Pamiêtacie s³ynne zdanie z "Folwarku zwierzêcego" - "Wszystkie zwierzêta s¹ równe, ale niektóre s¹ równiejsze"? W C++ nie ma niestety mo¿liwoœci zdefiniowania dla stringów operatora "równiejszoœci" (który wystêpuje np. w PHP), a œciœlej mówi¹c - to w³aœnie <SPAN CLASS=T>==</SPAN> jest takim operatorem, gdy¿ uwzglêdnia wielkoœæ liter (np. wyra¿enie <SPAN CLASS=T>a == </SPAN><SPAN CLASS=L>"Ala"</SPAN> z przyk³adu z Al¹ i kotem bêdzie prawdziwe, natomiast <SPAN CLASS=T>a == </SPAN><SPAN CLASS=L>"ala"</SPAN> ju¿ nie). Tak wiêc jeœli chcemy porównaæ dwa stringi, ignoruj¹c wielkoœæ liter, to musimy skorzystaæ z funkcji <SPAN CLASS=T>_stricmp</SPAN> (lub <SPAN CLASS=T>_strcmpi</SPAN>), albo jej odpowiednika w WinAPI, czyli <SPAN CLASS=T>lstrcmpi</SPAN> - pamiêtaj¹c przy tym, ¿e wszystkie te funkcje operuj¹ na <SPAN CLASS=K>const char*</SPAN>. Oto stosowny przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s1 = <SPAN CLASS=L>"s³owo"</SPAN>, s2 = <SPAN CLASS=L>"S³OwO"</SPAN>;<BR>
<SPAN CLASS=K>if</SPAN>(!_stricmp(s1.c_str(), s2.c_str()))<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"takie same"</SPAN> &lt;&lt; endl;<BR>
<SPAN CLASS=K>else</SPAN><BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"ró¿ne"</SPAN> &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
takie same<BR>
</SPAN>
</TD></TR>
</TABLE>

<h2>
Do³¹czanie
</h2>

<P>
Bardzo przydatn¹ w³aœciwoœci¹ klasy <SPAN CLASS=T>string</SPAN> jest metoda <SPAN CLASS=T>append</SPAN>, która dokleja na koñcu stringa ci¹g znaków (posiada ona te¿ ekwiwalent w postaci operatora <SPAN CLASS=T>+=</SPAN>, jeœli ktoœ woli):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string s = <SPAN CLASS=L>"To jest napis."</SPAN>;<BR>
s.append(<SPAN CLASS=L>" I to te¿."</SPAN>);<BR>
s += <SPAN CLASS=L>" Oraz to."</SPAN>;<BR>
cout &lt;&lt; s &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<h2>
Indeksowanie
</h2>

<P>
Operator indeksowania <SPAN CLASS=T>[]</SPAN> zwraca nam referencjê do dowolnego znaku w ci¹gu. Oznacza to, ¿e mo¿emy go sobie np. wyœwietliæ na ekranie, ale równie¿ zamieniæ na inny:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Wrrrrrrrr!!!"</SPAN>;<BR>
cout &lt;&lt; "Dziesi¹ty znak to: " &lt;&lt; text[<SPAN CLASS=L>9</SPAN>] &lt;&lt; endl;<BR>
text[<SPAN CLASS=L>11</SPAN>] = <SPAN CLASS=L>'?'</SPAN>;<BR>
cout &lt;&lt; text &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Dziesi¹ty znak to: !<BR>
Wrrrrrrrr!!?<BR>
</SPAN>
</TD></TR>
</TABLE>

<h2>
Podzia³ na fragmenty
</h2>

<P>
Oprócz uzyskiwania pojedynczych znaków stringa, mo¿emy te¿ z niego pobraæ ca³y ci¹g znaków, zajmuje siê tym metoda <SPAN CLASS=T>substr</SPAN>. Przyjmuje ona dwa argumenty, obydwa s¹ opcjonalne. Jeœli je pominiemy, to <SPAN CLASS=T>substr</SPAN> zwróci kopiê ca³ego stringa. Jeœli podamy tylko pierwszy (pocz¹tkowy znak) i bêdzie to <SPAN CLASS=T>n</SPAN>, wówczas dostaniemy fragment oryginalnego stringa pocz¹wszy od <SPAN CLASS=T>n</SPAN>-tego znaku do koñca:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Ala ma kota."</SPAN>;<BR>
cout &lt;&lt; text.substr(7) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
kota.<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Najczêœciej jednak podajemy obydwa parametry (pocz¹tek "ciêcia" i d³ugoœæ kopiowanego fragmentu), co pozwala nam pobraæ dowolny fragment ze œrodka oryginalnego stringa:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Ala ma kota."</SPAN>;<BR>
cout &lt;&lt; text.substr(<SPAN CLASS=L>7,3</SPAN>) &lt;&lt; endl; <BR>
</TD></TR>
</TABLE>

<P>
Warto te¿ wiedzieæ, ¿e metoda <SPAN CLASS=T>substr</SPAN> jest bezpieczna i np. poni¿szy kod nie zrobi wbrew pozorom nic z³ego (po prostu zadzia³a tak samo, jakby drugiego parametru w ogóle nie podano):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Ala ma kota."</SPAN>;<BR>
cout &lt;&lt; text.substr(<SPAN CLASS=L>7,300</SPAN>) &lt;&lt; endl; <BR>
</TD></TR>
</TABLE>

<h2>
Wstawianie
</h2>

<P>
Metoda <SPAN CLASS=T>insert</SPAN>, jak sama nazwa wskazuje, pozwala wepchn¹æ jeden ci¹g znaków do œrodka drugiego. Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Jacek ma 1000 z³otych."</SPAN>;<BR>
cout &lt;&lt; text &lt;&lt; endl;<BR>
text.insert(<SPAN CLASS=L>9, "d³ug w wysokoœci "</SPAN>);<BR>
cout &lt;&lt; text &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Jeœli policzyæ uwa¿nie znaki, to widaæ, ¿e numeryczny argument metody <SPAN CLASS=T>insert</SPAN> oznacza indeks znaku PRZED którym ma byæ wstawiony podany string. U nas znak o indeksie <SPAN CLASS=L>9</SPAN> to <SPAN CLASS=L>'1'</SPAN>, dlatego w³aœnie ca³y napis podany jako argument do metody <SPAN CLASS=T>insert</SPAN> trafia przed <SPAN CLASS=L>"1000"</SPAN> w ³añcuchu text, co zreszt¹ staje siê przyczyn¹ nielichego k³opotu dla Jacka ;-).
</P>

<h2>
Wyszukiwanie
</h2>

<P>
Ostatni¹ rzecz¹, któr¹ sobie omówimy, jest wyszukiwanie ci¹gów znaków w stringu. Klasa <SPAN CLASS=T>string</SPAN> jest pod tym wzglêdem ca³kiem nieŸle wyposa¿ona. Przede wszystkim mamy tu przeci¹¿on¹ metodê <SPAN CLASS=T>find</SPAN>, która po prostu szuka podanego tekstu, zaczynaj¹c od danej pozycji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Kot ma ¿arcie."</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Znaleziono na pozycji "</SPAN> &lt;&lt; text.find(<SPAN CLASS=L>"¿arcie"</SPAN>) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Znaleziono na pozycji 7
</SPAN>
</TD></TR>
</TABLE>

<P>
Powy¿ej nie podaliœmy pozycji startowej, wiêc wyszukiwanie zosta³o domyœlnie rozpoczête od znaku numer <SPAN CLASS=L>0</SPAN> (czyli od samego pocz¹tku stringa). Jeœli podamy znak nr <SPAN CLASS=L>8</SPAN>, to tekst nie zostanie ju¿ znaleziony i wtedy <SPAN CLASS=T>find</SPAN> zwróci <SPAN CLASS=L>0xFFFFFFFF</SPAN>, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Kot ma ¿arcie."</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Pozycja: "</SPAN> &lt;&lt; text.find(<SPAN CLASS=L>"¿arcie", 8</SPAN>) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Pozycja: 4294967295<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Inna wersja metody <SPAN CLASS=T>find</SPAN> przyjmuje dwa parametry i uwzglêdnia przy wyszukiwaniu tylko <SPAN CLASS=T>n</SPAN> znaków z podanego ci¹gu, jeœli drugim parametrem jest <SPAN CLASS=T>n</SPAN>, na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"Kot to ¿ar³ok."</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Pozycja: "</SPAN> &lt;&lt; text.find(<SPAN CLASS=L>"¿arcie", 0, 3</SPAN>) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Tutaj tekst zostanie znaleziony, mimo ¿e szukamy nieco innego stringa - po prostu przy porównaniu uwzglêdniamy tu tylko <SPAN CLASS=L>3</SPAN> pierwsze znaki.
</P>

<P>
Metoda <SPAN CLASS=T>rfind</SPAN> dzia³a podobnie, ale szuka wstecz (domyœln¹ pozycj¹ startow¹ jest koniec stringa). 
</P>
<P>
Bardzo przydatn¹ rzecz¹, szczególnie przy pisaniu wszelkiego rodzaju parserów, jest metoda find_first_of. Traktuje ona podany ci¹g znaków nie jako zwart¹ ca³oœæ, tylko jako zbiór pojedynczych znaków. Innymi s³owy, pozwala ona wyci¹gaæ z tekstu pojedyncze wyra¿enia, porozdzielane dowoln¹ liczb¹ okreœlonych znaków w dowolnej kombinacji. Na przyk³ad jeœli mamy tekst zawieraj¹cy spacje, tabulatory i znaki koñca linii:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
string text = <SPAN CLASS=L>"S³owo\t\t \n\r To bêdzie wyciête"</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
...i chcemy te znaki wyci¹æ (oraz wszystko, co po nich nastêpuje), to piszemy tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>unsigned int</SPAN> u;<BR>
u = text.find_first_of(<SPAN CLASS=L>" \t\n\r"</SPAN>);<BR>
cout &lt;&lt; text.substr(<SPAN CLASS=L>0</SPAN>, u) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Tak wiêc metoda <SPAN CLASS=T>find_first_of</SPAN>, jak sama nazwa wskazuje, szuka pierwszego wyst¹pienia jednego ze znaków z podanego zestawu (w naszym przypadku bêdzie to tabulacja, czyli <SPAN CLASS=L>\t</SPAN>). Mo¿emy te¿ podaæ indeks znaku, od którego ma byæ rozpoczête wyszukiwanie (analogicznie jak w <SPAN CLASS=T>find</SPAN>).
</P>
<P>
Podobn¹ metod¹, nawet przydatniejsz¹, jest <SPAN CLASS=T>find_first_not_of</SPAN>. Nietrudno siê domyœliæ, ¿e ona znajduje wszystko, czego nie znalaz³a <SPAN CLASS=T>find_first_of</SPAN> :-). Innymi s³owy, traktuje ona podany ci¹g jako znaki rozdzielaj¹ce, a wszystkie pozosta³e s¹ dla niej "celem". Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>unsigned int</SPAN> u = <SPAN CLASS=L>0</SPAN>;<BR>
string text = <SPAN CLASS=L>"   To    jest  \n    zdanie"</SPAN>;<BR>
<SPAN CLASS=K>while</SPAN>(<SPAN CLASS=K>true</SPAN>)<BR>
{<BR>
&nbsp;u = text.find_first_not_of(<SPAN CLASS=L>" \t\n\r"</SPAN>, u);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(u == <SPAN CLASS=L>0xFFFFFFFF</SPAN>) <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;cout &lt;&lt; text[u] &lt;&lt; endl;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(u&lt;text.length()-1) ++u; <SPAN CLASS=K>else break</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
T<BR>
o<BR>
j<BR>
e<BR>
s<BR>
t<BR>
z<BR>
d<BR>
a<BR>
n<BR>
i<BR>
e<BR>
</SPAN>
</TD></TR>
</TABLE>


<P>
Stosuj¹c ³¹cznie metody <SPAN CLASS=T>find_first_of</SPAN> i <SPAN CLASS=T>find_first_not_of</SPAN> otrzymujemy mo¿liwoœæ doœæ ³atwego podzia³u zdañ na pojedyñcze s³owa lub wyra¿enia, co na pewno w przysz³oœci nam siê bardzo przyda. Arsena³ ten uzupe³niaj¹ metody <SPAN CLASS=T>find_last_of</SPAN> i <SPAN CLASS=T>find_last_not_of</SPAN>, których dzia³anie jest chyba ³atwe do odgadniêcia, nieprawda¿?
</P>
<P>
Omówione cechy klasy string to tylko czêœæ jej bogatych mo¿liwoœci, ale powinno to wystarczyæ do wiêkszoœci zastosowañ. Opisy pozosta³ych metod oraz dok³adniejsze informacje o tych ju¿ omówionych mo¿na oczywiœcie znaleŸæ w dokumentacji do Biblioteki Standardowej.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN><A HREF="../cpp.html">&lt;&lt; Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A>
</TD>
</TR>
</TABLE>

</BODY>

</FONT>

</HTML>




