<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Menu</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apidlg3.html">&lt;&lt; Dialogi, cz.3</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apireg.html">Rejestr &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
Menu i pliki zasobów
</H2>

<P>
Program windowsowy bez menu to jak komputer bez klawiatury i myszki - niby dzia³a, ale nijak siê nie mo¿na do niego dobraæ ;-). Menu jest zwyk³¹ kontrolk¹, jednak traktowan¹ w specjalny sposób. Najprostsz¹ metod¹ stworzenia menu jest napisanie skryptu *.rc. Oto przyk³adowy plik:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=L>200</SPAN> <SPAN CLASS=K>MENU</SPAN><BR>
{<BR>
&nbsp;<SPAN CLASS=K>POPUP</SPAN> <SPAN CLASS=L>"&Plik"</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Nowy", 100</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Otwórz", 101</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Zapisz", 102</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM SEPARATOR</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>POPUP</SPAN> <SPAN CLASS=L>"&Importuj"</SPAN><BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Tekst", 103</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>POPUP</SPAN> <SPAN CLASS=L>"O&braz"</SPAN><BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"Bit&mapa", 104</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&JPEG", 105</SPAN><BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM SEPARATOR</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Koniec", 106</SPAN><BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>MENUITEM</SPAN> <SPAN CLASS=L>"&Edycja", 108</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jedyne, co musimy jeszcze zrobiæ, aby nasze pierwsze menu pojawi³o siê w okienku, to za³adowaæ je funkcj¹ <SPAN CLASS=T>LoadMenu</SPAN>, a nastêpnie przypisaæ do konkretnego okna. Funkcja <SPAN CLASS=T>LoadMenu</SPAN> ma dwa parametry: uchwyt programu (typ <SPAN CLASS=T>HINSTANCE</SPAN>), oraz identyfikator menu w pliku (u nas jest nim liczba <SPAN CLASS=L>200</SPAN>, któr¹ "przerabiamy" na identyfikator makrem <SPAN CLASS=T>MAKEINTRESOURCE</SPAN>). Zwraca natomiast uchwyt do menu (jak nietrudno siê domyœliæ, uchwyt ten jest typu <SPAN CLASS=T>HMENU</SPAN>). Oto jak to wygl¹da:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HMENU hMenu = LoadMenu(hThisInstance, MAKEINTRESOURCE(<SPAN CLASS=L>200</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
Powy¿sz¹ linijkê kodu powinieneœ wstawiæ PRZED instrukcj¹ tworz¹c¹ okno (<SPAN CLASS=T>CreateWindowEx</SPAN>), poniewa¿ jak ju¿ okno bêdzie gotowe, trudniej nam bêdzie wstawiæ do niego menu ;-). Oczywiœcie w miejsce <SPAN CLASS=T>hThisInstance</SPAN> wstawiasz swój w³asny uchwyt do aplikacji.
</P>
<P>
Mamy wiêc uchwyt do nowego menu, teraz tylko wstawimy go do funkcji <SPAN CLASS=T>CreateWindowEx</SPAN>, ¿eby menu pojawi³o siê w g³ównym oknie naszego programiku. Pamiêtasz trzeci od koñca parametr funkcji <SPAN CLASS=T>CreateWindowEx</SPAN>? Zwykle ustawialiœmy go na <SPAN CLASS=T>NULL</SPAN>, ewentualnie gdy u¿ywaliœmy tej funkcji do tworzenia kontrolek, to wstawialiœmy tam identyfikator kontrolki. Teraz po prostu wpisujemy w to miejsce <SPAN CLASS=T>hMenu</SPAN>, czyli nasz uchwyt do menu i ju¿ mo¿emy podziwiaæ efekty:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu1.gif" ALT="Nasze pierwsze menu - ciasne ale w³asne ;-)">
</P>

<P>
Teraz warto by sobie omówiæ te wszystkie zaklêcia, których u¿yliœmy w skrypcie ;-). Ka¿da pozycja menu odpowiada jednemu s³owu <SPAN CLASS=K>MENUITEM</SPAN>, po którym nastêpuje etykieta menu oraz identyfikator danej pozycji. W etykiecie mog¹ wyst¹piæ symbole <SPAN CLASS=L>&</SPAN>, które oznaczaj¹ literkê, która bêdzie w danym menu podkreœlona. Chyba wiesz, o co biega - dziêki temu bêdzie mo¿na obs³ugiwaæ twoje menu z klawiatury (prawy ALT + litera) i w dodatku bêdzie siê to dzia³o automatycznie, bez koniecznoœci pisania dodatkowego kodu (!).
</P>
<P>
Identyfikatory kolejnych pozycji menu musz¹ byæ unikalne w skali programu (tak jak wszystkie inne zasoby w plikach *.rc, rzecz jasna). Oczywiœcie zamiast "go³ych" liczb warto stosowaæ "sta³e", np.:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#define</SPAN> MNU_PLIK_NOWY <SPAN CLASS=L>100</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Zamiast <SPAN CLASS=K>MENUITEM</SPAN> mo¿emy u¿yæ <SPAN CLASS=K>POPUP</SPAN>. Jak ju¿ pewnie siê domyœlasz, dziêki temu dana pozycja menu bêdzie rozwijalna, czyli najechanie na ni¹ mysz¹ doprowadzi do pojawienia siê kolejnego poziomu menu, tak jak na obrazku powy¿ej. Pozycja menu zdefiniowana przez <SPAN CLASS=K>POPUP</SPAN> nie mo¿e zostaæ wybrana (jest tylko, hmm, etapem przejœciowym w drodze do kolejnej pozycji ;-)), tote¿ nie posiada w³asnego identyfikatora.
</P>
<P>
Specjalnym rodzajem pozycji menu jest <SPAN CLASS=K>MENUITEM SEPARATOR</SPAN> - czyli kreski rozdzielaj¹ce poszczególne grupy pozycji menu, ¿eby menu wygl¹da³o estetyczniej. Tutaj chyba nie potrzeba dalszych komentarzy.
</P>
<P>
Jako stary windowsowy wyjadacz na pewno niejedno menu ju¿ widzia³eœ ;-). Tak wiêc pewnie czujesz, ¿e czegoœ ci jeszcze brak. Nawet taka prosta aplikacyjka jak Notatnik, w którym piszê w³aœnie ten kurs, posiada zwykle dodatkowe drobne usprawnienia w swoim menu - niektóre pozycje s¹ "zafajkowane" (<SPAN CLASS=Inglisz>checked</SPAN>), inne s¹ nieaktywne, czyli nie mo¿na ich chwilowo wybraæ i s¹ wypisane szarym kolorem. Pierwszy efekt osi¹gamy przez dodanie (po przecinku) s³owa <SPAN CLASS=K>CHECKED</SPAN> do konkretnej pozycji menu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>MENUITEM <SPAN CLASS=L>"Bit&mapa", 104</SPAN>, CHECKED</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Niestety, "fajeczka" nie zniknie automatycznie po klikniêciu na zafajkowan¹ pozycjê :-(. Musimy o to zadbaæ sami (o tym póŸniej). Aby zaœ chwilowo wy³¹czyæ dan¹ pozycjê, dodajemy w ten sam sposób s³owo <SPAN CLASS=K>GRAYED</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>MENUITEM<SPAN CLASS=L> "&JPEG", 105</SPAN>, GRAYED</SPAN>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu2.gif" ALT="Teraz menu zaczyna wygl¹daæ 'profesjonalnie' ;-)">
</P>

<P>
Obydwu "efektów" mo¿emy u¿yæ jednoczeœnie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>MENUITEM <SPAN CLASS=L>"Bit&mapa", 104</SPAN>, CHECKED, GRAYED</SPAN>
</TD></TR>
</TABLE>

<P>
Warto wiedzieæ o parametrach <SPAN CLASS=K>MENUBREAK</SPAN> i <SPAN CLASS=K>MENUBARBREAK</SPAN>. Pozwalaj¹ one podzieliæ dane podmenu na kilka kolumn, przy czym <SPAN CLASS=K>MENUBARBREAK</SPAN> dodatkowo wstawia pionow¹ liniê w miejscu podzia³u, a <SPAN CLASS=K>MENUBREAK</SPAN> - nie. I tak na przyk³ad gdybyœmy dodali <SPAN CLASS=K>MENUBARBREAK</SPAN> do pozycji 'Otwórz', to orzymalibyœmy taki efekt:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>MENUITEM <SPAN CLASS=L>"&Otwórz", 101</SPAN>, MENUBARBREAK</SPAN><BR>
</TD></TR>
</TABLE>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu3.gif" ALT="Trochê œmiesznie, ale gdyby by³o wiêcej pozycji w tym menu...">
</P>

<P>
Niezbyt ³adne, ale gdy mamy w menu wiêcej pozycji, rozwi¹zanie takie bywa ca³kiem przydatne. Ciekawe rezultaty mo¿e daæ u¿ycie tych dwóch parametrów wobec pozycji z g³ównej belki menu (np. Plik, Edycja itp.). Kiedy tak zrobimy, bêd¹ one u³o¿one jedna pod drug¹, zamiast obok siebie. W tym przypadku nie ma ¿adnej ró¿nicy miêdzy <SPAN CLASS=K>MENUBREAK</SPAN> i <SPAN CLASS=K>MENUBARBREAK</SPAN>.
</P>
<P>
Wiêkszoœæ komend menu posiada klawiaturowe skróty, umo¿liwiaj¹ce wykonanie tych komend bez koniecznoœci rozwijania menu. Skróty wyœwietlane s¹ po prawej stronie menu i zazwyczaj s¹ to kombinacje Ctrl+litera. Mo¿emy sobie utworzyæ takie skróty, coby jeszcze bardziej uzywilizowaæ nasz przeœliczne menu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>
MENUITEM <SPAN CLASS=L>"&Nowy\tCtrl+N", 100</SPAN><BR>
MENUITEM <SPAN CLASS=L>"&Otwórz\tCtrl+O", 101</SPAN><BR>
MENUITEM <SPAN CLASS=L>"&Zapisz\tCtrl+Z", 102</SPAN><BR>
</SPAN>
</TD></TR>
</TABLE>


<P ALIGN=CENTER>
<IMG SRC="../gfx/menu4.gif" ALT="Skróty niby s¹, chocia¿ nie dzia³aj¹ :-/">
</P>

<P>
Jak widaæ, polega to po prostu na dodaniu do etykiety tabulacji (symbol <SPAN CLASS=L>\t</SPAN>) i wpisaniu skrótu. Niestety, automatycznie ten system skrótów nie dzia³a, musimy skorzystaæ z tzw. <SPAN CLASS=Wazne>akceleratorów</SPAN>, o których dowiemy siê w osobnej czêœci tego kursu.
</P>

<H2>
Modyfikacja menu w fazie wykonywania
</H2>

<P>
Czasami mo¿emy chcieæ zmieniæ menu w trakcie wykonywania programu, np. gdy dajemy u¿ytkownikowi mo¿liwoœæ dostosowania menu do w³asnych potrzeb. W takich wypadkach mo¿emy u¿yæ funkcji <SPAN CLASS=T>CreateMenu</SPAN> i <SPAN CLASS=T>CreatePopupMenu</SPAN> do stworzenia nowego, pustego menu, po czym wype³niæ je przy pomocy funkcji <SPAN CLASS=T>InsertMenuItem</SPAN>. Oczywiœcie nic nie stoi na przeszkodzie, by dodaæ now¹ pozycjê do gotowego menu stworzonego z pliku zasobów, co za moment sobie zrobimy.
</P>
<P>
S³usznie siê obawiasz - czeka nas teraz pracowite wype³nianie struktury. Zowie siê ona <SPAN CLASS=T>MENUITEMINFO</SPAN> i jak zwykle ma sporo pól, ale na szczêœcie nie wszystkie musimy wype³niaæ (te¿ jak zwykle). Robiliœmy ju¿ takie rzeczy nieraz, wiêc szczegó³y pomijam. Oto kompletna struktura, gotowa do u¿ycia:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
MENUITEMINFO mii;<BR>
ZeroMemory(&mii, <SPAN CLASS=K>sizeof</SPAN>(mii));<BR>
mii.cbSize = <SPAN CLASS=K>sizeof</SPAN>(mii);<BR>
mii.fMask = MIIM_ID | MIIM_TYPE;<BR>
mii.fType = MFT_STRING;<BR>
mii.wID = <SPAN CLASS=L>110</SPAN>;<BR>
mii.dwTypeData = <SPAN CLASS=L>"Reset"</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Pole <SPAN CLASS=T>fMask</SPAN> okreœla, jakie z pozosta³ych pól bêdziemy wype³niaæ. Potrzebujemy tylko dwóch: <SPAN CLASS=T>fType</SPAN> i <SPAN CLASS=T>wID</SPAN>, co widaæ po doborze flag (<SPAN CLASS=T>MIIM_TYPE</SPAN> i <SPAN CLASS=T>MIIM_ID</SPAN>). W polu <SPAN CLASS=T>fType</SPAN> dajemy sta³¹ <SPAN CLASS=T>MFT_STRING</SPAN>, co oznacza, ¿e chcemy podaæ etykietê dla naszej nowej pozycji menu. Etykietê tê wrzucamy ¿ywcem do pola <SPAN CLASS=T>dwTypeData</SPAN>. Pozostaje tylko ustaliæ identyfikator dla nowej pozycji menu - niech to bêdzie liczba <SPAN CLASS=L>110</SPAN>.
</P>
<P>
Nowa pozycja menu gotowa - zrobiliœmy polecenie do resetowania kompa, ale z nas wredne istoty ;-). Teraz korzystamy ze wspomnianej ju¿ funkcji <SPAN CLASS=T>InsertMenuItem</SPAN>. Podajemy jej kolejno: uchwyt do menu, identyfikator pozycji PRZED któr¹ chcemy umieœciæ nasz¹ now¹ pozycjê (tutaj wstawiamy 'Reset' przed pole 'Koniec', wiêc musimy podaæ identyfikator tego ostatniego - <SPAN CLASS=L>106</SPAN>), wartoœæ <SPAN CLASS=T>FALSE</SPAN> (lub <SPAN CLASS=T>TRUE</SPAN>, jeœli zamiast identyfikatora podaliœmy indeks pozycji), wreszcie adres naszej wype³nionej struktury:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
InsertMenuItem(hMenu, <SPAN CLASS=L>106</SPAN>, FALSE, &mii);<BR>
</TD></TR>
</TABLE>

<P>
Powy¿sz¹ instrukcjê mo¿emy umieœciæ zarówno przed utworzeniem okna zawieraj¹cego nasze menu, jak i po nim. Tadaaa! Gotowe:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu5.gif" ALT="W menu cosik jakby przyby³o ;-) ">
</P>

<P>
Na razie umiemy tylko dodawaæ "zwyk³e" pozycje menu - a jak dodaæ pozycje nieaktywne lub zafajkowane? Otó¿ musimy siê dodatkowo zainteresowaæ polem <SPAN CLASS=T>fState</SPAN> naszej struktury. Jeœli wpisaæ do tego pola <SPAN CLASS=T>MFS_GRAYED</SPAN> - nowa pozycja menu bêdzie "szara", jeœli damy <SPAN CLASS=T>MFS_CHECKED</SPAN> - zafajkujemy j¹ :-). Oczywiœcie musimy uwzglêdniæ pole <SPAN CLASS=T>fState</SPAN> przy wype³nianiu <SPAN CLASS=T>fMask</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;<BR>
mii.fState = MFS_CHECKED | MFS_ GRAYED; <BR>
</TD></TR>
</TABLE>

<P>
...i ju¿ mamy nasz¹ pozycjê 'Reset' oznaczon¹ faj¹ i nieaktywn¹ w dodatku.
</P>
<P>
Aby wstawiæ separator, w miejsce <SPAN CLASS=T>MFT_STRING</SPAN> dajemy <SPAN CLASS=T>MFT_SEPARATOR</SPAN>. Oczywiœcie wtedy ustawianie etykiety ani identyfikatora nie jest konieczne.
</P>
<P>
Jak byæ mo¿e zauwa¿y³eœ, w ró¿nych programach oprócz "fajek" wystêpuj¹ te¿ kó³eczka. Mo¿emy te¿ sobie takie zrobiæ. Wystarczy do <SPAN CLASS=T>fType</SPAN> dorzuciæ sta³¹ <SPAN CLASS=T>MFT_RADIOCHECK</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
mii.fType = MFT_STRING | MFT_RADIOCHECK;<BR>
mii.fState = MFS_CHECKED;<BR>
</TD></TR>
</TABLE>


<P ALIGN=CENTER>
<IMG SRC="../gfx/menu6.gif" ALT="Fajne te kó³eczka, nie? ;-)">
</P>

<P>
Jak widzimy, "rêczne" dodawanie menu jest zbyt pracoch³onne, ¿eby korzystaæ z tej mo¿liwoœci do stworzenia ca³ego menu, wiêc cieszmy siê, ¿e dobrzy ludzie wynaleŸli pliki skryptowe ;-).
</P>

<H2>
Ikonki menu
</H2>

<P>
Naprawdê wypasione programy, jak choæby Dev-C++, maj¹ w menu ikonki. My te¿ takie chcemy, a dla chc¹cego jak wiadomo nie ma nic trudnego ;-). Mo¿emy wykorzystaæ fakt, ¿e domyœlne fajki i kó³eczka dla oznaczenia stanu <SPAN CLASS=T>CHECKED</SPAN> mog¹ zostaæ wymienione na w³asne obrazki, niekoniecznie przedstawiaj¹ce fajki i kó³ka ;-).
</P>
<P>
Do wyboru mamy: wype³nienie pól <SPAN CLASS=T>hbmpChecked</SPAN> i <SPAN CLASS=T>hbmpUnchecked</SPAN> naszej kochanej struktury uchwytami do bitmap, które musimy sobie sami wczytaæ, oraz skorzystanie z funkcji <SPAN CLASS=T>SetMenuItemBitmaps</SPAN>, która zrobi to samo przy mniejszej iloœci pisaniny ;-). Oczywiœcie wybieramy tê drug¹ opcjê:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HBITMAP hbmMorda = (HBITMAP)LoadImage(hThisInstance, <SPAN CLASS=L>"morda.bmp"</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_BITMAP, <SPAN CLASS=L>0,0</SPAN>, LR_LOADFROMFILE|LR_LOADTRANSPARENT);<BR>
SetMenuItemBitmaps(hMenu, <SPAN CLASS=L>110</SPAN>, MF_BYCOMMAND, hbmMorda, hbmMorda);<BR>
</TD></TR>
</TABLE>

<P>
Jeœli pamiêtasz jeszcze kurs grafiki w WinAPI, to pewnie wiesz, jak korzystaæ z funkcji <SPAN CLASS=T>LoadImage</SPAN>. Dodaliœmy do niej jedn¹ flagê - <SPAN CLASS=T>LR_LOADTRANSPARENT</SPAN>. Dziêki niej funkcja zastêpuje kolor pierwszego piksela naszego obrazka w ca³ej bitmapie na domyœlny kolor systemowy menu, dziêki czemu nasz obrazek ma "przezroczyste" t³o.
</P>
<P>
Zanim przyst¹pisz do wybierania obrazka, zadbaj o jego wymiary. U mnie wynosz¹ one <SPAN CLASS=L>13x13</SPAN> pikseli, co prawdopodobnie jest domyœlnym ustawieniem Windowsa. Aby wszystko by³o cacy, mo¿esz pobraæ te wymiary funkcj¹ <SPAN CLASS=T>GetSystemMetrics</SPAN>, stosuj¹c flagi <SPAN CLASS=T>CXMENUCHECK</SPAN> i <SPAN CLASS=T>CYMENUCHECK</SPAN>, a nastêpnie odpowiednio wyskalowaæ wczytan¹ bitmapê (najlepiej zrobiæ to od razu w wywo³aniu funkcji <SPAN CLASS=T>LoadImage</SPAN>).
</P>
<P>
Funkcja <SPAN CLASS=T>SetMenuItemBitmaps</SPAN> pobiera kolejno: uchwyt menu, identyfikator pozycji, której dorabiamy ikonkê, flagê <SPAN CLASS=T>MF_BYCOMMAND</SPAN> (oznacza, ¿e poprzedni parametr jest identyfikatorem pozycji menu), wreszcie najwa¿niejsze - dwa uchwyty; bitmapa "zafajkowana" i bitmapa "odfajkowana". U nas daliœmy do obu identyczn¹ bitmapê, co zreszt¹ robi siê prawie zawsze przy korzystaniu z ikon menu. Efekt? Proszê bardzo:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu7.gif" ALT="Robi siê kolorowo i weso³o ;-)">
</P>



<H2>
Menu i komunikaty
</H2>

<P>
To naprawdê fajnie, ¿e umiemy ju¿ zrobiæ menu ze wszelkimi bajerami, ale co nam po nim, skoro klikanie na tym menu nic nie daje? Trzeba zrobiæ obs³ugê komunikatów. Klikniêcie na wybranej pozycji menu powoduje wys³anie komunikatu <SPAN CLASS=T>WM_COMMAND</SPAN>. Jak nietrudno siê domyœliæ, parametr <SPAN CLASS=T>wParam</SPAN> (a œciœlej: jego dolne s³owo) zawiera identyfikator pozycji menu, która zosta³a klikniêta. Tak wiêc nietrudno bêdzie przypisaæ odpowiednim pozycjom menu jakieœ dzia³anie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(LOWORD(wParam) == <SPAN CLASS=L>106</SPAN>)<BR>
&nbsp;&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Dziêkujemy za skorzystanie z naszego menu ;-P",<BR>
&nbsp;&nbsp;&nbsp;"Mesyd¿"</SPAN>, MB_ICONINFORMATION);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;
</TD></TR>
</TABLE>

<P>
Tutaj poszliœmy sobie na ³atwiznê i dodaliœmy dzia³anie menu 'Koniec', natomiast wybranie jakiejkolwiek innej pozycji spowoduje wyœwietlenie okna z wiadomoœci¹.
</P>
<P>
Skoro mamy ju¿ mo¿liwoœci, to nauczmy siê wreszcie, co zrobiæ z tymi cholernymi fajeczkami, ¿eby dzia³a³y jak Pan Bóg przykaza³. Wszystkie atrybuty menu mo¿na zmieniæ funkcj¹ <SPAN CLASS=T>SetMenuItemInfo</SPAN>, która korzysta z omówionej ju¿ struktury <SPAN CLASS=T>MENUITEMINFO</SPAN>. Nie przepadamy jednak za t¹ struktur¹ i korzystamy z niej tylko wtedy, gdy ju¿ naprawdê nie da siê inaczej. A w przypadku fajeczek siê da, bo mamy w zanadrzu ca³kiem mi³¹ funkcyjkê <SPAN CLASS=T>CheckMenuItem</SPAN>. Wywo³uje siê j¹ bardzo podobnie do <SPAN CLASS=T>SetMenuItemBitmaps</SPAN>, tyle ¿e do flag (trzeci argument) dodajemy dodatkowo <SPAN CLASS=T>MF_CHECKED</SPAN> lub <SPAN CLASS=T>MF_UNCHECKED</SPAN> (no i oczywiœcie nie podajemy uchwytów do bitmap, bo nie do tego ta funkcja s³u¿y).
</P>
<P>
Przechodz¹c do praktyki - potrzebowaæ bêdziemy globalnej zmiennej, przechowuj¹cej stan danej pozycji menu <NOBR>(zafajkowana/odfajkowana):</NOBR> 
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BOOL g_Checked = FALSE;<BR>
</TD></TR>
</TABLE>

<P>
Nastêpnie wybieramy sobie jak¹œ pozycjê menu, która ma byæ fajkowana - niech to bêdzie ta z plikiem JPEG w etykiecie (identyfikator: <SPAN CLASS=L>105</SPAN>). W obs³udze <SPAN CLASS=T>WM_COMMAND</SPAN> piszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(LOWORD(wParam) == <SPAN CLASS=L>105</SPAN>)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;g_Checked = ~g_Checked;<BR>
&nbsp;&nbsp;CheckMenuItem(hMenu, <SPAN CLASS=L>105</SPAN>, MF_BYCOMMAND |<BR>
&nbsp;&nbsp;&nbsp;(g_Checked)?MF_CHECKED:MF_UNCHECKED);<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Jeœli korzystasz raczej z kó³eczek, ni¿ z fajeczek, czyli masz grupê pozycji menu, z których tylko jedna mo¿e byæ w danym momencie zaznaczona, to przydatniejsza bêdzie dla ciebie funkcja <SPAN CLASS=T>CheckMenuRadioItem</SPAN>, której dodatkowo podajemy identyfikatory pierwszej i ostatniej pozycji w grupie, dziêki czemu mo¿e ona odznaczyæ wczeœniej zaznaczon¹ pozycjê i zaznaczyæ now¹ (heh ;-)).
</P>

<H2>
Menu kontekstowe
</H2>

<P>
Ostatni¹ rzecz¹ zwi¹zan¹ z menu, jak¹ sobie omówimy, bêd¹ menu <NOBR>kontekstowe/podrêczne/skrótowe/wyskakuj¹ce</NOBR> czy jak je tam sobie nazwiemy (po angielsku: <SPAN CLASS=Inglisz>popup menus</SPAN> lub <SPAN CLASS=Inglisz>shortcut menus</SPAN>), w ka¿dym razie chodzi o menu, pojawiaj¹ce siê zwykle po naciœniêciu prawego przycisku myszy. Mo¿emy sobie takowe utworzyæ ca³kiem oddzielnie od istniej¹cego ju¿ paska menu albo te¿ skorzystaæ z tego, co ju¿ mamy zrobione. Bardzo czêsto menu kontekstowe jest w³aœnie wycinkiem "w³aœciwego" menu (zw³aszcza menu 'Edycja').
</P>
<P>
Oto co trzeba zrobiæ, ¿eby prawy przycisk gryzonia pokazywa³ nam menu 'Plik' w dowolnym miejscu naszego okienka:
</P>


<TABLE BORDER WIDTH=100%>
<TR><TD>
TrackPopupMenu(GetSubMenu(hMenu,<SPAN CLASS=L>0</SPAN>),<SPAN CLASS=L>0</SPAN>,LOWORD(lParam),<BR>
&nbsp;HIWORD(lParam),<SPAN CLASS=L>0</SPAN>,hwnd,NULL);<BR>
</TD></TR>
</TABLE>

<P>
Pierwszy argument tej fajnej funkcji s³u¿y, jak sama nazwa wskazuje, do pobrania podmenu. Podmenu to takie menu, które rozwija siê w dó³ lub w bok. Aby pobraæ uchwyt podmenu 'Plik', musimy podaæ funkcji <SPAN CLASS=T>GetSubMenu</SPAN> wartoœæ zero jako drugi argument, poniewa¿ nasze menu 'Plik' jest na samym poczatku ca³ego menu.
</P>
<P>
Nastêpne dwa atrybuty to wspó³rzêdne, gdzie ma siê pojawiæ menu kontekstowe - dajemy tu wspó³rzêdne klikniêcia. Nastêpny argument jest zarezerwowany <NOBR>tylko-dla-Microsoftu</NOBR> i ma byæ równy <SPAN CLASS=L>0</SPAN>. Wreszcie dajemy uchwyt do okna i <SPAN CLASS=T>NULL</SPAN>. W tym ostatnim mo¿emy podaæ adres do prostok¹ta, w którym klikniêcie nie powoduje schowania menu kontekstowego. Jeœli zaœ pójdziemy na ³atwiznê i wrzucimy tam <SPAN CLASS=T>NULL</SPAN>, to menu bêdzie chowane zawsze wtedy, gdy klikniemy na zewn¹trz niego, co w wiêkszoœci przypadków chcemy w³aœnie osi¹gn¹æ. I gotowe ;-).
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/menu8.gif" ALT="Menu kontekstowe">
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apidlg3.html">&lt;&lt; Dialogi, cz.3</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apireg.html">Rejestr &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>