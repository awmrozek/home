<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Podstawowe kontrolki</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="api1.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apievnt.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Podstawowe kontrolki
</H1>

<P>
Nasze puste okienko jakoœ blado wygl¹da przy aplikacjach typu Word, albo chocia¿by przy samym Dev-C++. Warto by dorzuciæ te ró¿ne fajne bajery, jak przyciski, menu, pola tekstowe... Te wszystkie rzeczy nazywa siê po angielsku <SPAN CLASS=Inglisz>controls</SPAN>, co po naszemu t³umaczy siê (mo¿e niezbyt trafnie, ale ca³kiem funkcjonalnie) jako "<SPAN CLASS=Wazne>kontrolki</SPAN>".
</P>
<P>
Kontrolki to po prostu takie "ma³e" okienka, które wchodz¹ w sk³ad "du¿ego" okna macierzystego. Tak samo jak "zwyk³e" okna, kontrolki tworzymy wiêc funkcjami <SPAN CLASS=T>CreateWindow</SPAN> oraz <SPAN CLASS=T>CreateWindowEx</SPAN>. 
Co wrzuciæ do tych funkcji, ¿eby zamiast normalnego okna wyprodukowa³y nam kontrolkê? Przede wszystkim musimy wpisaæ predefiniowan¹ nazwê klasy. Jak byæ mo¿e pamiêtasz, podczas tworzenia g³ównego okna programu mogliœmy tam wpisaæ cokolwiek, np. <SPAN CLASS=L>"MyWindowClass"</SPAN>. Tworz¹c przycisk wpisujemy zaœ <SPAN CLASS=L>"BUTTON"</SPAN>. Pozosta³e klasy, których mo¿emy u¿yæ, to m.in.: <SPAN CLASS=L>COMBOBOX, EDIT, LISTBOX, SCROLLBAR, STATIC</SPAN>. Ich przeznaczenia zapewne siê domyœlasz, a jeœli nie, to i tak zaraz wszystko omówimy.
</P>
<P>
Druga rzecz, któr¹ trzeba dorzuciæ do argumentów funkcji tworz¹cej kontrolkê to styl <SPAN CLASS=T>WS_CHILD</SPAN>, który oznacza, ¿e tworzone przez nas okienko (kontrolka) jest oknem potomnym dla g³ównego okna programu. Jeœli ju¿ jesteœmy przy stylach okna, to musisz pamiêtaæ, ¿e ka¿da kontrolka ma swój specyficzny zestaw stylów, wiêc nie wszystkie style odnosz¹ce siê do "zwyk³ego" okna dzia³aj¹ z kontrolkami (i vice versa). Szczegó³y omówimy w rozdzia³ach poœwiêconych konkretnym kontrolkom.
</P>

<H2>
Przyciski
</H2>

<P>
Jak siê rzek³o, nazwa klasy odpowiadaj¹cej za przyciski to <SPAN CLASS=L>BUTTON</SPAN>. Zestaw stylów specyficznych dla tej klasy zaczyna siê przedrostkiem <SPAN CLASS=L>BS_</SPAN>, ale w sumie nie potrzebujemy na razie ¿adnego z nich do szczêœcia. Stwórzmy sobie najprostszy z mo¿liwych przycisków. Najpierw deklaracja globalnego uchwytu (poza funkcj¹ WinMain):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND g_hPrzycisk;<BR>
</TD></TR>
</TABLE>

<P>
...i tworzymy (wewn¹trz WinMain):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_hPrzycisk = CreateWindowEx(<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>"BUTTON"</SPAN>, <SPAN CLASS=L>"Nasz przycisk"</SPAN>, WS_CHILD | WS_VISIBLE, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>30</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Kod z tego przyk³adu nale¿y wkleiæ tu¿ po instrukcji tworz¹cej okienko g³ówne. Jeœli program, do którego ten przyk³adowy fragment wklejasz, u¿ywa innej zmiennej przechowuj¹cej uchwyt gównego okna ni¿ <SPAN CLASS=T>hwnd</SPAN>, to oczywiœcie musisz to w tym fragmencie odpowiednio zmieniæ. To samo tyczy siê uchwytu programu (w moim przyk³adzie <SPAN CLASS=T>hInstance</SPAN>).
</P>

<P>
Mo¿liwoœci klasy <SPAN CLASS=L>BUTTON</SPAN> s¹ jednak znacznie wiêksze, ni¿ mog³oby siê na pierwszy rzut oka wydawaæ. Oprócz bowiem zwyk³ych przycisków, u¿ywaj¹c tej klasy mo¿emy jeszcze tworzyæ checkboxy, przyciski radiowe (czyli te okr¹g³e, z których tyko jeden w danym momencie mo¿e byæ wciœniêty), a nawet ramki grupuj¹ce ró¿nego rodzaju kontrolki:
</P>

<P ALIGN=CENTER><IMG SRC="../gfx/buttons.gif" ALT="Ró¿ne rodzaje kontrolek klasy BUTTON"></P>

<P>
Jak to wszystko uzyskaæ? To bardzo proste. Wystarczy do³¹czyæ odpowiedni styl - <SPAN CLASS=T>BS_CHECKBOX</span> dla checkboxa, <SPAN CLASS=T>BS_RADIOBUTTON</SPAN> dla przycisku radiowego, <SPAN CLASS=T>BS_GROUPBOX </span> dla ramki grupuj¹cej. Mo¿esz te¿ poeksperymentowaæ z innymi stylami, których opisy znajdziesz w MSDN. A oto przyk³ad tworzenia przycisku z innym stylem, tak na wszelki wypadek:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_hPrzycisk = CreateWindowEx(<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>"BUTTON"</SPAN>, <SPAN CLASS=L>"Ckeckbox"</SPAN>, WS_CHILD | WS_VISIBLE | BS_CHECKBOX, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>30</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Naciœniêcie naszego przycisku generuje komunikat <SPAN CLASS=T>WM_COMMAND</SPAN>, dziêki czemu mo¿emy przyciskowi przypisaæ jak¹œ akcjê, np. wyœwietlenie wiadomoœci. Wystarczy dodaæ obs³ugê komunikatu <SPAN CLASS=T>WM_COMMAND</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Nacisn¹³eœ przycisk!"</SPAN>, <SPAN CLASS=L>"Ha!"</SPAN>, MB_ICONINFORMATION);<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Tak siê jednak sk³ada, ¿e komunikat <SPAN CLASS=T>WM_COMMAND</SPAN> mo¿e zostaæ wygenerowany przez bardzo wiele ró¿nych kontrolek, np. przez menu albo toolbar, w dodatku jeœli mamy w naszej aplikacji kilka przycisków, to ka¿dy z nich oczywiœcie bêdzie generowa³  <SPAN CLASS=T>WM_COMMAND</SPAN>. Jak wiêc sprawdziæ, czy pochodzi on w³aœnie od przycisku, i to tego przycisku, który nas interesuje? Otó¿ musimy przyjrzeæ siê uwa¿niej argumentom naszej procedury okna. Szczególnie dwa z nich s¹ dla nas interesuj¹ce podczas pisania obs³ugi komunikatów - <SPAN CLASS=T>lParam</SPAN> i <SPAN CLASS=T>wParam</SPAN>. S¹ to dwie 32-bitowe liczby (przynajmniej w systemach od Windows 95 w górê), które zawieraj¹ ró¿ne rzeczy bardzo przydatne lub wrêcz niezbêdne podczas obs³ugiwania tych komunikatów. Dla ka¿dego komunikatu inna jest rola <SPAN CLASS=T>wParam</SPAN> i <SPAN CLASS=T>lParam</SPAN>. I tak na przyk³ad kiedy chcemy obs³u¿yæ <SPAN CLASS=T>WM_COMMAND</SPAN>, parametr <SPAN CLASS=T>lParam</SPAN> zawiera uchwyt kontrolki, która wygenerowa³a ten komunikat. Tego w³aœnie szukaliœmy! Teraz mo¿emy poprawiæ kod, obs³uguj¹cy klikniêcie na przycisku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>((HWND)lParam == g_hPrzycisk)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Nacisn¹³eœ przycisk!"</SPAN>, <SPAN CLASS=L>"Ha!"</SPAN>, MB_ICONINFORMATION);<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Wyjaœniæ nale¿a³o by dwie rzeczy. Po pierwsze, jeœli mamy porównywaæ wartoœæ  <SPAN CLASS=T>lParam</SPAN> z uchwytem okna (czyli kontrolki), to nale¿y <SPAN CLASS=T>lParam </SPAN> przekonwertowaæ do  <SPAN CLASS=T>HWND</SPAN>, inaczej kompilator siê zdenerwuje. Druga sprawa - nasz przycisk tworzyliœmy wewn¹trz funkcji <SPAN CLASS=T>WinMain</SPAN>, gdybyœmy w tym samym miejscu zadeklarowali uchwyt do tego przycisku, to nie mielibyœmy dostêpu do tego uchwytu w procedurze okna (u nas <SPAN CLASS=T>WndProc</SPAN>). Dlatego w³aœnie uchwyt ten jest u nas  zmienn¹ globaln¹ (na zewn¹trz wszystkich funkcji programu), co w tym przyk³adzie zaznaczyliœmy przez dodanie przedrostka  <SPAN CLASS=T>g_</SPAN> do nazwy zmiennej (przyjêcie takiej konwencji jest bardzo po¿ytecznym zwyczajem, polecam).
</P>

<P>
Tym oto sposobem mamy przycisk, i nawet przycisk ten dzia³a jak przycisk ;-). Skoro osi¹gnêliœmy tak zadowalaj¹ce rezultaty, pora na nastêpn¹ kontrolkê...
</P>

<H2>
Pola tekstowe
</H2>

<P>
Te fajne bia³e prostok¹ty, w które wpisuje siê tekst lub liczby, zw¹ siê czasami polami tekstowymi, po angielsku <SPAN CLASS=Inglisz>text boxes</SPAN>. Odpowiadaj¹ca im nazwa klasy to <SPAN CLASS=L>EDIT</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hText = CreateWindowEx(<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>20</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Zauwa¿, ¿e zamiast nazwy okna podaliœmy <SPAN CLASS=T>NULL</SPAN>. Dla przycisku dobrze by³o, kiedy mia³ on wyœwietlon¹ jak¹œ nazwê, bo pusty przycisk wygl¹da raczej podejrzanie ;-). Pole tekstowe czegoœ takiego nie potrzebuje, bo i tak nie ma gdzie wyœwietliæ takiej nazwy.
</P>
<P>
Zapewne nie bêdziesz specjalnie zachwycony efektem - otrzymaliœmy zwyk³y, p³aski jak decha prostok¹t, i tak dobrze, ¿e z ramk¹. Dorzuæmy wiêc rozszerzony styl <SPAN CLASS=T>WS_EX_CLIENTEDGE</SPAN> (pierwszy argument funkcji <SPAN CLASS=T>CreateWindowEx</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hText = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>20</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Teraz wszystko jest jak Pan Bóg przykaza³, aczkolwiek oprócz ma³ych pól tekstowych stosuje siê te¿ czasem wiêksze, w które biedny u¿ytkownik musi wpisywaæ ca³e wypracowania. W takich wielkich polach tekstowych jest miejsce na wiele linijek tekstu, wiêc musimy sprawiæ, ¿eby w miarê wpisywania go zdania by³y automatycznie ³amane i przenoszone do nastêpnego wiersza. Co wiêcej, w razie gdyby u¿ytkownika ponios³a wena twórcza, musimy zapewniæ mo¿liwoœæ przewijania naszego pola tekstowego. Tê pierwsz¹ cechê zapewni nam styl <SPAN CLASS=T>ES_MULTILINE</SPAN>, zaœ drug¹ - po³¹czenie <SPAN CLASS=T>ES_AUTOVSCROLL</SPAN> (mo¿liwoœæ przewijania zawartoœci w pionie) i <SPAN CLASS=T>WS_VSCROLL</SPAN> (dodanie pionowego paska przewijania). Zauwa¿, ¿e ten ostatni styl jest dostêpny dla wszystkich rodzajów okien, nie tylko dla pól tekstowych. W praktyce wyjdzie to tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hText = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>150</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Dziêki paru zaklêciom nasze pole siê stosownie powiêkszy³o, dodany zosta³ pasek pionowego przewijania (na razie bêdzie nieaktywny, dopóki nie wpiszemy do pola odpowiedniej iloœci tekstu), a nie mieszcz¹ce siê w danym wierszu wyrazy bêd¹ automatycznie przenoszone do nastêpnego. Bêdzie to wygl¹daæ mniej wiêcej tak:
</P>

<P ALIGN=CENTER><IMG SRC="../gfx/edit.gif" ALT="Pole tekstowe w ca³ej okaza³oœci"></P>

<P>
Teraz mi³a niespodzianka: jeœli klikniesz na naszym polu tekstowym, pojawi siê automatycznie menu kontekstowe, takie samo jak w wiêkszoœci "profesjonalnych" aplikacji, umo¿liwiaj¹ce kopiowanie, wycinanie i wklejanie tekstu ze schowka! Dzia³aj¹ te¿ standardowe skróty klawiszowe, jak np. Ctrl+C, a nawet cofanie ostatniego polecenia. Wystarczy jeszcze tylko rozszerzyæ nasze pole tekstowe na ca³e okno i mamy imitacjê Notatnika ;-).
</P>
<P>
Jeszcze tylko ma³e pytanie: jak wstawiæ lub pobraæ tekst z pola w kodzie programu? Mo¿emy u¿yæ funkcji <SPAN CLASS=T>SetWindowText</SPAN> oraz <SPAN CLASS=T>GetWindowText</SPAN>. Na pocz¹tek ta pierwsza - wklejamy j¹ tu¿ po kodzie tworz¹cym nasze pole tekstowe:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SetWindowText(hText, <SPAN CLASS=L>"Wpisz tu coœ"</SPAN>);
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>GetWindowText</SPAN> wymaga oczywiœcie podania adresu bufora, do którego przekopiowany zostanie tekst z naszego pola. Bufor ten musi byæ odpowiednio du¿y, ¿eby pomieœci³ ca³y tekst zawarty w polu. Rozmiar bufora, czyli d³ugoœæ tekstu, nale¿y podaæ jako ostatni argument dla funkcji <SPAN CLASS=T>GetWindowText</SPAN>. D³ugoœæ tekstu z pola obliczymy przy pomocy funkcji <SPAN CLASS=T>GetWindowTextLength</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD dlugosc = GetWindowTextLength(hText);<BR>
LPSTR Bufor = (LPSTR)GlobalAlloc(GPTR, dlugosc + 1);<BR>
GetWindowText(hText, Bufor, dlugosc + 1);<BR>
</TD></TR>
</TABLE>

<P>
Tekst powêdruje tym samym do stringa <SPAN CLASS=T>Bufor</SPAN>, którego bêdziemy mogli sobie u¿ywaæ do woli w ró¿nych niecnych celach :-). Przy okazji pokazaliœmy, jak alokowaæ dynamicznie pamiêæ w Windows (funkcja GlobalAlloc). W szczegó³y alokacji zag³êbimy siê przy innej okazji ;-). Na razie jednak musimy wiedzieæ, w jaki sposób zwolniæ pamiêæ zajmowan¹ przez bufor, gdy ten nie bêdzie ju¿ potrzebny:
<P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
GlobalFree(Bufor);
</TD></TR>
</TABLE>

<H2>
Listy
</H2>

<P>
Chodzi oczywiœcie o kontrolki typu <SPAN CLASS=Wazne>List Box</SPAN>, a nie ¿adn¹ tam pocztê ;-). Tworzymy je tak samo, jak i pola tekstowe:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hListBox = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"LISTBOX"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>5</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>200</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
No i tak samo jak pola tekstowe wygl¹daj¹ :-/. Przynajmniej dopóki nie dodamy do nich ¿adnych elementów. ¯eby cokolwiek dodaæ do naszej listy, musimy wys³aæ odpowiedni komunikat do naszego okienka-kontrolki, na pocz¹tek najlepszy bêdzie <SPAN CLASS=T>LB_ADDSTRING</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hListBox, LB_ADDSTRING, <SPAN CLASS=L>0</SPAN>, (LPARAM)<SPAN CLASS=L>"Element 1"</SPAN>);<BR>
SendMessage(hListBox, LB_ADDSTRING, <SPAN CLASS=L>0</SPAN>, (LPARAM)<SPAN CLASS=L>"Element 2"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Zwróæ uwagê na jawn¹ konwersjê ostatniego argumentu (wskaŸnika do stringa) do typu <SPAN CLASS=T>LPARAM</SPAN> - jest ona konieczna, jeœli nie chcemy ogl¹daæ komunikatów o b³êdach kompilacji. Jeœli chodzi o funkcjê <SPAN CLASS=T>SendMessage</SPAN>, najlepiej jest stosowaæ takie konwersje w ka¿dym przypadku. Tymczasem efekt naszych wysi³ków bêdzie nastêpuj¹cy:
</P>

<P ALIGN=CENTER><IMG SRC="../gfx/listbox.gif" ALT="Dwa elementy na naszej czarnej liœcie ;-)"></P>

<P>
O listach nie bêdê siê zbytnio rozpisywa³, bo u¿ywa siê ich stosunkowo rzadko. Generalnie ca³a obs³uga list odbywa siê przy pomocy podobnych komunikatów, jak ten powy¿ej do dodawania elementów. Pe³n¹ listê tych komunikatów mo¿esz znaleŸæ w MSDN.
</P>

<H2>
Listy rozwijalne, czyli ComboBox
</H2>

<P>
Znacznie czêœciej wykorzystywanym rodzajem listy jest tzw. <SPAN CLASS=Wazne>Combo Box</SPAN>. Nazwa ta nie oznacza, ¿e jej twórcy byli fanami Mortal Kombat, tylko ¿e kontrolka ta jest kombajnem, ³¹cz¹cym w sobie funkcje listy i pola tekstowego. Intuicyjny (zwawa³oby siê) sposób jego utworzenia da doœæ dziwny rezultat:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hCombo = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"COMBOBOX"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>200</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Powsta³o nam ma³e pole tekstowe, a pod spodem - lista... Kto widzia³ takie dziwad³o w profesjonalnych aplikacjach!? Konia z rzêdem takiemu. My tu nie bêdziemy wiochy robiæ i zmajstrujemy sobie prawdziwego, cywilizowanego ComboBoxa. A wystarczy tylko dodaæ odpowiedni styl, mianowicie <SPAN CLASS=T>CBS_DROPDOWN</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hCombo = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"COMBOBOX"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER | CBS_DROPDOWN, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>200</SPAN>, hwnd, NULL, hInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Nooo, teraz to rozumiemy! Nowe Combo wygl¹da perfekcyjnie:
</P>

<P ALIGN=CENTER><IMG SRC="../gfx/combo.gif" ALT="Cywilizowane Combo ;-)"></P>

<P>
Warto zwróciæ uwagê na ma³¹ pu³apkê, w któr¹ wpada niejeden pocz¹tkuj¹cy amator ComboBoxów. Otó¿ jeœli zrobimy tak¹ kontrolkê ze stylem <SPAN CLASS=T>CBS_DROPDOWN</SPAN>, to parametr okreœlaj¹cy wysokoœæ okna-kotrolki (w naszym przypadku równy <SPAN CLASS=L>200</SPAN>) nie okreœla rozmiaru pola tekstowego ze strza³k¹, tylko CA£EGO ComboBoxa, razem z list¹ po rozwiniêciu. Natomiast wysokoœæ pola tekstowego jest domyœlna i zale¿y od ustawieñ systemowych (mo¿na j¹ zmieniæ w Panelu Sterowania, tylko po co). Oczywiœcie jeœli dodamy do listy ComboBoxa wiêcej elementów, ni¿ mog³oby siê zmieœciæ w podanej przez nas wysokoœci, to pojawi siê pasek przesuwania.
</P>

<P>
W³aœnie, dodawanie. Wygl¹da ono analogicznie, jak w przypadku list - wysy³amy komunikat <SPAN CLASS=T>CB_ADDSTRING</SPAN> (ró¿nica to ta jedna literka w nazwie ;-)):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
SendMessage(hCombo, CB_ADDSTRING, <SPAN CLASS=L>0</SPAN>, (LPARAM)<SPAN CLASS=L>"Element 1"</SPAN>);<BR>
SendMessage(hCombo, CB_ADDSTRING, <SPAN CLASS=L>0</SPAN>, (LPARAM)<SPAN CLASS=L>"Element 2"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Na koniec powiem jeszcze, jak zrobiæ prostsz¹ wersjê ComboBoxa. Jeœli dodamy styl <SPAN CLASS=T>CBS_DROPDOWNLIST</SPAN> zamiast <SPAN CLASS=T>CBS_DROPDOWN</SPAN>, to otrzymamy ComboBox, w którego polu tekstowym nie mo¿na ju¿ nic wpisaæ, za to pojawia siê tam aktualnie wybrany element. Postaæ taka jest moim zdaniem bardziej przyjazna zarówno dla u¿ytkownika, jak i programisty, wiêc polecam ;-).
</P>

<H2>
Paski przesuwu
</H2>

<P>
...Czyli scrollbary. Wiecie o co biega, ju¿ je zreszt¹ stosowaliœmy. Wtedy jednak by³y one integralnymi czêœciami innych kontrolek, a mo¿emy stworzyæ oddzielny pasek i wykorzystaæ go w sobie tylko wiadomych celach ;-). Samo tworzenie wygl¹da tak samo, jak w przypadku wczeœniej opisanych kontrolek (nazwa klasy: <SPAN CLASS=L>SCROLLBAR</SPAN>), z tym, ¿e domyœlnie tworzony jest pasek poziomy, natomiast stworzenie paska pionowego trzeba wymusiæ, dodaj¹c styl <SPAN CLASS=L>SBS_VERT</SPAN>. Wygl¹da toto w ten sposób:
</P>
<P align=center>
<img src="../gfx/scroll.gif" alt="Paski przesuwu jako samodzielne kontrolki">
</p>
<P>
Obs³uga pasków, tak samo jak i innych kontrolek, odbywa siê przy pomocy odpowiednich komunikatów, wiêc nie bêdê siê nad tym rozwodzi³ - wszystko co trzeba znajdziesz w MSDN, a kiedyœ mo¿e spiszê wszelkie niezbêdne komunikaty i wrzucê na stronkê.
</P>

<H2>
Statyczne elementy
</H2>

<P>
Oprócz kontrolek interaktywnych, które u¿ytkownik mo¿e wciskaæ, przesuwaæ, klikaæ i na inne sposoby molestowaæ, istniej¹ te¿ kontrolki statyczne - tych to ¿adn¹ si³¹ nie ruszysz ;-). Wykorzystuje siê je, po uaktywnieniu odpowiednich stylów, jako etykiety np. dla pól tekstowych (¿eby user wiedzia³, co w nie wpisywaæ), jako nieruchome obrazki, linie rozdzielaj¹ce poszczególne kontrolki, ramki itp. Leniwa ze mnie bestia, tote¿ pozostawiam ci ten rodzaj kontrolki do w³asnych eksperymentów. Nazwa klasy to <SPAN CLASS=L>STATIC</SPAN>.
</P>

<H2>
Identyfikowanie kontrolek w komunikatach
</H2>

<P>
Wróæmy na moment do naszego przycisku. Kiedy go nacisnêliœmy, wysy³a³ on komunikat <SPAN CLASS=T>WM_COMMAND</SPAN>, dziêki czemu mogliœmy przypisaæ przyciskowi jakieœ dzia³anie, i nawet to zrobiliœmy - przyciœniêcie wywo³ywa³o pojawienie siê krótkiej wiadomoœci. Nauczyliœmy siê te¿ rozró¿niaæ komunikaty pochodz¹ce od innych kontrolek oraz komunikaty od "zwyk³ych" przycisków. Wszystko fajnie a¿ do momentu (o którym te¿ ju¿ zreszt¹ napomknêliœmy), kiedy dorzucimy drugi przycisk - wtedy którykolwiek przycisk zawsze bêdzie powodowa³ wyœwietlenie wiadomoœci. Jak sprawdziæ, który przycisk z tych dwóch zosta³ naciœniêty?
</P>
<P>
Na szczêœcie komunikat <SPAN CLASS=T>WM_COMMAND</SPAN> nie przybywa do nas z go³ymi rêkami, a przynosi ze sob¹ argumencik <SPAN CLASS=T>wParam</SPAN>, który zawiera <SPAN CLASS=Wazne>identyfikator</SPAN> kontrolki, czyli unikaln¹, globaln¹ liczbê, przypisan¹ danej kontrolce. Dziêki temu mo¿emy wstawiæ instrukcjê <SPAN CLASS=K>switch</SPAN> i dok³adnie obs³u¿yæ komunikat <SPAN CLASS=T>WM_COMMAND</SPAN> bez wzglêdu na to, ile kontrolek tej samej klasy mog³o go wys³aæ.
</P>
<P>
Jak nadaæ kontrolce identyfikator? Robimy to na etapie tworzenia kontrolki funkcj¹ <SPAN CLASS=T>CreateWindowEx</SPAN>. Jak wspomnieliœmy w czêœci kursu poœwiêconej tworzeniu g³ównego okna, funkcja ta przyjmuje jako argument m.in. uchwyt do menu. W naszym oknie menu jeszcze nie tworzyliœmy, wiêc daliœmy tam <SPAN CLASS=T>NULL</SPAN>. Jeœli jednak tworzymy nie takie zwyk³e okienko, lecz kontrolkê, uchwyt do menu pe³ni rolê <SPAN CLASS=Wazne>identyfikatora</span>. Mówi¹c obrazowo: definiujemy jakieœ sta³e, najlepiej przy pomocy dyrektywy <SPAN CLASS=C>#define</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#define ID_PRZYCISK1 501<BR>
#define ID_PRZYCISK2 502<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
A nastêpnie tworzymy kontrolki, przypisuj¹c im identyfikatory tam, gdzie funkcja <SPAN CLASS=T>CreateWindowEx</SPAN> spodziewa siê podania uchwytów do menu (dla niepoznaki konwertujemy go do <SPAN CLASS=T>HMENU</SPAN> ;-) ):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HWND hButton1 = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"BUTTON"</SPAN>, <SPAN CLASS=L>"Pierwszy"</SPAN>, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>30</SPAN>, hwnd, (HMENU)ID_PRZYCISK1, hInstance, NULL),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hButton2 = CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"BUTTON"</SPAN>, <SPAN CLASS=L>"Drugi"</SPAN>, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50</SPAN>, <SPAN CLASS=L>100</SPAN>, <SPAN CLASS=L>150</SPAN>, <SPAN CLASS=L>30</SPAN>, hwnd, (HMENU)ID_PRZYCISK2, hInstance, NULL);
</TD></TR>
</TABLE>

<P>
Po czym komplikujemy troszkê obs³ugê komunikatu <SPAN CLASS=T>WM_COMMAND</SPAN> tak, ¿eby uwzglêdnia³ istnienie kilku kontrolek jednoczeœnie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_COMMAND:<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(wParam)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> ID_PRZYCISK1:<BR>
&nbsp;&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wcisn¹³eœ przycisk 1"</SPAN>, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> ID_PRZYCISK2:<BR>
&nbsp;&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wcisn¹³eœ przycisk 2"</SPAN>, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Zrobi³eœ coœ innego ;-)"</SPAN>, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Zauwa¿, ¿e "zapomnieliœmy" sprawdziæ, czy komunikat faktycznie pochodzi od przycisku, czy mo¿e od zupe³nie innego rodzaju kontrolki - by³a ju¿ o tym mowa wy¿ej. Tutaj jednak takie rozró¿nienie  nie jest nam potrzebne, za to zaciemni³oby nieco sytuacjê ;-).
</P>
<P>
Jeœli wklei³eœ ca³y ten przyk³ad i skompilowa³eœ, to byæ mo¿e zauwa¿y³eœ, ¿e dodatkowo zmieni³ siê wygl¹d przycisków. Fajne, nie? ;-) To oczywiœcie zas³uga stylu <SPAN CLASS=T>WS_EX_CLIENTEDGE</SPAN>, którego wczeœniej nie stosowaliœmy do przycisków (ale oczywiœcie nie jest to zabronione ;-)).
</P>

<h2>
Stan przycisków
</h2>

<P>
Skoro ju¿ jesteœmy przy identyfikatorach, to nauczmy siê od razu, w jaki sposób ustawiæ b¹dŸ usun¹æ "fajeczkê" z checkboxów (do tej pory nie mogliœmy tego zrobiæ). S³u¿y do tego funkcja CheckDlgButton, jej u¿ycie wygl¹da tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CheckDlgButton(hwnd, ID_CHECKBOX1, BST_CHECKED); <span class=C>//ustaw "fajeczkê"</span><br>
CheckDlgButton(hwnd, ID_CHECKBOX1, BST_UNCHECKED); <span class=C>//usuñ "fajeczkê"</span><br>
</TD></TR>
</TABLE>

<P>
Jeœli nie dysponujemy akurat identyfikatorem kontrolki, a mamy tylko do niej uchwyt, mo¿emy uzyskaæ identyfikator stosuj¹c GetDlgCtrlID:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<span class=K>int</span> ID_CHECKBOX1 = GetDlgCtrlID(hCheckBox1);
</TD></TR>
</TABLE>

<P>
Musimy tylko pamiêtaæ o tym, by w ogóle ten identyfikator zosta³ kontrolce nadany podczas jej tworzenia. A teraz sprawdŸmy, czy checkbox jest zafajkowany, czy nie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
BOOL bChecked = (IsDlgButtonChecked(hwnd, ID_CHECKBOX1) == BST_CHECKED);
</TD></TR>
</TABLE>

<P>
Funkcjê tê mo¿emy stosowaæ do wszystkich rodzajów przycisków, nie tylko do checkboxów. Warto wiedzieæ, ¿e oprócz <span class=T>BST_CHECKED</span> i <span class=T>BST_UNCHECKED</span> mo¿e ona jeszcze zwróciæ <span class=T>BST_INDETERMINATE</span> (czyli stan nieokreœlony) lub <span class=L>0</spaN> (co oznacza, ¿e przycisk nie posiada ¿adnego ze stylów, które umo¿liwia³yby mu bycie w jednym z trzech wymienionych stanów).
</P>

<P>
Przyciski radiowe zwykle wystêpuj¹ w grupie, wiêc jeœli jeden ma byæ zaznaczony, to pozosta³e nale¿y odznaczyæ. Dlatego w tym przypadku u¿ycie <span class=T>CheckDlgButton</span> nie wystarcza i nale¿y zastosowaæ inn¹ funkcjê - <span class=T>CheckRadioButton</span>. Jeœli na przyk³ad mamy grupê siedmiu przycisków o identyfikatorach od <span class=T>ID_RADIO1</span> do <span class=T>ID_RADIO7</span>, to w celu zaznaczenia przycisku z tej grupy o identyfikatorze <span class=T>ID_RADIO3</span> piszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CheckRadioButton(hwnd, ID_RADIO1, ID_RADIO7, ID_RADIO3);
</TD></TR>
</TABLE>

<P>
Dziêki temu mamy pewnoœæ, ¿e jeden w³aœciwy przycisk bêdzie zaznaczony, a pozosta³e z tej grupy - nie :-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="api1.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="apievnt.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</HTML>