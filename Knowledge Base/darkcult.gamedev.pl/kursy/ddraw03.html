<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Bezpoœredni dostêp do powierzchni</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw02.html">&lt;&lt; Animacja</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw04.html"> Utrata powierzchni &gt;&gt;</A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>Bezpoœredni dostêp do powierzchni</h2>

<P>
Do tej pory korzystaj¹c z DirectDraw g³ównie blitowaliœmy na ekran gotowe bitmapy. Jeœli chcieliœmy narysowaæ coœ "rêcznie" b¹dŸ wypisaæ jakiœ tekst, musieliœmy siê uciekaæ do takiej sztuczki: pobieraliœmy uchwyt kontekstu powierzchni i wykorzystywaliœmy funkcje WinAPI do rysowania po niej. Takie rozwi¹zanie mia³o dwie powa¿ne wady: by³o arcyniewygodne (te wszelkie pêdzle, pióra, pobieranie i zwalnianie zasobów... brrr) oraz zbyt powolne.
</P>
<P>
Nasuwa siê zatem pytanie: czy nie mo¿na by po prostu dostaæ dostêp do miejsca, gdzie przechowywane s¹ "surowe" dane o pikselach? To niew¹tpliwie by³aby najszybsza metoda rysowania po powierzchni, a zarazem niezbyt skomplikowana, co doskonale wiedz¹ ludzie, zaczynaj¹cy sw¹ programistyczn¹ karierê jeszcze pod DOS-em, gdzie o ¿adnych uchwytach, kontekstach, pêdzlach i innych g³upotach nie by³o mowy. OdpowiedŸ na pytanie brzmi: tak!
</P>
<P>
Naszym zadaniem bêdzie narysowanie kó³eczka, w którym barwy bêd¹ p³ynnie przechodziæ miêdzy ró¿nymi wartoœciami. Robliœmy ju¿ coœ takiego w kursie WinAPI. Metoda, która zwraca nam wskaŸnik do pikseli danej powierzchni, nazywa siê <SPAN CLASS=T>Lock</SPAN>. W najprostszej mo¿liwej postaci jej wywo³anie wymaga podania adresu struktury typu <SPAN CLASS=T>DDSURFACEDESC</SPAN>, któr¹ to strukturê funkcja <SPAN CLASS=T>Lock</SPAN> wype³ni niezbêdnymi (i nie tylko ;-)) danymi. Strukturê tê musimy najpierw odpowiednio przygotowaæ, tj. wyzerowaæ jej pola oraz wpisaæ rozmiar struktury do pola <SPAN CLASS=T>dwSize</SPAN>. Oczywiœcie pomijam takie pierdo³ki, jak tworzenie g³ównego obiektu DD oraz powierzchni, gdy¿ to wszystko masz ju¿ w ma³ym palcu (prawda? ;-)). Zaczynamy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DDSURFACEDESC ddsd;<BR>
ZeroMemory(&ddsd, <SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC));<BR>
ddsd.dwSize = <SPAN CLASS=K>sizeof</SPAN>(DDSURFACEDESC);<BR>
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy ju¿ zablokowaæ nasz¹ powierzchniê funkcj¹ <SPAN CLASS=T>Lock</SPAN>. S³owo "zablokowaæ" nie jest bynajmniej przypadkowe; od momentu kiedy to zrobimy, a¿ do wywo³ania funkcji <SPAN CLASS=T>Unlock</SPAN> (która, jak siê domyœlamy, odblokowuje powierzchniê) na powierzchni ¿aden inny proces nie mo¿e nic narysowaæ. Wyjaœnienia wymaga³aby jeszcze mo¿e flaga <SPAN CLASS=T>DDLOCK_WAIT</SPAN>, któr¹ podajemy jako trzeci argument; oznacza ona, ¿e w razie gdyby w momencie wywo³ania <SPAN CLASS=T>Lock</SPAN> powierzchnia by³a czymœ zajêta (np. blitowaniem grafiki), to funkcja <SPAN CLASS=T>Lock</SPAN> ma zaczekaæ, a¿ powierzchnia zakoñczy swoj¹ poprzedni¹ "misjê". W przeciwnym wypadku <SPAN CLASS=T>Lock</SPAN> natychmiast zwróci kod b³êdu.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HRESULT ret = lpPowierznia->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(ret != DD_OK) <SPAN CLASS=K>return</SPAN> FALSE;<BR>
</TD></TR>
</TABLE>

<P>
Gotowe, powierzchnia zablokowana (chyba, ¿e funkcja <SPAN CLASS=T>Lock</SPAN> zwróci³a nam coœ innego, ni¿ <SPAN CLASS=T>DD_OK</SPAN>, co staæ siê nie powinno). Gdzie zatem nasz wskaŸnik do pikseli? Jest on ukryty w strukturze <SPAN CLASS=T>ddsd</SPAN>, jak nietrudno siê domyœliæ. Nazwa jego kryjówki to <SPAN CLASS=T>lpSurface</SPAN>. Niestety, wskaŸnik ten wskazuje na tablicê jednowymiarow¹, a co za tym idzie - bêdziemy musieli zastosowaæ pewn¹ formu³ê matematyczn¹ (na szczêœcie niezbyt skomplikowan¹), aby dostaæ siê do konkretnego piksela. Chodzi mianowicie o odwzorowanie przestrzeni dwuwymiarowej (jak¹ jest ekran oraz wszelkie powierzchnie pozaekranowe) na jednowymiarow¹ (tablica z danymi pikseli). Jeœli chcemy dobraæ siê do piksela o wspó³rzêdnych <SPAN CLASS=T>(x,y)</SPAN>, nale¿y pomno¿yæ wartoœæ <SPAN CLASS=T>dwWidth</SPAN> (liczba pikseli w ka¿dej linii, czyli szerokoœæ linii) przez numer linii (<SPAN CLASS=T>y</SPAN>) i dodaæ numer kolumny (<SPAN CLASS=T>x</SPAN>). Tak wiêc instrukcja, ustawiaj¹ca piksel o takich wspó³rzêdnych na kolor wygl¹daæ mo¿e jakoœ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
((DWORD*)ddsd.lpSurface)[ddsd.dwWidth * y + x] = k;<BR>
</TD></TR>
</TABLE>

<P>
WskaŸnik <SPAN CLASS=T>lpSurface</SPAN> jest typu <SPAN CLASS=K>void*</SPAN>, tak wiêc przed u¿yciem musimy go przekonwertowaæ. Jeœli za³o¿ymy, ¿e operujemy na kolorze 32-bitowym, to powinniœmy przekonwertowaæ ten wskaŸnik na wskaŸnik do wartoœci 32-bitowej w³aœnie, czyli <SPAN CLASS=T>DWORD*</SPAN>. Maj¹c gotowy wskaŸnik, dysponujemy zarazem tablic¹ - tego chyba ju¿ nie muszê t³umaczyæ. Teraz pozostaje tylko zastosowaæ omówiony wy¿ej wzór i ju¿ mo¿emy rysowaæ nasze kolorowe kó³ko:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const</SPAN> WORD sx = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. x</SPAN><BR>
<SPAN CLASS=K>const</SPAN> WORD sy = <SPAN CLASS=L>100</SPAN>; <SPAN CLASS=C>// œrodek ko³a - wsp. y</SPAN><BR>
<SPAN CLASS=K>const</SPAN> WORD r = <SPAN CLASS=L>100</SPAN>;  <SPAN CLASS=C>// promieñ ko³a</SPAN><BR>
<BR>
<SPAN CLASS=K>for</SPAN>(WORD y=<SPAN CLASS=L>0</SPAN>; y&lt;<SPAN CLASS=L>200</SPAN>; ++y)<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(WORD x=<SPAN CLASS=L>0</SPAN>; x&lt;<SPAN CLASS=L>200</SPAN>; ++x)<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>( (x-sx)*(x-sx)+(y-sy)*(y-sy) <= r*r )<BR>
&nbsp;&nbsp;&nbsp;((DWORD*)ddsd.lpSurface)[ddsd.dwWidth * y + x] = Kolor32(<SPAN CLASS=L>255</SPAN>-x, y, <SPAN CLASS=L>255</SPAN>-y);<BR>
</TD></TR>
</TABLE>

<P>
Do "zmontowania" odpowiedniej wartoœci koloru u¿yliœmy sobie funkcji <SPAN CLASS=T>Kolor32</SPAN> (lub <SPAN CLASS=T>Kolor16</SPAN> dla trybu 16-bitowego). Funkcjê tê omówiliœmy sobie w miarê dok³adnie w poprzedniej czêœci kursu DirectDraw, wiêc nie bêdziemy siê powtarzaæ.
</P>
<P>
Jak ju¿ wspomnia³em, nasza powierzchnia jest teraz zablokowana i nale¿y u¿yæ <SPAN CLASS=T>Unlock</SPAN>, ¿eby znów przywróciæ j¹ do "normalnoœci":
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpPowierzchnia->Unlock(NULL);<BR>
</TD></TR>
</TABLE>

<P>
Pozosta³o nam tylko wrzucenie wyniku na ekran (o ile do tej pory rysowaliœmy na powierzchni pozaekranowej, bo równie dobrze moglibyœmy rysowaæ od razu po g³ównej powierzchni ekranu). Tak te¿ czynimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
lpEkran->BltFast(<SPAN CLASS=L>100,100</SPAN>,lpPowierzchnia,NULL, DDBLTFAST_WAIT|DDBLTFAST_NOCOLORKEY);
</TD></TR>
</TABLE>

<P>
Oczywiœcie jeœli stworzy³eœ sobie ³añcuch powierzchni, to zamiast blitowaæ, mo¿esz równie¿ przerzuciæ bufory funkcj¹ <SPAN CLASS=T>Flip</SPAN>. Jeœli niczego nie skaszani³eœ po drodze, otrzymujesz takie cuœ:
</P>

<p align=center>
<img src="../gfx/circle.jpg" alt="Nawet fajne kó³ko, nie?">
</p>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw02.html">&lt;&lt; Animacja</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw04.html"> Utrata powierzchni &gt;&gt;</A>
</TD>
</TR>
</TABLE>

</HTML>