<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05b.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Klasy, sk³adowe publiczne i prywatne klas
</h2>

<P>
Dokonajmy teraz ma³ej zmiany w naszej strukturze Gracz z poprzedniego odcinka kursu...
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;&nbsp;Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;&nbsp;Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
&nbsp;}<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Zmieniliœmy tylko jedn¹ rzecz - s³owo struct zast¹piliœmy przez class. Z punktu widzenia kompilatora te dwa s³owa ró¿ni¹ siê bardzo niewiele. Umownie struct oznacza "prost¹" klasê, która sk³ada siê tylko ze zmiennych, podczas gdy class jest ju¿ klas¹ w pe³nym tego s³owa znaczeniu, zawieraj¹c¹ równie¿ funkcje sk³adowe (oraz wiele innych ciekawych rzeczy, o których jednak póŸniej). Natomiast te niewielkie ró¿nice z punktu widzenia kompilatora za moment sobie wychwycimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz Gracz1;<BR>
Gracz1.Resetuj();<BR>
</TD></TR>
</TABLE>

<P>
Jeszcze przed chwil¹ taki kod dzia³a³ nam idealnie, a teraz zamieniliœmy tylko <SPAN CLASS=K>struct</SPAN> na <SPAN CLASS=K>class</SPAN> i nagle kompilator siê buntuje, wciskaj¹c nam jakiœ tekst o prywatnoœci... Co mu odbi³o? Zanim sobie wszystko wyjaœnimy, poprawmy deklaracjê naszej klasy <SPAN CLASS=T>Gracz</SPAN>, tak aby powy¿sze dwie linijki da³o siê znów poprawnie skompilowaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>
public:<BR>
&nbsp;void</SPAN> Resetuj()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;&nbsp;Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;&nbsp;Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
&nbsp;}<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Dodaliœmy dwie specjalne etykiety, które zarazem ustali³y nam podzia³ sk³adowych na czêœæ publiczn¹ oraz prywatn¹. Co to oznacza? Sk³adowe (zmienne i funkcje) <SPAN CLASS=Wazne>publiczne</SPAN> s¹ dostêpne zarówno "wewn¹trz" struktury (czyli w jej funkcjach sk³adowych - metodach), natomiast <SPAN CLASS=Wazne>prywatne</SPAN> - tylko "wewn¹trz" (w metodach). Próba odwo³ania siê do zmiennej (lub metody) prywatnej danej klasy z miejsca innego, ni¿ "wnêtrze" tej klasy skoñczy siê takim w³aœnie komunikatem, jak przed chwil¹ kompilacja tamtego b³êdnego przyk³adu.
</P>
<P>
Jeœli nie ustalimy sami, które sk³adowe s¹ prywatne, a które publiczne, kompilator zrobi to za nas. Jeœli nasza klasa zosta³a zadeklarowana s³owem <SPAN CLASS=K>struct</SPAN>, to wszystkie sk³adowe nie objête etykietami <SPAN CLASS=K>public</SPAN> lub <SPAN CLASS=K>private</SPAN> zostan¹ potraktowane domyœlnie jako <SPAN CLASS=K>public</SPAN>. Z kolei jeœli klasa by³a zadeklarowana s³owem <SPAN CLASS=K>class</SPAN>, to wszystkie sk³adowe nie objête etykietami <SPAN CLASS=K>public</SPAN> ani <SPAN CLASS=K>private</SPAN> potraktowane zostan¹ jako <SPAN CLASS=K>private</SPAN>. Teraz ju¿ wiesz, czemu wywo³anie metody <SPAN CLASS=T>Resetuj</SPAN> najpierw dzia³a³o, a póŸniej nie?
</P>
<P>
W tym miejscu warto zadaæ sobie bardzo wa¿ne pytanie i wbrew pozorom nie bêdzie to nic w stylu byæ albo nie byæ ;-). Otó¿ spytajmy, po co w³aœciwie te sk³adowe prywatne? Czy nie mog³oby wszystko po prostu byæ publiczne, tak aby dostêp do wszystkich sk³adowych by³ ³atwy i klarowny? Owszem, mog³oby. Ale znowu¿ - to nie by³oby programowanie obiektowe... Oto bowiem jednym z za³o¿eñ takiego programowania jest to, ¿e ka¿da klasa winna posiadaæ swój interfejs (sk³adowe, najlepiej same metody, które "widzi" osoba wykorzystuj¹ca nasz¹ klasê) oraz implementacjê (w³aœciwy mechanizm, dziêki któremu klasa dzia³a zgodnie z przeznaczeniem).
</P>
<P>
Ale po co, po co...? OdpowiedŸ jest bardzo prosta. Czy aby korzystaæ na przyk³ad z zegarka, musisz wiedzieæ, w jaki dok³adnie sposób dzia³aj¹ te wszystkie œmieszne kó³eczka i sprê¿ynki w œrodku? Oczywiœcie, ¿e nie musisz - dla ciebie wa¿ne s¹ tylko wskazówki i ewentualnie cyferka z dzisiejsz¹ dat¹. Ba, wskazane by³oby nawet, ¿ebyœ w ogóle nie zagl¹da³ do œrodka, bo a nu¿ wsadzaj¹c tam swojego niezgrabnego palucha coœ popsujesz w tym precyzyjnym wynalazku ;-). Dok³adnie tak samo jest z klasami - osoba korzystaj¹ca z nich wprawdzie te¿ jest programist¹, ale byæ mo¿e o znacznie mniejszym doœwiadczeniu, ni¿ nasze (:D). Dlatego na wszelki wypadek nie powinniœmy jej dawaæ wgl¹du w szczegó³y implementacyjne naszej klasy, a¿eby przypadkiem ta osoba czegoœ w niej nie spsu³a ;-).
</P>
<P>
Ale¿ siê rozgadaliœmy... Pora na trochê kodu. Dochodzimy do wniosku, ¿e programista, który dostanie do rêki nasz¹ wspania³¹ klasê <SPAN CLASS=T>Gracz</SPAN>, nie powinien wprawdzie mieæ mo¿liwoœci modyfikacji zmiennych sk³adowych tej klasy, ale za to przyda³oby siê mieæ mo¿liwoœæ ich odczytania - choæby po to, by móc wyœwietlaæ na ekranie, ile gracz ma jeszcze pocisków, energii itp. Jak to zrobimy, skoro te wszystkie zmienne s¹ teraz prywatne? Pamiêtamy, ¿e zmienne prywatne mog¹ byæ wykorzystane tylko w metodach, tak wiêc... napiszmy sobie nowe metody! Ich zadaniem bêdzie tylko i wy³¹cznie "wydobycie na œwiat³o dzienne" wartoœci poszczególnych zmiennych sk³adowych:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Resetuj()<BR>
&nbsp;{<BR>
&nbsp;&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;&nbsp;Amunicja =<SPAN CLASS=L> 50</SPAN>;<BR>
&nbsp;&nbsp;Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> GetBron() &nbsp;&nbsp;&nbsp;&nbsp;{ <SPAN CLASS=K>return</SPAN> Bron;     }<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> GetAmunicja() { <SPAN CLASS=K>return</SPAN> Amunicja; }<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> GetPancerz()&nbsp; { <SPAN CLASS=K>return</SPAN> Pancerz;  }<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> GetZdrowie()&nbsp; { <SPAN CLASS=K>return</SPAN> Zdrowie;  }<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> GetZycia()&nbsp;&nbsp;&nbsp; { <SPAN CLASS=K>return</SPAN> Zycia;    }<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Teraz mo¿emy wyœwietliæ wartoœæ dowolnej zmiennej sk³adowej obietu typu <SPAN CLASS=T>Gracz</SPAN> tak¿e na zewn¹trz klasy <SPAN CLASS=T>Gracz</SPAN>, a jednoczeœnie nie mo¿emy stamt¹d zmieniæ tej wartoœci:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz g;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Zostalo amunicji: "</SPAN> &lt;&lt; g.GetAmunicja() &lt;&lt; endl;<BR>
<SPAN CLASS=C>//g.Amunicja = 0; //niedozwolone</SPAN>
</TD></TR>
</TABLE>

<P>
Metody tego typu - zwracaj¹ce wartoœæ danej sk³adowej klasy - nazywaj¹ siê <SPAN CLASS=Wazne>akcesorami</SPAN>. 
</P>

<h2>
Deklaracja a definicja klasy
</h2>

<P>
Tworzenie metod (funkcji sk³adowych) w taki sposób jak powy¿ej wydaje siê bardzo wygodne - nie musimy pisaæ prototypu. Jednak w przypadku wiêkszych klas, maj¹cych po piêæ, dziesiêæ i wiêcej metod zrobi³by nam siê wewn¹trz wielki bajzel. Tego oczywiœcie nie chcemy. Dlatego wracamy do naszych starych i niezbyt lubianych zwyczajów, czyli zostawiamy wewn¹trz klasy sam prototyp, natomiast w³aœciwe cia³o funkcji napiszemy sobie póŸniej:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR><SPAN CLASS=K>
private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Resetuj();<BR>
&nbsp;<SPAN CLASS=C>//pomijam deklaracje akcesorów...</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Nic zaskakuj¹cego - zwyk³y prototyp funkcji. No dobra, tylko jak teraz dopisaæ cia³o do takiej deklaracji metody? Chcemy to uczyniæ na zewn¹trz naszej klasy, tak wiêc musimy wskazaæ, do której klasy bêdzie siê odnosi³a definicja funkcji <SPAN CLASS=T>Resetuj</SPAN>. Oczywiœcie na razie mamy tylko tê jedn¹ klasê, ale kompilator o tym "nie wie", wiêc zak³ada, ¿e istnieje nieskoñczenie wiele klas i ka¿da z nich posiada deklaracjê metody <SPAN CLASS=T>Resetuj</SPAN> ;-). Rozwi¹zaniem jest operator zasiêgu (podwójny dwukropek), a w praniu wygl¹da on tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> Gracz::Resetuj()<BR>
{<BR>
&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=C>//pomijam definicje akcesorów...</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Gdybyœmy do klasy <SPAN CLASS=T>Gracz</SPAN> dodali jeszcze kilka metod, a nastêpnie w ten sam sposób zdefiniowali te metody, to wszystkie definicje tych metod ³¹cznie moglibyœmy nazwaæ definicj¹ klasy, natomiast sam blok oznaczony s³owem <SPAN CLASS=K>class</SPAN>, wraz z deklaracjami zmiennych sk³adowych i prototypami metod by³by wtedy deklaracj¹ klasy. Deklaracjê umieszcza siê zwykle w plikach nag³ówkowych *.h (wreszcie mamy dla nich jakieœ konkretne zastosowanie ;-)), zaœ definicjê - w zwyk³ych plikach ¿ród³owych (*.cpp). W przypadku bardziej rozbudowanych klas jeden plik *.cpp i jeden plik *.h odpowiada czêsto tylko jednej klasie, a bywa nawet, ¿e jedna klasa jest umieszczona w kilku plikach. Nie straszmy siê jednak takimi perspektywami, bowiem klasy o których bêdziemy tutaj mówiæ bêd¹ w gruncie rzeczy bardzo proste ;-).
</P>

<h2>
WskaŸnik this i operator ->
</h2>

<P>
Pamiêtasz jeszcze, jak mówi³em o tym, ¿e wewn¹trz metod danej klasy wszelkie odwo³ania do zmiennych sk³adowych tej klasy nie musz¹ byæ poprzedzone nazw¹ klasy? Czyli np. w metodzie <SPAN CLASS=T>Resetuj</SPAN> piszemy <SPAN CLASS=T>Bron = </SPAN><SPAN CLASS=L>1</SPAN>, a nie <SPAN CLASS=T>Gracz.Bron = </SPAN><SPAN CLASS=L>1</SPAN>? Otó¿ jest to mo¿liwe dziêki wskaŸnikowi <SPAN CLASS=K>this</SPAN>. Jest to specjalny argument, który przekazywany jest niejawnie (czyli robi to za nas kompilator, bez naszej zgody, a czasem i bez naszej wiedzy ;-)) do KA¯DEJ metody (oprócz metod statycznych, o których powiemy sobie póŸniej). WskaŸnik ten zawiera adres "aktualnego obiektu" danej klasy. Tylko czym jest ten "aktualny obiekt"? WeŸmy przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz g1, g2, g3;<BR>
g2.Resetuj();<BR>
</TD></TR>
</TABLE>

<P>
Wchodzimy sobie wiêc do metody <SPAN CLASS=T>Resetuj</SPAN>. Wywo³ana zosta³a ona dla obiektu <SPAN CLASS=T>g2</SPAN>, wiêc to <SPAN CLASS=T>g2</SPAN> jest w tej chwili "obiektem aktualnym". Czyli wskaŸnik this wewn¹trz metody <SPAN CLASS=T>Resetuj</SPAN> w tym w³aœnie momencie jest równy <SPAN CLASS=T>&g2</SPAN>.
</P>
<P>
U¿ycie wskaŸnika <SPAN CLASS=K>this</SPAN> jest, podobnie jak jego przekazywanie jako argument, ca³kowicie niejawne. Nie musi jednak tak byæ, a czasem wrêcz nie ma innego wyjœcia, jak tylko skorzystaæ z <SPAN CLASS=K>this</SPAN> jawnie. Dla przyk³adu moglibyœmy napisaæ nasz¹ metodê <SPAN CLASS=T>Resetuj</SPAN> w postaci:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> Gracz::Resetuj()<BR>
{<BR>
&nbsp;(*<SPAN CLASS=K>this</SPAN>).Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;(*<SPAN CLASS=K>this</SPAN>).Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;(*<SPAN CLASS=K>this</SPAN>).Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;(*<SPAN CLASS=K>this</SPAN>).Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;(*<SPAN CLASS=K>this</SPAN>).Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
...tyle, ¿e by³aby oczywista redundacja, a w dodatku masa pisaniny. Niemniej jednak mo¿emy siê spotkaæ z sytuacjami, gdzie jawnego u¿ycia <SPAN CLASS=K>this</SPAN> nie da³oby siê unikn¹æ. Sytuacj¹ tak¹ jest przypadek, gdy metoda musi zwróciæ referencjê do obiektu, dla którego j¹ wywo³ano, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Klasa& Klasa::Metoda()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return *this</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Po co zwracaæ tak¹ referencjê, dowiemy siê ju¿ wkrótce. Na razie zaœ zajmiemy siê szczegó³em na pozór ma³o istotnym, który jednak okazaæ siê mo¿e bardzo przydatny. Otó¿ w sytuacji, kiedy chcemy dostaæ siê do sk³adowej jakiegoœ obiektu, ale nie dysponujemy samym obiektem, a tylko wskaŸnikiem do niego, wówczas zamiast:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
(*Wsk).Skladowa = Wartosc;<BR>
</TD></TR>
</TABLE>

<P>
...mo¿emy (i powinniœmy) pisaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Wsk->Skladowa = Wartosc;
</TD></TR>
</TABLE>

<P>
Ten nowy (i fajny) operator niew¹tpliwie wygl¹da du¿o estetyczniej i bardziej przejrzyœcie, zw³aszcza ¿e przypomina strza³kê, a wiêc kojarzy siê dobrze ze wskaŸnikami. Radzê ju¿ teraz zacz¹æ siê do niego przyzwyczajaæ ;-).
</P>
<P>
Poniewa¿ this jest takim samym wskaŸnikiem jak wszystkie inne, wobec niego równie¿ mo¿emy stosowaæ operator <SPAN CLASS=T>-&gt;</SPAN>. Tak wiêc powy¿szy przyk³ad z jawnym (i zarazem niepotrzebnym ;-)) u¿yciem <SPAN CLASS=K>this</SPAN> móg³by równie dobrze wygl¹daæ nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
void Gracz::Resetuj()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>this</SPAN>->Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>this</SPAN>->Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>this</SPAN>->Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>this</SPAN>->Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>this</SPAN>->Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>


<h2>
Konstruktory i destruktory
</h2>

<P>
Zacznijmy od szkolnej regu³ki - konstruktor jest to specjalna funkcja sk³adowa klasy, której zadaniem jest stworzenie obiektu. Niby proste i jasne, ale co w³aœciwie nale¿y rozumieæ przez "stworzenie obiektu"? To zale¿y tylko od programisty... Zazwyczaj aby cokolwiek stworzyæ, musimy mieæ na to trochê pamiêci operacyjnej, tak wiêc zadaniem konstruktora by³oby zaalokowanie tej pamiêci. Z kolei w przypadku naszej klasy <SPAN CLASS=T>Gracz</SPAN> (któr¹ rozwijamy coraz bardziej, ale w gruncie rzeczy wci¹¿ jest ona tylko prymitywn¹ struktur¹) nic nie trzeba alokowaæ, gdy¿ wszystkie zmienne sk³adowe s¹ alokowane statycznie (ich rozmiar z góry jest okreœlony). Za to przyda³oby siê te wszystkie zmienne zainicjalizowaæ (wci¹¿ mamy w pamiêci przestrogê o nieokreœlonej zawartoœci pocz¹tkowej zmiennych). Wprawdzie robi to ju¿ za nas metoda <SPAN CLASS=T>Resetuj</SPAN>, ale dziêki zainicjalizowaniu wszystkich sk³adowych w konstruktorze nie bêdziemy musieli pamiêtaæ o ka¿dorazowym wywo³ywaniu <SPAN CLASS=T>Resetuj</SPAN> dla ka¿dego nowego obiektu klasy <SPAN CLASS=T>Gracz</SPAN>.
</P>
<P>
Zreszt¹ wcale nie musimy przenosiæ kodu z metody <SPAN CLASS=T>Resetuj</SPAN> do konstruktora, ani tym bardziej powielaæ tego kodu. Wystarczy, ¿e konstruktor bêdzie po prostu wywo³ywa³ metodê <SPAN CLASS=T>Resetuj</SPAN>. Dziêki temu stan ka¿dego obiektu typu <SPAN CLASS=T>Gracz</SPAN> bêdzie zawsze resetowany podczas tworzenia tego obiektu, a ponadto zachowamy mo¿liwoœæ wywo³ania metody <SPAN CLASS=T>Resetuj</SPAN> w dowolnym momencie programu. Doœæ gadania, do roboty - zróbmy wreszcie ten konstruktor:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR><SPAN CLASS=K>
private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Gracz(); <SPAN CLASS=C>//konstruktor - deklaracja</SPAN><BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj();<BR>
&nbsp;<SPAN CLASS=C>//pomijam deklaracje akcesorów...</SPAN><BR>
};<BR>
<BR>
Gracz::Gracz() <SPAN CLASS=C>//konstruktor - definicja</SPAN><BR>
{<BR>
&nbsp;Resetuj();<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Gracz::Resetuj()<BR>
{<BR>
&nbsp;Bron = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;Amunicja = <SPAN CLASS=L>50</SPAN>;<BR>
&nbsp;Pancerz = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;Zdrowie = <SPAN CLASS=L>100</SPAN>;<BR>
&nbsp;Zycia = <SPAN CLASS=L>3</SPAN>;<BR>
}<BR>
<BR><SPAN CLASS=C>
//pomijam definicje... wiadomo czego ;-)</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Najwa¿niejsze fragmenty oznaczyliœmy sobie komentarzami. Deklaracja konstruktora ró¿ni siê od deklaracja "zwyk³ej" metody dwiema rzeczami - po pierwsze: nie ma ¿adnego typu zwracanego, po drugie: nazwa funkcji w przypadku konstruktora jest jednoczeœnie nazw¹ klasy. Innymi s³owy: chc¹c zadeklarowaæ konstruktor, piszemy nazwê klasy i parê nawiasów okr¹g³ych, koñcz¹c oczywiœcie œrednikiem.
</P>
<P>
Teraz rodzi siê pytanie - w którym dok³adnie momencie wywo³ywany jest konstruktor? W momencie powo³ywania ka¿dego obiektu do ¿ycia. Jeœli obiekt ma zasiêg globalny, dzieje siê to na pocz¹tku programu, w chwili zadeklarowania obiektu, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz g; <SPAN CLASS=C>//tu wywo³ywany jest konstruktor</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//...</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeœli obiekt jest "tylko" lokalny, konstruktor wywo³ywany jest w momencie, gdy wykonanie programu "wchodzi" do danego bloku i napotka deklaracjê obiektu, np.:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Gracz g1; <SPAN CLASS=C>//tu wywo³ywany jest konstruktor</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=C>//jakieœ instrukcje</SPAN><BR>
<BR>
&nbsp;Gracz g2; <SPAN CLASS=C>//tu te¿ wywo³ywany jest konstruktor</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}
</TD></TR>
</TABLE>

<P>
Wywo³anie konstruktora poci¹ga te¿ za sob¹ skorzystanie z operatora <SPAN CLASS=K>new</SPAN> (który, jak wiemy, tworzy nowy obiekt):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz* wsk_g = <SPAN CLASS=K>new</SPAN> Gracz;
</TD></TR>
</TABLE>

<P>
Mo¿emy ³atwo sprawdziæ, czy nasz konstruktor aby na pewno dzia³a tak, jak nale¿y:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Gracz g1;<BR>
<BR>
&nbsp;cout &lt;&lt; g1.GetZycia() &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Ten programik wyœwietli nam na ekranie trójeczkê, albowiem w³aœnie na tê wartoœæ konstruktor klasy <SPAN CLASS=T>Gracz</SPAN> ustawia sk³adow¹ <SPAN CLASS=T>Zycia</SPAN> (która to wartoœæ zwracana jest przez <SPAN CLASS=T>GetZycia</SPAN>).
</P>
<P>
Jak zapewne siê domyœlasz, destruktory powinne niszczyæ to, co zbudowa³ konstruktor. Bynajmniej nie czyni¹ tego z wrodzonej z³oœliwoœci. Po prostu zaalokowan¹ pamiêæ nale¿y zwolniæ (obiekt nie bêdzie ju¿ u¿ywany), coby inne programy te¿ mia³y jej pod dostatkiem. Do dobrego tonu nale¿y te¿ wyzerowanie wszelkich wskaŸników i tym podobne operacje, czyli tak jakby ponowna inicjalizacja obiektu. Destruktor jest "zaprzeczeniem" konstruktora, tote¿ i jego deklaracja wygl¹da jak zanegowanie deklaracji konstruktora:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Gracz(); &nbsp;<SPAN CLASS=C>//konstruktor</SPAN><BR>
&nbsp;~Gracz(); <SPAN CLASS=C>//destruktor</SPAN><BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj();<BR>
&nbsp;<SPAN CLASS=C>//pomijamy wiadomo co ;-)</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Destruktor wywo³ywany jest wówczas, gdy obiekt koñczy swój ¿ywot. W przeciwieñstwie do sytuacji, gdy obiekt jest tworzony, tutaj raczej nie mamy do czynienia z ¿adn¹ "de-deklaracj¹" - jeœli nie niszczymy obiektu za pomoc¹ <SPAN CLASS=K>delete</SPAN>, to moment wywo³ania destruktora jest "wyczuwany" przez kompilator, czyli na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz g1;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> funkcja()<BR>
{<BR>
&nbsp;Gracz g2;<BR>
<BR>
&nbsp;<SPAN CLASS=C>//jakieœ tam instrukcje...<BR>
<BR>
&nbsp;//destruktor dla g2</SPAN><BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//jakieœ tam instrukcje</SPAN><BR>
}<BR>
<BR>
<SPAN CLASS=C>//destruktor dla g1</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Równie dobrze mo¿emy sobie wywo³aæ destruktor jawnie, np:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Gracz g;<BR>
&nbsp;g.~Gracz(); <SPAN CLASS=C>//jawne wywo³anie destruktora</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>; <SPAN CLASS=C>//niejawne wywo³anie destruktora</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
...jednak zbyt ³adnie to nie wygl¹da, a przy okazji w wiêkszoœci sytuacji jest raczej niebezpieczne (ryzykujemy próbê powtórnego niszczenia obiektu, który ju¿ zosta³ zniszczony - najpierw jawnie, potem niejawnie).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05b.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</BODY>
</HTML>