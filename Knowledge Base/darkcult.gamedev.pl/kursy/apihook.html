<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Haki</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">

<style type="text/css">
<!--
body { color: #000000; background-color: #000000; }
.cpp1-assembler { color: #00FF00; }
.cpp1-character { color: #FF00FF; }
.cpp1-comment { color: #969696; font-style: italic; }
.cpp1-float { color: #FF00FF; }
.cpp1-hexadecimal { color: #FF00FF; }
.cpp1-identifier { color: #00FF00; }
.cpp1-illegalchar { background-color: #800000; color: #FF0000; }
.cpp1-number { color: #FF00FF; }
.cpp1-octal { color: #FF00FF; }
.cpp1-preprocessor { color: #00FF00; }
.cpp1-reservedword { color: #3366FF; font-weight: bold; }
.cpp1-space { background-color: #464646; color: #FFFFFF; }
.cpp1-string { color: #FF00FF; }
.cpp1-symbol { color: #FFFF00; }
-->
</style>

</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Haki</H1>

<P>
Enkapsulacja ró¿nych niskopoziomowych operacji w funkcjach Windows API to dla programistów niew¹tpliwie dobra rzecz. Dzieki temu nie musimy siê na przyk³ad grzebaæ w dokumentacji naszego hardware'u i martwiæ o to, czy nasz program uruchomi siê na innych konfiguracjach sprzêtowych (to ostatnie oczywiœcie nie do koñca jest prawd¹, ale z pewnoœci¹ bez WinAPI by³oby pod tym wzglêdem du¿o, du¿o gorzej).
</P>
<P>
Jednak zdarzaj¹ siê sytuacje, ¿e ta enkapsulacja jest dla nas niema³¹ przeszkod¹. Czasem chcia³oby siê dostaæ do &quot;bebechów&quot; Windowsa i trochê pozmieniaæ jego dzia³anie. W jednej z poprzednich czêœci tego kursu poznaliœmy takie techniki, jak subclassing i superclassing, pozwalaj¹ce przede wszystkim dokonaæ pewnych zmian w kontrolkach. Mia³y one jednak doœæ w¹skie pole zastosowañ i sporo ograniczeñ. Na szczêœcie nie s¹ jedynym, co w tej sprawie mo¿e nam przyjœæ z pomoc¹.
</P>
<P>
Haki (ang. <span class=Inglisz>hooks</span>) to takie miejsca w mechanizmie komunikatów, w których mo¿emy &quot;podstawiæ&quot; w³asn¹ procedurê, przechwytuj¹c¹ te komunikaty, zanim dotr¹ one do swojej docelowej procedury okna. Owa &quot;w³asna procedura&quot; mo¿e sama podejmowaæ decyzjê, co z takim komunikatem zrobiæ. Przede wszystkim - mo¿e go przes³aæ dalej (do docelowej procedury okna) lub te¿ unicestwiæ. Mo¿e równie¿ wyci¹gaæ ró¿ne informacje z komunikatu i wykorzystywaæ ich do w³asnych, cnych lub niecnych, celów :-).
</P>
<P>
Przyk³adowe u¿ycie takiego mechanizmu mo¿emy zaobserwowaæ w znanym i (z koniecznoœci) lubianym komunikatorze GG. Jak powszechnie wiadomo, gdy wyjdziemy na kawê, s³oneczko na ikonie programu zachodzi za chmurkê. Sk¹d GG wie, ¿e u¿ytkownik gdzieœ polaz³? Oczywiœcie musi za³o¿yæ globalny hak, monitoruj¹cy komunikaty klawiatury i myszy - jeœli przez okreœlony czas nie przyjdzie ¿aden taki komunikat, GG uznaje, ¿e u¿ytkownik &quot;zaraz wraca&quot;. I rzeczywiœcie, w katalogu z programem znajdziemy plik gghook.exe - niew¹tpliwie zawiera on procedurê hakow¹, o której zaraz siê dowiemy coœ wiêcej.
</P>
<P>
Zanim przejdziemy dalej, umówmy siê jeszcze, ¿e odt¹d dla uproszczenia hakiem bêdziemy zwali sam¹ procedurê, która przechwytuje &quot;cudze&quot; komunikaty systemowe.
</P>
<P>

</p>

<H2>
Rodzaje haków
</H2>

<P>
Nie ma jednego uniwersalnego haka, który potrafi³by przechwyciæ ka¿dy komunikat. Zale¿nie od potrzeb musimy sobie wybraæ odpowiedni rodzaj:
</P>
<UL>
<li> <span class=Wazne>WH_CALLWNDPROC</span> oraz <span class=Wazne>WH_CALLWNDPROCRET</span> - pozwalaj¹ monitorowaæ komunikaty przeznaczone dla konkretnej procedury okna. WH_CALLWNDPROC przechwytuje komunikat przed jego dotarciem do procedury okna, WH_CALLWNDPROCRET - po.

<li> <span class=Wazne>WH_CBT</span> - nazwa pochodzi od computer-based training (CBT), czyli komputerowej edukacji, dla którego to rodzaju aplikacji przede wszystkim powsta³ ten hak. W ka¿dym razie hak WH_CBT pozwala przechwytywaæ komunikaty przed utworzeniem, zniszczeniem, minimalizacj¹, maksymalizacj¹, przeniesieniem, zmian¹ rozmiaru (uff...) okna, przed wykonaniem polecenia systemowego, przed zdjêciem komunikatu myszy lub klawiatury z kolejki komunikatów, przed ustawieniem fokusa oraz przed synchronizacj¹ kolejki komunikatów. Dziêki temu mo¿emy okreœliæ, czy nasza aplikacja &quot;pozwala&quot; na te operacje czy te¿ nie. Teraz ju¿ co niektórzy mog¹ kojarzyæ - tak, wszelkiego rodzaju komputerowe testy, quizy i programy egzaminacyjne korzystaj¹ z tego, by zablokowaæ biednym studentom dostêp do pomocy naukowych ;-).

<li> <span class=Wazne>WH_DEBUG</span> - ten hak wywo³ywany jest zawsze przed wszystkimi innymi hakami, wiêc mo¿na go u¿yæ do &quot;odpluskwiania&quot; innych haków

<li> <span class=Wazne>WH_FOREGROUNDIDLE</span> - hak pozwalaj¹cy nam wykonywaæ ró¿ne zadania w tle, gdy system wykryje, ¿e pierwszoplanowy w¹tek nic w danej chwili nie robi

<li> <span class=Wazne>WH_GETMESSAGE</span> - pozwala przechwyciæ komunikat, który w³aœnie ma byæ zwrócony przez GetMessage lub PeekMessage (w przeciwieñstwie do WH_CALLWNDPROC, który przechwytuje komunikat ju¿ po wywo³aniu DispatchMessage). To jest w³aœnie najbardziej zalecany hak do przechwytywania komunikatów zwi¹zanych z mysz¹ i klawiatur¹

<li> <span class=Wazne>WH_JOURNALPLAYBACK</span> - ciekawy hak, który umo¿liwia odtworzenie &quot;nagranych&quot; wczeœniej zdarzeñ wejœciowych (np. ruchu myszy). Jest to hak globalny, dotycz¹cy wszystkich w¹tków w systemie.

<li> <span class=Wazne>WH_JOURNALRECORD</span> - &quot;nagrywa&quot; zdarzenia do póŸniejszego wykorzystania przez WH_JOURNALPLAYBACK; oczywiœcie to równie¿ jest hak globalny

<li> <span class=Wazne>WH_KEYBOARD_LL</span> - przechwytuje niskopoziomowe (low-level) zdarzenia, wywo³ane przez klawiaturê

<li> <span class=Wazne>WH_KEYBOARD</span> - przechwytuje wysokopoziomowe zdarzenia klawiatury (jest to wiêc wyspecjalizowany wariant haka WH_GETMESSAGE)

<li> <span class=Wazne>WH_MOUSE_LL</span> - przechwytuje niskopoziomowe zdarzenia myszy

<li> <span class=Wazne>WH_MOUSE</span> - przechwytuje wysokopoziomowe zdarzenia myszy (kolejna wyspecjalizowana wersja WH_GETMESSAGE)

<li> <span class=Wazne>WH_MSGFILTER</span> oraz <span class=Wazne>WH_SYSMSGFILTER</span> - dziêki tym hakom mo¿emy monitorowaæ komunikaty pochodz¹ce z menu, pasków przewijania, message box'ów oraz okien dialogowych. Mo¿emy te¿ wykrywaæ aktywacjê okna przy pomocy Alt+Tab lub Alt+Esc. Normalnie nie mo¿emy tego wszystkiego zrobiæ, gdy wykonywana jest jakakolwiek pêtla modalna (np. wewnêtrzna pêtla message box'a). WH_SYSMSGFILTER ma dzia³anie globalne, zaœ WH_MSGFILTER dotyczy jedynie aplikacji, która zainstalowa³a hak

<li> wreszcie <span class=Wazne>WH_SHELL</span> zosta³ stworzony po to, byœmy w aplikacji shell'owej (jeœli takow¹ piszemy) mogli otrzymywaæ istotne powiadomienia systemowe. Domyœlnie jest to aktywacja aplikacji shell'owej oraz utworzenie/zniszczenie jej g³ównego okna.
</ul>

<p>
W tym momencie mo¿e siê jeszcze wydawaæ, ¿e wiêkszoœæ wymienionych rodzajów haków wzajemnie duplikuje swoj¹ funkcjonalnoœæ i co za tym idzie, jest to tylko niepotrzebna nadmiarowoœæ wyboru. Zauwa¿my jednak, ¿e niemal ka¿dy hak dzia³a na nieco innym poziomie w
indowsowego mechanizmu komunikatów. W prostych przypadkach najczêœciej nie ma du¿ej ró¿nicy, jakiego haka u¿yjemy, jednak docenisz tê ró¿norodnoœæ, gdy tylko spróbujesz napisaæ coœ naprawdê z³o¿onego :-).
</P>
<h2>
Przyk³ad - przechwytywanie klawiszy
</h2>
<P>
Pora zrobiæ wreszcie coœ konkretnego z hakami. Zacznijmy od przechwytywania klawiatury. Normalnie obs³ugujemy j¹ przez komunikaty w rodzaju WM_KEYDOWN. Takie komunikaty generuje dla nas system, czêsto po wielu doœæ skomplikowanych manewrach. W wyniku tych manewrów czasami dostajemy ju¿ jakieœ zdarzenie wy¿szego poziomu. I tak na przyk³ad wciœniêcie kombinacji Alt+F4 zamknie nasze okno i nie bêdziemy mieli szansy obs³u¿enia tego przez WM_KEYDOWN. Chyba, ¿e za³o¿ymy odpowiedni hak:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">HHOOK g_MyHook = NULL;

</span></span>
</code>
<P>
Funkcja SetWindowsHookEx za³o¿y hak i zwróci do niego uchwyt. Powinniœmy j¹ wywo³aæ tam, gdzie wykonujemy inicjalizacjê naszej aplikacji - np. po stworzeniu g³ównego okna:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">g_MyHook = SetWindowsHookEx (WH_KEYBOARD, &amp;AltF4Proc, NULL, GetThreadId (GetCurrentThread()));
</span></span>
</code>
<P>
Tutaj skojarzyliœmy nasz hak tylko z bie¿¹cym w¹tkiem. Mo¿emy jednak równie¿ tworzyæ globalne haki, tyle ¿e takie musimy umieszczaæ wewn¹trz DLL.
</P>
<P>
Od razu, ¿eby nie zapomnieæ, zadbamy o usuniêcie haka w momencie zakoñczenia naszej aplikacji:
</P><pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WM_DESTROY</span><span class="cpp1-symbol">:</span><span class="cpp1-space">	    
     </span><span class="cpp1-identifier">UnhookWindowsHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">g_MyHook</span><span class="cpp1-symbol">);</span><span class="cpp1-space">		
     </span><span class="cpp1-identifier">PostQuitMessage</span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">);</span><span class="cpp1-space">		
</span><span class="cpp1-reservedword">break</span><span class="cpp1-symbol">;
</span></span>
</code></pre>
<P>
Teraz najwa¿niejszy etap zabawy, czyli stworzenie procedury hakowej. Jej deklaracja wygl¹da u nas tak:
</P>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">LRESULT</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CALLBACK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">AltF4Proc</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);
</span></span>
</code>
<P>
Jak widaæ, jest ca³kiem podobna do procedury okna i nie jest to przypadkowe podobieñstwo. Pe³niona przez ni¹ rola to równie¿ obs³uga przychodz¹cych komunikatów, ró¿ni siê w³aœciwie tylko momentem, w którym te komunikaty obs³ugujemy.
</P>
<P>
Jak siê zaj¹æ komunikatem, który ju¿ dotrze do naszej procedury hakowej? Przede wszystkim musimy zbadaæ wartoœæ parametru code. Jeœli jest ona mniejsza od 0, to powinniœmy zrezygnowaæ z dalszego przetwarzania i od razu wywo³aæ CallNextHookEx() i zwróciæ wartoœæ od niej otrzyman¹. Jak siê byæ mo¿e domyœlasz, funkcja CallNextHookEx() wo³a kolejn¹ procedurê hakow¹ typu WH_KEYBOARD, o ile taka zosta³a zainstalowana. Wywo³ywanie tej funkcji pozwala wiêc na wspó³dzia³anie wielu haków, pochodz¹cych z ró¿nych aplikacji.
</P>
<P>
Jeœli code jest wiêksze lub równe 0, to mo¿emy normalnie obs³u¿yæ komunikat. Za³ó¿my, ¿e chcemy aby nasza aplikacja po wciœniêciu Alt+F4 nie zamyka³a siê, tylko wyœwietla³a jak¹œ wiadomoœæ. Musimy sprawdziæ, czy klawisz którego dotyczy komunikat to F4 oraz dodatkowo czy wciœniêto prawy Alt. Parametr wParam zawiera kod wirtualnego klawisza, zaœ lParam dodatkowe flagi - nas interesuje bit numer 29, ustawiony gdy naciœniêto Alt. Maska bitowa odpowiadaj¹ca tej fladze to 536870912 (czyli 2^29). Czynimy wiêc nastêpuj¹co:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">LRESULT</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CALLBACK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">AltF4Proc</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">)
{
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CallNextHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);

</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">wParam</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">VK_F4</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&amp;&amp;</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">lParam</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&amp;</span><span class="cpp1-space"> </span><span class="cpp1-number">536870912</span><span class="cpp1-symbol">))</span><span class="cpp1-space">    
    </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">MessageBox</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">hwnd</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;Nie zamkniesz mnie tak ³atwo!&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">MB_ICONEXCLAMATION</span><span class="cpp1-symbol">);</span><span class="cpp1-space">        
        </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">1</span><span class="cpp1-symbol">;</span><span class="cpp1-space">    
    </span><span class="cpp1-symbol">}

</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CallNextHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);
}
</span></span>
</code></pre>
<P>
Skoro ju¿ przekonaliœmy siê, ¿e u¿ytkownik nacisn¹³ Alt+F4, to pokazujemy nasz¹ g³upi¹ wiadomoœæ i zwracamy wartoœæ niezerow¹, co oznacza, ¿e obs³u¿yliœmy komunikat i nie chcemy przekazywaæ go dalej. To powoduje, ¿e jest on &quot;konsumowany&quot; i ¿e u¿ytkownik nie bêdzie móg³ w ten sposób zamkn¹æ okna (za to nadal mo¿e klikn¹æ przycisk &quot;X&quot;).
</P>
<h2>
Przyk³ad - odtwarzanie akcji
</h2>
<P>
Teraz coœ jeszcze zabawniejszego. Wykorzystamy parê haków WH_JOURNALRECORD i WH_JOURNALPLAYBACK, by odtworzyæ dok³adnie czynnoœci, które przed chwil¹ wykona³ u¿ytkownik.
</P>
<P>
Najpierw musimy te czynnoœci zarejestrowaæ, instaluj¹c hak WH_JOURNALRECORD. Poniewa¿ jest to hak globalny, umieœcimy kod jego procedury w bibliotece DLL. Nie jest to wprawdzie obowi¹zkowe dla WH_JOURNALRECORD, ale ju¿ dla WH_JOURNALPLAYBACK - owszem, wiêc ¿eby mieæ wszystko w jednym miejscu, zarówno procedurê dla WH_JOURNALRECORD, jak i dla WH_JOURNALPLAYBACK wrzucimy do DLL.
</P>
<P>
Tworzenie DLL omówione jest w odpowiednim artykule, wiêc nie bêdziemy siê powtarzaæ. Zaczynamy od niezbêdnych deklaracji:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-preprocessor">#include &lt;vector&gt;
</span><span class="cpp1-reservedword">using</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">namespace</span><span class="cpp1-space"> </span><span class="cpp1-identifier">std</span><span class="cpp1-symbol">;

</span><span class="cpp1-identifier">vector</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;</span><span class="cpp1-identifier">EVENTMSG</span><span class="cpp1-symbol">&gt;
</span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">;
</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">;
</span><span class="cpp1-reservedword">bool</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_PlaybackStopped</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">HHOOK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_RecordHook</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">HHOOK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_PlaybackHook</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">DWORD</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">HINSTANCE</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_hInst</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;
</span></span>
</code></pre>
<P>
Wszystkie akcje wykonywane przez u¿ytkownika bêdziemy przechowywaæ w wektorze z STL - nazwiemy go g_Events. Zmienna g_CurrentEvent bêdzie wykorzystana przy odtwarzaniu i bêdzie przechowywaæ numer aktualnie odtwarzanego zdarzenia (coœ jakby numer klatki w animacji). Zmienn¹ g_PlaybackStopped deklarujemy na wszelki wypadek, by nie przekroczyæ zakresu tablicy g_Events. Dalej mamy uchwyty do naszych dwóch haków g_RecordHook i g_PlaybackHook - musimy je pamiêtaæ, by móc usun¹æ haki, gdy przestan¹ byæ potrzebne (jak w poprzednim rozdziale).
</P>
<P>
W zmiennej g_StartTime bêdziemy przechowywaæ czas, w którym rozpoczêliœmy nagrywanie / odtwarzanie. Wyjaœnimy póŸniej, po co tak robimy. Wreszcie w g_hInst zapamiêtamy sobie uchwyt do modu³u DLL, który uzyskamy jako parametr z funkcji DllMain, wygl¹daj¹cej mniej wiêcej tak:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">BOOL</span><span class="cpp1-space"> </span><span class="cpp1-identifier">APIENTRY</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DllMain</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">HMODULE</span><span class="cpp1-space"> </span><span class="cpp1-identifier">hModule</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DWORD</span><span class="cpp1-space"> </span><span class="cpp1-identifier">ul_reason_for_call</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LPVOID</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lpReserved</span><span class="cpp1-symbol">)
{
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_hInst</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">hModule</span><span class="cpp1-symbol">;

</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">switch</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">ul_reason_for_call</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">    </span><span class="cpp1-symbol">{</span><span class="cpp1-space">     
    </span><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DLL_PROCESS_ATTACH</span><span class="cpp1-symbol">:</span><span class="cpp1-space">     
    </span><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DLL_THREAD_ATTACH</span><span class="cpp1-symbol">:</span><span class="cpp1-space">     
    </span><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DLL_THREAD_DETACH</span><span class="cpp1-symbol">:</span><span class="cpp1-space">     
    </span><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">DLL_PROCESS_DETACH</span><span class="cpp1-symbol">:</span><span class="cpp1-space">     
    </span><span class="cpp1-reservedword">break</span><span class="cpp1-symbol">;</span><span class="cpp1-space">    
    </span><span class="cpp1-symbol">}
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">TRUE</span><span class="cpp1-symbol">;
}
</span></span>
</code></pre>
<P>
Jeœli nie wyjaœniliœmy sobie tego w którymœ z pozosta³ych odcinków kursu WinAPI, to zróbmy to teraz: uchwyty typu HMODULE i HINSTANCE s¹ praktycznie to¿same, dlatego mo¿emy bez obaw przypisaæ jeden do drugiego, tak jak to czynimy powy¿ej. Uchwyt taki bêdzie nam potrzebny do za³o¿enia haków.
</P>
<P>
Teraz musimy napisaæ procedury hakowe. Zaczniemy oczywiœcie od procedury &quot;nagrywaj¹cej&quot; - u nas bêdzie siê ona nazywaæ RecordProc:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LRESULT</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CALLBACK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">RecordProc</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">)
{</span><span class="cpp1-space">    
     </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CallNextHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);</span><span class="cpp1-space">        
     
     </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">HC_ACTION</span><span class="cpp1-symbol">)</span><span class="cpp1-space">    
     </span><span class="cpp1-symbol">{</span><span class="cpp1-space">        
          </span><span class="cpp1-identifier">EVENTMSG</span><span class="cpp1-symbol">*</span><span class="cpp1-space"> </span><span class="cpp1-identifier">msg</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">EVENTMSG</span><span class="cpp1-symbol">*)</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">          </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">time</span><span class="cpp1-space"> </span><span class="cpp1-symbol">-=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-symbol">;</span><span class="cpp1-space">        
          </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">.</span><span class="cpp1-identifier">push_back</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(*</span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">);
</span><span class="cpp1-space">          </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;</span><span class="cpp1-space">            
     </span><span class="cpp1-symbol">}

</span><span class="cpp1-space">     </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CallNextHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);
}
</span></span>
</code></pre>
<P>
Dzia³anie makra DLL_API jest opisane w odcinku o DLL, wiêc nie musimy tutaj tego t³umaczyæ. Zajmijmy siê wa¿niejszymi w tej chwili sprawami. Generalnie procedura dla haka &quot;nagrywaj¹cego&quot; jest wo³ana przede wszystkim wtedy, gdy z kolejki komunikatów zdejmowany jest jakiœ komunikat. Wtedy parametr code jest równy HC_ACTION, a lParam zawiera wskaŸnik do struktury typu EVENTMSG, która opisuje ten komunikat. Struktura ta zawiera miêdzy innymi pole time, które oznacza czas wys³ania opisywanego przez strukturê komunikatu. Jest to czas bezwglêdny, wiêc nic nam po nim - odtwarzanie mo¿e równie dobrze mieæ miejsce kilka godzin po nagraniu, albo... kilka godzin wczeœniej, bo czas jest tutaj liczony w &quot;tykniêciach&quot; zegara systemowego od momentu uruchomienia systemu, a wiêc gdybyœmy chcieli odtworzyæ zdarzenia zapisane w takiej strukturze po zresetowaniu komputera, to mog³oby siê okazaæ, ¿e zosta³y one nagrane &quot;w przysz³oœci&quot;. Dlatego lepiej jest liczyæ czas wzglêdem rozpoczêcia nagrywania i dlatego te¿ odejmujemy wartoœæ zmiennej g_StartTime (w momencie rozpoczêcia nagrywania, a tak¿e odtwarzania, musimy tê zmienn¹ ustawiæ na aktualny czas systemowy). Po tej operacji po prostu dodajemy strukturê wskazywan¹ przez lParam do wektora i zwracamy dowoln¹ wartoœæ (jest w tym przypadku ignorowana). Poza tymi szczegó³ami procedura RecordProc dzia³a podobnie jak wszystkie inne procedury hakowe - te ogólne zasady ich bytowania ju¿ omówiliœmy wczeœniej.
</P>
<P>
Warto wiedzieæ, ¿e oprócz HC_ACTION procedura &quot;nagrywaj¹ca&quot; mo¿e zostaæ wywo³ana równie¿ z innymi parametrami. Tutaj je ignorujemy dla uproszczenia, jednak jeœli chcemy napisaæ w 100% poprawn¹ procedurê hakow¹, powinniœmy je oczywiœcie uwzglêdniæ - po detale odsy³am do dokumentacji Platform SDK.
</P>
<P>
Teraz pora na drug¹ procedurê - &quot;odtwarzaj¹c¹&quot;:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LRESULT</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CALLBACK</span><span class="cpp1-space"> </span><span class="cpp1-identifier">PlaybackProc</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">int</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LPARAM</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">)
{
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&lt;</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">CallNextHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">code</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">wParam</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">);
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">HC_GETNEXT</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">    </span><span class="cpp1-symbol">{</span><span class="cpp1-space">        
    
        </span><span class="cpp1-identifier">EVENTMSG</span><span class="cpp1-symbol">*</span><span class="cpp1-space"> </span><span class="cpp1-identifier">msg</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">EVENTMSG</span><span class="cpp1-symbol">*)</span><span class="cpp1-space"> </span><span class="cpp1-identifier">lParam</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">hwnd</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">[</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">].</span><span class="cpp1-identifier">hwnd</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">message</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">[</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">].</span><span class="cpp1-identifier">message</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">paramH</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">[</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">].</span><span class="cpp1-identifier">paramH</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">paramL</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">[</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">].</span><span class="cpp1-identifier">paramL</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">time</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-space"> </span><span class="cpp1-symbol">+</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">[</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">].</span><span class="cpp1-identifier">time</span><span class="cpp1-symbol">;</span><span class="cpp1-space">    
            
        </span><span class="cpp1-identifier">DWORD</span><span class="cpp1-space"> </span><span class="cpp1-identifier">delta</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">-&gt;</span><span class="cpp1-identifier">time</span><span class="cpp1-space"> </span><span class="cpp1-symbol">-</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetTickCount</span><span class="cpp1-symbol">();
</span><span class="cpp1-space">        
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">delta</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&gt;</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-identifier">delta</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">else
</span><span class="cpp1-space">            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;</span><span class="cpp1-space">                     
    </span><span class="cpp1-symbol">}
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">code</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">HC_SKIP</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">    </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(!</span><span class="cpp1-identifier">g_PlaybackStopped</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">            </span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-symbol">++;
</span><span class="cpp1-space">            
        </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-space"> </span><span class="cpp1-symbol">&gt;=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Events</span><span class="cpp1-symbol">.</span><span class="cpp1-identifier">size</span><span class="cpp1-symbol">())
</span><span class="cpp1-space">        </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">            </span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">            </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetTickCount</span><span class="cpp1-symbol">();
</span><span class="cpp1-space">            </span><span class="cpp1-identifier">g_PlaybackStopped</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">            </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">        </span><span class="cpp1-symbol">}
</span><span class="cpp1-space">    </span><span class="cpp1-symbol">}
</span><span class="cpp1-space">    
    </span><span class="cpp1-reservedword">return</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
}
</span></span>
</code></pre>
<P>
Tutaj mamy do obs³u¿enia co najmniej dwie sytuacje. Pierwsza zachodzi wtedy, gdy parametr code jest równy HC_SKIP i wtedy musimy, zgodnie z dokumentacj¹, &quot;przygotowaæ nastêpny komunikat do kopiowania&quot;. W naszym przypadku oznacza to po prostu zwiêkszenie licznika g_CurrentEvent. Dodatkowo sprawdzamy, czy przypadkiem nie skoñczy³y siê nam komunikaty, zapamiêtane w wektorze g_Events. Jeœli tak, to zerujemy licznik, co oznacza, ¿e odtwarzamy wszystko od pocz¹tku. W ten sposób odtwarzanie bêdzie trwa³o w nieskoñczonoœæ - a przynajmniej do momentu, gdy u¿ytkownik siê zniecierpliwi i coœ naciœnie :-).
</P>
<P>
Nie jest jednak obojêtne, co takiego naciœnie. Klawiatura i mysz s¹ bowiem &quot;wy³¹czone&quot; w trakcie odtwarzania. Aktywne s¹ jedynie dwie dobrze znane u¿ytkownikom Windows kombinacje specjalne: Ctrl+Esc i Ctrl+Alt+Del. Obie powoduj¹ natychmiastowe przerwanie odtwarzania (a tak¿e nagrywania) poprzez usuniêcie odpowiedniego hooka. Tak wiêc ¿adnego dodatkowego kodu przerywaj¹cego nie musimy pisaæ.
</P>
<P>
Drug¹ akcj¹, któr¹ musimy wykonaæ, jest skopiowanie nastêpnej &quot;klatki animacji&quot; (komunikatu do odtworzenia) z tablicy do struktury wskazywanej przez lParam (code == HC_GETNEXT). Znów musimy &quot;poprawiæ&quot; pole z czasem. Jak pamiêtamy, jest on wzglêdny, a system operuje w tym przypadku na czasach bezwglêdnych. Tak wiêc aby system siê nie pogubi³, dodajemy mu czas rozpoczêcia odtwarzania (tak - odtwarzania, a nie nagrywania!) do czasu wzglêdnego z tablicy.
</P>
<P>
Kolejnym krokiem jest zwrócenie odpowiedniej wartoœci. Jeœli bêdzie ona wiêksza od 0, system zostanie &quot;uœpiony&quot; na tê w³aœnie iloœæ czasu. Dziêki temu dzia³ania bêd¹ odtworzone w dok³adnie takim tempie, w jakim zosta³y nagrane. ¯eby obliczyæ w³aœciwy interwa³ czasowy, odejmujemy aktualny czas (pobrany za pomoc¹ funkcji GetTickCount()) od czasu jaki w³aœnie zapisaliœmy w strukturze.
</P>
<P class=UWAGA>W systemie Vista wystêpuj¹ problemy z odczekiwaniem ¿¹danego czasu. Prawdopodobnie mo¿na to obejœæ, wo³aj¹c Sleep(), a z procedury &quot;odtwarzaj¹cej&quot; zwracaj¹c zawsze 0. Nie sprawdzi³em tego jednak, wiêc nie podpisujê siê pod tym rozwi¹zaniem :-).
</P>
<P>
Aby nasze procedury (umieszczone w DLL) by³y dostêpne dla zewnêtrznej aplikacji (któr¹ te¿ zaraz sobie napiszemy), musimy je wyeksportowaæ. Albo nasze dwa haki za³o¿ymy bezpoœrednio z DLL, co bêdzie du¿o wygodniejsze. W tym celu stworzymy sobie interfejs w postaci takich oto dwóch funkcji:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> </span><span class="cpp1-identifier">StartRecording</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">void</span><span class="cpp1-symbol">)
{
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetTickCount</span><span class="cpp1-symbol">();
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_RecordHook</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">SetWindowsHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">WH_JOURNALRECORD</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">RecordProc</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_hInst</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">);</span><span class="cpp1-space">    
</span><span class="cpp1-symbol">}


</span><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> </span><span class="cpp1-identifier">StartPlayback</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">void</span><span class="cpp1-symbol">)
{
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_CurrentEvent</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_StartTime</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetTickCount</span><span class="cpp1-symbol">();
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">g_PlaybackStopped</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">false</span><span class="cpp1-symbol">;
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">UnhookWindowsHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">g_RecordHook</span><span class="cpp1-symbol">);</span><span class="cpp1-space">    	        
    </span><span class="cpp1-identifier">g_PlaybackHook</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">SetWindowsHookEx</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">WH_JOURNALPLAYBACK</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">PlaybackProc</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_hInst</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">);</span><span class="cpp1-space">	
</span><span class="cpp1-symbol">}
</span></span>
</code></pre>
<P>
Zak³adanie haków w DLL ró¿ni siê od zak³adania ich w &quot;zwyk³ej&quot; aplikacji praktycznie tylko tym, ¿e musimy pamiêtaæ, by przekazaæ uchwyt do modu³u DLL. Ju¿ go sobie zapamiêtaliœmy w zmiennej g_hInst, wiêc nie mamy z tym problemu. Obie funkcje ustawiaj¹ zmienn¹ g_StartTime na aktualny czas systemowy - zgodnie z tym, co ju¿ wczeœniej powiedzieliœmy. Dodatkowo StartPlayback zeruje licznik g_CurrentEvent oraz usuwa hak &quot;nagrywaj¹cy&quot;. 
</P>
<P>
Jedyne, co musimy teraz wyeksportowaæ z DLL, to nasz interfejs - funkcje StartRecording i StartPlayback:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">extern</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;C&quot;
</span><span class="cpp1-symbol">{
</span><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> </span><span class="cpp1-identifier">StartPlayback</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">void</span><span class="cpp1-symbol">);
</span><span class="cpp1-identifier">DLL_API</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> </span><span class="cpp1-identifier">StartRecording</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">void</span><span class="cpp1-symbol">);
}</span></span></code></pre>
<P>
Teraz przechodzimy do napisania aplikacji, która skorzysta z tego DLL. Najpierw kilka globalnych zmiennych:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">typedef</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">void</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(*</span><span class="cpp1-identifier">VOIDFN</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-reservedword">void</span><span class="cpp1-symbol">);

</span><span class="cpp1-identifier">VOIDFN</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Play</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">VOIDFN</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_Record</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;
</span><span class="cpp1-identifier">HINSTANCE</span><span class="cpp1-space"> </span><span class="cpp1-identifier">g_hInstDLL</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">;</span></span></code></pre>
<P>
WskaŸniki g_Play i g_Record bêd¹ nam potrzebne, aby zapamiêtaæ w nich adresy dwóch funkcji z DLL, które przed chwil¹ stworzyliœmy. £adujemy wiêc tego DLL-a (za³ó¿my, ¿e nazwaliœmy go journal.dll i wrzuciliœmy go do katalogu, gdzie jest projekt naszej aplikacji) i te funkcje:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-identifier">HINSTANCE</span><span class="cpp1-space"> </span><span class="cpp1-identifier">hInstDLL</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-identifier">LoadLibrary</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-string">&quot;journal.dll&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> 
</span><span class="cpp1-identifier">g_Play</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">VOIDFN</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetProcAddress</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">hInstDLL</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;StartPlayback&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> 
</span><span class="cpp1-identifier">g_Record</span><span class="cpp1-space"> </span><span class="cpp1-symbol">=</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">VOIDFN</span><span class="cpp1-symbol">)</span><span class="cpp1-space"> </span><span class="cpp1-identifier">GetProcAddress</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">hInstDLL</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;StartRecording&quot;</span><span class="cpp1-symbol">);</span><span class="cpp1-space"> </span></span></code></pre>
<P>
Pozostaje ju¿ tylko wywo³aæ obydwie funkcje w odpowiednich momentach. Za³ó¿my, ¿e nagrywanie chcemy rozpocz¹æ klawiszem F2, a odtwarzanie - F3:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">case</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WM_KEYDOWN</span><span class="cpp1-symbol">:
{
</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">wParam</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">VK_F2</span><span class="cpp1-symbol">)
</span><span class="cpp1-space"> </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">  </span><span class="cpp1-identifier">g_Record</span><span class="cpp1-symbol">();</span><span class="cpp1-space">    
 </span><span class="cpp1-symbol">}
</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">else</span><span class="cpp1-space"> </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">wParam</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">VK_F3</span><span class="cpp1-symbol">)
</span><span class="cpp1-space"> </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">  </span><span class="cpp1-identifier">g_Play</span><span class="cpp1-symbol">();</span><span class="cpp1-space">		        
 </span><span class="cpp1-symbol">}</span><span class="cpp1-space">		
</span><span class="cpp1-symbol">}
</span><span class="cpp1-reservedword">break</span><span class="cpp1-symbol">;</span><span class="cpp1-space"> 	
</span></span>
</code></pre>
<P>
Po wciœniêciu F2 mo¿emy sobie teraz wykonaæ parê ruchów mysz¹ albo powciskaæ jakieœ klawisze (wszystko jedno w jakim programie - hak jest przecie¿ globalny), po czym naciskaj¹c F3 sprawimy, ¿e to wszystko zostanie powtórzone. Oczywiœcie nie zawsze dok³adnie - jeœli zamkniemy okno mysz¹ podczas nagrywania, to podczas odtwarzania mysz kliknie ju¿ na czymœ innym :-).
</P>
<P>
Przyda³aby nam siê jeszcze jakaœ reakcja na zakoñczenie odtwarzania. Wprawdzie haki - jak ju¿ wspomnieliœmy - usun¹ siê automatycznie, ale w pewnych sytuacjach chcielibyœmy wiedzieæ, ¿e u¿ytkownik przerwa³ odtwarzanie, np. jeœli musimy schowaæ jakiœ element GUI, na którym wyœwietlaliœmy czas odtwarzania.
</P>
<P>
Otó¿ jeœli odtwarzanie (lub nagrywanie) zostanie przerwane, np. poprzez wciœniêcie Ctrl+Esc, to dostaniemy komunikat WM_CANCELJOURNAL. Jest z nim jednak pewien problem - nie jest skierowany do konkretnej procedury okna, jego parametr hwnd wynosi NULL. Tak wiêc jeœli umieœcimy jego obs³ugê w procedurze okna, tak jak jesteœmy przyzwyczajeni, to kod ten po prostu siê nie wywo³a. S¹ dwa sposoby, aby temu zaradziæ. Mo¿emy albo przechwyciæ ten jeden komunikat &quot;na dziko&quot;, czyli bezpoœrednio w pêtli komunikatów, albo... za³o¿yæ nastêpny hak, który to uczyni (WH_GETMESSAGE). To pierwsze rozwi¹zanie jest oczywiœcie prostsze, ale nie mo¿na z niego skorzystaæ, jeœli nie mamy w naszym programie w³asnej g³ównej pêtli. Za³ó¿my, ¿e nasz programik przyk³adowy tak¹ posiada i mo¿emy napisaæ tak:
</P>
<pre>
<code><span style="font: 10pt Courier New;"><span class="cpp1-reservedword">while</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">GetMessage</span><span class="cpp1-symbol">(&amp;</span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">NULL</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-number">0</span><span class="cpp1-symbol">))
{
</span><span class="cpp1-space">    </span><span class="cpp1-reservedword">if</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">.</span><span class="cpp1-identifier">message</span><span class="cpp1-space"> </span><span class="cpp1-symbol">==</span><span class="cpp1-space"> </span><span class="cpp1-identifier">WM_CANCELJOURNAL</span><span class="cpp1-symbol">)
</span><span class="cpp1-space">    </span><span class="cpp1-symbol">{
</span><span class="cpp1-space">        </span><span class="cpp1-identifier">MessageBox</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(</span><span class="cpp1-identifier">hwnd</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;Koniec zabawy!&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-string">&quot;Info&quot;</span><span class="cpp1-symbol">,</span><span class="cpp1-space"> </span><span class="cpp1-identifier">MB_ICONINFORMATION</span><span class="cpp1-symbol">);</span><span class="cpp1-space">	     
    </span><span class="cpp1-symbol">}
</span><span class="cpp1-space">	
		
</span><span class="cpp1-identifier">    TranslateMessage</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(&amp;</span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">);
</span><span class="cpp1-space">    </span><span class="cpp1-identifier">DispatchMessage</span><span class="cpp1-space"> </span><span class="cpp1-symbol">(&amp;</span><span class="cpp1-identifier">msg</span><span class="cpp1-symbol">);
}</span></span></code></pre>
<P>
Istotne jest, ¿e &quot;dobraliœmy siê&quot; do komunikatu, zanim trafi³ on do DispatchMessage, sk¹d by ju¿ nie wyszed³ ;-). Teraz gdy wciœniemy Ctrl+Esc albo Ctrl+Alt+Del podczas dzia³ania jednego z naszych dwóch haków, uraczeni zostaniemy mi³ym komunikatem. 
</P>
<P>
Zauwa¿my, ¿e nie ma mo¿liwoœci zwolnienia wykorzystanej przez nas biblioteki DLL. Jej licznik referencji jest bowiem zwiêkszany dla ka¿dej aplikacji dzia³aj¹cej w systemie! Dzieje siê tak dlatego, ¿e u¿yliœmy haka globalnego. Zawo³anie FreeLibrary() nic nie da, bo mo¿emy z tej funkcji skorzystaæ tylko dla naszego w³asnego procesu. Biblioteka zostanie zwolniona dopiero po zamkniêciu wszystkich niejawnie z ni¹ po³¹czonych procesów albo... wtedy, gdy jakimœ cudem wszystkie te procesy zwolni¹ j¹ przez FreeLibrary(). Oczywiœcie cudów nie ma, wiêc wszystkie te aplikacje musz¹ wiedzieæ o istnieniu naszego DLL, co w praktyce oznacza, ¿e musieliœmy je sami napisaæ ;-).
</P>
<P>
Programik, który sobie napisaliœmy, mo¿e s³u¿yæ nie tylko do g³upich ¿artów. Na pewno znajdziesz niejedno nu¿¹ce zadanie, podczas którego trzeba wiele razy powtarzaæ te same czynnoœci. Po paru drobnych ulepszeniach nasz program wykona je za nas :-).
</P>
<P>
Omówiliœmy dok³adniej tylko dwa rodzaje haków, ale to powinno w zupe³noœci wystarczyæ. Wszystkie inne rodzaje obs³guje siê w bardzo podobny sposób. Ka¿dy ma swoje specyficzne zastosowanie, które zapewne znajdziesz, gdy bêdziesz go potrzebowaæ :-). Oczywiœcie, ka¿dy niesie za sob¹ równie¿ mnóstwo potencjalnych (i tak¿e specyficznych) problemów - pamiêtajmy, ¿e u¿ywaj¹c haków grzebiemy doœæ g³êboko w systemie, a wiêc musimy najpierw dok³adnie wiedzieæ, co robimy - ale to ju¿ wszystko jest materia³em na podrêcznik, a nie króki kurs ;-).

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
</TR>
</TABLE>

</HTML>