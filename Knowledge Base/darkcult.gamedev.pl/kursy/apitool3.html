<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Toolbary</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitool2.html">&lt;&lt; Toolbary, cz.2</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitree.html">TreeView &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Wiêcej mo¿liwoœci
</H1>

<P>
Niezaprzeczalnie toolbary to fajna sprawa. Ale w wiêkszych aplikacjach (jak np. Visual C++), gdzie do dyspozycji jest kilkadziesi¹t czy nawet kilkaset poleceñ menu, wstawienie ich wszystkich do toolbaru jest fizycznie niemo¿liwe - w koñcu na ekranie musi zostaæ jeszcze trochê miejsca na pozosta³e elementy aplikacji ;-). Z drugiej strony ograniczanie u¿ytkownika do kilku najczêœciej stosowanych poleceñ k³óci siê z polityk¹ maksymalnej przyjaznoœci interfejsu, zreszt¹ programiœci mo¿e i s¹ inteligentni, ale na pewno ¿aden z nich nie jest jasnowidzem i nie potrafi na 100% stwierdziæ, czy ka¿dy u¿ytkownik bêdzie korzysta³ z danego przycisku na toolbarze czy te¿ nie.
</P>
<P>
Z powy¿szych powodów (a tak¿e kilku innych) ka¿dy cywilizowany toolbar powinien daæ siê dowolnie modyfikowaæ. U¿ytkownik musi mieæ mo¿liwoœæ dodawania i usuwania przycisków, grupowania ich wed³ug w³asnego uznania, wstawiania separatorów, przenoszenia poszczególnych grup przycisków w inne miejsce (tak¿e poza obszar toolbaru, jako osobne okienko), a nawet definiowania w³asnych przycisków, których przeznaczenie nie zosta³o przewidziane przez programistów albo przewidziane tylko czêœciowo. Wszystkich tych cudów (mo¿e za wyj¹tkiem ostatniego) za moment siê nauczymy. Brzmi to mo¿e doœæ kosmicznie, ale jest ca³kiem proste w implementacji - wiêkszoœæ akcji wykonuje za nas automatycznie biblioteka Comctl32.dll.
</P>
<h2>
Rebar
</H2>
<P>
Pod wzglêdem wizualnym najwiêcej nowoœci oferuje nam specjalny rodzaj kontrolki, zwany <SPAN CLASS=Wazne>rebarem</SPAN>. Jest to rodzaj <SPAN CLASS=Wazne>kontenera</SPAN> - mo¿na na nim umieszczaæ inne kontrolki (mniej wiêcej tak, jak to robiliœmy z ComboBoxem w poprzedniej czêœci kursu). Kontrolki te mog¹ byæ samodzielnymi toolbarami lub te¿ czymkolwiek innym, przy czym ka¿da kontrolka musi wystêpowaæ na oddzielnej bandzie (nale¿y ten termin kojarzyæ raczej z obrêcz¹, ni¿ szajk¹ zbirów ;-) ). Zreszt¹ zobacz, jak to jest zrobione np. w Dev-C++ - kilka band zawiera toolbary, a w jednej s¹ dwa ComboBoxy (co prawdopodobnie uzyskano w ten sposób, ¿e banda zawiera toolbar, a ten z kolei ComboBoxy).
</P>
<P ALIGN=center>
<img src="..\gfx\rebar_a.gif" alt="Rebar z programu ACDSee">
</P>
<P>
No to od czego zaczynamy? Pewnie od stworzenia rebaru. Mamy do dyspozycji klasê <SPAN CLASS=T>REBARCLASSNAME</SPAN>... Mamy? Nie mamy. Ale mo¿emy mieæ, jeœli j¹ zarejestrujemy. W tym celu zamieniamy wywo³anie naszej funkcji <SPAN CLASS=T>InitCommonControls</SPAN> na jej rozszerzon¹ wersjê - <SPAN CLASS=T>InitCommonControlsEx</SPAN> (znan¹ wœród programistów z poczuciem humoru jako InitCommonControlSex ;-)). Ró¿ni siê ona od "zwyk³ej" wersji tym, ¿e korzysta dodatkowo z pewnej struktury (ju¿ widzê, jak podskakujecie z radoœci ;-)). Struktura ta to <SPAN CLASS=T>INITCOMMONCONTROLSEX</SPAN> i omawiaæ jej nie bêdziemy, a przynajmniej nie tutaj. Jedyna interesuj¹ce nas w tym momencie zastosowanie jest nastêpuj¹ce:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
INITCOMMONCONTROLSEX icex;<BR>
<BR>
icex.dwSize = <SPAN CLASS=K>sizeof</SPAN>(INITCOMMONCONTROLSEX);<BR>
icex.dwICC = ICC_COOL_CLASSES|ICC_BAR_CLASSES;<BR>
InitCommonControlsEx(&icex);<BR>
</TD></TR>
</TABLE>

<P>
W ten sposób zapewniliœmy sobie dostêp do "fajnych klas", w tym do rebaru. Teraz mo¿emy spokojnie przyst¹piæ sobie do jego tworzenia:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
hRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_BORDER | WS_CLIPCHILDREN | RBS_VARHEIGHT | RBS_BANDBORDERS,
<SPAN CLASS=L>0, 0, 0, 0</SPAN>,
hwndOwner,
NULL,
hThisInstance,
NULL);<BR>
</TD></TR>
</TABLE>

<P>
Coœ tam sobie namodziliœmy w programie, ino efektów nie widaæ... I w sumie nic dziwnego - nie dodaliœmy przecie¿ ¿adnych band. Dopiero kiedy to zrobimy, efekty naszych starañ stan¹ siê widoczne. Do dodawania band, a tak¿e kilku innych zastosowañ przydatna jest... o radoœci, kolejna nowa struktura. Tym razem nazywa siê toto <SPAN CLASS=T>REBARBANDINFO</SPAN>. 
</P>
<P>
Ustalamy, ¿e chcemy sobie wyczarowaæ dwie bandy - jedn¹ z toolbarem, jedn¹ na przyk³ad z ComboBoxem. Struktura <SPAN CLASS=T>REBARBANDINFO</SPAN> jest doœæ obszerna, wiêc warto na pocz¹tek zastanowiæ siê, które z pól tej struktury bêd¹ u¿yte przez obie bandy, a które trzeba bêdzie ustawiaæ oddzielnie. Na pewno obydwie wymagaj¹ ustawienia pola <SPAN CLASS=T>cbSize</SPAN> (analogicznie jak w przypadku wiêkszoœci struktur w WinAPI) i <SPAN CLASS=T>fMask</SPAN> (te¿ analogicznie). Nie zaszkodzi te¿ zaliczyæ do tej grupy pola <SPAN CLASS=T>dwStyle</SPAN>, bowiem styl obu band powinien byæ taki sam. Deklarujemy wiêc zmienn¹ i ustawiamy wspólne pola:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
REBARBANDINFO rbbi;<BR>
rbbi.cbSize = <SPAN CLASS=K>sizeof</SPAN>(REBARBANDINFO);<BR>
rbbi.fMask = RBBIM_TEXT | RBBIM_BACKGROUND | RBBIM_STYLE | RBBIM_CHILD |
              RBBIM_CHILDSIZE | RBBIM_SIZE;<BR>
rbbi.fStyle = RBBS_CHILDEDGE | RBBS_FIXEDBMP | RBBS_GRIPPERALWAYS;<BR>
rbbi.hbmBack = LoadBitmap(hThisInstance, MAKEINTRESOURCE(IDB_BACKGRND));<BR>
</TD></TR>
</TABLE>

<P>
Warto zwróciæ uwagê, ¿e wczytaliœmy tu sobie z pliku zasobów bitmapkê - mo¿emy bowiem ustawiæ bitmapê t³a dla kazdej bandy, co poprawia jej walory wizualne ;-) (jak na rysunku powy¿ej).
</P>
<P>
Teraz tworzymy kontrolki do poszczególnych band. Najpierw toolbar - procedurê jego tworzenia ju¿ znamy - wype³niamy strukturê z przyciskami i wywo³ujemy <SPAN CLASS=T>CreateToolbarEx</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
TBBUTTON tbb[<SPAN CLASS=L>3</SPAN>];<BR>
<BR>
ZeroMemory(tbb, <SPAN CLASS=K>sizeof</SPAN>(tbb));<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>3</SPAN>; ++i)<BR>
{<BR>
&nbsp;tbb[i].idCommand = i;<BR>
&nbsp;tbb[i].fsState = TBSTATE_ENABLED;<BR>
&nbsp;tbb[i].fsStyle = TBSTYLE_BUTTON;<BR>
}<BR>
tbb[<SPAN CLASS=L>0</SPAN>].iBitmap = STD_FILENEW;<BR>
tbb[<SPAN CLASS=L>1</SPAN>].iBitmap = STD_FILEOPEN;<BR>
tbb[<SPAN CLASS=L>2</SPAN>].iBitmap = STD_FILESAVE;<BR>
<BR>
hToolbar = CreateToolbarEx(hRebar, WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN |
  CCS_NORESIZE | CCS_NODIVIDER |  TBSTYLE_FLAT, 
  <SPAN CLASS=L>500, 3</SPAN>, HINST_COMMCTRL, IDB_STD_SMALL_COLOR, tbb, <SPAN CLASS=L>3,16,16,16,16</SPAN>, <SPAN CLASS=K>sizeof</SPAN>(TBBUTTON));<BR>
</TD></TR>
</TABLE>

<P>
Teraz wype³niamy te pola struktury <SPAN CLASS=T>REBARBANDINFO</SPAN>, które bêd¹ wykorzystane tylko do toolbaru, a póŸniej bêd¹ oddzielnie wype³nione dla ComboBoxa. Nastêpnie dodajemy gotow¹ bandê do rebaru, korzystaj¹c z odpowiedniego komunikatu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
rbbi.lpText     = <SPAN CLASS=L>""</SPAN>;<BR>
rbbi.hwndChild  = hToolbar;<BR>
rbbi.cxMinChild = <SPAN CLASS=L>100</SPAN>;<BR>
rbbi.cyMinChild = <SPAN CLASS=L>22</SPAN>;<BR>
rbbi.cx         = <SPAN CLASS=L>100</SPAN>;<BR>
<BR>
SendMessage(hRebar, RB_INSERTBAND, (WPARAM)<SPAN CLASS=L>-1</SPAN>, (LPARAM)&rbbi);<BR>
</TD></TR>
</TABLE>

<P>
Teraz kolej na ComboBox - u¿ywamy oczywiœcie funkcji <SPAN CLASS=T>CreateWindowEx</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
hCombo = CreateWindowEx(<SPAN CLASS=L>0, "COMBOBOX"</SPAN>, NULL,
 WS_CHILD | WS_BORDER | WS_VISIBLE |
 WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBS_DROPDOWN,
<SPAN CLASS=L> 0, 0, 70, 200,</SPAN>
 hRebar, (HMENU)IDC_COMBOBOX, hThisInstance, <SPAN CLASS=L>0</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Bêdziemy potrzebowali zmiennej do zapamiêtania wymiarów ComboBoxa - przydadz¹ siê one za chwilê do okreœlenia wymiarów ca³ej bandy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
RECT rc;<BR>
GetWindowRect(hCombo, &rc);<BR>
</TD></TR>
</TABLE>

<P>
Wype³niamy strukturê informacjami o naszej drugiej bandzie, po czym dodajemy j¹ do rebaru:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
rbbi.lpText     = <SPAN CLASS=L>"ComboBox"</SPAN>;<BR>
rbbi.hwndChild  = hCombo;<BR>
rbbi.cxMinChild = rc.right - rc.left;<BR>
rbbi.cyMinChild = rc.bottom - rc.top;<BR>
rbbi.cx         = <SPAN CLASS=L>200</SPAN>;<BR>
<BR>
SendMessage(hRebar, RB_INSERTBAND, (WPARAM)<SPAN CLASS=L>-1</SPAN>, (LPARAM)&rbbi);<BR>
</TD></TR>
</TABLE>

<P>
To wszystko, mo¿emy siê ju¿ delektowaæ widokiem, który bêdzie przypomina³ coœ z tego screena. Zmieni³em tutaj kolor t³a na ciemnoszary, ¿eby rebar by³ lepiej widoczny:
</P>

<P align=center>
<img src="..\gfx\rebar.gif" alt="A oto i rebar w³asnej roboty">
</P>

<P>
Powy¿szy przyk³ad pomija oczywiœcie ca³e mnóstwo "nikomu niepotrzebnych" informacji o rebarze, ale gdybym zacz¹³ opisywaæ wszystkie mo¿liwoœci tej kontrolki, to wysz³oby z dziesiêæ dodatkowych odcinków tego kursu, a przecie¿ do wszystkiego mo¿esz sobie w miarê potrzeb dojœæ sam, wspieraj¹c siê tym, co ju¿ siê dowiedzia³eœ w tej czêœci kursu oraz MSDN.
</P>

<h2>
Dostosowywanie toolbaru
</h2>

<P>
Rebar, nawet tak prosty jak ten przedstawiony powy¿ej, daje nam ju¿ pewne mo¿liwoœci dopasowania go do naszych wyœrubowanych potrzeb. Mo¿emy sobie zmieniaæ szerokoœæ poszczególnych band, zamieniaæ je miejscami, a nawe umieœciæ ka¿d¹ bandê w osobnym wierszu. Ale to dziabkê za ma³o. Potrzebna jeszcze mo¿liwoœæ manipulowania rozmieszczeniem przycisków w obrêbie ka¿dej bandy.
</P>
<P>
Zadanie jest ca³kiem proste. Na poczatek wystarczy ustawiæ toolbarowi styl <SPAN CLASS=T>CCS_ADJUSTABLE</SPAN>. Wtedy zacznie od wysy³aæ do swego okna rodzicielskiego rozmaite ciekawe powiadomienia w momencie, gdy u¿ytkownik kliknie na ten toolbar dwukrotnie. Te powiadomienia maj¹ s³u¿yæ do pobrania od programisty informacji, jak dok³adnie u¿ytkownik mo¿e zmodyfikowaæ toolbar (tj. jakie przyciski mo¿e dodaæ, jakie usun¹æ, jakie przesun¹æ na inn¹ pozycjê itp.). Jeœli odpowiemy przynajmniej na obowi¹zkowe powiadomienia, wyœwietlony bêdzie dialog dostosowywania toolbaru:
</P>
<P align=center>
<img src="..\gfx\customiz.gif" alt="Tak wygl¹da dialog dostosowywania...">
<P>
Nie bêdziemy siê bawili w przyd³ugie wstêpy, od razu na sam pocz¹tek zobaczymy, w jaki sposób uzyskaæ "na skróty" mo¿liwoœæ modyfikowania paska w fazie run-time:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_NOTIFY:<BR>
{<BR>
&nbsp;LPNMHDR lpn = (LPNMHDR)lParam;<BR>
<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN> (lpn->code)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TBN_QUERYINSERT:<BR>
&nbsp;&nbsp;{ <SPAN CLASS=K>return</SPAN> TRUE; }<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TBN_QUERYDELETE:<BR>
&nbsp;&nbsp;{ <SPAN CLASS=K>return</SPAN> TRUE; }<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> TBN_GETBUTTONINFO:<BR>
&nbsp;&nbsp;{ <SPAN CLASS=K>return</SPAN> FALSE; }<BR>
&nbsp;&nbsp;<SPAN CLASS=K>default: break</SPAN>;<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, te "obowi¹zkowe" powiadomienia (jeœli na nie nie odpowiemy, to dialog dostosowywania siê w ogóle nie uka¿e) to <SPAN CLASS=T>TBN_QUERYINSERT, TBN_QUERYDELETE</SPAN> i <SPAN CLASS=T>TBN_GETBUTTONINFO</SPAN>, a odpowiadanie na nie polega po prostu na zwróceniu odpowiedniej wartoœci. Teraz pora na szczegó³y. Po wspomnianym ju¿ dwukrotnym klikniêciu na toolbar wysy³ane s¹ nastêpuj¹ce powiadomienia:
</P>

<UL>
<LI>powiadomienie <SPAN CLASS=T>TBN_BEGINADJUST</SPAN>
<LI>powiadomienie <SPAN CLASS=T>TBN_INITCUSTOMIZE</SPAN>
<LI>seria powiadomieñ <SPAN CLASS=T>TBN_QUERYINSERT</SPAN>
<LI>seria powiadomieñ <SPAN CLASS=T>TBN_QUERYDELETE</SPAN>
<LI>seria powiadomieñ <SPAN CLASS=T>TBN_GETBUTTONINFO</SPAN>
</UL>

<P>
<SPAN CLASS=T>TBN_BEGINADJUST</SPAN> po prostu zawiadamia aplikacjê, ¿e u¿ytkownik chce dostosowywaæ toolbar i tego powiadomienia obs³ugiwaæ nie musimy. Podobnie jest z <SPAN CLASS=T>TBN_INITCUSTOMIZE</SPAN>, które s³u¿y praktycznie tylko do ukrywania przycisku Pomoc, jeœli programista ma tak¹ chêæ (wówczas musi zwróciæ <SPAN CLASS=T>TBNRF_HIDEHELP</SPAN>).
</P>
<P>
Na nastêpne wymienione powiadomienia odpowiedzieæ ju¿ trzeba. <SPAN CLASS=T>TBN_QUERYINSERT</SPAN> wysy³ane jest dla ka¿dego przycisku na toolbarze osobno i jeœli odpowiemy na nie <SPAN CLASS=T>FALSE</SPAN>, to zablokujemy mo¿liwoœæ wstawienia innego przycisku po lewej stronie od tego, dla którego aktualnie wysy³ane jest powiadomienie (a jak to z kolei sprawdziæ, ju¿ wiemy - struktura <SPAN CLASS=T>NMHDR</SPAN> bêdzie bardzo pomocna ;-)). Przynajmniej na jedno powiadomienie <SPAN CLASS=T>TBN_QUERYINSERT</SPAN> musimy odpowiedzieæ <SPAN CLASS=T>TRUE</SPAN>, inaczej dialog siê nie wyœwietli. W powy¿szym przyk³adzie odpowiadamy <SPAN CLASS=T>TRUE</SPAN> na wszystkie powiadomienia tego rodzaju (nie sprawdzamy nawet, od którego przycisku pochodz¹), daj¹c tym samym mo¿liwoœæ wstawiania dodatkowych przycisków gdzie popadnie ;-).
</P>
<P>
Powiadomienia <SPAN CLASS=T>TBN_QUERYDELETE</SPAN> równie¿ wysy³ane s¹ dla ka¿dego przycisku z osobna i dziêki nim mo¿emy poinformowaæ system, które przyciski u¿ytkownik mo¿e sobie usun¹æ z toolbaru, a które pozostaj¹ na nim do¿ywotnio. W przyk³adzie powy¿ej u¿ytkownik mo¿e usun¹æ wszystkie przyciski (a niech siê cieszy, bestyja ;-)).
</P>
<P>
Wreszcie - <SPAN CLASS=T>TBN_GETBUTTONINFO</SPAN> s³u¿y do tego, byœmy mogli wype³niæ listê dostêpnych przycisków do dodania na toolbar (lista ta jest wyœwietlana po lewej stronie dialogu dostosowywania). Wype³nianie polega na wype³nieniu struktury <SPAN CLASS=T>NMTOOLBAR</SPAN> (do której wskaŸnik otrzymujemy wraz z powiadomieniem <SPAN CLASS=T>TBN_GETBUTTONINFO</SPAN>) oraz zwróceniu <SPAN CLASS=T>TRUE</SPAN>. Operacjê tak¹ nale¿y powtórzyæ dla ka¿dego przycisku, który chcemy dodaæ na tê listê. Na koniec powinniœmy zaœ zwróciæ <SPAN CLASS=T>FALSE</SPAN>, co przerwie wysy³anie powiadomieñ <SPAN CLASS=T>TBN_GETBUTTONINFO</SPAN>. Powy¿ej zrobiliœmy to na samym pocz¹tku, tote¿ na liœcie dostêpnych przycisków do dodania mamy tylko domyœly separator (za to mo¿emy ich sobie na toolbar wstawiæ od groma ;-)).
</P>
<P>
Nie bêdê tu siê rozpisywa³ na temat wype³niania <SPAN CLASS=T>NMTOOLBAR</SPAN>, gdy¿ nie zawiera ona w zasadzie nic, o czym do tej pory byœmy nie mówili, wiêc jest to praktycznie tylko kwestia wypróbowania tego na w³asn¹ rêkê. Poza tym nie mam pomys³u, jakie by tu jeszcze przyciski dodaæ do toolbaru w naszym przyk³adzie ;-).
</P>
<P>
Podczas gdy u¿ytkownik wyczynia z toolbarem cuda za poœrednictwem wspomnianego dialogu, jego niecne czyny oczywiœcie nie przechodz¹ niezauwa¿one. Za ka¿dym razem, gdy drañ coœ miesza, wysy³ane s¹ odpowiednie donosy, tak ¿e w razie czego mo¿emy zapobiec dalszym szkodom, a nawet ukaraæ ³obuza ;-). Gdy wstawiany jest przycisk, system wysy³a <SPAN CLASS=T>TBN_QUERYINSERT</SPAN> i mo¿emy zwróciæ <SPAN CLASS=T>FALSE</SPAN> - wtedy przycisk nie zostanie wstawiony i mroczne plany u¿ytkownika spe³zn¹ na niczym. Gdy u¿ytkownik usuwa przycisk, wysy³ane jest powiadomienie <SPAN CLASS=T>TBN_DELETINGBUTTON</SPAN>. Jeœli u¿ytkownik zmienia cokolwiek, przychodzi powiadomienie <SPAN CLASS=T>TBN_TOLBARCHANGE</SPAN> (takie uogólnienie dwóch poprzednich, obejmuj¹ce dodatkowo przeniesienie przycisku). Wreszcie <SPAN CLASS=T>TBN_CUSTHELP</SPAN> oznacza wciœniêcie przez usera przycisku Pomoc, a <SPAN CLASS=T>TBN_RESET</SPAN> - wciœniêcie przycisku Resetuj.
</P>
<P>
Na samym koñcu, gdy u¿ytkownikowi zabawa siê ju¿ znudzi albo sumienie go ruszy, ¿e za du¿o napsu³, zamyka on dialog dostosowywania i wówczas dostajemy powiadomienie <SPAN CLASS=T>TBN_ENDADJUST</SPAN> (ufff...).
</P>
<P>
To, o czym tutaj napisa³em, nie wyczerpuje oczywiœcie tematu nawet w po³owie, ale jakieœ tam wytyczne ju¿ mamy, reszta to ju¿ tylko praktyka...
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apitool2.html">&lt;&lt; Toolbary, cz.2</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apitree.html">TreeView &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>