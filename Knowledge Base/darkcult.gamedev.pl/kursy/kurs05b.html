<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 3</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05c.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>


<h2>
Argumenty konstruktora
</h2>

<P>
Podobnie jak zwyk³e funkcje, konstruktory mog¹ byæ przeci¹¿ane. Czynimy to przez deklarowanie konstruktorów o ró¿nych listach argumentów. I tak na przyk³ad dla naszej klasy <SPAN CLASS=T>Gracz</SPAN> móg³by nam siê przydaæ konstruktor o piêciu argumentach, który pozwala³by od razu przy tworzeniu obiektu tej klasy zainicjalizowaæ wszystkie jego sk³adowe prywatne (<SPAN CLASS=T>Bron, Amunicja</SPAN> itd.)
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Gracz();  <SPAN CLASS=C>//konstruktor domyœlny</SPAN><BR>
&nbsp;Gracz(<SPAN CLASS=K>int</SPAN> PBro, <SPAN CLASS=K>int</SPAN> PAmu, <SPAN CLASS=K>int</SPAN> PPan, <SPAN CLASS=K>int</SPAN> PZdr, <SPAN CLASS=K>int</SPAN> PZyc); <SPAN CLASS=C>//drugi konstruktor</SPAN><BR>
&nbsp;~Gracz(); <SPAN CLASS=C>//destruktor</SPAN><BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj();<BR>
&nbsp;<SPAN CLASS=C>//pomijamy wiadomo co ;-)</SPAN><BR>
};<BR>
<BR>
Gracz::Gracz(<SPAN CLASS=K>int</SPAN> PBro, <SPAN CLASS=K>int</SPAN> PAmu, <SPAN CLASS=K>int </SPAN>PPan, <SPAN CLASS=K>int</SPAN> PZdr, <SPAN CLASS=K>int</SPAN> PZyc)<BR>
{<BR>
&nbsp;Bron = PBro;<BR>
&nbsp;Amunicja = PAmu;<BR>
&nbsp;Pancerz = PPan;<BR>
&nbsp;Zdrowie = PZdr;<BR>
&nbsp;Zycia = PZyc;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Konstruktor bezargumentowy wywo³ywany jest domyœlnie, a jak wywo³aæ ten drugi, nowy? Po prostu do deklaracji obiektu dodajemy argumenty (w nawiasach okr¹g³ych, oczywiœcie):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz Gracz1(<SPAN CLASS=L>3, 50, 100, 100, 3</SPAN>);
</TD></TR>
</TABLE>

<P>
Dziêki takiemu kontruktorowi nie musimy kierowaæ poczynaniami jakiegoœ tam ¿ó³todzioba - od razu na poczatku programu mo¿emy sobie stworzyæ istnego Rambo, gotowego do koszenia kolejnych dywizji nieprzyjació³ ;-).
</P>

<P class=UWAGA>
Destruktory nie mog¹ mieæ ¿adnych argumentów. Powód jest chyba oczywisty - destruktor wywo³ywany jest zazwyczaj niejawnie w momencie, gdy obiekt przestaje byæ potrzebny. Wówczas nie ma po prostu mo¿liwoœci przekazania argumentu, gdy¿ programista nie oznacza w sposób jawny miejsca w kodzie, gdzie obiekt ma byæ niszczony.
</P>
<P>
Gdyby nasz konstruktor mia³ tylko jeden argument, moglibyœmy korzystaæ z jeszcze jednego sposobu zainicjalizowania nowo utworzonego obiektu - znamy ju¿ ten sposób, stosujemy go od samego pocz¹tku kursu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> zmienna = <SPAN CLASS=L>1</SPAN>;
</TD></TR>
</TABLE>

<P>
Na wszelki wypadek zobaczmy jednak, jak wygl¹da definicja takiego jednoargumentowego konstruktora. Jego zadaniem bêdzie tylko inicjalizacja zmiennej oznaczaj¹cej broñ naszego komandosa:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz::Gracz(<SPAN CLASS=K>int</SPAN> PBro)<BR>
{<BR>
&nbsp;Bron = PBro;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Analogicznie do argumentów zwyk³ych funkcji, tak¿e i argumenty konstruktora mog¹ mieæ sw¹ wartoœæ domyœln¹. Bardzo czêsto bêdziemy projektowaæ klasy, w których potrzebny bêdzie zarówno konstruktor z argumentami, jak i bez nich. W takim wypadku najlepiej jest stworzyæ w³aœnie konstruktor z argumentami z wartoœciami domyœlnymi. Przyk³adowo mo¿e on wygl¹daæ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Gracz<BR>
{<BR>
<SPAN CLASS=K>private:<BR>
&nbsp;int</SPAN> Bron, Amunicja, Pancerz, Zdrowie, Zycia;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Gracz(<SPAN CLASS=K>int</SPAN> PBro=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> PAmu=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> PPan=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> PZdr=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> PZyc=<SPAN CLASS=L>0</SPAN>);<BR>
&nbsp;~Gracz(); <SPAN CLASS=C>//destruktor</SPAN><BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Resetuj();<BR>
&nbsp;<SPAN CLASS=C>//pomijamy wiadomo co ;-)</SPAN><BR>
};<BR>
<BR>
Gracz::Gracz(<SPAN CLASS=K>int</SPAN> PBro, <SPAN CLASS=K>int</SPAN> PAmu, <SPAN CLASS=K>int</SPAN> PPan, <SPAN CLASS=K>int</SPAN> PZdr, <SPAN CLASS=K>int</SPAN> PZyc)<BR>
{<BR>
&nbsp;Bron = (PBro==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>1</SPAN> : PBro;<BR>
&nbsp;Amunicja = (PAmu==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>100</SPAN> : PAmu;<BR>
&nbsp;Pancerz = (PPan==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>0</SPAN> : PPan;<BR>
&nbsp;Zdrowie = (PZdr==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>100</SPAN> : PZdr;<BR>
&nbsp;Zycia = (PZyc==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>3</SPAN> : PZyc;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Wykorzystaliœmy tutaj operator <SPAN CLASS=T>?:</SPAN> do sprawdzenia, czy argument zosta³ pominiêty przy wywo³aniu konstruktora (wtedy ma wartoœæ domyœln¹ <SPAN CLASS=L>0</SPAN>). Jeœli tak, to danej zmiennej sk³adowej nadawana jest pewna sta³a wartoœæ (innymi s³owy: tworzymy ¿o³nierza-¿ó³todzioba ;-)), w przeciwnym wypadku zmienne sk³adowe otrzymuj¹ takie wartoœci pocz¹tkowe, jak podano w liœcie argumentów. Przyk³adowe wywo³ania tego konstruktora:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz Zoltodziob,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Weteran(<SPAN CLASS=L>2, 200, 100</SPAN>),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rambo(<SPAN CLASS=L>4, 400, 200, 200, 5</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
W przypadku obiektu <SPAN CLASS=T>Zoltodziob</SPAN> wszystkie argumenty bêd¹ mia³y domyœln¹ wartoœæ <SPAN CLASS=L>0</SPAN>, wiêc konstruktor ustawi zmienne sk³adowe na wartoœci: <SPAN CLASS=L>1, 100, 0, 100, 3</SPAN>. W przypadku Weterana trzy pierwsze sk³adowe otrzymaj¹ wartoœci: <SPAN CLASS=L>2, 200, 100</SPAN>, natomiast dwie pozosta³e - <SPAN CLASS=L>100</SPAN> i <SPAN CLASS=L>3</SPAN>. Wreszcie Rambo bêdzie mia³ sk³adowe ustawione na wartoœci <SPAN CLASS=L>4, 400, 200, 200, 5</SPAN>.
</P>

<P class=UWAGA>Jeœli nasza klasa nie zostanie w ogóle wyposa¿ona w konstruktor lub destruktor, kompilator wygeneruje domyœlny konstruktor / destruktor za nas (mi³o z jego strony, nieprawda¿? ;-)).</SPAN>


<H2>
Konstruktor kopiuj¹cy
</H2>

<P>
Jest pewien specjalny rodzaj konstruktora, który zajmuje siê tworzeniem obiektów danej klasy w specjalny sposób: tworzy on jeden obiekt na podobieñstwo drugiego, czyli kopiuje obiekty. Potrzeba taka zachodzi, gdy przypisujemy jednemu obiektowi referencjê do drugiego w instrukcji inicjalizacji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz Rambo;<BR>
Gracz Nowy(Rambo); <SPAN CLASS=C>//Stworzenie "klona" Rambo</SPAN><BR>
</TD></TR>
</TABLE>

<P>
...oraz przy przekazywaniu obiektu przez wartoœæ do funkcji i zwracaniu go:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Gracz funkcja(Gracz arg)<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//jakieœ skomplikowane instrukcje :-)<BR>
&nbsp;//najlepiej zmieniaj¹ce wartoœæ arg</SPAN><BR>
&nbsp;<SPAN CLASS=K>return</SPAN> arg;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
W tym drugim przypadku mamy kopiowanie dwukrotne: raz kopiowana jest wartoœæ obiektu, który przekazujemy jako argument (do lokalnej zmiennej <SPAN CLASS=T>arg</SPAN>), drugi raz kopia <SPAN CLASS=T>arg</SPAN> zwracana jest do funkcji wo³aj¹cej (natomiast sam <SPAN CLASS=T>arg</SPAN>, jako obiekt lokalny, jest niszczony - mo¿e wygl¹da to na marnotrawstwo, ale takie s¹ zasady dzia³ania programów ;-) ). Wszystkie trzy powy¿sze przyk³ady kopiowania wykonywane s¹ przez konstruktor kopiuj¹cy, o którym przed chwil¹ wspomnieliœmy. Nie zadeklarowaliœmy na razie takiego konstruktora w naszej klasie <SPAN CLASS=K>Gracz</SPAN>, wiêc kompilator sam go dopisa³ (kolejna uprzejmoœæ z jego strony). Taki niejawny konstruktor kopiuj¹cy sprawdza siê nieŸle, dopóki wewn¹trz kopiowanego obiektu nie ma wskaŸników na inne obiekty. Zobaczmy to na przyk³adowej klasie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;string.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> Bardzo_Zla_Klasa<BR>
{<BR>
<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* dane;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Bardzo_Zla_Klasa(<SPAN CLASS=K>const char</SPAN>* str) { ::strcpy(dane, str); }<BR>
&nbsp;~Bardzo_Zla_Klasa() { <SPAN CLASS=K>delete[]</SPAN> dane; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Zmien(<SPAN CLASS=K>const char</SPAN>* str) { ::strcpy(dane, str) }<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Bardzo_Zla_Klasa T(<SPAN CLASS=L>"dupa"</SPAN>), U;<BR>
&nbsp;U = T;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeœli przypadkiem nie wiesz: funkcja <SPAN CLASS=T>strcpy(to, from)</SPAN> kopiuje znaki ze stringa <SPAN CLASS=T>from</SPAN> do stringa <SPAN CLASS=T>to</SPAN>, i to w³aœnie z jej powodu do³¹czyliœmy nag³ówek <SPAN CLASS=C>string.h</SPAN>. Dwa dwukropki <SPAN CLASS=T>::</SPAN> dodaliœmy, poniewa¿ <SPAN CLASS=T>strcpy</SPAN> jest funkcj¹ globaln¹ (inaczej móg³by wyst¹piæ konflikt nazw z innymi plikami naszego programu, które ewentualnie mog³yby wykorzystywaæ <SPAN CLASS=T>strcpy</SPAN>).
</P>
<P>
Wszystko dzia³a bardzo piêknie, a¿ do momentu <SPAN CLASS=T>U = T</SPAN>. Wówczas zachodzi kopiowanie z wykorzystaniem niejawnego konstruktora. Konstruktor ten skopiuje wszystko bezmyœlnie, w³¹cznie ze wskaŸnikiem <SPAN CLASS=T>dane</SPAN>, a dok³adniej - zawartym w nim adresem naszego piêknego, czteroliterowego napisu. Tak, tak, wartoœæ adresu zostanie skopiowana, zaœ wskazywany napis nie zostanie bynajmniej umieszczony jako kopia w nowym miejscu. Efekt? Obydwa obiekty, <SPAN CLASS=T>T</SPAN> i <SPAN CLASS=T>U</SPAN>, bêd¹ zawiera³y wskaŸnik na jedno i to samo miejsce w pamiêci. Czyli jeœli napiszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
U.Zmien(<SPAN CLASS=L>"ty³ek"</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
...to obiekt <SPAN CLASS=T>T</SPAN> równie¿ bêdzie zawiera³ tekst <SPAN CLASS=L>"ty³ek"</SPAN>! Ale to jeszcze nic, prawdziwe jaja zaczynaj¹ siê wtedy, gdy wywo³any zostanie destruktor, czyli pod koniec funkcji <SPAN CLASS=T>main</SPAN>. Poniewa¿ obydwa obiekty zwalniaj¹ pamiêæ, wskazywan¹ przez wskaŸnik <SPAN CLASS=T>dane</SPAN>, a ten zosta³ skopiowany, wiêc obydwa destruktory bêd¹ chcia³y zwolniæ dok³adnie ten sam fragment pamiêci! A konkretnie najpierw jeden destruktor najlegalniej na œwiecie zniszczy sobie swój wewnêtrzny ³añcuch, a nastêpnie drugi bêdzie chcia³ zniszczyæ jeszcze raz to, co ju¿ przed chwil¹ zosta³o zniszczone.
</P>
<P>
Jak siê zapewne domyœlasz, tego wszystkiego wolelibyœmy raczej unikn¹æ, chyba ¿e lubisz te urocze komunikaty w stylu "program wykona³ niedozwolon¹ operacjê". Jedyne wyjœcie to napisanie w³asnego konstruktora kopiuj¹cego, który bêdzie na tyle inteligentny, ¿eby skopiowaæ w³aœciwe obiekty wewnêtrzne, a nie tylko wskaŸniki do nich.
</P>
<P>
Konstruktor kopiuj¹cy, jak siê mo¿e domyœlasz, powinien przyjmowaæ jako argument referencjê lub wskaŸnik do naszej klasy. Innymi s³owy, jest to konstruktor do inicjalizacji obiektem naszej klasy, wiêc jeœli chodzi o nag³ówek, to wystarczy w konstruktorze zmieniæ typ <SPAN CLASS=K>char</SPAN><SPAN CLASS=T>*</SPAN> na nazwê klasy. Tym razem nazwiemy j¹ <SPAN CLASS=T>Calkiem_Dobra_Klasa</SPAN>, poniewa¿ bêdzie ju¿ dzia³aæ zgodnie z oczekiwaniami ;-). Oto i ona:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Calkiem_Dobra_Klasa<BR>
{<BR>
<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* dane;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Calkiem_Dobra_Klasa(<SPAN CLASS=K>const char</SPAN>* str) { ::strcpy(dane, str); }<BR>
&nbsp;Calkiem_Dobra_Klasa(<SPAN CLASS=K>const</SPAN> Calkiem_Dobra_Klasa&); <SPAN CLASS=C>//Ÿród³o sukcesu ;-)</SPAN><BR>
&nbsp;~Calkiem_Dobra_Klasa() { <SPAN CLASS=K>delete[]</SPAN> dane; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Zmien(<SPAN CLASS=K>const</SPAN> char* str) { ::strcpy(dane, str) }<BR>
};<BR>
<BR>
<SPAN CLASS=C>//nasze panaceum - konstruktor kopiuj¹cy</SPAN><BR>
Calkiem_Dobra_Klasa::Calkiem_Dobra_Klasa(<SPAN CLASS=K>const</SPAN> Calkiem_Dobra_Klasa& s)<BR>
{<BR>
&nbsp;dane = <SPAN CLASS=K>new char</SPAN>[::strlen(s.dane) + <SPAN CLASS=L>1</SPAN>];<BR>
&nbsp;::strcpy(dane, s.dane);<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Calkiem_Dobra_Klasa T(<SPAN CLASS=L>"kwiatek"</SPAN>), U;<BR>
&nbsp;U = T;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
No i gra ;-). Teraz przy przypisaniu <SPAN CLASS=T>U = T</SPAN> do zmiennej <SPAN CLASS=T>U</SPAN> wpisujemy kopiê zmiennej <SPAN CLASS=T>T</SPAN>, ale wskaŸnik <SPAN CLASS=T>dane</SPAN> wskazuje ju¿ na inny obszar pamiêci. Wobec tego instrukcja:
</P>

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
U.Zmien(<SPAN CLASS=L>"Motylek"</SPAN>);<BR>
</TD></TR>
</TABLE>
<BR>

<P>
...nie spowoduje zamazania napisu <SPAN CLASS=L>"kwiatek"</SPAN> w zmiennej <SPAN CLASS=T>T</SPAN>. Gwoli twojej ciekawoœci dodam, ¿e u¿yte w przyk³adzie wyrazy maj¹ podkreœliæ idyllicznoœæ klas z konstruktorem kopiuj¹cym, zaœ œwiñstwa ze "z³ego" przyk³adu - dennoœæ klas bez tego konstruktora ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05c.html">Nastêpna czêœæ kursu &gt;&gt;</A></TD>
</TR>
</TABLE>

</BODY>
</HTML>