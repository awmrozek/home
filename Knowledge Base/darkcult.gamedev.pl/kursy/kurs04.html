<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kurs, funkcje</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs03a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
4. Funkcje
</H1>

<H2>
4.1 Funkcja - z czym to siê je
</H2>

Funkcje stosujesz ju¿ od pocz¹tku swojej zabawy z C++. Korzystasz przy tym g³ównie z funkcji bibliotecznych, np. <SPAN CLASS=T>printf</SPAN>, ale jedn¹ ca³y czas deklarujesz sam - jest to oczywiœcie funkcja <SPAN CLASS=T>main</SPAN>. W bardziej skomplikowanych programach bêdziesz musia³ pisaæ znacznie wiêcej funkcji. 
<BR><BR>
Pierwsze, co musisz wiedzieæ o fukcjach to to, ¿e sk³ada siê takie coœ z deklaracji, zwanej te¿ <SPAN CLASS=Wazne>prototypem funkcji</SPAN>, oraz z <SPAN CLASS=Wazne>definicji</SPAN>. Prototyp funkcji umnieszczamy zwykle na pocz¹tku programu, przed wszelkimi tej funkcji <SPAN CLASS=Wazne>wywo³aniami</SPAN>. Zawiera on tylko nazwê i typ funkcji oraz listê jej <SPAN CLASS=Wazne>argumentów</SPAN>. Definicja funkcji, zwykle znajduj¹ca siê w pliku za funkcj¹ <SPAN CLASS=T>main</SPAN>, zawiera oprócz tego równie¿ w³aœciwe cia³o funkcji, czyli wszelkie instrukcje, z jakich siê ona sk³ada oraz przynajmniej jedn¹ instrukcjê <SPAN CLASS=K>return</SPAN>.
<BR><BR>
Tutaj zatrzymajmy siê na d³u¿ej. Instrukcja <SPAN CLASS=K>return</SPAN> s³u¿y do zwracania wartoœci funkcji, jeœli wpiszemy j¹ w postaci:

<BR><BR>
<SPAN CLASS=K>return</SPAN> <SPAN CLASS=T>wartosc</SPAN>;
<BR><BR>

Zwrócenie wartoœci oznacza te¿ jednoczeœnie wyjœcie z funkcji. Natomiast samo s³owo <SPAN CLASS=K>return</SPAN> oznacza po prostu wyjœcie z funkcji, bez zwracania ¿adnej wartoœci i najczêœciej stosujemy to w funkcjach typu <SPAN CLASS=K>void</SPAN> (s³owo <SPAN CLASS=K>void</SPAN> oznacza brak konkretnego typu).
<BR><BR>
Tak wiêc prototyp funkcji ma postaæ:

<BR><BR>
<SPAN CLASS=Wazne>&lt;typ&gt; &lt;nazwa&gt; ([&lt;lista_argumentów&gt;]);</SPAN>
<BR><BR>

(zwróæ uwagê na œrednik na koñcu), natomiast definicja:

<BR><BR>
<SPAN CLASS=Wazne>
&lt;typ&gt; &lt;nazwa&gt; ([&lt;lista_argumentów&gt;])<BR>
{<BR>
&nbsp;&lt;instrukcje&gt;<BR>
}<BR>
</SPAN>
<BR><BR>

Jeszcze lepiej bêdzie, jeœli poka¿ê wszystko na konkretnym przyk³adzie. Bêdzie to funkcja, podnosz¹ca podan¹ liczbê do kwadratu:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> kwadrat(<SPAN CLASS=K>int</SPAN>);<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> podana=<SPAN CLASS=L>0</SPAN>;<BR>
<BR>
&nbsp;printf(<SPAN CLASS=L>"Podaj liczbê, która ma byæ podniesiona do kwadratu: "</SPAN>);<BR>
&nbsp;scanf(<SPAN CLASS=L>"%d"</SPAN>, &podana);<BR>
&nbsp;printf(<SPAN CLASS=L>"\n%d do kwadratu równa siê %d\n"</SPAN>, podana, kwadrat(podana));<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> kwadrat(<SPAN CLASS=K>int</SPAN> liczba)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> liczba*liczba;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Jak widzimy, na samym pocz¹tku mamy prototyp naszej nowej funkcji <SPAN CLASS=T>kwadrat</SPAN>. Zauwa¿, ¿e w nawiasach nie podaliœmy nazwy naszego argumentu - w prototypie nie jest to konieczne (ale i nie zabronione).
<BR><BR>
Mo¿na by tutaj spytaæ, czy przypadkiem funkcja <SPAN CLASS=T>main</SPAN> równie¿ nie wymaga napisania prototypu. Otó¿ nie wymaga, chocia¿ niektóre (czytaj: g³upie ;-) ) kompilatory mog¹ na nas nakrzyczeæ, jeœli tego nie zrobimy. Podobnie niektóre kompilatory (czytaj: fajne) nie wymagaj¹ obecnoœci prototypów funkcji w ogóle, ale na wszelki wypadek warto o prototypach wiedzieæ coœ niecoœ. W wiêkszoœci nastêpnych przyk³adów prototyp bêdê skrupulatnie omija³, z czystego lenistwa, ale ty masz o nim pamiêtaæ :-).
<BR><BR>
Wywo³anie funkcji, które polega po prostu na podaniu jej nazwy z nawiasami okr¹g³ymi (pamiêtaj o tych nawiasach, nawet jeœli funkcja nie ma ¿adnych argumentów), w naszym przypadku znajduje siê w drugiej instrukcji <SPAN CLASS=T>printf</SPAN>. Jako argument podajemy zmienn¹ <SPAN CLASS=T>podana</SPAN>. Teraz rzuæ okiem na definicjê funkcji <SPAN CLASS=T>kwadrat</SPAN> na koñcu. W liœcie argumentów mamy <SPAN CLASS=K>int</SPAN> <SPAN CLASS=T>liczba</SPAN>, i do zmiennej <SPAN CLASS=T>liczba</SPAN> jest w³aœnie kopiowana wartoœæ zmiennej <SPAN CLASS=T>podana</SPAN>. Funkcja <SPAN CLASS=T>kwadrat</SPAN> sk³ada siê tylko z jednej instrukcji, <SPAN CLASS=K>return</SPAN>, która oprócz wykonania obliczenia (czyli podniesienia liczby do potêgi <SPAN CLASS=L>2</SPAN>) od razu wychodzi z funkcji i zwraca obliczon¹ wartoœæ. Mam nadziejê, ¿e wszystko jest jasne...

<H2>
4.2 Przekazywanie przez wartoœæ i przez adres
</H2>

Jak ju¿ wspomnia³em, w naszym prostym przyk³adziku wartoœæ zmiennej podanej jako argument dla funkcji <SPAN CLASS=T>kwadrat</SPAN> jest kopiowana do zmiennej <SPAN CLASS=T>liczba</SPAN>. Zmienna <SPAN CLASS=T>liczba</SPAN> ma zasiêg lokalny, ograniczony do funkcji <SPAN CLASS=T>kwadrat</SPAN> - poza ni¹ nie jest dostêpna. Zwróæ uwagê - przy przekazywaniu argumentu do funkcji WARTOŒÆ jest KOPIOWANA do zmiennej lokalnej. Oznacza to, ¿e jeœli zmienimy wartoœæ zmiennej lokalnej, to <SPAN CLASS=T>podana</SPAN> nie zmieni wartoœci.  Mo¿esz to sobie sam sprawdziæ:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba = <SPAN CLASS=L>67</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> b = test(liczba);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//wypisze 67, a b bêdzie równe oczywiœcie 0</SPAN><BR>
&nbsp;printf(<SPAN CLASS=L>"liczba == %d\n"</SPAN>, liczba);<BR>
 <BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> test(<SPAN CLASS=K>int</SPAN> arg)<BR>
{<BR>
&nbsp;arg = <SPAN CLASS=L>10</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Bardzo to mi³e i przyjemne, ale s¹ i takie przypadki, ¿e chcemy jednak wykonaæ jak¹œ operacjê na jakichœ zmiennych zewnêtrznych, która to operacja ma zmieniaæ ich wartoœæ. Klasyczny przyk³ad to zamiana dwóch zmiennych wartoœciami. Nic prostszego, wystarczy jako argument przekazaæ zamiast zmiennych - ich adresy...

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>4</SPAN>, b=<SPAN CLASS=L>17</SPAN>;<BR>
<BR>
&nbsp;zamien(&a, &b);<BR>
&nbsp;printf(<SPAN CLASS=L>"Po zamianie: a == %d, b == %d\n"</SPAN>, a, b);<BR>
 <BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> zamien(<SPAN CLASS=K>int</SPAN>* liczba1, <SPAN CLASS=K>int</SPAN>* liczba2)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> temp = *liczba1; <SPAN CLASS=C>//zmienna pomocnicza</SPAN><BR>
&nbsp;*liczba1 = *liczba2;<BR>
&nbsp;*liczba2 = temp;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Tym razem zastosowaliœmy funkcjê typu <SPAN CLASS=K>void</SPAN>, czyli bez konkretnego typu, gdy¿ nie musi ona zwracaæ ¿adnej wartoœci (tylko wykonuje operacje na podanych zmiennych). Dlatego te¿ nie ma tu instrukcji <SPAN CLASS=K>return</SPAN>. Reszta programu jest chyba jasna.

<H2>
4.3 Zmienna o wielu imionach, czyli referencje
</H2>

Powy¿sze zadanie mo¿na rozwi¹zaæ kapkê proœciej, wykorzystuj¹c <SPAN CLASS=Wazne>referencje</SPAN>. A có¿ to za czort? Otó¿ jest to taka jakby dodatkowa nazwa dla zmiennej. Deklarujemy j¹ "odwrotnie" do wskaŸnika, zamiast gwiazdki po nazwie wstawiaj¹c <SPAN znak CLASS=T>&</SPAN>:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> a = <SPAN CLASS=L>10</SPAN>;<BR>
<SPAN CLASS=K>int</SPAN> ref_a& = a;
</TD></TR>
</TABLE>
<BR>

Po takiej deklaracji <SPAN CLASS=T>ref_a</SPAN> i przypisaniu jej zmiennej <SPAN CLASS=T>a</SPAN> bêdziemy mogli wszêdzie w kodzie naszego programu u¿ywaæ zapisu <SPAN CLASS=T>ref_a</SPAN> zamiast <SPAN CLASS=T>a</SPAN>. Niby bez sensu... Przydatnoœæ takiego rozwi¹zania zauwa¿ymy jednak dopiero przy funkcjach. Oto problem zamiany wartoœci zmiennych rozwi¹zany przy pomocy referencji:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>4</SPAN>, b=<SPAN CLASS=L>17</SPAN>;<BR>
<BR>
&nbsp;zamien(a, b);<BR>
&nbsp;printf(<SPAN CLASS=L>"Po zamianie: a == %d, b == %d\n"</SPAN>, a, b);<BR>
 <BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> zamien(<SPAN CLASS=K>int</SPAN>&liczba1, <SPAN CLASS=K>int</SPAN>& liczba2)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> temp = liczba1; <SPAN CLASS=C>//zmienna pomocnicza</SPAN><BR>
&nbsp;liczba1 = liczba2;<BR>
&nbsp;liczba2 = temp;<BR>
}
</TD></TR>
</TABLE>
<BR>

Jak widaæ, wszystko tak samo jak na górze, tylko mniej dziwnych znaczków :-).

<H2>
4.4 Funkcja main nie gêœ...
</H2>

...i swoje argumenty ma. Mo¿emy uzupe³niæ jej listê argumentów, i w ten prosty sposób uzyskaæ dostêp do parametrów, które wpisuje u¿ytkownik naszego programiku w <SPAN CLASS=Wazne>linii poleceñ</SPAN>. Robi siê to tak:

<BR><BR>
<SPAN CLASS=T>
<SPAN CLASS=K>int</SPAN> main(<SPAN CLASS=K>int</SPAN> argc, <SPAN CLASS=K>char</SPAN>* argv[])
</SPAN>
<BR><BR>

Od tej pory mo¿emy w naszym programie korzystaæ ze zmiennej <SPAN CLASS=T>argc</SPAN>, która zawiera liczbê parametrów z <SPAN CLASS=Wazne>linii poleceñ</SPAN>, oraz z tablicy <SPAN CLASS=T>argv</SPAN>, której kolejne argumenty to kolejne fragmenty owej linii poleceñ. Tak wiêc liczba elementów <SPAN CLASS=T>argv</SPAN> jest równa <SPAN CLASS=T>argc</SPAN>. Drugi element <SPAN CLASS=T>argv</SPAN> (czyli <SPAN CLASS=T>argv[<SPAN CLASS=L>1</SPAN>]</SPAN>) zawiera pierwszy parametr z linii poleceñ, <SPAN CLASS=T>argv[<SPAN CLASS=L>2</SPAN>]</SPAN> - drugi itp. W <SPAN CLASS=T>argv[<SPAN CLASS=L>0</SPAN>]</SPAN> zawarta jest nazwa pliku z naszym programem, natomiast <SPAN CLASS=T>argv[argc]</SPAN> jest pusty. Czyli jeœli wywo³amy nasz program poleceniem:

<BR><BR>
<SPAN CLASS=Wazne>
prog1 /opcja
</SPAN>
<BR><BR>

to argumenty funkcji <SPAN CLASS=T>main</SPAN> bêd¹ takie:

<BR><BR>
<SPAN CLASS=Wazne>
argc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=L>2</SPAN><BR>
argv[0] <SPAN CLASS=L>"prog1"</SPAN><BR>
argv[1] <SPAN CLASS=L>"/opcja"</SPAN><BR>
argv[2] <SPAN CLASS=L>0</SPAN>
</SPAN>
<BR><BR>

Programu przyk³adowego nie bêdzie, bo autor jest patentowanym leniem :-).

<H2>
4.5 Nie daj siê wyrolowaæ, czyli funkcje rozwijalne
</H2>

Fukcje tego typu, co <SPAN CLASS=T>kwadrat</SPAN> z przyk³adu z pocz¹tku tej czêœci kursu, czyli cholernie krótkie, czasami bywaj¹ w programie wywo³ywane np. ze œrodka jakiejœ pêtli, a wiêc cholernie czêsto. W takiej sytuacji szybciej by komputerowi posz³o, gdyby zamiast wywo³ania danej funkcji wstawiæ te kilka linijek jej instrukcji (czyli tzw. cia³o funkcji). Sama operacja wywo³ywania funkcji mo¿e siê bowiem okazaæ na tyle czasoch³onna (w skali wszystkich instrukcji tej funkcji oczywiœcie, bo dla cz³owieka to nadal mgnienie oka), ¿e po prostu nie op³aca³oby siê w ogóle robiæ odrêbnej fukcji dla danego zadania. Programista oczywiœcie raczej nie chcia³by rezygnowaæ z umieszczenia tych kilku linijek w funkcji, poniewa¿ po pierwsze nie chcia³oby mu siê wpisywaæ tego w ka¿dym miejscu programu, a po drugie odpowiednio czêste korzystanie z funkcji zamiast z "go³ych" instrukcji znacznie zwiêksza przejrzystoœæ programu.
<BR><BR>
Z powodów tych istnieje w C++ s³owo <SPAN CLASS=K>inline</SPAN>, które pozwala nam zadeklarowaæ normaln¹ funkcjê, któr¹ jednak kompilator bêdzie traktowa³ jako rozwijaln¹, czyli w ka¿de miejsce, w którym wywo³ujemy funkcjê wstawi wszystkie instrukcje, które ona zawiera. Tym samym nasz program bêdzie dzia³a³ identycznie, jak bez tego <SPAN CLASS=K>inline</SPAN>, ale nie bêdzie niepotrzebnie traci³ czasu na dostêp do instrukcji zawieranych przez nasz¹ k³opotliw¹ funkcjê. Z drugiej strony, kod wykonywalny mo¿e siê trochê powiêkszyæ. Zreszt¹ spójrz na przyk³ad. Jeœli napiszemy:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>inline int</SPAN> kwadrat(<SPAN CLASS=K>int</SPAN> liczba) {<SPAN CLASS=K>return</SPAN> liczba*liczba;}<BR>
</TD></TR>
</TABLE>
<BR>

to nastêpuj¹cy kod:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>3</SPAN>, b=<SPAN CLASS=L>8</SPAN>, w1, w2;<BR>
<BR>
&nbsp;w1 = kwadrat(a);<BR>
&nbsp;w2 = kwadrat(b);<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>; <BR>
}
</TD></TR>
</TABLE>
<BR>

zostanie zinterpretowany jako:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>3</SPAN>, b=<SPAN CLASS=L>8</SPAN>, w1, w2;<BR>
<BR>
&nbsp;w1 = a*a;<BR>
&nbsp;w2 = b*b;<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>; <BR>
}
</TD></TR>
</TABLE>
<BR>

Po tym wszystkim mog³oby siê wydawaæ, ¿e nale¿y stosowaæ <SPAN CLASS=K>inline</SPAN>, kiedy tylko siê da. A nieprawda. Oto bowiem kompilator przy odpowiednio prostych funkcjach sam traktuje je jako rozwijalne, wiêc dopisuj¹c <SPAN CLASS=K>inline</SPAN> niepotrzebnie zu¿ywasz klawiaturê ;-). W dodatku czasami mo¿esz niechc¹cy u¿yæ tego s³ówka w przypadku funkcji, która na rozwijaln¹ siê nie nadaje (np. jest za d³uga), i nieszczêœcie gotowe ;-). Poruszy³em to zagadnienie tylko po to, byœ mia³ œwiadomoœæ jego istnienia, no i ¿eby nikt nie kwestionowa³ mojej rzetelnoœci :-).

<H2>
4.6 Jak szybko zawiesiæ program, czyli rekurencja
</H2>

<SPAN CLASS=Wazne>Rekurencja</SPAN> robi siê nam wtedy, gdy funkcja wywo³uje sam¹ siebie. Wbrew ewentualnym pozorom, nie zawsze jest to zjawisko szkodliwe, czêsto jest bardzo przydatne, a do niektórych zagadnieñ wrêcz niezbêdne. Rzecz w tym, ¿e funkcjê rekurencyjn¹ trzeba niezwykle starannie zaprojektowaæ, bo inaczej nasz program bêdzie siê zawiesza³, powodowa³ prze³adowanie stosu i inne niemi³e rzeczy. Sêk w tym, abyœmy napisali dobry warunek wyjœcia z funkcji.
<BR><BR>
Typowym problemem, rozwi¹zywalnym praktycznie tylko na drodze rekurencji, jest wyszukiwanie plików. Dajmy na to, ¿e stworzyliœmy funkcjê <SPAN CLASS=T>PrzeszukajKatalog</SPAN>. Funkcja ta tworzy listê plików w podanym katalogu, oraz podkatalogów wewn¹trz aktualnie przeszukiwanego. Nastêpnie ka¿dy z tych podkatalogów trzeba oddzielnie przeszukaæ - a wiêc dla ka¿dego podkatalogu nasza funkcja <SPAN CLASS=T>PrzeszukajKatalog</SPAN> musi wywo³aæ funkcjê <SPAN CLASS=T>PrzeszukajKatalog</SPAN> (czyli sam¹ siebie, jak byæ mo¿e ktoœ bystry zauwa¿y³ ;-) ). Za ka¿dym razem, kiedy funkcja wywo³uje sam¹ siebie, jej dzia³anie jest wstrzymywane, a stan funkcji zapisywany na stos (coœ jak savegame w grach), po czym wywo³ywana jest kopia tej funkcji. Kiedy kopia, i jej ewentualne "podkopie" zrobi¹, co maj¹ do zrobienia, funkcja-matka pobierana jest z powrotem ze stosu i jej dzia³anie jest kontynuowane.
<BR><BR>
Teraz konkretny przyk³adzik: obliczanie NWD (najwiêkszego wspólnego dzielnika :-) ). Na razie bez rekurencji:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> nwd(<SPAN CLASS=K>int</SPAN> a, <SPAN CLASS=K>int</SPAN> b)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> temp;<BR>
<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(b)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;temp = b;<BR>
&nbsp;&nbsp;b = a % b;<BR>
&nbsp;&nbsp;a = temp;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> a;<BR>
}
</TD></TR>
</TABLE>
<BR>

oraz to samo z rekurencj¹:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> nwd_r(<SPAN CLASS=K>int</SPAN> a, <SPAN CLASS=K>int</SPAN> b)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(b==<SPAN CLASS=L>0</SPAN>) <SPAN CLASS=K>return</SPAN> x;<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> nwd_r(b, a % b);<BR>
}
</TD></TR>
</TABLE>
<BR>

W tym przypadku wersja rekurencyjna jest sporo krótsza od "zwyk³ej", ale nie zawsze tak jest, dlatego te¿ jeœli da siê rozwi¹zaæ jakiœ problem "klasycznie", to lepiej nie bawiæ siê w rekurencjê. Wersja rekurencyjna, nawet jeœli krótsza od "zwyk³ej", zu¿ywa znacznie wiêcej zasobów systemowych, dlatego te¿ bywa ma³o bezpieczna. W dodatku trzeba nieŸle wysiliæ zwoje mózgowe, ¿eby wyobraziæ sobie, jak ta rekurencja w danym przypadku w ogóle dzia³a - spójrz na powy¿szy przyk³ad, jest on tak krótki, ¿e a¿ podejrzany ;-).

<H2>
4.7 Coœ trochê dziwnego, czyli wskaŸniki do funkcji
</H2>

Kiedyœ, w pocz¹tkach mojego zainteresowania C++, pewien kolo tworz¹cy jakieœ menu w jakimœ programie zapyta³ mnie, czy nie da³oby siê zapisaæ jakoœ funkcji w tablicach i dziêki temu zrobiæ to menu w jednej instrukcji. Wtedy wyda³o mi siê to bardzo naiwne, wiêc bardzo siê zdziwi³em, gdy póŸniej przeczyta³em o wskaŸnikach do funkcji.
<BR><BR>
WskaŸnik do funkcji pozwala nam uzyskaæ <SPAN CLASS=Wazne>adres funkcji</SPAN>. Dziêki temu mo¿emy j¹ wywo³ywaæ poœrednio, tak jak w poprzedniej czêœci kursu uzyskiwaliœmy poœredni dostêp do zmiennych. Nic nie stoi równie¿ na przeszkodzie, aby przechowywaæ takie wskaŸniki w tablicach. Jednak najwa¿niejszym zastosowaniem takich wskaŸników jest mo¿liwoœæ przekazywania ich do funkcji jako argumenty oraz zwracanie ich instrukcj¹ <SPAN CLASS=K>return</SPAN>. Dziêki temu mo¿emy na przyk³ad napisaæ funkcjê biblioteczn¹, która przejmuje obs³ugê klawiatury czy zegara systemowego i przekazujê t¹ obs³ugê funkcji o podanym adresie. Wiele tego rodzaju przyk³adów mo¿e dostarczyæ np. znana biblioteka Allegro. 
<BR><BR>
Deklaracja wskaŸnika do funkcji wygl¹da np. tak:

<BR><BR>
<SPAN CLASS=T>
<SPAN CLASS=K>int</SPAN> (*wsk_do_f)();
</SPAN>
<BR><BR>

przypisanie mu adresu przyk³adowej funkcji <SPAN CLASS=T>f</SPAN>:

<BR><BR>
<SPAN CLASS=T>
wsk_do_f = &f;
</SPAN>
<BR><BR>

a poœrednie wywo³anie funkcji <SPAN CLASS=T>f</SPAN>:

<BR><BR>
<SPAN CLASS=T>
(*wsk_do_f)();
</SPAN>
<BR><BR>

lub po prostu:

<BR><BR>
<SPAN CLASS=T>
wsk_do_f();
</SPAN>
<BR><BR>

Oczywiœcie typ wskaŸnika musi byæ taki sam, jak typ funkcji, a ponadto wskaŸnik musi mieæ tak¹ sam¹ listê argumentów, np:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>long double</SPAN> f(<SPAN CLASS=K>char</SPAN>*, <SPAN CLASS=K>int</SPAN>, <SPAN CLASS=K>float</SPAN>); <SPAN CLASS=C>//prototyp wskazywanej funkcji</SPAN><BR>
<SPAN CLASS=K>long double</SPAN> (*wsk_do_f)(<SPAN CLASS=K>char</SPAN>*, <SPAN CLASS=K>int</SPAN>, <SPAN CLASS=K>float</SPAN>) = &f; <SPAN CLASS=C>//wskaŸnik do f</SPAN>
</TD></TR>
</TABLE>
<BR>

<H2>
4.8 Funkcje-atleci, czyli przeci¹¿anie funkcji
</H2>

Zdarza siê, ¿e mamy w programie dwie funkcje, które wykonuj¹ podobne czynnoœci, ale ka¿da z nich operuje na innym typie danych. Gdyby tak mo¿na by³o nazwaæ je tak samo, by³oby nam bardzo wygodnie, bo nie musielibyœmy pisaæ osobnych wywo³añ dla ka¿dej z nich. Wtedy po prostu wywo³ywalibyœmy wspóln¹ nazwê funkcji, a kompilator sam decydowa³by, która z kilku funkcji o tej samej nazwie bardziej pasowa³aby do podanych argumentów.
<BR><BR>
Twórcy jêzyka C++ pomyœleli o tym i co wiêcej, myœl tê wprowadzili w ¿ycie. Takie przystosowywanie funkcji do wykonywania ró¿nych dodatkowych zadañ nazywa siê przeci¹¿aniem funkcji. Na przyk³ad:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> test;<BR>
&nbsp;test = funkcja(<SPAN CLASS=L>3.1</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> funkcja(<SPAN CLASS=K>int</SPAN> argument) { <SPAN CLASS=C>/* instrukcje */</SPAN> }<BR>
<SPAN CLASS=K>int</SPAN> funkcja(<SPAN CLASS=K>double</SPAN> argument) { <SPAN CLASS=C>/* instrukcje */</SPAN> }
</TD></TR>
</TABLE>
<BR>

Mamy tutaj dwie funkcje o tej samej nazwie; za³ó¿my, ¿e wykonuj¹ one podobne operacje, tylko ¿e pierwsza pobiera argument bêd¹cy liczb¹ <SPAN CLASS=K>int</SPAN>, a druga - <SPAN CLASS=K>double</SPAN>. Poniewa¿ liczba <SPAN CLASS=L>3.1</SPAN> pasuje bardziej do typu <SPAN CLASS=K>double</SPAN> (jej konwersja na <SPAN CLASS=K>int</SPAN> spowodowa³aby utratê czêœci u³amkowej), wiêc wywo³ana bêdzie ta druga wersja funkcji <SPAN CLASS=T>funkcja</SPAN>.


<H2>
4.9 Zmienne statyczne
</H2>

Wszystkie zmienne, zadeklarowane wewn¹trz jakiejœ funkcji, s¹ tzw. <SPAN CLASS=Wazne>zmiennymi lokalnymi</SPAN> - niedostêpnymi na zewn¹trz i w dodatku nie zachowuj¹cymi swojej wartoœci po ka¿dym wywo³aniu macierzystej funkcji. Oznacza to, ¿e nie mo¿emy przy ich pomocy np. liczyæ wywo³añ danej funkcji:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> funkcja()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> licznik;<BR>
&nbsp;<SPAN CLASS=C>//<BR>
&nbsp;//jakieœ instrukcje<BR>
&nbsp;//</SPAN><BR>
&nbsp;licznik++;<BR>
&nbsp;printf(<SPAN CLASS=L>"%d"</SPAN>, licznik);<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

W powy¿szym przyk³adzie zmienna <SPAN CLASS=T>licznik</SPAN> jest "resetowana" za ka¿dym razem, gdy wywo³ywana jest <SPAN CLASS=T>funkcja</SPAN>, za ka¿dym razem wyœwietlana jest wiêc liczba <SPAN CLASS=L>0</SPAN>, co zupe³nie nie odpowiada naszym zamiarom. Recepta na ten ból jest prosta: dodajemy s³ówko <SPAN CLASS=K>static</SPAN> przed deklaracj¹ naszej zmiennej <SPAN CLASS=T>licznik</SPAN> i sprawdzamy, co siê dzieje:

<BR><BR>
<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> funkcja()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>static int</SPAN> licznik;<BR>
&nbsp;<SPAN CLASS=C>//<BR>
&nbsp;//jakieœ instrukcje<BR>
&nbsp;//</SPAN><BR>
&nbsp;licznik++;<BR>
&nbsp;printf(<SPAN CLASS=L>"%d"</SPAN>, licznik);<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>

Dzieje siê tyle, ¿e teraz nasz <SPAN CLASS=T>licznik</SPAN> jest statyczny, zachowuje swoj¹ wartoœæ przez ca³y czas dzia³ania programu i nic go stamt¹d nie wykurzy, chyba ¿e sami tego chcemy. Wobec tego <SPAN CLASS=T>printf</SPAN> przy ka¿dym kolejnym wywo³aniu bêdzie wyœwietla³ coraz wiêksze liczby. Muzyczka gra...

<BR><BR>

<HR WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs03a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kurs05.html">Nastêpna czêœæ kursu >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>