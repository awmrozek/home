<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Szablony, cz. 1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs07.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs08a.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Szablony
</H1>

<P>
Przed nami prawdziwa wunderwaffe jêzyka C++, a zarazem jeden z jego najistotniejszych sk³adników, bez którego wielu ludzi ju¿ nie wyobra¿a sobie programowania.
</P>

<H2>
Szablony funkcji
</H2>

<P>
Byæ mo¿e zdarzy³o ci siê kiedyœ napisaæ funkcjê, która wykonywa³a jak¹œ operacjê na jakimœ konkretnym typie danych, a nastêpnie musia³eœ j¹ przeci¹¿yæ na rzecz innego typu. W rezultacie powsta³y dwie, a mo¿e nawet wiêcej funkcji, które by³y niemal dok³adnymi kopiami (bo wykonywa³y takie same czynnoœci), a ró¿ni³y siê jedynie typami argumentów, typami zwracanymi i ewentualnie typami jakichœ pomocniczych zmiennych lokalnych. Takie funkcje (a jeszcze czêœciej - ca³e klasy, ale o tym nieco póŸniej) zdarzaj¹ siê programistom ca³kiem czêsto, doprowadzaj¹c ich tym samym do bia³ej gor¹czki (takie przeci¹¿anie jest wyj¹tkowo nudne i ¿mudne). Podsunê³o to twórcom jêzyka C++ pomys³ wprowadzenia szablonów.
</P>
<P>
Sam szablon nie jest formalnie kodem wykonywalnym, tylko "instrukcj¹" dla kompilatora, w jaki sposób ma on wykonaæ w³aœciwy "egzemplarz" funkcji. Coœ jakby foremka, dziêki której mo¿na wykonaæ wiele babek z piasku ;-). Z tym, ¿e babki raczej nie ró¿ni¹ siê miêdzy sob¹ niczym (chyba, ¿e ich twórca wypi³ za du¿o soczku i stawia³ je krzywo), natomiast funkcje generowane z szablonu MUSZ¥ siê ró¿niæ parametrami, a konkretnie typem przynajmniej jednego z parametrów.
</P>
<P>
Doœæ paplania, zabierzmy siê za konkretny przyk³ad. Niech bêdzie to banalna funkcja, obliczaj¹ca kwadrat podanej liczby:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> Kwadrat(<SPAN CLASS=K>int</SPAN> L)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> L*L;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, zarówno typ argumentu, jak i typ zwracany funkcji to <SPAN CLASS=K>int</SPAN>. Ktoœ mo¿e jednak dojœæ do wniosku, ¿e nie potrzebuje obliczaæ kwadratów a¿ tak du¿ych liczb, a za to bardzo zale¿y mu na wydajnoœci funkcji <SPAN CLASS=T>Kwadrat</SPAN>, w zwi¹zku z czym wystarczy, ¿eby typem argumentu (oraz funkcji) by³ <SPAN CLASS=K>short</SPAN>, a nawet <SPAN CLASS=K>unsigned char</SPAN>. Jeszcze póŸniej ten sam ktoœ byæ mo¿e dojdzie do wniosku, ¿e w pewnym miejscu jego programu zajdzie potrzeba obliczenia kwadratu liczby 64-bitowej albo liczby zmiennoprzeciwkowej (<SPAN CLASS=K>float, double</SPAN>...). Tak wiêc nasz ktoœ musi powieliæ kod swojej funkcyjki <SPAN CLASS=T>Kwadrat</SPAN> w taki mniej wiêcej sposób:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kwadrat(<SPAN CLASS=K>int</SPAN> L)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <SPAN CLASS=K>return</SPAN> L*L; }<BR>
<SPAN CLASS=K>short</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kwadrat(<SPAN CLASS=K>short</SPAN> L)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   { <SPAN CLASS=K>return</SPAN> L*L; }<BR>
<SPAN CLASS=K>unsigned char</SPAN> Kwadrat(<SPAN CLASS=K>unsigned char</SPAN> L)   { <SPAN CLASS=K>return</SPAN> L*L; }<BR>
<SPAN CLASS=K>float</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kwadrat(<SPAN CLASS=K>float</SPAN> L)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <SPAN CLASS=K>return</SPAN> L*L; }<BR>
<SPAN CLASS=K>int64_</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kwadrat(<SPAN CLASS=K>int64_</SPAN> L)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <SPAN CLASS=K>return</SPAN> L*L; }<BR>
</TD></TR>
</TABLE>

<P>
Widaæ jak na d³oni (po to w³aœnie te œmieszne tabulacje), ¿e cia³a tych przeci¹¿onych funkcji s¹ identyczne, ró¿nice s¹ tylko w typach argumentów i typach zwracanych. Oczywiœcie, w tak prostym przypadku wcale nam to nie przeszkadza, mo¿e nawet wrêcz przeciwnie. Ale to tylko przyk³ad, w praktyce zdarzaj¹ siê o wiele bardziej skomplikowane sytuacje... I tutaj w³aœnie pasuje nam zrobiæ szablonik:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;
TYP Kwadrat(TYP L)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> L*L;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Typ funkcji oraz typ jej jedynego argumentu <SPAN CLASS=Wazne>sparametryzowaliœmy</SPAN>. Uczyniliœmy to, dodaj¹c na poczatku nag³ówka s³owo kluczowe <SPAN CLASS=K>template</SPAN>, a nastêpnie deklaruj¹c <SPAN CLASS=Wazne>parametr szablonu</SPAN>, którym jest tutaj <SPAN CLASS=Wazne>nazwa typu</SPAN> (w nawiasach trójk¹tnych).
</P>

<P class=UWAGA>
Parametrem szablonu nie musi byæ koniecznie nazwa typu; mo¿e nim byæ praktycznie cokolwiek. Jednak¿e w tym kursie interesuj¹ nas w tym przypadku tylko nazwy typów.
</P>

<P>
Aby zadeklarowaæ nazwê typu jako parametr szablonu, u¿ywamy s³owa kluczowego <SPAN CLASS=K>typename</SPAN>. Zadeklarowany parametr od tej pory staje siê "uniwersaln¹" nazw¹ typu w danym szablonie (w wiêkszoœci przypadków zastêpujemy t¹ nazw¹ wszystkie istotne deklaracje zarówno w nag³ówku, jak i w ciele funkcji). Dziêki niemu mo¿emy w naszym przyk³adowym programie obliczyæ kwadrat dowolnej wartoœci zapisanej w zmiennej numerycznej.
</P>

<P class=UWAGA>
Zamiast s³owa typename w starszych kompilatorach u¿ywa³o siê s³owa <SPAN CLASS=K>class</SPAN>. Obecnie nadal jest ono dozwolone (w tym kontekœcie <SPAN CLASS=K>typename</SPAN> i <SPAN CLASS=K>class</SPAN> s¹ synonimami), aczkolwiek zalecane jest stosowanie tego pierwszego ze wzglêdu na to, ¿e lepiej oddaje ono sens parametrów szablonu (które niekoniecznie musz¹ byæ klasami w pe³nym tego s³owa znaczeniu).
</P>

<P>
A jak w³aœciwie u¿yæ funkcji szablonowej? Dok³adnie tak samo, jak zwyk³ej funkcji! Kompilator sprawdzi typ podanego przy wywo³aniu argumentu i u¿yje szablonu, by <SPAN CLASS=Wazne>automatycznie</SPAN> wygenerowaæ najlepiej pasuj¹c¹ "wariacjê" funkcji. Programista musi tylko ewentualnie ustaliæ, czy to automatyczne dopasowanie na pewno mu odpowiada, a o resztê martwiæ siê ju¿ nie musi. Tak wiêc ju¿ w tym momencie uwidacznia siê kolejna wielka zaleta szablonów. Pora na trochê praktyki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#include &lt;iostream.h&gt;<BR>
</SPAN>
<BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;
TYP Kwadrat(TYP L)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> L*L;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>short</SPAN> t = <SPAN CLASS=L>3</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> i = <SPAN CLASS=L>1000000</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>float</SPAN> f = <SPAN CLASS=L>7.5</SPAN>;<BR>
<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"t="</SPAN> &lt;&lt; Kwadrat(t)<BR>
&nbsp;&lt;&lt; <SPAN CLASS=L>", i="</SPAN> &lt;&lt; Kwadrat(i)<BR>
&nbsp;&lt;&lt; <SPAN CLASS=L>", f="</SPAN> &lt;&lt; Kwadrat(f) &lt;&lt; endl;<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Kompilator w tym wypadku zakasa rêkawy, rzuci okiem na kod i od razu zauwa¿y, ¿e mamy w nim szablon. Wtedy rzuci okiem po raz drugi i znajdzie w kodzie trzy wywo³ania szablonowej funkcji <SPAN CLASS=T>Kwadrat</SPAN>. Stwierdzi, ¿e pierwsze jest dla parametru <SPAN CLASS=K>short</SPAN>, drugie - <SPAN CLASS=K>int</SPAN>, trzecie - <SPAN CLASS=K>float</SPAN>. Tak wiêc wygenerowane zostan¹ trzy "wersje" funkcji <SPAN CLASS=T>Kwadrat</SPAN> i ka¿da bêdzie wywo³ana w odpowiednim miejscu.
</P>

<h2>
Szablony klas
</h2>

<P>
Mo¿emy te¿ robiæ szablony ca³ych klas i w praktyce s¹ one wykorzystywane znacznie czêœciej, ni¿ szablony funkcji. Chocia¿by dlatego, ¿e przy równie niewielkim nak³adzie pracy mo¿emy dziêki nim zaoszczêdziæ jeszcze wiêcej czasu i nerwów. Szablony klas dzia³aj¹ na bardzo podobnych zasadach. Przyk³adowo, mo¿emy zrobiæ klasê <SPAN CLASS=T>Tablica</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane, <SPAN CLASS=K>typename</SPAN> TIterator&gt;
<SPAN CLASS=K>class</SPAN> Tablica<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;&nbsp;TDane* dane;<BR>
&nbsp;&nbsp;TIterator liczba;<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
&nbsp;<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;&nbsp;Tablica();<BR>
&nbsp;&nbsp;~Tablica();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>bool</SPAN> Dodaj(TDane* elem);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>bool</SPAN> Alokuj(TIterator ile);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Czysc();<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ...</SPAN> <BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W szczegó³y implementacyjne nie bêdziemy siê bawiæ, chodzi tylko o pokazanie, jak dzia³aj¹ szablony klas. Widzimy, ¿e zgodnie z tym co przed chwil¹ powiedzia³em, przypominaj¹ one szablony funkcji (no proszê, nie ok³ama³em was :D). Tu równie¿ poprzedzamy definicjê (w tym przypadku bêd¹c¹ jednoczeœnie deklaracj¹) s³owem <SPAN CLASS=K>template</SPAN> oraz list¹ parametrów szablonu. Tym razem wprowadziliœmy dwa parametry: <SPAN CLASS=T>TDane</SPAN> oznacza typ danych, przechowywanych w tablicy (czyli typ pojednyczego elementu), natomiast <SPAN CLASS=T>TIterator</SPAN> - typ licznika / zmiennej indeksuj¹cej tablicê (najczêœciej <SPAN CLASS=K>int</SPAN> lub unsigned <SPAN CLASS=K>int</SPAN>, ale ktoœ mo¿e sobie przecie¿ za¿yczyæ inny).
</P>
<P>
Ró¿nica w u¿yciu szablonu klasy i szablonu funkcji jest taka, ¿e w tym pierwszym przypadku nale¿y podaæ parametry szablonu przy ka¿dej deklaracji obiektu danej klasy. To znaczy, ¿e nie mo¿emy po prostu zadeklarowaæ obiektu <SPAN CLASS=T>Tablica</SPAN>, poniewa¿ by³aby to deklaracja niejednoznaczna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Tablica tab; <SPAN CLASS=C>//cholernie Ÿle!</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Kompilator po prostu dosta³by krêæka, bo nie wiedzia³by, jakiego typu s¹ niektóre zmienne sk³adowe oraz metody klasy <SPAN CLASS=T>Tablica</SPAN> (te mianowicie, które zadeklarowaliœmy jako typ <SPAN CLASS=T>TDane</SPAN> lub <SPAN CLASS=T>TIterator</SPAN>). Deklaracja obiektu, wykorzystuj¹cego szablon musi wygl¹daæ tak (lub podobnie):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Tablica&lt;DWORD, DWORD&gt;  tab1; <SPAN CLASS=C>//dobrze</SPAN><BR>
Tablica&lt;HFONT, <SPAN CLASS=K>int</SPAN>&gt; &nbsp;&nbsp;tab2; <SPAN CLASS=C>//te¿ dobrze</SPAN><BR>
Tablica&lt;string,<SPAN CLASS=K> long</SPAN>&gt; tab3; <SPAN CLASS=C>//te¿ dobrze</SPAN><BR>
Tablica&lt;string*, <SPAN CLASS=K>int</SPAN>&gt; tab4; <SPAN CLASS=C>//te¿ mo¿e byæ</SPAN><BR>
</TD></TR>
</TABLE>

<H2>
Umiejscowienie kodu szablonów
</H2>

<P>
Jeœli szablony umieœci siê tak, jak w powy¿szym przyk³adzie z funkcj¹ <SPAN CLASS=T>Kwadrat</SPAN> (czyli ca³y kod w jednym pliku), to wszystko chodzi jak w zegarku szwajcarskim. Ale spróbuj tylko przenieœæ szablon do innego pliku (z pewnoœci¹ wymaga³aby tego estetyka, a wkrótce te¿ dosz³yby do tego czysto techniczne przes³anki) - prawie na pewno pojawi¹ siê zgrzyty. Có¿, nie ma ró¿y bez kolców, a ¿e szablony s¹ ró¿yczk¹ wyj¹tkowo kolorow¹ i pachn¹c¹, to i kolce maj¹ ogromne i k³uj¹ce jak jasny gwint.
</P>
<P>
Jeœli jesteœ szczêœliwym posiadaczem nowoczesnego kompilatora, takiego jak w Visual Studio .NET 2003, to mo¿esz skorzystaæ z zaklêcia <SPAN CLASS=K>export</SPAN> (które w dodatku jest "jeszcze ciep³e" i jeszcze nie do koñca sprawdzone w praktyce). Kompilator stosowany w Dev-C++ takiej mo¿liwoœci na razie nie posiada, chocia¿ widaæ, ¿e jego twórcy poczynili ju¿ pewne kroki w kierunku jego wprowadzenia (w przypadku u¿ycia pojawia siê specjalne ostrze¿enie, ¿e s³owo <SPAN CLASS=K>export</SPAN> nie jest jeszcze zaimplementowane i ¿e bêdzie zignorowane).
</P>
<P>
Tak wiêc pozostaje nam tylko doœæ hardkorowe (a w ka¿dym razie niezbyt eleganckie) rozwi¹zanie, polegaj¹ce na umieszczeniu CA£EGO kodu szablonu (deklaracja + definicja) w pliku nag³ówkowym, który nastêpnie do³¹czymy do reszty kodu dyrektyw¹ <SPAN CLASS=C>#include</SPAN>...
</P>
<P>
Tyle w tym dobrego, ¿e mo¿emy tradycyjnie oddzieliæ deklaracjê od definicji, co w przypadku klas bardziej z³o¿onych od tych, które tu sobie przytaczamy jako przyk³ady, znacznie zwiêksza przejrzystoœæ kodu. Tylko... jak to zrobiæ? Otó¿ musimy pamiêtaæ o dwóch rzeczach. Po pierwsze - ka¿da metoda szablonu klasy musi zostaæ oddzielnie opatrzona s³ówkiem <SPAN CLASS=K>template</SPAN> oraz nawiasami trójk¹tnymi z deklaracj¹ parametrów szablonu. Po drugie - w okreœleniu "pochodzenia" metody musimy równie¿ podaæ nawias trójk¹tny z parametrami szablonu (innymi s³owy - nazwa klasy szablonowej W KA¯DYM MIEJSCU kodu Ÿród³owego musi mieæ postaæ: <SPAN CLASS=T>nazwa_klasy&lt;lista_parametrów&gt;</SPAN>). Jako przyk³ad zdefiniujemy metodê <SPAN CLASS=T>Dodaj</SPAN> klasy <SPAN CLASS=T>Tablica</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
//DEKLARACJA KLASY</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane, <SPAN CLASS=K>typename</SPAN> TIterator&gt;<BR>
<SPAN CLASS=K>class</SPAN> Tablica<BR>
{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>bool</SPAN> Dodaj(TDane* elem);  <BR>
&nbsp;&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
};<BR>
<BR>
<SPAN CLASS=C>//DEFINICJA METODY<BR></SPAN>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane, <SPAN CLASS=K>typename</SPAN> TIterator&gt;<BR>
Tablica&lt;TDane, TIterator&gt;::Dodaj(TDane* elem)<BR>
{<BR>
&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Tak wiêc trochê pisaniny z tym jest i gdybyœmy mieli wykorzystaæ taki szablon do wygenerowania zaledwie jednej "wersji" klasy <SPAN CLASS=T>Tablica</SPAN>, to by³oby to ewidentne marnotrawstwo czasu i klawiatury ;-). Za to ju¿ przy dwóch-trzech "wersjach" (co w wiêkszych programach i w przypadku tak uniwersalnych kategorii klas, jak nasza przyk³adowa klasa <SPAN CLASS=T>Tablica</SPAN> jest niemal nie do unikniêcia) oszczêdnoœæ by³aby widoczna go³ym okiem.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs07.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs08a.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>
