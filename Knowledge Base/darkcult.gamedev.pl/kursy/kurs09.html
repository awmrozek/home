<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Dynamiczna Kontrola Typów</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs10.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Statyczne rzutowanie
</h2>

<P>
Zanim zaczniemy siê faktycznie bawiæ dynamiczn¹ kontrol¹ typów, poznamy trzy nowe operatory, które do jêzyka C++ dosta³y siê niejako "przy okazji" wprowadzania mechanizmu RTTI (<span class=Inglisz>Run-Time Type Information</SPAN> - informacja o typie w fazie wykonania programu), bo s³u¿¹ w³aœciwie do czego innego.
</P>
<P>
Pierwszym jest operator zwyk³ego, statycznego rzutowania.
</P>

<P class=UWAGA>
Generalnie s³owo "konwersja" jakoœ bardziej mi pasuje jako nazwa dla operacji zmiany typu. Poniewa¿ jednak operatory jêzyka C++ odpowiedzialne za tê czynnoœæ maj¹ w nazwie "cast", wiêc utar³o siê, ¿eby nazywaæ zmianê typu rzutowaniem (chocia¿ po angielsku "cast" znaczy "rzucaæ", nie "rzutowaæ"). A konwersjê w stylu C (z nawiasami okrag³ymi) bêdê nadal nazywa³ po prostu konwersj¹.</P>

<P>
Wspomniany operator zastêpuje konwersjê przy u¿yciu nawiasów okr¹g³ych, która jest pozosta³oœci¹ z jêzyka C, niezbyt lubian¹ przez niektórych programistów. Dlaczego niezbyt lubian¹? Po pierwsze, gwa³townie zwiêkszaj¹ liczbê nawiasów w wyra¿eniach, co nie wp³ywa najlepiej na jego przejrzystoœæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> a, b = <SPAN CLASS=L>2</SPAN>, c = <SPAN CLASS=L>4</SPAN>;<BR>
a = (<SPAN CLASS=K>int</SPAN>)((<SPAN CLASS=K>float</SPAN>)(b+<SPAN CLASS=L>1</SPAN>)/(<SPAN CLASS=K>float</SPAN>)(c+<SPAN CLASS=L>1</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
Musisz przyznaæ, ¿e oczopl¹su mo¿na dostaæ, patrz¹c na tê drug¹ linijkê. A przecie¿ jest to zwyk³a zamiana liczb ca³kowitych na zmiennoprzecinkowe dla uzyskania dok³adniejszego dzielenia i zamiana wyniku z powrotem na liczbê ca³kowit¹. Oczywiœcie mo¿na zastosowaæ te¿ drugi rodzaj notacji dla konwersji w stylu C, na pewno bardziej czytelny:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
a = <SPAN CLASS=K>int</SPAN>(<SPAN CLASS=K>float</SPAN>(b+<SPAN CLASS=L>1</SPAN>)/<SPAN CLASS=K>float</SPAN>(c+<SPAN CLASS=L>1</SPAN>));<BR>
</TD></TR>
</TABLE>

<P>
...ale takie rozwi¹zanie równie¿ nie ka¿demu przypadnie do gustu, gdy¿ kojarzy siê z wywo³ywaniem funkcji (a ¿adnych tu nie ma).
</P>
<P>
Drug¹ wad¹ "klasycznych" konwersji jest fakt, ¿e prze³ykaj¹ one g³adko równie¿ wszelkie udziwnienia, na przyk³ad konwersjê z <SPAN CLASS=T>std::string</SPAN> na <SPAN CLASS=K>int</SPAN> (sam jêzyk nie zawiera definicji takiej zamiany, chocia¿ realizuj¹ce j¹ funkcje obecne s¹ w Standardowej Biliotece C++). Dla mnie i jedna, i druga "wada" to bzdety, którymi nie powinno siê zawracaæ sobie g³owy, ale pomimo to ludzie pracuj¹cy nad rozwojem C++ wziêli je sobie do serca i sprezentowali nam operatorek, który wykonuje to samo zadanie, co konwersje "a la C", a przy tym jest ³adniejszy (przynajmniej niektórzy tak s¹dz¹) i bezpieczniejszy (chocia¿ czy szanuj¹cy siê programista bêdzie próbowa³ konwersji z <SPAN CLASS=T>std::string</SPAN> na <SPAN CLASS=K>int</SPAN>? ;-)). Zowie siê to cudo <SPAN CLASS=K>static_cast</SPAN>, a przyk³adowe u¿ycie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
a = <SPAN CLASS=K>static_cast</SPAN>&lt;<SPAN CLASS=K>int</SPAN>&gt;( <SPAN CLASS=K>static_cast</SPAN>&lt;<SPAN CLASS=K>float</SPAN>&gt;(b+<SPAN CLASS=L>1</SPAN>) / <SPAN CLASS=K>static_cast</SPAN>&lt;<SPAN CLASS=K>float</SPAN>&gt;(c+<SPAN CLASS=L>1</SPAN>) );<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, kod z powy¿szego przyk³adu, potraktowany naszym nowym cackiem sta³ siê nieco czytelniejszy, choæ na pewno nie krótszy. Myœlê równie¿, ¿e pocz¹tkuj¹cy (zw³aszcza tacy, którzy programowali ju¿ np. w Pascalu i przyzwyczaili siê, ¿e nawiasy trójk¹tne s³u¿¹ tylko do porównywania liczb) bêd¹ mieli nieliche problemy z odszyfrowaniem powy¿szego zapisu. Dlatego te¿ nie zalecam operatora <SPAN CLASS=K>static_cast</SPAN> na kilka pierwszych randek z C++.
</P>
<P>
Gwoli œcis³oœci - wspomnia³em, ¿e <SPAN CLASS=K>static_cast</SPAN> jest bezpieczny. Oznacza to, ¿e jeœli uzna on dan¹ konwersjê za niewykonaln¹ (np. ten nieszczêsny <SPAN CLASS=T>std::string</SPAN> na <SPAN CLASS=K>int</SPAN>), to wydarzy siê to jeszcze podczas kompilacji programu, która z tego powodu zostanie przerwana.
</P>
<P>
Pozosta³e dwa operatory rzutowania statycznego maj¹ raczej ma³e pole zastosowañ i zosta³y wprowadzone przede wszystkim dlatego, aby wszystkie operacje wykonywalne przy pomocy konwersji w stylu C da³o siê wykonaæ równie¿ za pomoc¹ konwersji w stylu C++. Pierwszy, <SPAN CLASS=K>reinterpret_cast</SPAN>, s³u¿y do rzutowania "na chama", czyli bez sprawdzania, czy taka operacja ma sens. Jak pewnie siê domyœlasz, nie jest to zbyt bezpieczne, zatem stosowanie <SPAN CLASS=K>reinterpret_cast</SPAN> nie jest zalecane, dopóki nie mamy absolutnej pewnoœci, ¿e da on poprawny wynik. Typowe zadanie realizowane przez operator <SPAN CLASS=K>reinterpret_cast</SPAN> to zamiana wskaŸnika na liczbê ca³kowit¹ lub odwrotnie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> a = <SPAN CLASS=L>77</SPAN>;<BR>
cout &lt;&lt; <SPAN CLASS=L>"Adres fizyczny zmiennej a to "</SPAN> &lt;&lt; <SPAN CLASS=K>reinterpret_cast</SPAN>&lt;<SPAN CLASS=K>int</SPAN>&gt;(&a) &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Po co nam adres zmiennej jako liczba? Dziêki temu mo¿emy sobie wykonywaæ niskopoziomowe operacje na pamiêci, niczym asemblerowcy ;-). W praktyce mo¿e siê nam to przydaæ np. do napisania funkcji haszuj¹cej (generuj¹cej unikalne adresy dla obiektów na podstawie ich fizycznego adresu).
</P>
<P>
Operator <SPAN CLASS=K>const_cast</SPAN> s³u¿y do usuwania z obiektów modyfikatora <SPAN CLASS=K>const</SPAN> lub <SPAN CLASS=K>volatile</SPAN>. Tutaj praktyczne zastosowanie znaleŸæ jeszcze trudniej, ni¿ w przypadku <SPAN CLASS=K>reinterpret_cast</SPAN>, wiêc weŸmy sobie przyk³ad doœæ oderwany od rzeczywistoœci (i niemal w ca³oœci zer¿niêty z MSDN ;-)). Oto on:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;stdlib.h&gt;<BR>
#include &lt;iostream&gt;<BR></SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> Klasa<BR>
{<BR><SPAN CLASS=K>
private:<BR>
&nbsp;int</SPAN> Liczba;<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> GetLiczba() <SPAN CLASS=K>const</SPAN>;<BR>
&nbsp;Klasa();<BR>
};<BR>
<BR>
Klasa::Klasa()<BR>
{<BR>
&nbsp;Liczba = <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Klasa::GetLiczba() <SPAN CLASS=K>const</SPAN><BR>
{<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Stan pocz¹tkowy: "</SPAN> &lt;&lt; Liczba &lt;&lt; endl;<BR>
&nbsp;<SPAN CLASS=K>const_cast</SPAN>&lt;Klasa*&gt;(<SPAN CLASS=K>this</SPAN>)-&gt;Liczba = <SPAN CLASS=L>666</SPAN>;<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Stan obecny: "</SPAN> &lt;&lt; Liczba &lt;&lt; endl;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Klasa Test;<BR>
&nbsp;Test.GetLiczba();<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN><SPAN CLASS=L> 0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, metoda <SPAN CLASS=T>GetLiczba</SPAN> (lubiê takie polsko-angielskie mieszañce ;-)) jest funkcj¹ sta³¹. Oznacza to, ¿e ukryty w niej wskaŸnik <SPAN CLASS=K>this</SPAN> te¿ jest sta³y, czyli jest typu <SPAN CLASS=K>const</SPAN><SPAN CLASS=T> Klasa*</SPAN> i nie mo¿na za jego poœrednictwem zmieniæ pola <SPAN CLASS=T>Liczba</SPAN>. Nie mo¿na, dopóki nie u¿yjemy na nim rzutowania za pomoc¹ <SPAN CLASS=K>const_cast</SPAN>, które usunie s³ówko <SPAN CLASS=K>const</SPAN> (czyli po rzutowaniu <SPAN CLASS=K>this</SPAN> bêdzie typu <SPAN CLASS=T>Klasa*</SPAN>). Zabieg ten umo¿liwi nam przypisanie liczby <SPAN CLASS=L>666</SPAN> do zmiennej sk³adowej <SPAN CLASS=T>Liczba</SPAN>.
</P>

<h2>
Dynamiczne rzutowanie
</h2>

<P>
Jedn¹ z najprzydatniejszych cech dziedziczenia jest mo¿liwoœæ tworzenia wskaŸników do klas bazowych, które mog¹ przechowywaæ adresy obiektów klas pochodnych. Czêsto wrzucamy takie wskaŸniki do ró¿nych klas (ale opartych na tej samej klasie bazowej) do tablicy, otrzymuj¹c dziêki temu tzw. kolekcjê obiektów. Jest to niesamowicie przydatna konstrukcja, ale o tym mo¿e pogadamy przy innej okazji. Teraz zajmiemy siê problemami, które pojawiaj¹ siê zwykle przy operowaniu wskaŸnikami do klas bazowych.
</P>
<P>
Otó¿ jeœli mamy taki wskaŸnik, to przy u¿yciu poznanych do tej pory œrodków nie jesteœmy w stanie stwierdziæ, jakiej tak naprawdê klasy jest obiekt, na który ten wskaŸnik wskazuje. WeŸmy na przyk³ad tak¹ sytuacjê: tworzymy sobie grê strategiczn¹. Mamy klasê bazow¹ <SPAN CLASS=T>CObiekt</SPAN> oraz dziedzicz¹ce po niej klasy: <SPAN CLASS=T>CBudynek, CCzolg, COddzial</SPAN>. Rzeczywiste obiekty w grze, czyli budynki, czo³gi i oddzia³y piechoty reprezentowane bêd¹ tylko przez klasy pochodne, bêd¹ te¿ oczywiœcie alokowane dynamicznie, a ich adresy (wskaŸniki typu <SPAN CLASS=T>CObiekt*</SPAN>) bêd¹ przechowywane w tablicy. Oto nasze klasy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> CObiekt<BR>
{<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> CBudynek : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> CCzolg : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> COddzial : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Przegrupuj() {};<BR>
};
</TD></TR>
</TABLE>

<P>
Nie zadeklarowaliœmy ¿adnych sk³adowych, oprócz metody <SPAN CLASS=T>Rysuj</SPAN> (dla wszystkich klas pochodnych)  oraz metody <SPAN CLASS=T>Przegrupuj</SPAN>, wystêpuj¹cej tylko w klasie <SPAN CLASS=T>COddzial</SPAN> - na razie nic wiêcej nie bêdzie nam potrzebne. Teraz tworzymy sobie tablicê wskaŸników do typu <SPAN CLASS=T>CObiekt*</SPAN>.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CObiekt* Obiekty[<SPAN CLASS=L>5</SPAN>];
</TD></TR>
</TABLE>

<P>
Mo¿emy ju¿ utworzyæ kolekcjê obiektów przez ich dynamiczne zaalokowanie i zapisanie otrzymanych w ten sposób wskaŸników do tablicy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Obiekty[<SPAN CLASS=L>0</SPAN>] = <SPAN CLASS=K>new</SPAN> CBudynek;<BR>
Obiekty[<SPAN CLASS=L>1</SPAN>] = <SPAN CLASS=K>new</SPAN> CCzolg;<BR>
Obiekty[<SPAN CLASS=L>2</SPAN>] = <SPAN CLASS=K>new</SPAN> CCzolg;<BR>
Obiekty[<SPAN CLASS=L>3</SPAN>] = <SPAN CLASS=K>new</SPAN> COddzial;<BR>
Obiekty[<SPAN CLASS=L>4</SPAN>] = <SPAN CLASS=K>new</SPAN> COddzial;<BR>
</TD></TR>
</TABLE>

<P>
Mamy ju¿ konkretne argumenty niezbêdne do prowadzenia wojny oraz jeden problem. Ka¿dy obiekt - czy jest to czo³g, czy zwyk³y piechur - trzeba bêdzie kiedyœ narysowaæ. Wywo³ujemy wiêc metodê <SPAN CLASS=T>Rysuj</SPAN> dla wszystkich istniej¹cych obiektów:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=T>0</SPAN>; i&lt;<SPAN CLASS=L>5</SPAN>; ++i)<BR>
&nbsp;Obiekty[i]-&gt;Rysuj(); <SPAN CLASS=C>//nie skompiluje siê</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Kompilator odmówi oczywiœcie wykonania rozkazu, gdy¿ metody <SPAN CLASS=T>Rysuj</SPAN> bêdzie poszukiwa³ w klasie <SPAN CLASS=T>CObiekt</SPAN> (nie ma jej tam), poniewa¿ poprzez wskaŸnik do tej w³aœnie klasy zosta³a wywo³ana metoda <SPAN CLASS=T>Rysuj</SPAN>. Wyjœciem by³aby zamiana metody <SPAN CLASS=T>Rysuj</SPAN> na wirtualn¹ - wystêpuje ona we wszystkich klasach pochodnych w naszym przyk³adzie. Co wiêcej, powinna ona byæ czysto wirtualna, poniewa¿ nie chcemy, aby w naszej grze wystêpowa³y obiekty abstrakcyjne (czyli chcemy, aby klasa <SPAN CLASS=T>CObiekt</SPAN> by³a abstrakcyjna - brzmi jak majaczenie kolesia z 40-stopniow¹ gor¹czk¹, ale jest jak najbardziej logiczne ;-)). Dokonajmy sobie takiej zamiany:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;virtual void</SPAN> Rysuj() = <SPAN CLASS=L>0</SPAN>;<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Teraz kompilator nie bêdzie ju¿ mia³ nic przeciwko wywo³aniu Rysuj przez wskaŸnik typu <SPAN CLASS=T>CObiekt*</SPAN>. Ale to nie koniec k³opotów - nie potrafimy bowiem wywo³aæ w ten sam sposób metody <SPAN CLASS=T>Przegrupuj</SPAN>. Tym razem nie pomo¿e zadeklarowanie jej jako wirtualnej, gdy¿ nie wystêpuje ona we wszystkich klasach pochodnych, a tylko w jednej z nich (<SPAN CLASS=T>COddzial</SPAN>).
</P>
<P>
W tym w³aœnie miejscu przyda nam siê rzutowanie dynamiczne. Jak byæ mo¿e siê ju¿ domyœlasz, zadanie to powierzymy operatorowi <SPAN CLASS=K>dynamic_cast</SPAN>. S³u¿y on w³aœnie do zamiany wskaŸników do klas pochodnych na wskaŸniki do klasy bazowej i vice versa. Mo¿emy to zrobiæ, wykorzystuj¹c konwersje w stylu C, ale maj¹ one jedn¹ powa¿n¹ wadê: nie sprawdzaj¹ poprawnoœci takiej operacji. Operator <SPAN CLASS=K>dynamic_cast</SPAN> jest tej wady pozbawiony; jeœli rzutowanie nie powiedzie siê, zamiast wynikowego wskaŸnika operator zwróci <SPAN CLASS=T>NULL</SPAN>.
</P>
<P>
Uzbrojeni w tê wiedzê, mo¿emy sobie zadeklarowaæ wskaŸnik typu <SPAN CLASS=T>COddzial*</SPAN>, przekszta³ciæ odpowiednie (dwa ostatnie elementy naszej tablicy) wskaŸniki typu <SPAN CLASS=T>CObiekt*</SPAN> na <SPAN CLASS=T>COddzial*</SPAN>, zapisaæ je do nowej zmiennej wskaŸnikowej i przez tê zmienn¹ wywo³aæ wreszcie metodê <SPAN CLASS=T>Przegrupuj</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
COddzial* wsk;<BR>
wsk = <SPAN CLASS=K>dynamic_cast</SPAN>&lt;COddzial*&gt;(Obiekty[<SPAN CLASS=L>3</SPAN>]);<BR>
<SPAN CLASS=K>if</SPAN>(wsk != NULL)<BR>
&nbsp;wsk-&gt;Przegrupuj();<BR>
wsk = <SPAN CLASS=K>dynamic_cast</SPAN>&lt;COddzial*&gt;(Obiekty[<SPAN CLASS=L>4</SPAN>]);<BR>
<SPAN CLASS=K>if</SPAN>(wsk != NULL)<BR>
&nbsp;wsk-&gt;Przegrupuj();<BR>
</TD></TR>
</TABLE>

<P>
W tym przypadku nie jest konieczne sprawdzanie, czy <SPAN CLASS=T>wsk</SPAN> jest ró¿ne od <SPAN CLASS=T>NULL</SPAN>, poniewa¿ i tak wiemy, ¿e rzutowane wskaŸniki wskazuj¹ na obiekt typu <SPAN CLASS=T>COddzial</SPAN>, wiêc rzutowanie musi siê powieœæ. Robimy to tylko w celach dydaktycznych ;-).
</P>

<h2>
Dynamiczna identyfikacja klasy obiektu
</h2>

<P>
W powy¿szym przyk³adzie mamy malutk¹, <SPAN CLASS=L>5</SPAN>-elementow¹ tablicê ze wskaŸnikami. W praktyce takich tablic raczej nie stosuje siê. Zamiast nich w "powa¿nych" grach nie tylko same obiekty alokowane s¹ dynamicznie, ale te¿ sama tablica wskaŸników rozszerza siê w miarê dodawania kolejnych obiektów. Poza tym ró¿ne obiekty dodawane s¹ w ró¿nej kolejnoœci; nie mamy na przyk³ad, jak tutaj, pewnoœci, ¿e czwarty z kolei obiekt jest klasy <SPAN CLASS=T>COddzial</SPAN>. W jaki zatem sposób stwierdzimy, czy mo¿na dla danego wskaŸnika wywo³aæ metodê <SPAN CLASS=T>Przegrupuj</SPAN>? (Innymi s³owy: czy wskazuje on na klasê <SPAN CLASS=T>COddzial</SPAN>?)
</P>
<P>
Bardzo prosto. Mo¿emy w ka¿dej z klas pochodnych umieœciæ sobie metodê, np. o nazwie <SPAN CLASS=T>Klasa</SPAN>, która bêdzie zwraca³a odpowiedni¹ sta³¹, jednoznacznie idetyfikuj¹c¹ klasê obiektu. Poniewa¿ metoda ta bêdzie wywo³ywana w praktyce tylko przez wskaŸnik typu <SPAN CLASS=T>CObiekt</SPAN>*, wiêc bêdzie ona wirtualna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const int</SPAN> KLASA_BUDYNEK = <SPAN CLASS=L>1</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> KLASA_CZOLG   = <SPAN CLASS=L>2</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> KLASA_ODDZIAL = <SPAN CLASS=L>3</SPAN>;<BR>
<BR>
<SPAN CLASS=K>class</SPAN> CObiekt<BR>
{<BR>
&nbsp;<SPAN CLASS=K>virtual int</SPAN> Klasa() = <SPAN CLASS=L>0</SPAN>; <BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> CBudynek : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Klasa() { <SPAN CLASS=K>return</SPAN> KLASA_BUDYNEK; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> CCzolg : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Klasa() { <SPAN CLASS=K>return</SPAN> KLASA_CZOLG; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> COddzial : <SPAN CLASS=K>public</SPAN> CObiekt<BR>
{<BR>
<SPAN CLASS=K>public:<BR>
&nbsp;void</SPAN> Rysuj() {};<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Przegrupuj() {};<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> Klasa() { <SPAN CLASS=K>return</SPAN> KLASA_ODDZIAL; }<BR>
};
</TD></TR>
</TABLE>

<P>
Teraz sprawa nam siê bardzo upraszcza. Mo¿emy po kolei egzaminowaæ poszczególne wskaŸniki z tablicy <SPAN CLASS=T>Obiekty</SPAN> w pêtli, wykorzystuj¹c metodê <SPAN CLASS=T>Klasa</SPAN>. Dziêki temu wiemy na pewno, na jak¹ klasê który wskazuje i mo¿emy dokonaæ rzutowania go na wskaŸnik do tej klasy. A maj¹c wskaŸnik do konkretnej klasy pochodnej... Wtedy mo¿emy siê ju¿ bez przeszkód odwo³ywaæ do dowolnej sk³adowej danej klasy, bez obawy, ¿e kompilator tej sk³adowej nie znajdzie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CBudynek* wsk_bud;<BR>
CCzolg*   wsk_cz;<BR>
COddzial* wsk_odd;<BR>
<BR>
<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>5</SPAN>; ++i)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(Obiekty[i]-&gt;Klasa())<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> KLASA_BUDYNEK:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;wsk_bud = <SPAN CLASS=K>dynamic_cast</SPAN>&lt;CBudynek*&gt;(Obiekty[i]);<BR>
&nbsp;&nbsp;&nbsp;wsk_bud-&gt;Rysuj();<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> KLASA_CZOLG:   <BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;wsk_cz = <SPAN CLASS=K>dynamic_cast</SPAN>&lt;CCzolg*&gt;(Obiekty[i]);<BR>
&nbsp;&nbsp;&nbsp;wsk_cz-&gt;Rysuj();<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> KLASA_ODDZIAL: <BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;wsk_odd = <SPAN CLASS=K>dynamic_cast</SPAN>&lt;COddzial*&gt;(Obiekty[i]);<BR>
&nbsp;&nbsp;&nbsp;wsk_odd-&gt;Rysuj();<BR>
&nbsp;&nbsp;&nbsp;wsk_odd-&gt;Przegrupuj();<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Przyk³ad ten bierze kolejno wszystkie wskaŸniki z tablicy, rzutuje je na wskaŸniki do w³aœciwych klas, a nastêpnie wywo³uje dla nich metodê <SPAN CLASS=T>Rysuj</SPAN>. Jeœli dojdzie do obiektu typu <SPAN CLASS=T>COddzial</SPAN>, to dodatkowo wywo³uje metodê <SPAN CLASS=T>Przegrupuj</SPAN>. Oczywiœcie z punktu widzenia gry przegrupowywanie oddzia³u zawsze wtedy, gdy jest on rysowany niekoniecznie musi mieæ sens, ale chcia³em koniecznie pokazaæ, ¿e po rzutowaniu wywo³anie tej metody bêdzie mo¿liwe ;-).
</P>

<h2>
Operator typeid
</h2>

<P>
Zamiast stosowaæ pokazan¹ wy¿ej sztuczkê z wirtualn¹ metod¹ <SPAN CLASS=T>Klasa</SPAN>, mo¿emy wykorzystaæ czêœæ mechanizmu RTTI, jak¹ jest operator <SPAN CLASS=K>typeid</SPAN>. Aby to zrobiæ, musimy najpierw do³¹czyæ do naszego programu nag³ówek <SPAN CLASS=C>typeinfo</SPAN>. Operator <SPAN CLASS=K>typeid</SPAN> zwraca referencjê do klasy <SPAN CLASS=T>type_info</SPAN>. Mo¿na go stosowaæ zarówno do nazw typów (np. <SPAN CLASS=T>COddzial</SPAN>), jak i wyra¿eñ (np. <SPAN CLASS=T>Obiekty[i]</SPAN>). Oczywiœcie nas najbardziej interesuje ta druga opcja:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;typeinfo&gt;<BR>
#include &lt;iostream&gt;<BR>
<BR>
//...</SPAN><BR>
<BR>
cout &lt;&lt; <SPAN CLASS=L>"Typ pierwszego elementu: "</SPAN> &lt;&lt; <SPAN CLASS=K>typeid</SPAN>(Obiekty[<SPAN CLASS=L>0</SPAN>]).name() &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Jeœli spodziewasz siê, ¿e na ekranie pojawi siê nazwa "<SPAN CLASS=L>CBudynek</SPAN>", to bêdziesz rozczarowany. Mo¿esz spytaæ: po jak¹ cholerê jest ten operator <SPAN CLASS=K>typeid</SPAN>, skoro ka¿dy g³upi widzi, ¿e elementy tablicy <SPAN CLASS=T>Obiekty</SPAN> s¹ typu <SPAN CLASS=T>CObiekt*</SPAN>? Có¿, tutaj <SPAN CLASS=K>typeid</SPAN> wykrêci³ siê sianem, poniewa¿ podaliœmy mu wskaŸnik, ale mo¿na go zmusiæ do wiêkszego pos³uszeñstwa - wystarczy ten wskaŸnik poprzedziæ gwiazdk¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
cout &lt;&lt; <SPAN CLASS=L>"Typ pierwszego elementu: "</SPAN> &lt;&lt; <SPAN CLASS=K>typeid</SPAN>(*Obiekty[<SPAN CLASS=L>0</SPAN>]).name() &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P class=UWAGA>
Jeœli chcesz uzyskaæ w ten sposób nazwê klasy pochodnej, a nie bazowej, to oprócz poprzedzenia wskaŸnika gwiazdk¹, klasa bazowa musi byæ polimorficzna (zawieraæ przynajmniej jedn¹ wirtualn¹ metodê).</P>

<P>
Poza metod¹ <SPAN CLASS=T>name</SPAN>, klasa <SPAN CLASS=T>type_info</SPAN> ma jeszcze dwa operatory: <SPAN CLASS=T>==</SPAN> i <SPAN CLASS=T>!=</SPAN>. Dziêki nim mo¿emy porównywaæ ró¿ne obiekty (lub wskaŸniki) albo po prostu sprawdzaæ, czy dany obiekt (lub wskaŸnik) jest danego typu. Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(<SPAN CLASS=K>typeid</SPAN>(*Obiekty[<SPAN CLASS=L>0</SPAN>]) != <SPAN CLASS=K>typeid</SPAN>(*Obiekty[<SPAN CLASS=L>1</SPAN>]))<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Pierwszy i drugi element wskazuj¹ na obiekty ró¿nych typów!"</SPAN> &lt;&lt; endl;<BR>
<SPAN CLASS=K>else</SPAN><BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Pierwszy i drugi element wskazuj¹ na obiekty tego samego typu."</SPAN> &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Dla polimorficznej wersji klasy <SPAN CLASS=T>CObiekt</SPAN> wyœwietlony zostanie pierwszy komunikat (obiekty ró¿nych typów). Dla nie-polimorficznej (bez deklaracji wirtualnej funkcji <SPAN CLASS=T>Klasa</SPAN>) bêdzie to zaœ drugi komunikat (program nie wykryje ró¿nicy miêdzy typem obiektów).
</P>
<P>
Ostatnim sekretem, ukrytym w klasie <SPAN CLASS=T>type_info</SPAN> jest metoda <SPAN CLASS=T>before</SPAN>. Teoretycznie s³u¿y ona do ustalania kolejnoœci obiektów klasy <SPAN CLASS=T>type_info</SPAN>, ale trudno mi powiedzieæ, po co w³aœciwie mielibyœmy to robiæ. Tym bardziej, i¿ nie ma ¿adnej gwarancji, ¿e <SPAN CLASS=T>before</SPAN> da ten sam wynik dla dwóch ró¿nych wykonañ tego samego programu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(<SPAN CLASS=K>typeid</SPAN>(*Obiekty[<SPAN CLASS=L>0</SPAN>]).before(<SPAN CLASS=K>typeid</SPAN>(*Obiekty[<SPAN CLASS=L>1</SPAN>])))<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"CBudynek przed CCzolg"</SPAN> &lt;&lt; endl;<BR>
</TD></TR>
</TABLE>

<P>
Operator <SPAN CLASS=K>typeid</SPAN> mo¿e siê wydawaæ wygodniejszy w u¿yciu, ni¿ omówiona przez nas wczeœniej sztuczka z wirtualn¹ funkcj¹ <SPAN CLASS=T>Klasa</SPAN>. Ma on jednak spore u³omnoœci. Po pierwsze - jest niezbyt wydajny. Po drugie - mo¿e sprawiæ, ¿e kod staje siê nieprzenoœny (dzia³anie programu mo¿e zale¿eæ od platformy). Na przyk³ad SDK do Dev-C++ w ogóle nie zawiera metody <SPAN CLASS=T>raw_name</SPAN>, obecnej w klasie <SPAN CLASS=T>type_info</SPAN> w SDK do Visual C++. Funkcja <SPAN CLASS=T>name</SPAN> równie¿ daje dla tych dwóch SDK zupe³nie inne efekty. Tak wiêc w zdecydowanej wiêkszoœci przypadków lepiej jest z niego zrezygnowaæ na rzecz alternatywnych rozwi¹zañ, nawet gdyby mia³y one kosztowaæ nieco wiêcej stukania w klawiaturê ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs10.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>