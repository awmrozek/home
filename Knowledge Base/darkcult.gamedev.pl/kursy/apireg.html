<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Rejestr</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apimenu.html">&lt;&lt; Tworzenie menu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apiclass.html">Subclassing i superclassing &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h1>
Rejestr
</h1>

<P>
W opisywanie, czym jest Rejestr i do czego s³u¿y nie bêdê siê tutaj bawiæ - wszystko to powinieneœ ju¿ dawno wiedzieæ, a jeœli nie wiesz, to pan Google chêtnie powie. W tym kursie zak³adam, ¿e odpowiedni¹ terminologiê znasz, a i Edytor Rejestru jest ci nieobcy. Dlatego te¿ bez zbêdnych ceregieli przechodzimy od razu do grzebania w tym najwiêkszym windowsowym œmietnisku ;-)
</P>

<h2>
Otwieranie i tworzenie kluczy
</h2>

<P>
¯eby cokolwiek zrobiæ z danym kluczem Rejestru, musi on byæ najpierw otwarty. Trochê to dziwne, zw³aszcza dla kogoœ kto przyzwyczai³ siê, ¿e klucze to przyrz¹dy do otwierania czegoœ, a nie odwrotnie. Mniejsza jednak o szczegó³y. Mo¿na dokonaæ otwarcia klucza przy pomocy funkcji <SPAN CLASS=T>RegOpenKeyEx</SPAN> lub <SPAN CLASS=T>RegCreateKeyEx</SPAN>. £atwo siê domyœliæ, ¿e ta druga dodatkowo tworzy klucz, jeœli wczeœniej on nie istnia³. W obu przypadkach po otwarciu danego klucza uzyskujemy do niego uchwyt (typu <SPAN CLASS=T>HKEY</SPAN>). Pos³uguj¹c siê tym uchwytem mo¿emy z kluczem zrobiæ niemal wszystko, co nam potrzebne.
</P>
<P>
PrzejdŸmy teraz do praktyki. Odpalmy Edytor Rejestru (co najproœciej uczyniæ, wciskaj¹c Win+R, a nastêpnie wpisuj¹c 'regedit' i Enter). Otwieramy klucz <SPAN CLASS=L>HKEY_CURRENT_USER/Software</SPAN>, oczom naszym ukazuje siê mniej wiêcej taki widok:
</P>
<p align=center><img src="../gfx/rejestr1.gif" alt="Edytor Rejestru, otwarty klucz HKEY_CURRENT_USER/Software">
</p>

<P>
Nastêpnie tworzymy w nim nowy klucz, np. o nazwie <SPAN CLASS=L>Test</SPAN>:
</P>
<P>
Tyle nam na razie wystarczy, spróbujemy teraz otworzyæ ten klucz z poziomu C++. Funkcja <SPAN CLASS=T>RegOpenKeyEx</SPAN> prezentuje siê nastêpuj¹co:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: RegOpenKeyEx(<I>hKey, lpSubKey, ulOptions, samDesired, phkResult</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hKey</I></TD><TD CLASS=ARGLIST>Uchwyt otwartego klucza</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpSubKey</I></TD><TD CLASS=ARGLIST>Nazwa podklucza, którey otwieramy/tworzymy</TD></TR>
<TR><TD CLASS=ARGLIST><I>ulOptions</I></TD><TD CLASS=ARGLIST>Zarezerwowane - nie u¿ywaæ</TD></TR>
<TR><TD CLASS=ARGLIST><I>samDesired</I></TD><TD CLASS=ARGLIST>Maska bezpieczeñstwa dostêpu</TD></TR>
<TR><TD CLASS=ARGLIST><I>nXSrc, nYSrc</I></TD><TD CLASS=ARGLIST>Adres zmiennej na uchwyt klucza </TD></TR>
</TABLE>

<P>
Warto wiedzieæ, ¿e istnieje te¿ funkcja <SPAN CLASS=T>RegOpenKey</SPAN> o znacznie prostszej sk³adni, jednak pochodzi ona jeszcze z czasów Windows 3.1 (gdzie, jak wiemy, Rejestru w znanej nam formie w³aœciwie nie by³o) i jej stosowanie nie jest zalecane.
</P>
<P>
Z powy¿szych argumentów najbardziej interesuje nas pierwszy. Jest to, jak widaæ w opisie, uchwyt do otwartego klucza. Wiêc jak to - móg³by ktoœ trzeŸwo zapytaæ - ¿eby otworzyæ klucz i uzyskaæ do niego uchwyt, musimy podaæ uchwyt do ju¿ otwartego klucza? Przecie¿ mo¿na w ten sposób w nieskoñczonoœæ... Na szczêœcie nikt nie wymaga od programistów, ¿eby próbowali goniæ w³asny ogon ;-). Okazuje siê bowiem, ¿e niektóre klucze s¹ otwarte przez ca³y czas, a uchwyty do nich s¹ sta³ymi: <SPAN CLASS=T>HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS</SPAN> (przy okazji dowiedzieliœmy siê, sk¹d wziê³y siê te nazwy w Regedicie, co pewnie niejednego nurtowa³o ;-)). Te cztery akurat s¹ wspólne dla wszystkich 32-bitowych Windowsów, natomiast w zale¿noœci od konkretnej platformy mog¹ wyst¹piæ tak¿e inne predefiniowane klucze (np. w Windows 98 s¹ jeszcze: <SPAN CLASS=T>HKEY_CURRENT_CONFIG</SPAN> i <SPAN CLASS=T>HKEY_DYN_DATA</SPAN>).
</P>
<P>
Tak wiêc, skoro mamy dane uchwyty kluczy pierwszego i najwy¿szego poziomu, to przy ich pomocy mo¿emy otworzyæ klucze drugiego poziomu, np. w naszym przypadku klucz <SPAN CLASS=L>Software</SPAN>. Uczyñmy to zatem:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HKEY hkSoftware;<BR>
LONG result;<BR>
result = RegOpenKeyEx(HKEY_CURRENT_USER, <SPAN CLASS=L>"software", 0</SPAN>, KEY_ALL_ACCESS, &hkSoftware);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Uda³o siê otworzyæ klucz.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
Z parametrów funkcji <SPAN CLASS=T>RegOpenKeyEx</SPAN> niewiele jest do omawiania; w sumie rola ka¿dego z nich powinna byæ oczywista. Nieco mniej jasne wydaje siê u¿ycie sta³ej <SPAN CLASS=T>KEY_ALL_ACCESS</SPAN> - oznacza ona, ¿e ¿yczymy sobie pe³nego dostêpu do danego klucza. Mog³oby siê okazaæ, ¿e np. klucz jest zabezpieczony przed zapisem i wtedy otwarcie go z flag¹ <SPAN CLASS=T>KEY_ALL_ACCESS</SPAN> zapewne by siê nie powiod³o. W przeciwnym razie funkcja zwraca wartoœæ o doœæ schizofrenicznej nazwie <SPAN CLASS=T>ERROR_SUCCESS</SPAN> (jawny dowód na to, ¿e w systemie Windows sukces jest sytuacj¹ wyj¹tkow¹ ;-)), co oznacza, ¿e klucz jest ju¿ gotowy do u¿ycia.
</P>
<P>
W samym kluczu <SPAN CLASS=L>Software</SPAN> grzebaæ trochê nie wypada, gdy¿ jest on wspólny dla wszystkich aplikacji w systemie, w tym równie¿ dla samych aplikacji systemowych. Du¿o grzeczniej z naszej strony bêdzie, jeœli stworzymy sobie w³asny klucz do prywatnego u¿ytku. Tutaj znowu mamy do wyboru dwa warianty: prostszy <SPAN CLASS=T>RegCreateKey</SPAN> oraz doœæ skomplikowany <SPAN CLASS=T>RegCreateKeyEx</SPAN>. I znowu wybieramy ten drugi, gdy¿ jesteœmy akurat chorobliwie ambitni:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
HKEY hkTest;<BR>
LONG result;<BR>
DWORD dwDisp;<BR>
<BR>
result = RegCreateKeyEx(hkSoftware, <SPAN CLASS=L>"test", 0</SPAN>, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkTest, &dwDisp);<BR>
<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(dwDisp == REG_CREATED_NEW_KEY)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Uda³o siê stworzyæ nowy klucz.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
&nbsp;<SPAN CLASS=K>else if</SPAN>(dwDisp == REG_OPENED_EXISTING_KEY)<BR>
&nbsp;&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Uda³o siê otworzyæ istniej¹cy klucz.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
Trzy pierwsze argumenty funkcji s¹ identyczne jak w przypadku <SPAN CLASS=T>RegOpenKeyEx</SPAN>. Czwarty, <SPAN CLASS=T>lpClass</SPAN>, oznacza stringa z nazw¹ klasy klucza - mo¿emy tu daæ <SPAN CLASS=T>NULL</SPAN>. Kolejny argument to specjalne opcje tworzenia klucza - znów nie musimy siê tym specjalnie przejmowaæ, gdy¿ maj¹ one znaczenie (i to niewielkie) tylko w systemach klasy NT (co prawda teraz prawie wszyscy maj¹ takie systemy... no, nieistotne :-)). Daliœmy wiêc <SPAN CLASS=T>REG_OPTION_NON_VOLATILE</SPAN> tylko po to, ¿eby ³adnie wygl¹da³o ;-). Argument <SPAN CLASS=T>samDesired</SPAN> ju¿ znamy - to opcje dostêpu do nowo tworzonego klucza. Poniewa¿ to w³aœnie my tworzymy ten klucz, wiêc raczej chcemy mieæ do niego pe³ny dostêp, czyli dajemy <SPAN CLASS=T>KEY_ALL_ACCESS</SPAN>.
</P>
<P>
Pozosta³y trzy argumenty. Ten figuruj¹cy jako <SPAN CLASS=T>lpSecurityAttributes</SPAN> znowu bezczelnie olejemy, podaj¹c <SPAN CLASS=T>NULL</SPAN>. Wreszcie dochodzimy do wskaŸnika do zmiennej typu <SPAN CLASS=T>HKEY</SPAN>, która otrzyma uchwyt nowo utworzonego klucza oraz wskaŸnika do zmiennej typu <SPAN CLASS=T>DWORD</SPAN>, która otrzyma wartoœæ mówi¹c¹, czy klucz istnia³ przed wywo³aniem funkcji <SPAN CLASS=T>RegCreateKeyEx</SPAN> czy te¿ nie istnia³. Trzeba ci bowiem wiedzieæ, ¿e funkcja ta nie bêdzie protestowa³a w przypadku próby utworzenia ju¿ od wieków istniej¹cego klucza i równie¿ w takim przypadku, co mo¿e siê wydaæ zaskakuj¹ce, zwróci <SPAN CLASS=T>ERROR_SUCCESS</SPAN>. Efekt:
</P>

<p align=center>
<img src="../gfx/rejestr2.gif" alt="Utworzyliœmy klucz - jeden œmieæ wiêcej w Rejestrze ;-)"
</P>

<h2>
Tworzenie i odczytywanie wartoœci
</h2>

<P>
Z samych kluczy niewielki mamy po¿ytek, wiêc warto dowiedzieæ siê, jak ustawiamy konkretne wartoœci. Intuicja podpowiada, ¿e s³u¿y do tego funkcja <SPAN CLASS=T>RegSetValue</SPAN> - i faktycznie, istnieje taka. Jednak jest to kolejny relikt z czasów Windows 3.1 i do naszych celów funkcja ta jest praktycznie bezu¿yteczna, gdy¿ potrafi tylko ustawiaæ domyœln¹ wartoœæ klucza. Aby ustawiæ "zwyk³¹" wartoœæ, musimy skorzystaæ z nowszej wersji tej funkcji, czyli oczywiœcie <SPAN CLASS=T>RegSetValueEx</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN> buf[<SPAN CLASS=L>20</SPAN>];<BR>
lstrcpy(buf, <SPAN CLASS=L>"Jakiœ tam tekst"</SPAN>);<BR>
result = RegSetValueEx(hkTest,<SPAN CLASS=L> "MojaWartoœæ", 0</SPAN>, REG_SZ, (LPBYTE)buf, lstrlen(buf)+<SPAN CLASS=L>1</SPAN>);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"value is set.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
Sk³adnia naszej funkcji przypomina trochê poprzednie dwie, tyle ¿e tym razem zamiast nazwy podklucza podajemy nazwê wartoœci. Czwarty argument, czyli <SPAN CLASS=T>dwType</SPAN>, to typ wartoœci. Oto tabelka z najczêœciej stosowanymi typami:
</P>

<TABLE WIDTH=100%>
<TR><TH CLASS=ARGLIST>Sta³a</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>REG_BINARY</I></TD><TD CLASS=ARGLIST>Dowolne dane binarne</TD></TR>
<TR><TD CLASS=ARGLIST><I>REG_DWORD</I></TD><TD CLASS=ARGLIST>Liczba 32-bitowa bez znaku</TD></TR>
<TR><TD CLASS=ARGLIST><I>REG_SZ</I></TD><TD CLASS=ARGLIST>String</TD></TR>
<TR><TD CLASS=ARGLIST><I>REG_MULTI_SZ</I></TD><TD CLASS=ARGLIST>Tablica stringów</TD></TR>
</TABLE>

<P>
W powy¿szym przyk³adzie u¿yliœmy sobie typu <SPAN CLASS=T>REG_SZ</SPAN>, czyli zwyk³ego stringa (najpowszechniejszy typ danych w Rejstrze). Aby umieœciæ stringa w Rejestrze, musieliœmy najpierw stworzyæ sobie bufor, skopiowaæ do niego tego stringa za pomoc¹ funkcji lstrcpy, a nastêpnie podaæ adres bufora funkcji <SPAN CLASS=T>RegSetValueEx</SPAN>. Funkcja ta oczekuje wskaŸnika tylko do pierwszego bajtu wartoœci, wiêc musieliœmy przekonwertowaæ adres bufora do typu <SPAN CLASS=T>LPBYTE</SPAN> (czyli <SPAN CLASS=T>BYTE*</SPAN>). Oczywiœcie jeœli funkcja oczekuje wskaŸnika typu <SPAN CLASS=T>LPBYTE</SPAN>, a wskazywany bufor jest zwykle d³u¿szy ni¿ <SPAN CLASS=L>1</SPAN> bajt, to nale¿y siê spodziewaæ, ¿e bêdziemy równie¿ musieli podaæ d³ugoœæ tego bufora. A poniewa¿ funkcja przyjmuje dane ró¿nych typów (nie tylko stringi), wiêc do tej d³ugoœci wlicza siê równie¿ znak zerowy na koñcu stringa, dlatego te¿ dodajemy jedynkê do d³ugoœci otrzymanej przy pomocy <SPAN CLASS=T>lstrlen</SPAN>.
</P>
<P>
Naturalnie, jeœli los siê na nas nie uwzi¹³, to po tych wszystkich zabiegach <SPAN CLASS=T>RegSetValueEx</SPAN> powinna nam zwróciæ <SPAN CLASS=T>ERROR_SUCCESS</SPAN>.
</P>
<P>
Odczytywanie wartoœci jest bardzo podobne do ich ustawiania, przynajmniej pod wzglêdem sk³adniowym. Tak wiêc wystarczy nieco zmodyfikowaæ poprzedni przyk³ad. Funkcja, któr¹ tu zaprzêgniemy do pracy, zowie siê <SPAN CLASS=T>RegQueryValueEx</SPAN>.
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: RegQueryValueEx(<I>hKey, lpValueName, lpReserved, lpType, lpData, lpcbData</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hKey</I></TD><TD CLASS=ARGLIST>Uchwyt klucza</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpValueName</I></TD><TD CLASS=ARGLIST>Nazwa wartoœci</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpReserved</I></TD><TD CLASS=ARGLIST>Nie dotykaæ, grozi trwa³ym kalectwem</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpType</I></TD><TD CLASS=ARGLIST>Adres bufora na typ wartoœci</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpData</I></TD><TD CLASS=ARGLIST>Adres bufora na dane wartoœci</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpcbData</I></TD><TD CLASS=ARGLIST>Rozmiar bufora na dane</TD></TR>
</TABLE>


<P>
Poni¿szy przyk³ad pokazuje, jak pobraæ wartoœæ typu tekstowego do bufora i nastêpnie ukazaæ j¹ zaskoczonym oczêtom u¿ytkownika:
 </P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char</SPAN> buf[<SPAN CLASS=L>21</SPAN>];<BR>
DWORD dwBufSize = <SPAN CLASS=L>20</SPAN>;<BR>
result = RegQueryValueEx(hkTest, <SPAN CLASS=L>"MojaWartoœæ"</SPAN>, NULL, REG_SZ, (LPBYTE)buf, &dwBufSize);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
{<BR>
&nbsp;buf[<SPAN CLASS=L>20</SPAN>] = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;MessageBox(hwnd, buf, <SPAN CLASS=L>"Test"</SPAN>, MB_ICONINFORMATION);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jedyna istotna dla nas ró¿nica jest taka, ¿e ostatni parametr funkcji <SPAN CLASS=T>RegQueryValueEx</SPAN> to tym razem wskaŸnik. Musimy do niego wpisaæ adres zadeklarowanej zmiennej, która bêdzie zawieraæ rozmiar bufora (i do której póŸniej powêdruje liczba bajtów skopiowanych do bufora przez funkcjê <SPAN CLASS=T>RegQueryValueEx</SPAN>). Powinna to byæ zmienna typu <SPAN CLASS=T>DWORD</SPAN>.
</P>
<P>
Jeœli <SPAN CLASS=T>RegQueryValueEx</SPAN> nie napotka po drodze ¿adnych przeszkód, to tradycyjnie zwróci<SPAN CLASS=T> ERROR_SUCCESS</SPAN>, ¿¹dana przez nas wartoœæ zostanie wpisana do bufora wskazywanego przez <SPAN CLASS=T>lpData</SPAN>, zaœ rozmiar tej wartoœci w bajtach zostanie wpisany do zmiennej wskazywanej przez <SPAN CLASS=T>lpcbData</SPAN>.
</P>
<P>
Przewidziano jeszcze jedno zastosowanie funkcji <SPAN CLASS=T>RegQueryValueEx</SPAN>, mianowicie samo sprawdzenie, czy dana wartoœæ istnieje, bez jej pobierania do bufora. Wówczas zamiast dwóch ostatnich wskaŸników podajemy <SPAN CLASS=T>NULL</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
result = RegQueryValueEx(hkTest, <SPAN CLASS=L>"MojaWartoœæ"</SPAN>, NULL, REG_NONE, NULL, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Wartoœæ istnieje ;-)", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
W tym przypadku u¿ycie <SPAN CLASS=T>REG_NONE</SPAN> jako typ wartoœci ma znaczenie czysto kosmetyczne - robimy tak, ¿eby na pierwszy rzut oka by³o widaæ, ¿e de facto nie pobieramy ¿adnej wartoœci.
</P>

<h2>
Usuwanie kluczy i wartoœci
</h2>

<P>
Usuwanie wartoœci nie jest spraw¹ skomplikowan¹, przynajmniej w porównaniu do wy¿ej opisanych funkcji. Zajmuje siê tym funkcja <SPAN CLASS=T>RegDeleteValue</SPAN> (tym razem bez Ex ;-)). Podajemy jej tylko uchwyt klucza i nazwê wartoœci do skasowania:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
result = RegDeleteValue(hkTest, <SPAN CLASS=L>"MojaWartoœæ"</SPAN>);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Z wartoœci pozosta³o tylko wspomnienie ", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
Analogicznie usuwamy klucze. Podobnie jak w przypadku otwierania kluczy, tak¿e i tutaj nie mo¿emy siê odwo³aæ do klucza bezpoœrednio, lecz musimy podaæ uchwyt do klucza nadrzêdnego i nazwê podklucza, który chcemy usun¹æ. Tak wiêc nie mo¿na usun¹æ kluczy, które s¹ najwy¿ej w hierarchii, np. <SPAN CLASS=L>HKEY_CLASSES_ROOT</SPAN> (no i bardzo dobrze ;-)). Przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
result = RegDeleteKey(hkSoftware, <SPAN CLASS=L>"test"</SPAN>); <SPAN CLASS=C>//usuñ klucz "test"</SPAN><BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Ulotny jest ¿ywot klucza... ;-)", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
W rodzinie Windows 9x klucze usuwane s¹ kaskadowo (czyli poklucz wraz ze wszystkimi ewentualnymi pod-podkluczami). W rodzinie NT (czyli równie¿ w Windows 2000 oraz XP) mo¿na usuwaæ tylko puste klucze (tj. nie mog¹ one zawieraæ ¿adnych podkluczy). Za to w tym drugim przypadku mo¿esz skorzystaæ z funkcji <SPAN CLASS=T>SHDeleteKey</SPAN>, aby usuwaæ klucze rekurencyjnie (kaskadowo).
</P>

<h2>
Wiêcej wartoœci naraz
</h2>

<P>
Odczytywanie wielu wartoœci pod rz¹d potrafi byæ deczko nu¿¹ce. Jeœli nie mamy pod rêk¹ jakiegoœ frajera, który by to za nas zakodzi³, mo¿emy sobie u³atwiæ ¿ycie dziêki funkcji <SPAN CLASS=T>RegEnumValue</SPAN>. Nie jest to mo¿e najprzyjaŸniejsza w u¿yciu funkcja WinAPI, ale i tak du¿o nam pomo¿e w sytuacjach podobnych do tej:
</P>

<p align=center>
<img src="../gfx/rejestr3.gif" alt="Nasze zadanie bojowe - 3 wartoœci do odczytania">
</p>

<P>
Funkcja <SPAN CLASS=T>RegEnumValue</SPAN> s³u¿y do pobieranie kolejnych wartoœci z danego podklucza (np. tych trzech powy¿ej). Poza tym u¿ywamy jej wtedy, gdy nie znamy nazw wartoœci, do których w³aœnie siê chcemy dobraæ ;-). Sk³adnia jest nastêpuj¹ca:
</P>

<TABLE WIDTH=100%>
<TR><TD CLASS=ARGLIST COLSPAN=2>
<U>Sk³adnia</U>: RegEnumValue(<I>hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData</I>)
</TD></TR>
<TR><TH CLASS=ARGLIST>Argument</TH><TH CLASS=ARGLIST>Znaczenie</TH></TR>
<TR><TD CLASS=ARGLIST><I>hKey</I></TD><TD CLASS=ARGLIST>uchwyt klucza</TD></TR>
<TR><TD CLASS=ARGLIST><I>dwIndex</I></TD><TD CLASS=ARGLIST>Indeks wartoœci do odczytania</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpValueName</I></TD><TD CLASS=ARGLIST>Bufor na nazwê wartoæci</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpcbValueName</I></TD><TD CLASS=ARGLIST>Adres zmiennej z rozmiarem powyœzego bufora</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpReserved</I></TD><TD CLASS=ARGLIST>Nie dotykaæ</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpType</I></TD><TD CLASS=ARGLIST>Adres bufora na typ</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpData</I></TD><TD CLASS=ARGLIST>Adres bufora na dane</TD></TR>
<TR><TD CLASS=ARGLIST><I>lpcbData</I></TD><TD CLASS=ARGLIST>Adres na rozmiar bufora na dane</TD></TR>
</TABLE>
 
<P>
 U¿ywamy tej funkcji w ten sposób, ¿e wywo³ujemy j¹ tak d³ugo, a¿ zwróci <SPAN CLASS=T>ERROR_NO_MORE_ITEMS</SPAN>. Za ka¿dym wywo³aniem powinniœmy te¿ zwiêkszaæ wartoœæ <SPAN CLASS=T>dwIndex </SPAN>(zaczynaj¹c od <SPAN CLASS=L>0</SPAN>). Jeœli funkcja znajdzie w danym podkluczu wartoœæ o podanym przez nas indeksie, to umieœci jej nazwê w buforze wskazywanym przez <SPAN CLASS=T>lpValueName</SPAN>, typ w buforze wskazywanym przez <SPAN CLASS=T>lpType</SPAN>, natomiast wartoœæ w buforze wskazywanym przez <SPAN CLASS=T>lpData</SPAN>. Bufor na typ wartoœci musi byæ typu <SPAN CLASS=T>DWORD</SPAN>, natomiast pozosta³e dwa z wymienionych buforów powinne byæ odpowiednio du¿e, ¿eby pomieœciæ: nazwê i dane naszej wartoœci. Tylko jak uczyniæ je "odpowiednio du¿ymi", jeœli nie wiemy nic o wartoœci, któr¹ w³aœnie pobieramy?
</P>
<P>
Na szczêœcie informacja o maksymalnym rozmiarze tych buforów jest przechowywana przez system dla ka¿dego klucza osobno. Mo¿emy j¹ pobraæ za pomoc¹ <SPAN CLASS=T>RegQueryInfoKey</SPAN>. Liczba argumentów tej funkcji nie jest ma³a - "jedyne" 12. Wiêkszoœæ z nich to wskaŸniki do typu <SPAN CLASS=T>DWORD</SPAN>, ka¿dy z nich reprezentuje jakiœ atrybut klucza. Na szczêœcie te, które nas nie interesuj¹ (czyli wiêkszoœæ), mo¿na spokojnie ustawiæ na <SPAN CLASS=T>NULL</SPAN>. Chcemy tylko dwóch liczb - maksymalny rozmiar bufora na nazwê oraz bufora na wartoœæ. A ¿eby nas palce nie zabola³y od wpisywania tych <SPAN CLASS=T>NULL</SPAN>-ów, to pobierzemy sobie jeszcze ca³kowit¹ liczbê wartoœci w danym kluczu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD dwMaxName, dwMaxData, dwMaxIndex;<BR>
result = RegQueryInfoKey(hkTest, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxIndex, &dwMaxName, &dwMaxData, NULL, NULL);<BR>
<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=K>"Niesamowite, ale siê uda³o.", "Test"</SPAN>, MB_ICONINFORMATION);<BR>
</TD></TR>
</TABLE>

<P>
W ten oto sposób otrzymaliœmy interesuj¹ce nas dane. Wiemy ju¿, ile jest wszystkich wartoœci w kluczu <SPAN CLASS=T>hkTest</SPAN> (ich liczba jest w zmiennej <SPAN CLASS=T>dwMaxIndex</SPAN> - znaj¹c tê liczbê nie musimy sprawdzaæ, czy <SPAN CLASS=T>RegEnumValue</SPAN> zwróci³a <SPAN CLASS=T>ERROR_NO_MORE_ITEMS</SPAN>), wiemy równie¿, jak du¿e powinne byæ bufory, które teraz u¿yjemy wraz z <SPAN CLASS=T>RegEnumValue...</SPAN> No w³aœnie, rozmiar buforów. Twórcy funkcji operuj¹cych na rejestrze najwyraŸniej nie mogli siê zdecydowaæ, czy w rozmiar ten wliczaæ znak zerowy na koñcu, czy te¿ nie. W rezultacie nie doœæ, ¿e ka¿da funkcja interpretuje to inaczej, to jeszcze taka np. <SPAN CLASS=T>RegEnumValue</SPAN> przyjmuje rozmiar wraz z zerem, ale zwraca bez niego. ¯eby ten ba³agan jako tako opanowaæ, musimy zwiêkszyæ o 1 wartoœci otrzymane dziêki <SPAN CLASS=T>RegQueryInfoKey</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
++dwMaxName;<BR>
++dwMaxData;<BR>
</TD></TR>
</TABLE>

<P>
Drug¹ pu³apk¹ czyhaj¹c¹ na amatora rejestru jest fakt, ¿e <SPAN CLASS=T>RegEnumValue</SPAN>, jako siê rzek³o, coœ tam sobie zwraca oprócz kodu b³êdu. A tak dok³adniej - zwraca liczbê znaków, skopiowanych do podanych przez nas buforów, wpisuj¹c tê liczbê do zmiennych, których adresy podajemy (czyli u nas <SPAN CLASS=T>dwMaxName</SPAN> i <SPAN CLASS=T>dwMaxData</SPAN>). Poniewa¿ zaœ zmienne te przekazujemy jako argumenty wielokrotnie, wiêc przy ka¿dym wywo³aniu <SPAN CLASS=T>RegEnumValue</SPAN> musimy do nich wpisywaæ odpowiedni¹ wartoœæ od nowa. Dlatego te¿ bêdziemy potrzebowaæ dodatkowych dwóch zmiennych, w których zapamiêtamy pierwotne wartoœci <SPAN CLASS=T>dwMaxName</SPAN> i <SPAN CLASS=T>dwMaxData</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD dwMaxName_ = dwMaxName, dwMaxData_ = dwMaxData;<BR>
</TD></TR>
</TABLE>

<P>
Teraz dopiero mo¿emy przyst¹piæ do pobierania w pêtli kolejnych wartoœci z rejestru:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>char*</SPAN> ValueName = (<SPAN CLASS=K>char*</SPAN>)GlobalAlloc(GMEM_FIXED, dwMaxName);<BR>
<SPAN CLASS=K>char*</SPAN> Data = (<SPAN CLASS=K>char*</SPAN>)GlobalAlloc(GMEM_FIXED, dwMaxData);<BR>
<BR>
DWORD ValueType;<BR>
<BR>
<SPAN CLASS=K>for</SPAN>(DWORD i=<SPAN CLASS=L>0</SPAN>; i&lt;dwMaxIndex; ++i)<BR>
{<BR>
&nbsp;result = RegEnumValue(hkTest, i, ValueName, &dwMaxName, NULL, &ValueType, (LPBYTE)Data, &dwMaxData);<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(result == ERROR_SUCCESS)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;MessageBox(hwnd, ValueName, <SPAN CLASS=L>"Nazwa"</SPAN>, MB_ICONINFORMATION); <BR>
&nbsp;&nbsp;MessageBox(hwnd, Data, <SPAN CLASS=L>"Wartoœæ"</SPAN>, MB_ICONINFORMATION); <BR>
&nbsp;}<BR>
}<BR>
<BR>
GlobalFree(ValueName);<BR>
GlobalFree(Data);<BR>
</TD></TR>
</TABLE>

<P>
Powy¿szy przyk³adzik po prostu wyœwietla kolejno wszystkie wartoœci z klucza <SPAN CLASS=T>hkTest</SPAN>. Zak³adamy w nim, ¿e wszystkie wartoœci s¹ typu <SPAN CLASS=T>REG_SZ</SPAN> (dla przyzwoitoœci powinniœmy to najpierw sprawdziæ - typ wartoœci kopiowany jest tutaj do <SPAN CLASS=T>ValueType</SPAN> - jednak¿e, jak wiadomo, autor tej strony s³ynie z lenistwa).
</P>

<P>
Zwróæ uwagê, ¿e zgodnie z tym, co w MSDN napisano, kolejnoœæ pobierania wartoœci z rejestru mo¿e byæ dowolna (chocia¿ najczêœciej pobierane s¹ w takiej kolejnoœci, w jakiej zosta³y utworzone).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apimenu.html">&lt;&lt; Tworzenie menu</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apiclass.html">Subclassing i superclassing &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>