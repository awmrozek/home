<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs06.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs07.html"> Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H2>
6.3 Konstruktory z argumentami
</H2>

<P>
Jeœli konstruktor ma pusty wykaz argumentów, sprawa jest prosta. Jednak w praktyce wiêkszoœæ obiektów czymœ chcemy zainicjalizowaæ i wtedy pojawiaj¹ siê konflikty pomiêdzy konstruktorami klasy rodzicielskiej i potomnej. WeŸmy sobie klasê <SPAN CLASS=T>Rodzic</SPAN>, zawieraj¹c¹ zmienne <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>b</SPAN> oraz klasê <SPAN CLASS=T>Dzieciak</SPAN>, która dziedziczy tamte dwie zmienne oraz dodatkowo zawiera trzeci¹ zmienn¹, <SPAN CLASS=T>c</SPAN>. Obie klasy maj¹ odpowiednie konstruktory:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a, b;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Rodzic(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb)<BR>
&nbsp;&nbsp;{ a = na; b = nb; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Dzieciak : <SPAN CLASS=K>public</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> c;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Dzieciak(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb, <SPAN CLASS=K>int</SPAN> nc) : Rodzic(na, nb)<BR>
&nbsp;&nbsp;{ c = nc; }<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Widzimy tutaj coœ nowego - jest to budowa konstruktora klasy <SPAN CLASS=T>Dzieciak</SPAN>. Klasa ta dziedziczy zmienne <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>b</SPAN> od klasy <SPAN CLASS=T>Rodzic</SPAN>, a wiêc w sumie konstruktor musi zainicjalizowaæ trzy zmienne: <SPAN CLASS=T>a</SPAN>, <SPAN CLASS=T>b</SPAN> i <SPAN CLASS=T>c</SPAN>, co widaæ w jego wykazie argumentów. Zmienn¹ <SPAN CLASS=T>c</SPAN> klasa <SPAN CLASS=T>Dzieciak</SPAN> musi inicjalizowaæ sama w normalny sposób, ale ZANIM to zrobi, wywo³uje jawnie konstruktor klasy <SPAN CLASS=T>Rodzic</SPAN>, aby ten zainicjalizowa³ "swoje" zmienne argumentami <SPAN CLASS=T>na</SPAN> i <SPAN CLASS=T>nb</SPAN>. W ten sposób mamy pewnoœæ, ¿e konstruktory siê nie pok³óc¹; ka¿dy dba o "swoje" zmienne.
</P>
<P>
Dodam jeszcze, ¿e po tym tajemniczym dwukropku, który umo¿liwi³ nam jawne wywo³anie konstruktora klasy <SPAN CLASS=T>Rodzic</SPAN>, mo¿emy sobie wstawiæ niemal dowolne wyra¿enie, a wiêc tak¿e np. wywo³anie jakiejœ funkcji sk³adowej, co daje nam du¿¹ swobodê przy budowaniu konstruktora klasy potomnej.
</P>
<P>
SprawdŸmy, czy siê udadz¹ stuczki z "leniw¹" wersj¹ konstruktora, tworz¹c obiekt typu <SPAN CLASS=T>Dzieciak</SPAN> (tylko bez skojarzeñ proszê ;-)):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Dzieciak A(<SPAN CLASS=L>10</SPAN>,<SPAN CLASS=L>20</SPAN>,<SPAN CLASS=L>30</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
No, efektu wielkiego nie widaæ, ale gdybyœmy dorzucili do obu klas jakieœ funkcje wypisuj¹ce stan zmiennych sk³adowych na ekran, moglibyœmy siê na w³asne oczêta przekonaæ, ¿e wszystko jest OK:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR></SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a, b;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Rodzic(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb)<BR>
&nbsp;&nbsp;{ a = na; b = nb; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> PodajR()<BR>
&nbsp;&nbsp;{ cout << <SPAN CLASS=L>"a="</SPAN> << a << <SPAN CLASS=L>", b="</SPAN> << b << endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Dzieciak : <SPAN CLASS=K>public</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> c;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Dzieciak(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb, <SPAN CLASS=K>int</SPAN> nc) : Rodzic(na, nb)<BR>
&nbsp;&nbsp;{ c = nc; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> PodajD()<BR>
&nbsp;&nbsp;{ PodajR(); cout << <SPAN CLASS=L>"c="</SPAN> << c << endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Rodzic R(<SPAN CLASS=L>2</SPAN>,<SPAN CLASS=L>3</SPAN>);<BR>
&nbsp;Dzieciak D(<SPAN CLASS=L>10</SPAN>,<SPAN CLASS=L>20</SPAN>,<SPAN CLASS=L>30</SPAN>);<BR>
<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Rodzica: "</SPAN> << endl;<BR>
&nbsp;R.PodajR();<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Dzieciaka: "</SPAN> << endl;<BR>
&nbsp;D.PodajD();<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Efekt jest zgodny z naszymi oczekiwaniami:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black;">
<SPAN CLASS=W>
Stan Rodzica:<BR>
a=2, b=3<BR>
Stan Dzieciaka:<BR>
a=10, b=20<BR>
c=30<BR>
Naciœnij dowolny klawisz, aby kontynuowaæ . . .<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Poniewa¿ jesteœmy leniwi, do wypisania sk³adowych <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>b</SPAN> obiektu klasy <SPAN CLASS=T>Dzieciak</SPAN> u¿yliœmy odziedziczonej funkcji <SPAN CLASS=T>PodajR</SPAN>, natomiast tylko do wypisania stanu zmiennej <SPAN CLASS=T>c</SPAN> dopisaliœmy "nowy" kod. A co, wolno nam!
</P>

<H2>
6.4 Przys³anianie
</H2>

<P>
W poprzednim podrozdziale celowo u¿yliœmy ró¿nych nazw dla funkcji wypisuj¹cych stan obiektu; w klasie <SPAN CLASS=T>Rodzic</SPAN> by³a to nazwa <SPAN CLASS=T>PodajR</SPAN>, a w klasie <SPAN CLASS=T>Dzieciak</SPAN> - <SPAN CLASS=T>PodajD</SPAN>. Taki zabieg pozwoli³ nam dodatkowo na u¿ycie funkcji <SPAN CLASS=T>PodajR</SPAN> wewn¹trz klasy <SPAN CLASS=T>Dzieciak</SPAN>, a wiêc nie musieliœmy siê trudziæ wypisywaniem zmiennych <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>b</SPAN>. Co natomiast sta³oby siê, gdyby zrobiæ w tych dwóch klasach dwie zupe³nie ze sob¹ nie powi¹zane funkcje <SPAN CLASS=T>Podaj</SPAN>? SprawdŸmy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR></SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a, b;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Rodzic(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb)<BR>
&nbsp;&nbsp;{ a = na; b = nb; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Podaj()<BR>
&nbsp;&nbsp;{ cout << <SPAN CLASS=L>"a="</SPAN> << a << <SPAN CLASS=L>", b="</SPAN> << b << endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Dzieciak : <SPAN CLASS=K>public</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> c;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Dzieciak(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb, <SPAN CLASS=K>int</SPAN> nc) : Rodzic(na, nb)<BR>
&nbsp;&nbsp;{ c = nc; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Podaj()<BR>
&nbsp;&nbsp;{ cout << <SPAN CLASS=L>"a="</SPAN> << a << <SPAN CLASS=L>", b="</SPAN> << b << <SPAN CLASS=L>", c="</SPAN> << c << endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Rodzic R(<SPAN CLASS=L>2</SPAN>,<SPAN CLASS=L>3</SPAN>);<BR>
&nbsp;Dzieciak D(<SPAN CLASS=L>10</SPAN>,<SPAN CLASS=L>20</SPAN>,<SPAN CLASS=L>30</SPAN>);<BR>
<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Rodzica: "</SPAN> << endl;<BR>
&nbsp;R.Podaj();<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Dzieciaka: "</SPAN> << endl;<BR>
&nbsp;D.Podaj();<BR>
&nbsp;cout << <SPAN CLASS=L>"Zmienne a i b Dzieciaka: "</SPAN> << endl;<BR>
&nbsp;D.Rodzic::Podaj();<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Niespodzianka - nic siê nie stanie! Program skompilowa³ siê prawid³owo. Funkcja <SPAN CLASS=T>Podaj</SPAN> z klasy <SPAN CLASS=T>Rodzic</SPAN> zosta³a przes³oniêta przez funkcjê o takiej samej nazwie z klasy <SPAN CLASS=T>Dzieciak</SPAN>, a wiêc instrukcja <SPAN CLASS=T>R.Podaj()</SPAN> wywo³uje <SPAN CLASS=T>Podaj</SPAN> z klasy <SPAN CLASS=T>Rodzic</SPAN>, a <SPAN CLASS=T>D.Podaj()</SPAN> wywo³uje <SPAN CLASS=T>Podaj</SPAN> z klasy <SPAN CLASS=T>Dzieciak</SPAN>. ¯eby by³o œmieszniej, nadal mamy dostêp do "starej wersji" funkcji <SPAN CLASS=T>Podaj</SPAN> w klasie <SPAN CLASS=T>Dzieciak</SPAN>! Robimy to tak: <SPAN CLASS=T>D.Rodzic::Podaj()</SPAN>, jak powy¿ej zreszt¹. Oto wydruk z programu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Stan Rodzica:<BR>
a=2, b=3<BR>
Stan Dzieciaka:<BR>
a=10, b=20, c=30<BR>
Zmienne a i b Dzieciaka:<BR>
a=10, b=20<BR>
Naciœnij dowolny klawisz, aby kontynuowaæ . . .
</SPAN>
</TD></TR>
</TABLE>

<H2>
6.5 Konwersje
</H2>

<P>
Równie ciekawie jest z konwersjami w hierarchii klas. Rozbudujmy trochê naszego Rodzica, dorzucaj¹c mu operator przypisania:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a, b;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Rodzic(<SPAN CLASS=K>int</SPAN> na, <SPAN CLASS=K>int</SPAN> nb)<BR>
&nbsp;&nbsp;{ a = na; b = nb; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Podaj()<BR>
&nbsp;&nbsp;{ cout << <SPAN CLASS=L>"a="</SPAN> << a << <SPAN CLASS=L>", b="</SPAN> << b << endl; }<BR>
&nbsp;Rodzic& <SPAN CLASS=K>operator=</SPAN>(<SPAN CLASS=K>const</SPAN> Rodzic& obj)<BR>
&nbsp;&nbsp;{ a = obj.a; b = obj.b; <SPAN CLASS=K>return *this</SPAN>; }<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W klasie <SPAN CLASS=T>Dzieciak</SPAN> zostawiamy wszystko po staremu i testujemy nasz nowy operatorek:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Rodzic R(<SPAN CLASS=L>1</SPAN>,<SPAN CLASS=L>2</SPAN>);<BR>
&nbsp;Dzieciak D(<SPAN CLASS=L>3</SPAN>,<SPAN CLASS=L>4</SPAN>,<SPAN CLASS=L>5</SPAN>);<BR> 
<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Rodzica przed przypisaniem: "</SPAN>;<BR>
&nbsp;R.Podaj();<BR>
&nbsp;cout << <SPAN CLASS=L>"Stan Rodzica po przypisaniu: "</SPAN>;<BR>
&nbsp;R = D;<BR>
&nbsp;R.Podaj();<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Dostajemy takie napisy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Stan Rodzica przed przypisaniem: a=1, b=2<BR>
Stan Rodzica po przypisaniu: a=3, b=4<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Zastanawiasz siê, co w³aœciwie siê sta³o? Proste jak drut: mo¿liwa jest niejawna konwersja obiektu klasy potomnej na obiekt klasy rodzicielskiej! Wykonuj¹c instrukcjê <SPAN CLASS=T>R = D</SPAN> komputer po prostu przepisa³ wartoœci zmiennych <SPAN CLASS=T>a</SPAN> i <SPAN CLASS=T>b</SPAN> z obiektu <SPAN CLASS=T>D</SPAN> do obiektu <SPAN CLASS=T>R</SPAN>, natomiast zmienn¹ <SPAN CLASS=T>c</SPAN> po prostu sobie zignorowa³, poniewa¿ klasa <SPAN CLASS=T>Rodzic</SPAN> jej nie zna.
</P>
<P>
W drug¹ stronê oczywiœcie to nie dzia³a, tzn. nie mo¿emy napisaæ <SPAN CLASS=T>D = R</SPAN>. Mo¿emy za to dodaæ odpowiedni operator konwersji do klasy <SPAN CLASS=T>Dzieciak</SPAN> i wtedy bêdzie siê da³o zrobiæ równie¿ i takie przypisanie. 
</P>
<P>
Co ciekawe, wskaŸniki i referencje do klasy rodzicielskiej mog¹ byæ u¿ywane tak¿e z obiektami klasy potomnej (co, rzecz jasna, jest zupe³nie niezale¿ne od zdefiniowania operatora <SPAN CLASS=T>'='</SPAN>):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Dzieciak D;<BR>
Rodzic* wskRodzic;<BR>
wskRodzic = &D;<BR>
Rodzic& refRodzic = D;<BR>
</TD></TR>
</TABLE>

<H2>
6.6 Dziedziczenie mnogie
</H2>

<P>
Obiekt w C++ mo¿e mieæ wielu rodziców. Sam te¿ mo¿e byæ rodzicem dla wielu innych obiektów. Realizuje siê to w tzw. <SPAN CLASS=Wazne>dziedziczeniu mnogim</SPAN>. W ten sposób mo¿emy tworzyæ naprawdê skomplikowane hierarchie klas. Mo¿emy te¿ u¿yæ dziedziczenia mnogiego do ca³kiem niewinnego celu, np. stworzenia hybrydy psa i dzia³a laserowego ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> MechPiesek<BR>
{<BR>
<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> kolor;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> wielkosc;<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> wypisz_imie();<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> szczekaj();<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> aportuj();<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Laser<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> strzel();<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> MechPsisko : <SPAN CLASS=K>public</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> atakuj_akwizytora();<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Hybryda : <SPAN CLASS=K>public</SPAN> MechPsisko, <SPAN CLASS=K>public</SPAN> Laser<BR>
{<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Jak widzimy, klasa Hybryda jest zupe³nie pusta, a jednak ma sporo mo¿liwoœci - wszystkie odziedziczone - a wiêc: mo¿e strzelaæ z lasera, mo¿e atakowaæ akwizytora, mo¿e szczekaæ, aportowaæ i wypisywaæ swoje imiê, a w dodatku posiada kolor i wielkoœæ. Widzimy równie¿, ¿e specyfikatory i nazwy klas rodzicielskich przy dziedziczeniu rozdzieliliœmy przecinkiem.
</P>
<P>
Nasz schemat dziedziczenia tworzy ju¿ ca³e drzewo, mo¿na go przedstawiæ nastêpuj¹co:
</P>
<P ALIGN=CENTER>
<IMG SRC = "../gfx/drzewo.gif" ALT="Schemat dziedziczenia dla bie¿¹cego przyk³adu">
</P>
<P>
Nad dziedziczeniem mnogim nie ma siê co rozwodziæ, bo wszystko jest tu prawie takie samo, jak w dziedziczeniu pojedynczym. Warto jednak wspomnieæ o przys³anianiu dziedziczonych sk³adowych. Kiedy np. dziedziczymy od dwóch klas równoczeœnie i w obu tych klasach wystêpuj¹ sk³adowe o identycznych nazwach, to przes³oniêcie nie nast¹pi, poniewa¿ kompilator nie bêdzie móg³ rozstrzygn¹æ, która z tych dwóch klas jest "wa¿niejsza". Z tego powodu ¿adna z dwóch sk³adowych nie bêdzie bezpoœrednio dostêpna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR>
</SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> Rodzic1<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> x;<BR>
&nbsp;Rodzic1(<SPAN CLASS=K>int</SPAN> z) { x=z; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Rodzic2<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> x;<BR>
&nbsp;Rodzic2(<SPAN CLASS=K>int</SPAN> z) { x=z; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Dzieciak : <SPAN CLASS=K>public</SPAN> Rodzic1, <SPAN CLASS=K>public</SPAN> Rodzic2<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a;<BR>
&nbsp;Dzieciak(<SPAN CLASS=K>int</SPAN> z1, <SPAN CLASS=K>int</SPAN> z2, <SPAN CLASS=K>int</SPAN> z3)<BR>
&nbsp;&nbsp;: Rodzic1(z1), Rodzic2(z2) { a=z3; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Dzieciak D(<SPAN CLASS=L>5</SPAN>,<SPAN CLASS=L>10</SPAN>,<SPAN CLASS=L>15</SPAN>);<BR>
&nbsp;cout << D.Rodzic1::x << endl;<BR>
&nbsp;cout << D.Rodzic2::x << endl;<BR>
&nbsp;cout << D.a << endl;<BR>
<SPAN CLASS=C>// cout << D.x << endl; //tak nie mo¿na!</SPAN><BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
W sumie klasa <SPAN CLASS=T>Dzieciak</SPAN> ma tu trzy sk³adowe zmienne: w³asn¹ <SPAN CLASS=T>a</SPAN> oraz dwie odziedziczone <SPAN CLASS=T>x</SPAN>. Konstruktor dla takich dwóch niejawnych zmiennych o identycznych nazwach jest dok³adnie taki sam, jak we wczeœniejszych przyk³adach, ale odwo³ania do tych zmiennych - nie bardzo. Nie mo¿emy odwo³ywaæ siê do nich bezpoœrednio, tak jak w wykomentowanej linijce, poniewa¿ kompilator stwierdzi, ¿e jest to niejednoznacznoœæ (mo¿esz sprawdziæ, usuwaj¹c komentarz). Musimy u¿yæ operatora dostêpu <SPAN CLASS=T>::</SPAN> (podwójny dwukropek), ¿eby pokazaæ kompilatorowi, do której zmiennej <SPAN CLASS=T>x</SPAN> chcemy siê odwo³aæ. Powy¿szy przyk³ad pokazuje zreszt¹, ¿e <SPAN CLASS=T>x</SPAN> w klasie <SPAN CLASS=T>Dzieciak</SPAN> to dwie zupe³nie niezale¿ne zmienne: jedna bêdzie zawieraæ wartoœæ <SPAN CLASS=L>5</SPAN>, a druga <SPAN CLASS=L>10</SPAN>.
</P>

<H2>
6.7 Przestroga na przysz³oœæ ;-)
</H2>

<P>
Nie rozpêdzaj siê zbytnio z tym dziedziczeniem. To dobra rzecz, ale stosuj je tylko wtedy, gdy jest to naprawdê potrzebne. Bardzo rozleg³e hierarchie klas s¹ bardzo trudne do zaprojektowania, zupe³nie niepostrze¿enie mo¿na w nich zrobiæ trudny do wykrycia b³¹d, który sprawi, ¿e ca³a hierarchia nie bêdzie dzia³aæ.
</P>
<P>
Z dziedziczeniem jest w C++ tak samo, jak w naturze. Gdyby jakiœ gatunek zwierz¹tek, np. cz³owiek, okaza³ siê na tyle g³upi, by wynaleŸæ cywilizacjê, przestaæ uznawaæ prawo d¿ungli i przestaæ zabijaæ s³absze zwierz¹tka aby mog³y przetrwaæ silniejsze, to te s³absze rozmna¿aj¹c siê przekazywa³yby swoje s³abe geny dalej, a¿ w koñcu skazi³yby nimi ca³y gatunek, który by zgin¹³, do czego nawiasem mówi¹c nieuchronnie zmierzamy. Sytuacjê analogiczn¹ mamy w klasach: klasa s³aba, z najmniejszym nawet b³êdem mo¿e popsuæ wszystkie swoje klasy potomne. W dodatku takie b³êdy potêguj¹ siê z ka¿dym dziedziczeniem, a¿ w koñcu "najm³odsza" klasa jest jednym wielkim b³êdem.
</P>
<P>
Im drzewo klas rozleglejsze, tym trudniej programiœcie ogarn¹æ je umys³em, a wiêc tym trudniej kontrolowaæ. Pamiêtaj!
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs06.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs07.html"> Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>