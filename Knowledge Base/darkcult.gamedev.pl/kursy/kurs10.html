<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Wyj¹tki, cz.1</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs10.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h1>
Wyj¹tki
</h1>

<H2>
Po co to komu?
</H2>

<p>
Im bardziej z³o¿ony jest program, który piszemy, tym trudniej jest nam przewidzieæ wszystkie mo¿liwe "scenariusze" jego wykorzystania przez potencjalnego u¿ytkownika (nawet jeœli to my jesteœmy tym u¿ytkownikiem!). Oczywiœcie, zawsze mo¿na napisaæ bardzo szczegó³ow¹ instrukcjê, gdzie punkt po punkcie wyjaœnimy, co mo¿na robiæ, a czego nie mo¿na, jednak nawet jeœli uda³oby nam siê tak¹ instrukcjê napisaæ w odpowiednio krótkim czasie, to nie mo¿emy oczekiwaæ, ¿e ka¿dy user jest geniuszem, zdolnym tak¹ instrukcjê po pierwszym przeczytaniu od razu sobie przyswoiæ. W praktyce bywa zupe³nie inaczej (co zreszt¹ wiemy z w³asnych doœwiadczeñ, choæby z naszym w³asnym IDE). Uczymy siê obs³ugi programów (tak¿e gier) powoli, zwykle metod¹ prób i b³êdów. Jeœli b³êdy maj¹ zbyt wiele bolesnych skutków (np. program ci¹gle siê bezczelnie wykrzacza), to zniechêcamy siê do dalszych prób.
</p>
<P>
Tak wiêc jeœli chcemy, by ktokolwiek mêczy³ siê z naszymi programami, musimy uczyniæ je maksymalnie odpornymi na <SPAN CLASS=Wazne>wyj¹tkowe sytuacje</SPAN> (zarówno te, które s¹ lub powinny byæ ca³kowicie przewidywalne, np. brak podanego przez u¿ytkownika pliku lub wyczerpanie siê zasobów systemowych, jak i te nieco bardziej "nietypowe", jak np. brak pliku DLL niezbêdnego do dzia³ania naszego programu lub nag³e "znikniêcie" karty graficznej). Pytanie brzmi: co to znaczy "maksymalnie odpornymi"?
</P>
<P>
Od strony u¿ytkownika naszego programu znaczy to, ¿e:
</P>

<UL>
<LI>Program w sytuacjach wyj¹tkowych nie mo¿e traciæ kontroli (co zwykle objawia siê prób¹ wtargniêcia w "cudzy" obszar pamiêci operacyjnej i - przynajmniej w systemie Windows - nies³awnym komunikatem "Program wykona³ niedozwolon¹ operacjê...")
<LI>W przypadku wyst¹pienia sytuacji wyj¹tkowej program powinien spróbowaæ jakoœ z niej wybrn¹æ, a jeœli jest to niemo¿liwe, to przynajmniej pozwoliæ u¿ytkownikowi zapisaæ wyniki jego dotychczasowej pracy (lub stanu gry) i zwolniæ zarezerwowane zasoby systemowe (np. RAM)
<LI>Wyst¹pienie sytuacji wyj¹tkowej (w skrócie: <SPAN CLASS=Wazne>wyj¹tku</SPAN>) musi byæ zakomunikowane u¿ytkownikowi (niedopuszczalne jest pozwolenie programowi np. na zakoñczenie dzia³ania bez wyœwietlenia jakiegoœ komunikatu)
<LI>Komunikat o wyj¹tku powinien zawieraæ maksymaln¹ iloœæ informacji, która mog³aby u³atwiæ u¿ytkownikowi usuniêcie przyczyny powstania tego wyj¹tku (np. brak pliku DLL), a w ostatecznoœci - u³atwiæ programiœcie naprawienie b³êdu w kodzie
</UL>

<P>
T³umacz¹c to na jêzyk programistyczny:
</P>

<UL>
<LI>Musi istnieæ sposób na przekazanie sterowania z miejsca w kodzie, gdzie wyst¹pi³ wyj¹tek, do innego miejsca, gdzie nast¹pi obs³uga tego wyj¹tku
<LI>Sposób ten musi byæ taki, ¿eby istnia³ powrót do "g³ównej pêtli" programu (np. do pêtli komunikatów w WinAPI) lub przynajmniej wywo³ania dowolnej procedury (w domyœle: zapisuj¹cej efekty pracy u¿ytkownika do pliku i/lub zwalniaj¹cej zasoby)
<LI>Musi zostaæ wyœwietlona wiadomoœæ, mile widziany jest dziennik (w jêzyku marynarzy: <SPAN CLASS=Inglisz>log)</SPAN>, zawieraj¹cy listê najwa¿niejszych zdarzeñ, które mog³y doprowadziæ do sytuacji wyj¹tkowej
<LI>Musi istnieæ sposób przekazania wszelkich mo¿liwych informacji o wyj¹tku z miejsca jego wyst¹pienia do miejsca obs³ugi wyj¹tku
</UL>

<P>
S¹ ró¿ne sposoby spe³nienia wszystkich powy¿szych postulatów (nie bêdziemy ich omawiaæ, ale od czasu do czasu pojawi¹ siê wzmianki o "tradycyjnych metodach obs³ugi b³êdów"). Ka¿dy z tych sposobów ma jednak pewne wady, dlatego te¿ wprowadzono do jêzyka C++ specjalny mechanizm, który (przynajmniej w za³o¿eniach) wad tych nie posiada, a za to potrafi zrobiæ wszystkie wymienione rzeczy. Dyskusjê o rzeczywistej przydatnoœci tego mechanizmu w praktyce zostawiamy sobie na koniec tej czêœci kursu, natomiast teraz zajmiemy siê samym omówieniem obs³ugi wyj¹tków w C++.
</P>

<H2>
Rzucanie wyj¹tków
</h2>

<p>
Jak ju¿ wspomnieliœmy - wykrycie, ¿e wyst¹pi³ wyj¹tek oraz zg³oszenie tego faktu nale¿y do programisty, czyli do nas. ¯eby to zrobiæ, najpierw musimy w specjalny sposób oznaczyæ miejsce, gdzie mo¿e siê wydarzyæ coœ nieprzyjemnego. Ten specjalny sposób to nowy rodzaj bloku - <SPAN CLASS=K>try</SPAN>. Robimy to mniej wiêcej tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
// "zwyk³e" instrukcje<BR>
</SPAN>
<BR>
<SPAN CLASS=K>
try</SPAN><BR>
{<BR>
&nbsp;<SPAN CLASS=C>// ...<BR>
&nbsp;// strefa zagro¿enia ;-)<BR>
&nbsp;// ...</SPAN><BR>
}<BR>
<BR><SPAN CLASS=C>
// dalszy ci¹g "zwyk³ych" instrukcji</SPAN><BR>
</TD></TR>
</TABLE>

<P>
W jaki sposób okreœliæ, które fragmenty naszego kodu nale¿y obj¹æ blokiem <SPAN CLASS=K>try</SPAN> - o tym powiemy sobie póŸniej. Na razie mo¿emy przyj¹æ, ¿e robi siê to intuicyjnie :-).
</P>
<P>
Nastêpnym krokiem jest wykrycie, ¿e nast¹pi³ wyj¹tek oraz zg³oszenie go, czyli rzucenie wyj¹tku. Na przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>// "zwyk³e" instrukcje</SPAN><BR>
<BR>
<SPAN CLASS=K>try</SPAN><BR>
{<BR>
&nbsp;wynik = zrob_cos();<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wynik == <SPAN CLASS=L>0</SPAN>) <SPAN CLASS=K>throw</SPAN> wynik;<BR>
}<BR>
<BR><SPAN CLASS=C>
// ci¹g dalszy "zwyk³ych" instrukcji</SPAN><BR>
</TD></TR>
</TABLE>

<P>
Rzucenie wyj¹tku wi¹¿e siê z przekazaniem sterowania innej czêœci kodu, wiêc mo¿emy sobie wyobraziæ, ¿e <SPAN CLASS=K>throw</SPAN> jest jakby inn¹ wersj¹ instrukcji <SPAN CLASS=K>return</SPAN>. Drug¹ analogi¹ jest fakt, ¿e <SPAN CLASS=K>throw</SPAN> równie¿ przekazuje pewn¹ wartoœæ jako parametr (w powy¿szym przyk³adzie jest nim wartoœæ zmiennej <SPAN CLASS=T>wynik</SPAN>). Parametr ten z za³o¿enia s³u¿y przede wszystkim do przekazania (o czym wspomnieliœmy na pocz¹tku) jak najpe³niejszej informacji o wyj¹tku, np. rodzaj b³êdu, miejsce wyst¹pienia.
</P>

<h2>
£apanie wyj¹tków
</h2>

<P>
Teraz zastanówmy siê, co dzieje siê z rzuconym wyj¹tkiem. O ile grawitacja funkcjonuje prawid³owo, to powinien gdzieœ spaœæ ;-). Sêk w tym, ¿e wyj¹tek to wielce delikatna rzecz i móg³by narobiæ niez³ego ba³aganu, gdyby tak po prostu waln¹³ o pod³o¿e, dlatego te¿ nale¿y zrobiæ wszystko, aby go przedtem z³apaæ.
</P>
<P>
£apanie odbywa siê w bloku <SPAN CLASS=K>catch</SPAN>. Ka¿dy blok <SPAN CLASS=K>try</SPAN> powinien mieæ odpowiadaj¹cy mu przynajmniej jeden blok <SPAN CLASS=K>catch</SPAN>, umieszczony bezpoœrednio (wa¿ne!) za blokiem <SPAN CLASS=K>try</SPAN>. Jeœli kompilator takowego nie znajdzie, to odmówi dalszej kompilacji naszego programu. Blok <SPAN CLASS=K>catch</SPAN> mo¿e wygl¹daæ nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> wynik;<BR>
<BR><SPAN CLASS=C>
// "zwyk³e" instrukcje</SPAN><BR>
<BR>
<SPAN CLASS=K>try</SPAN><BR>
{<BR>
&nbsp;wynik = zrob_cos();<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(wynik == <SPAN CLASS=L>0</SPAN>) <SPAN CLASS=K>throw</SPAN> wynik;<BR>
}<BR>
<BR>
<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>int</SPAN> a)<BR>
{<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Z³apa³em wyj¹tek. Parametr a="</SPAN> &lt;&lt; a &lt;&lt; endl;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Dzia³anie tego mechanizmu jest nastêpuj¹ce. W normalnym przebiegu programu (tzn. gdy wartoœæ zmiennej <SPAN CLASS=T>wynik</SPAN> jest niezerowa) instrukcje znajduj¹ce siê w bloku <SPAN CLASS=K>catch</SPAN> nie s¹ wykonywane. Dopiero gdy <SPAN CLASS=T>wynik ==</SPAN><SPAN CLASS=L> 0</SPAN>, wtedy wchodzimy do bloku <SPAN CLASS=K>catch</SPAN>. Blok ten przypomina definicjê funkcji; tutaj równie¿ mamy listê parametrów. Oznacza ona <SPAN CLASS=Wazne>typy wyj¹tków</SPAN>, jakie mo¿e ³apaæ dany blok <SPAN CLASS=K>catch</SPAN>.  W naszym przyk³adzie mamy prost¹ sytuacjê: rzucamy wyj¹tek typu <SPAN CLASS=K>int</SPAN> i mamy dok³adnie jeden blok <SPAN CLASS=K>catch</SPAN>, ³api¹cy wyj¹tki typu <SPAN CLASS=K>int</SPAN>. Jednak nieco dalej bêdziemy omawiaæ równie¿ sytuacje, kiedy rzucamy ró¿ne typy wyj¹tków i dysponujemy wieloma blokami <SPAN CLASS=K>catch</SPAN>.
</P>
<P>
Póki co jednak, dokoñczmy omawianie tej prostszej sytuacji na nieco bardziej konkretnym przyk³adzie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;cstdlib&gt;<BR>
#include &lt;iostream&gt;</SPAN><BR>
<BR><SPAN CLASS=K>
using namespace</SPAN> std;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> tab[<SPAN CLASS=L>3</SPAN>] = {<SPAN CLASS=L> 10,20,30</SPAN> }, indeks;<BR>
 <BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Podaj indeks (0-2): "</SPAN>;<BR>
&nbsp;cin &gt;&gt; indeks;<BR>
&nbsp;cout &lt;&lt; endl &lt;&lt; endl;<BR>
<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(indeks &lt; <SPAN CLASS=L>0</SPAN> || indeks &gt; <SPAN CLASS=L>2</SPAN>) <SPAN CLASS=K>throw</SPAN> indeks;<BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Element "</SPAN> &lt;&lt; indeks &lt;&lt; <SPAN CLASS=L>" jest rowny "</SPAN> &lt;&lt; tab[indeks] &lt;&lt; endl;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>int</SPAN> nWartosc)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;clog &lt;&lt; <SPAN CLASS=L>"Nieprawidlowa wartosc indeksu: "</SPAN> &lt;&lt; nWartosc &lt;&lt; endl;<BR>
&nbsp;}<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mamy tu tablicê trzech liczb. Program prosi u¿ytkownika o podanie indeksu, po czym wypisuje na ekranie liczbê o tym indeksie. Prawid³owe s¹ oczywiœcie indeksy z zakresu <SPAN CLASS=L>0-2</SPAN>, zaœ jeœli podamy inny, to zostanie rzucony wyj¹tek z tym nieprawid³owym indeksem w roli parametru. Dziêki temu unikamy wykrzaczenia siê naszego programu, które mo¿e byæ spowodowane wpisaniem np. zbyt du¿ej liczby. Po rzuceniu wyj¹tku przeskakujemy do jedynego bloku <SPAN CLASS=K>catch</SPAN>, gdzie zostaje wypisany odpowiedni komunikat (<SPAN CLASS=T>clog</SPAN> dzia³a praktycznie tak samo jak <SPAN CLASS=T>cout</SPAN>, z tym ¿e do wypisywania komunikatów o b³êdach zaleca siê w³aœnie obiekty <SPAN CLASS=T>clog</SPAN> i <SPAN CLASS=T>cerr</SPAN>).
</P>

<h2>
Wiele bloków catch
</h2>

<P>
Jeœli rzucamy wyj¹tki o ró¿nych typach, to musimy byæ przygotowani na ³apanie ich w kilku oddzielnych blokach <SPAN CLASS=K>catch</SPAN>. Jak to wygl¹da, demonstruje ten oto przyk³adzik:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;cstdlib&gt;<BR>
#include &lt;iostream&gt;</SPAN><BR>
<BR><SPAN CLASS=K>
using namespace</SPAN> std;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>char</SPAN> typ, wyj_c;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> wyj_i;<BR>
&nbsp;<SPAN CLASS=K>float</SPAN> wyj_f;<BR>
<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{ <BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Podaj typ wyj¹tku (c/f/i): "</SPAN>;<BR>
&nbsp;&nbsp;cin &gt;&gt; typ;<BR>
&nbsp;&nbsp;cout &lt;&lt; endl &lt;&lt; endl;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>switch</SPAN>(typ)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'c'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_c;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'f'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_f;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'i'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_i;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>char</SPAN>)  { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu char"</SPAN>  &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>float</SPAN>) { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu float"</SPAN> &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>int</SPAN>)   { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu int"</SPAN>   &lt;&lt; endl; }<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Po rzuceniu wyj¹tku danego typu, program sam znajdzie sobie odpowiedni blok <SPAN CLASS=K>catch</SPAN>, co mo¿emy sprawdziæ uruchamiaj¹c ten program. Co zaœ stanie siê, jeœli takiego nie znajdzie? Có¿, nieweso³o bêdzie. Program po prostu natychmiast zakoñczy swój krótki ¿ywot. Wywo³ana zostaje wtedy funkcja <SPAN CLASS=T>unexpected</SPAN> (nazwa pochodzi od wyra¿enia <SPAN CLASS=Inglisz>unexpected exception</SPAN>, czyli "niespodziewany wyj¹tek"), która domyœlnie wywo³uje funkcjê <SPAN CLASS=T>terminate</SPAN>, a ta z kolei wywo³uje <SPAN CLASS=T>abort</SPAN>, co oznacza natychmiastowe przerwanie wykonywania programu. 
</P>

<P class=UWAGA>
Niez³apane wyj¹tki powoduj¹ wyjœcie z programu.
</P>

<P>
Dlatego w³aœnie musimy siê tak bardzo staraæ, ¿eby wszystkie wyj¹tki zosta³y z³apane :-). Nie ma siê jednak co martwiæ, gdy¿ w praktyce niekoniecznie musi to byæ takie trudne, jak siê wydaje.
</P>

<h2>
Niez³apane wyj¹tki
</h2>

<P>
Rodzajem zabezpieczenia przeciwko takim niespodziewanym wyj¹tkom mo¿e byæ "uniwersalna" wersja bloku <SPAN CLASS=K>catch</SPAN>. Wygl¹da ona nastêpuj¹co:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>catch</SPAN>(...)<BR>
{<BR>
&nbsp;<SPAN CLASS=C>// tutaj obs³ugujemy wszystkie niespodziewane wyj¹tki</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Dzia³a to w ten sposób, ¿e je¿eli dla wyj¹tku danego typu nie zostanie znaleziony ¿aden odpowiedni blok <SPAN CLASS=K>catch</SPAN>, to przydziela mu siê automatycznie ów blok z trzykropkiem (coœ rodzaju ostatniej deski ratunku). Przyk³ad:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;cstdlib&gt;<BR>
#include &lt;iostream&gt;</SPAN><BR>
<BR><SPAN CLASS=K>
using namespace</SPAN> std;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>char</SPAN> typ, wyj_c; <BR>
&nbsp;<SPAN CLASS=K>double</SPAN> wyj_d;</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> wyj_i;</SPAN><BR>
&nbsp;<SPAN CLASS=K>float</SPAN> wyj_f;</SPAN> <BR>
&nbsp;<SPAN CLASS=K>unsigned</SPAN> wyj_u;</SPAN><BR>
<BR>
&nbsp;<SPAN CLASS=K>try</SPAN><BR>
&nbsp;{ <BR>
&nbsp;&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Podaj typ wyj¹tku (c/d/f/i): "</SPAN>;<BR>
&nbsp;&nbsp;cin &gt;&gt; typ;<BR>
&nbsp;&nbsp;cout &lt;&lt; endl &lt;&lt; endl;<BR>
<BR>
&nbsp;&nbsp;<SPAN CLASS=K>switch</SPAN>(typ)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'c'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_c;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'d'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_d;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'f'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_f;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>'i'</SPAN> : <SPAN CLASS=K>throw</SPAN> wyj_i;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>default : throw</SPAN> wyj_u;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>char</SPAN>)  { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu char"</SPAN>  &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>float</SPAN>) { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu float"</SPAN> &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(<SPAN CLASS=K>int</SPAN>)   { cout &lt;&lt; <SPAN CLASS=L>"Wyjatek typu int"</SPAN>   &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>catch</SPAN>(...)   { cout &lt;&lt; <SPAN CLASS=L>"Inny wyjatek"</SPAN> &lt;&lt; endl; }<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Rozszerzyliœmy nasz poprzedni przyk³ad o mo¿liwoœæ rzucania wyj¹tków typu <SPAN CLASS=K>double</SPAN> i <SPAN CLASS=K>unsigned</SPAN> (przy czym wyj¹tek typu <SPAN CLASS=K>double</SPAN> zostaje rzucony, jeœli u¿ytkownik wpisze literkê <SPAN CLASS=L>d</SPAN>, natomiast wyj¹tek typu <SPAN CLASS=K>unsigned</SPAN> - w przypadku wpisania czegokolwiek oprócz wymienionych literek). "Zapomnieliœmy" wprawdzie dodaæ bloki <SPAN CLASS=K>catch</SPAN> dla tych dwóch typów wyj¹tków, ale za to mamy "uniwersalny", trzykropkowy <SPAN CLASS=K>catch</SPAN>. I to w³aœnie w nim nast¹pi z³apanie wyj¹tków typu <SPAN CLASS=K>double</SPAN> oraz <SPAN CLASS=K>unsigned</SPAN>, jeœli takie bêd¹ rzucone.
</P>
<P>
Co natomiast, jeœli nie chcemy trzykropka? Jest jeszcze inne wyjœcie. Wspomnia³em o funkcji <SPAN CLASS=T>unexpected</SPAN> i o tym, ¿e domyœlnie koñczy ona dzia³anie programu, wywo³uj¹c <SPAN CLASS=T>terminate</SPAN>. Mo¿emy jednak sprawiæ, by zamiast tego wywo³ywa³a inn¹ funkcjê, zdefiniowan¹ przez nas. Czynimy to za pomoc¹ <SPAN CLASS=T>set_unexpected</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
set_unexpected(Nieoczekiwany);<BR>
</TD></TR>
</TABLE>

<P>
gdzie <SPAN CLASS=T>Nieoczekiwany</SPAN> jest nazw¹ dowolnej bezargumentowej funkcji typu <SPAN CLASS=K>void</SPAN>, na przyk³ad takiej:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> Nieoczekiwany()<BR>
{<BR>
&nbsp;cout &lt;&lt; <SPAN CLASS=L>"Wystapil nieoczekiwany wyjatek. Program zostanie zakonczony."</SPAN> &lt;&lt; endl;<BR>
&nbsp;terminate();<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
W tym przypadku ka¿dy wyj¹tek, który z jakichœ powodów nie zostanie z³apany w programie, wywo³a wprawdzie zakoñczenie wykonywania programu, ale przedtem wypisze na ekranie odpowiedni komunikat, dziêki czemu u¿ytkownik bêdzie wiedzia³, ¿e wyst¹pi³ wyj¹tek i nie bêdzie musia³ siê zastanawiaæ nad przyczynami, dla których program nagle przesta³ siê wykonywaæ.
</P>


<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08a.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs10.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>