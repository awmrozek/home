<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - WinAPI - Subclassing i superclassing</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apireg.html">&lt;&lt; Rejestr</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidll.html">DLL &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
SUBCLASSING POJEDYNCZEGO OKNA
</h2>

<P>
Zapewne zd¹¿y³eœ ju¿ zauwa¿yæ, ¿e wszelkie kontrolki twojej aplikacji mog¹ siê okazaæ w pewnych sytuacjach upierdliw¹ przeszkod¹. Jeœli na przyk³ad tworzysz sobie edytor tekstu i chcesz, by wciœniêcie F12 powodowa³o zapisanie aktualnie otwartego dokumentu do pliku, to kontrolka <SPAN CLASS=L>EDIT</SPAN>, która przecie¿ jest sercem twojego programu, w momencie otrzymania fokusa bêdzie przechwytywa³a wszelkie komunikaty od klawiatury (w tym równie¿ ten wywo³any przez naciœniêcie F12) i interpretowa³a je po swojemu (np. strza³ki bêd¹ porusza³y kursorem, Enter - przejœcie do nastêpnego wiersza itp.). W ten sposób twój klawisz odpowiedzialny za quick-save dokumentu bêdzie "dzia³a³" tylko wtedy, gdy pole tekstowe (EDIT) nie bêdzie mia³o fokusa.
</P>
<P>
W skrócie: nie mamy kontroli nad komunikatami przechwyconymi przez kontrolkê! Taka sytuacja jest czasami dobra, a czasami z³a (jak w przyk³adzie powy¿ej). W tym drugim przypadku mamy jednak sposób, ¿eby temu zaradziæ: jest to w³aœnie subclassing. Z definicji:
</P>

<P class=UWAGA>
Subclassing jest to zmiana wskaŸnika do procedury okna dla pojedynczego okna lub ca³ej klasy okien.
</P>

<P>
Mo¿e to brzmieæ nieco zawile (jak wiêkszoœæ definicji), ale w gruncie rzeczy jest bardzo proste :-). Ka¿de okno ma swoj¹ w³asn¹ procedurê okna, czego zreszt¹ doœwiadczyliœmy na w³asnej skórze ju¿ w pierwszym odcinku kursu WinAPI (musieliœmy dla naszego g³ównego okna napisaæ procedurê okna i podaæ wskaŸnik do niej przy rejestracji klasy okna). Jeœli mamy do czynienia z dwoma oknami tej samej klasy, to wspó³dziel¹ one tê sam¹ procedurê okna, np. wszystkie okna klasy <SPAN CLASS=L>EDIT</SPAN> (pola tekstowe) korzystaj¹ z procedury okna, która sprawia, ¿e wciskanie klawiszy powoduje wyœwietlanie w polu tekstowym literek, ¿e dzia³a zaznaczanie tekstu mysz¹, ¿e klikniêcie prawym przyciskiem myszy wywo³uje menu kontekstowe do edycji itp. Mimo to mamy mo¿liwoœæ zmiany procedury okna dla ka¿dego okna z osobna.
</P>

<P class=UWAGA>
Zmiana procedury okna powoduje powstanie podklasy (ang. <SPAN CLASS=Inglisz>subclass</SPAN>) dla klasy tego okna.
</P>

<P>
Wniosek z tych rozwa¿añ jest prosty - podmieniaj¹c domyœln¹ procedurê okna danej kontrolki mo¿emy zmusiæ j¹ do interpretowania przechwyconych przez ni¹ komunikatów w taki sposób, jaki NAM najbardziej odpowiada.
</P>
<P>
Pora zabraæ siê wreszcie do roboty. Naszym zadaniem bêdzie zmuszenie pola tekstowego (za³ó¿my, ¿e ju¿ je stworzyliœmy pod uchwytem <SPAN CLASS=T>g_hText</SPAN>), ¿eby reagowa³o jakoœ na wciœniêcie klawiszy. Dodamy sobie tzw. sprzê¿enie zwrotne (ktoœ jeszcze pamiêta czasy Atari? ;-)), czyli wkurzaj¹cy sygna³ dŸwiêkowy po ka¿dym wciœniêciu klawisza. Na pocz¹tku spróbujemy zrobiæ to "normalnie", czyli dopisuj¹c odpowiedni kod do g³ównej procedury okna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_KEYDOWN:<BR>
{<BR>
&nbsp;Beep(<SPAN CLASS=L>0, 0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ (lub raczej s³ychaæ), wciœniêcie ka¿dego klawisza daje nam sygna³ dŸwiêkowy, o ile pole tekstowe nie ma fokusa. Jeœli spróbujemy cokolwiek w nim napisaæ i dopiero wtedy wcisn¹æ coœ, sygna³u nie bêdzie. Przyczynê ju¿ znamy - pole tekstowe przechwytuje wszystkie naciœniêcia klawiszy i nie chce ich oddaæ do g³ównego okna. Zaraz mu powiemy, co o tym myœlimy.
</P>
<P>
Zacznijmy od napisania nowej procedury okna dla pola tekstowego - jej zadaniem bêdzie wywo³anie funkcji <SPAN CLASS=T>Beep </SPAN>w przypadku naciœniêcia klawisza (czyli to samo, co robi obecnie g³ówna procedura okna):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK NewWndProc(HWND hwnd, UINT mesg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(mesg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_KEYDOWN:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Beep(<SPAN CLASS=L>0, 0</SPAN>);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Na razie nie jest to zbyt dobry kod, poniewa¿ skopiowaliœmy to, co ju¿ mieliœmy w innym miejscu napisane (chodzi o <SPAN CLASS=T>Beep)</SPAN> - to z³y nawyk :-). Nie przejmujemy siê tym jednak w tej chwili i idziemy dalej. Musimy teraz "podmieniæ" procedurê okna pola tekstowego. S³u¿y do tego funkcja <SPAN CLASS=T>SetWindowLong</SPAN>. Pamiêtaj, ¿eby wywo³aæ j¹ ju¿ PO utworzeniu pola tekstowego:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
// <-- utworzenie pola tekstowego o uchwycie g_hText<BR></SPAN>
<BR>
SetWindowLong(g_hText, GWL_WNDPROC, (LONG)NewWndProc);<BR>
<BR><SPAN CLASS=C>
// <-- wejœcie w pêtlê komunikatów<BR></SPAN>
</TD></TR>
</TABLE>

<P>
Hmmm, podejrzane - nasze pole tekstowe diabli wziêli! Gdzie siê podzia³o? Bez obaw, jest ci¹gle tam, gdzie wczeœniej, tylko po prostu siê nie narysowa³o :-). Powód - "zabieraj¹c" mu domyœln¹ procedurê okna pozbawiliœmy je jednoczeœnie ca³ej funkcjonalnoœci; teraz jest wiêc w³aœciwie bezu¿yteczne. St¹d wniosek, ¿e aby dokonaæ prawid³owego subclassingu, musimy nie tylko napisaæ now¹ procedurê okna, ale te¿ zachowaæ "star¹" i wywo³aæ j¹ w odpowiednim momencie, ¿eby pole tekstowe mog³o sobie obs³u¿yæ pozosta³e, nie interesuj¹ce nas komunikaty (a niezbêdne do jego normalnego funkcjonowania).
</P>
<P>
Do "rêcznego" wywo³ywania procedury okna s³u¿y funkcja <SPAN CLASS=T>CallWindowProc</SPAN>. Oczywiœcie, aby wywo³aæ "star¹" procedurê okna pola tekstowego, musimy gdzieœ zapamiêtaæ wskaŸnik do niej. Tak wiêc musimy ten wskaŸnik zadeklarowaæ (jako zmienn¹ globaln¹ najlepiej):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WNDPROC g_OldWndProc;<BR>
</TD></TR>
</TABLE>

<P>
...oraz poprawiæ wywo³anie <SPAN CLASS=T>SetWindowLong</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_OldWndProc = (WNDPROC)SetWindowLong(g_hText, GWL_WNDPROC, (LONG)NewWndProc);
</TD></TR>
</TABLE>

<P>
Teraz dysponujemy ju¿ wskaŸnikiem do domyœlnej procedury okna dla wszystkich pól tekstowych Windowsa i nie zawahamy siê go u¿yæ ;-). WprowadŸmy w tym celu korektê do naszej nowej procedury okna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK NewWndProc(HWND hwnd, UINT mesg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(mesg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_KEYDOWN:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Beep(<SPAN CLASS=L>0, 0</SPAN>);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> CallWindowProc(g_OldWndProc, hwnd, mesg, wParam, lParam);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Od tej pory wszystko zaczê³o dzia³aæ tak, jak sobie tego ¿yczyliœmy. Pozostaje tylko zadbaæ o jeden szczegó³: otó¿ jak wspomnia³em wczeœniej, zrobiliœmy ma³e powtórzenie (dwa razy wywo³ujemy funkcjê <SPAN CLASS=T>Beep</SPAN> w odpowiedzi na to samo zdarzenie - osobno dla g³ównego okna, osobno dla pola tekstowego). Powinniœmy zmieniæ to tak, ¿eby wciœniêcie klawisza w polu tekstowym by³o przekazywane do procedury g³ównego okna aplikacji. Teraz ju¿ wiemy, jak to mo¿na zrobiæ - pos³u¿ymy siê po raz drugi znan¹ ju¿ funkcj¹ <SPAN CLASS=T>CallWindowProc</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LRESULT CALLBACK NewWndProc(HWND hwnd, UINT mesg, WPARAM wParam, LPARAM lParam)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(mesg)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> WM_KEYDOWN:<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;CallWindowProc(WndProc, hwnd, mesg, wParam, lParam);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> CallWindowProc(g_OldWndProc, hwnd, mesg, wParam, lParam);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie zak³adam tutaj, ¿e twoja g³ówna procedura okna nazywa siê w³aœnie <SPAN CLASS=T>WndProc</SPAN>. Dziêki powy¿szemu zabiegowi uzyskaliœmy po prostu to, ¿e od tej pory pole tekstowe nie zachowuje naciœniêæ klawiszy wy³¹cznie dla siebie, lecz przekazuje je najpierw do g³ównego okna, a dopiero potem samo je sobie obs³uguje (jeœli musi).
</P>
<P>
Taki rodzaj subclassingu, któremu poddajemy tylko pojedyncze okienka, nazywamy <SPAN CLASS=Wazne>subclassingiem wyst¹pienia</SPAN> (<SPAN CLASS=Inglisz>instance subclassing</SPAN>).
</P>

<h2>
TWORZENIE PODKLASY OKIEN
</H2>

<P>
Gdybyœmy po u¿yciu subclassingu wyst¹pienia na klasie <SPAN CLASS=L>EDIT</SPAN> stworzyli nastêpne pola tekstowe, to zachowywa³yby siê ju¿ one normalnie (czyli nie wydawa³yby ¿adnych g³upich dŸwiêków ;-)). Czasami mo¿e nam jednak zale¿eæ na czymœ wiêcej - zmodyfikowaniu ca³ej klasy kontrolek, np. w³aœnie pól tekstowych, tak aby wydawa³y one dŸwiêki podczas pisania.
</P>
<P>
Mo¿emy to uczyniæ dziêki funkcji <SPAN CLASS=T>SetClassLong</SPAN>. Funkcja ta zmienia parametry klasy, tak wiêc zmiany bêd¹ dotyczyæ tylko tych okien, które zostan¹ utworzone PO modyfikacji klasy. Taki rodzaj subclassingu nazywamy <SPAN CLASS=Wazne>globalnym subclassingiem</SPAN>.
</P>
<P>
Argumenty funkcji <SPAN CLASS=T>SetClassLong</SPAN> s¹ w zasadzie takie same, jak w przypadku <SPAN CLASS=T>SetWindowLong</SPAN>, zmienia siê jednak nieco ich znaczenie. Przede wszystkim parametry klasy to zupe³nie co innego, ni¿ parametry okna. Dziêki <SPAN CLASS=T>SetClassLong</SPAN> mo¿emy wiêc zmieniæ np. kolor t³a okna, domyœlny kursor, menu, ikonê, style klasy (nie myliæ ze stylami okna). Jedyna wspólna rzecz z funkcj¹ <SPAN CLASS=T>SetWindowLong</SPAN> to mo¿liwoœæ zmiany procedury okna, i tê w³aœnie mo¿liwoœæ wykorzystamy do globalnego subclassingu.
</P>
<P>
Warto zwróciæ uwagê, ¿e <SPAN CLASS=T>SetClassLong</SPAN> nie pobiera nazwy klasy, któr¹ modyfikujemy, lecz uchwyt do okna tej klasy (który poœrednio równie¿ identyfikuje klasê). Tak wiêc...
</P>

<P class=UWAGA>
Aby dokonaæ globalnego subclassingu, musimy dysponowaæ uchwytem do ju¿ utworzonego okna danej klasy.
</P>

<P>
Je¿eli akurat nie mamy takiego okna, to mo¿emy je sobie stworzyæ. Nie musi ono byæ widoczne, tak wiêc jeœli bêdzie nam w aplikacji potrzebne wy³¹cznie do subclassingu, to "zapominamy" daæ mu flagê <SPAN CLASS=T>WS_VISIBLE</SPAN>. Nie musimy te¿ martwiæ siê zbytnio o pozosta³e jego parametry ani tym bardziej o rozszerzone style (mo¿emy wiêc skorzystaæ z nieco prostszego <SPAN CLASS=T>CreateWindow</SPAN> zamiast <SPAN CLASS=T>CreateWindowEx</SPAN>) - potrzebujemy tylko jakiegokolwiek okna tej klasy - w tym przypadku pola tekstowego:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_hDummy = CreateWindow(<SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD <SPAN CLASS=C>/*| WS_VISIBLE*/</SPAN>,<SPAN CLASS=L> 0, 0, 0, 0</SPAN>, hwnd, NULL, hThisInstance, NULL);
</TD></TR>
</TABLE>

<P>
Nastêpnym krokiem bêdzie zast¹pienie "starej" procedury okna now¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_OldWndProc = (WNDPROC)SetClassLong(g_hDummy, GCL_WNDPROC, (LONG)NewWndProc);
</TD></TR>
</TABLE>

<P>
Od tej pory ka¿de nowo utworzone okienko klasy <SPAN CLASS=L>EDIT</SPAN> bêdzie wydawa³o irytuj¹ce dŸwiêki przy pisaniu ;-). SprawdŸmy zreszt¹:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50, 50, 150, 25</SPAN>, hwnd, NULL, hThisInstance, NULL);<BR>
CreateWindowEx(WS_EX_CLIENTEDGE, <SPAN CLASS=L>"EDIT"</SPAN>, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, <SPAN CLASS=L>50, 85, 150, 25</SPAN>, hwnd, NULL, hThisInstance, NULL);<BR>
</TD></TR>
</TABLE>

<P>
Wszystko siê zgadza; mamy dwa pola tekstowe, a obydwa wydaj¹ dŸwiêki, nawet jeœli usuniemy z procedury <SPAN CLASS=T>WndProc</SPAN> wywo³anie funkcji <SPAN CLASS=T>Beep</SPAN>. Warto jeszcze zadbaæ o to, ¿eby nam siê system nie wykrzaczy³, co teoretycznie mo¿na spowodowaæ, zapominaj¹c o usuniêciu subclassingu z systemowej klasy <SPAN CLASS=L>EDIT</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> WM_DESTROY: <SPAN CLASS=C>//do g³ównej procedury okna</SPAN><BR>
{<BR>
&nbsp;SetClassLong(g_hDummy, GCL_WNDPROC, (LONG)g_OldWndProc);<BR>
&nbsp;PostQuitMessage(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;
</TD></TR>
</TABLE>

<P>
W przypadku subclassingu wyst¹pienia nie musieliœmy tego robiæ, poniewa¿ tam eksperymentowaliœmy tylko na pojedynczych oknach, których ¿ywot koñczy³ siê wraz z dzia³aniem naszej aplikacji. Tym razem modyfikujemy ca³¹ klasê, a wiêc wprowadzone przez nas zmiany mog¹ dotyczyæ ca³ego systemu.
</P>
<P>
Na koniec jeszcze jedna przestroga:
</P>

<P class=UWAGA>
Ten przyk³ad to jeszcze jeden z serii "dzieci, nie róbcie tego w domu!". Microsoft nie zaleca modyfikowania systemowych klas okien, takich jak EDIT. Jeœli chcemy masowo tworzyæ okna o zmienionym przez nas zachowaniu, powinniœmy korzystaæ z superclassingu.
</P>

<h2>
SUPERCLASSING
</h2>

<P>
Oprócz "psucia" istniej¹cych ju¿ klas mo¿emy na ich podstawie utworzyæ w³asn¹, ca³kowicie now¹ klasê (przypomina to nieco mechanizm dziedziczenia w C++). To jest w³aœnie <SPAN CLASS=Wazne>superclassing</SPAN>. Jest on technik¹ stuprocentowo bezpieczn¹ (w przeciwieñstwie do subclassingu), poniewa¿ taka superklasa "widoczna" jest tylko w obrêbie naszej aplikacji i na resztê systemu w ¿aden sposób nie wp³ywa.
</P>
<P>
Zabawê w superclassing zaczynamy od pobrania informacji o klasie bazowej - na przyk³ad <SPAN CLASS=L>EDIT</SPAN>. Robi siê to przy pomocy <SPAN CLASS=T>GetClassInfo</SPAN> b¹dŸ <SPAN CLASS=T>GetClassInfoEx</SPAN>. Funkcje te wype³niaj¹ ¿¹danymi informacjami odpowiedni¹ strukturê - w pierwszym przypadku <SPAN CLASS=T>WNDCLASS</SPAN>, w drugim - <SPAN CLASS=T>WNDCLASSEX</SPAN>. Jak byæ mo¿e pamiêtasz z pierwszego odcinka kursu, jedyn¹ w³aœciwie ró¿nic¹ pomiêdzy tymi strukturami jest brak w tej pierwszej pola odpowiedzialnego za ma³¹ ikonkê, tak wiêc jako lenie patentowane wybieramy drogê na skróty i bierzemy funkcjê <SPAN CLASS=T>GetClassInfo</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WNDCLASS wc;<BR>
GetClassInfo(hThisInstance, <SPAN CLASS=L>"EDIT"</SPAN>, &wc);<BR>
</TD></TR>
</TABLE>

<P>
Jako siê rzek³o, struktura ma zostaæ wype³niona a¿ po brzegi niezbêdnymi informacjami. No, mo¿e z tymi brzegami to lekka przesada, poniewa¿ a¿ trzy pola struktury nie s¹ przez <SPAN CLASS=T>GetClassInfo</SPAN> w ogóle ruszane: <SPAN CLASS=T>lpszMenuName, lpszClassName, hInstance</SPAN>. Powody s¹ w sumie oczywiste; mo¿esz siê ich sam domyœliæ. Wszystkie te trzy pola wype³niamy sami:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
wc.lpszMenuName = NULL;<BR>
wc.lpszClassName = <SPAN CLASS=L>"Nowy, lepszy EDIT ;-)"</SPAN>;<BR>
wc.hInstance = hThisInstance;<BR>
</TD></TR>
</TABLE>

<P>
Pole <SPAN CLASS=T>lpszClassName</SPAN> ma zawieraæ now¹ nazwê klasy - tu wpisz, co chcesz. Z kolei pole <SPAN CLASS=T>hInstance</SPAN> powinno zawieraæ uchwyt wyst¹pienia naszej aplikacji. Menu nie mamy, wiêc <SPAN CLASS=T>lpszMenuName</SPAN> mo¿emy po prostu olaæ.
</P>
<P>
Pozostaje najwa¿niejsza czêœæ zadania, czyli wstawienie nowej procedury okna (u¿yjemy tej zdefiniowanej w poprzednich przyk³adach, wprowadzaj¹cej dŸwiêki towarzysz¹ce klawiszom), a tak¿e zapamiêtanie wskaŸnika do "starej" procedury:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
g_OldWndProc = wc.lpfnWndProc;<BR>
wc.lpfnWndProc = NewWndProc;<BR>
</TD></TR>
</TABLE>

<P>
Struktura z informacjami o nowej klasie jest ju¿ gotowa do u¿ycia; mo¿emy teraz tê klasê zarejestrowaæ. Proces ten jest nam ju¿ znany z poczatków kursu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(!RegisterClass(&wc))<BR>
{<BR>
&nbsp;MessageBox(hwnd, <SPAN CLASS=L>"Nie uda³o siê zarejestrowaæ nowej klasy.", "Yh..."</SPAN>, MB_ICONSTOP);<BR>
&nbsp;DestroyWindow(hwnd);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeœli wszystko posz³o OK, to dysponujemy od tego momentu klas¹ o wdziêcznej nazwie <SPAN CLASS=L>"Nowy, lepszy EDIT ;-)"</SPAN> i mo¿emy tworzyæ kontrolki tej klasy, podaj¹c tak¹ w³aœnie nazwê jako argument funkcji <SPAN CLASS=T>CreateWindowEx</SPAN>. Jeœli natomiast utworzymy kontrolkê, podaj¹æ nazwê <SPAN CLASS=L>"EDIT"</SPAN>, to utworzone zostanie najzwyklejsze pole tekstowe, bez ¿adnych dŸwiêków. Zauwa¿, ¿e w przeciwieñstwie do globalnego subclassingu nie musimy wykonywaæ tutaj ¿adnego sprz¹tania, czyli przywracaæ "starej" procedury okna klasie przy koñczeniu dzia³ania aplikacji, poniewa¿ klasa ta bêdzie "odrejestrowana" automatycznie (jak wszystkie klasy zarejestrowane przez nasz¹ aplikacjê).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="apireg.html">&lt;&lt; Rejestr</A> &nbsp;
<A HREF="../winapi.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="apidll.html">DLL &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>