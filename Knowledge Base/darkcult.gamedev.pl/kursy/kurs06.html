<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Klasy, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html">Spis</A> &nbsp;
<A HREF="kurs06a.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
6. Dziedziczenie
</H1>

<P>
Programiœci to z regu³y kreatury skrajnie leniwe, tote¿ ci¹gle wymyœlaj¹ sobie coœ, ¿eby sobie ¿ycie u³atwiæ. Jedn¹ z takich rzeczy jest w³aœnie dziedziczenie, czyli przejmowanie przez klasê czêœci lub wszystkich <SPAN CLASS=Wazne>cech</SPAN> jednej lub wiêcej innych klas (cechami klasy nazywam jej zmienne sk³adowe i metody). 
</P>
<P>
W ten oto sposób jeœli mamy dwie klasy charakteryzuj¹ce siê identycznymi cechami, nie musimy tych cech definiowaæ dwa razy - wystarczy, ¿e zrobimy to raz, tylko dla jednej z tych klas, a druga po prostu odziedziczy od tamtej odpowiednie cechy. Wtedy tê pierwsz¹ klasê nazwiemy <SPAN CLASS=Wazne>klas¹ macierzyst¹</SPAN> (bazow¹), a drug¹ - <SPAN CLASS=Wazne>potomn¹</SPAN> (lub pochodn¹).
</P>

<H2>
6.1 Trochê mniej abstrakcyjnie...
</H2>

<P>
Za³ó¿my, ¿e kupiliœmy sobie mechanicznego psa. Piesek jest bardzo sympatyczny, pos³uszny i potrafi szczekaæ, ale nie jest zbyt groŸny, wiêc nie poszczujesz nim upierdliwego akwizytora. Mo¿emy sobie oczywiœcie kupiæ wiêkszego pieska, równie przy tym mi³ego i pos³usznego, ale po diab³a nam taki gigant w domu, przecie¿ mamy skromne M-3, zreszt¹ du¿y pies mo¿e coœ niechc¹cy rozwaliæ albo po³kn¹æ kota.
</P>
<P>
Decyzja brzmi: ma³y piesek zostaje jako maskotka dla rodziny, a do celów defensywnych konstruujemy wiêkszego mechanicznego czworonoga, który zamieszka w budzie pod domem. I tutaj nasuwa siê pytanie: jak to zrobiæ? Ano, wiêkszy pies równie¿ ma ogon, cztery ³apy, parê uszu itp., ma równie¿ potrafiæ szczekaæ, podawaæ ³apê i aportowaæ, jedyna ró¿nica jest taka, ¿e ma byæ groŸniejszy. Po co wiêc mamy wymyœlaæ ca³ego psa od nowa, skoro mo¿emy podpatrzeæ niektóre rozwi¹zania zastosowane w mniejszym piesku i po prostu je skopiowaæ?
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> kolor;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> wielkosc;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> wypisz_imie();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> szczekaj();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> aportuj();<BR>
};
</TD></TR>
</TABLE>

<P>
To ogólny zarys konstrukcji naszego ma³ego psiaka. Niby nie ma tego wiele, ale i tak nie bêdzie nam siê chcia³o wszystkiego kopiowaæ, tworz¹c klasê <SPAN CLASS=T>MechPsisko</SPAN> ;-). Dlatego te¿ sprawimy, ¿eby klasa <SPAN CLASS=T>MechPsisko</SPAN> dziedziczy³a wszystkie cechy klasy <SPAN CLASS=T>MechPiesek</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> MechPsisko : <SPAN CLASS=K>public</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> kolor;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> wielkosc;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> atakuj_akwizytora();<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Jak na d³oni widaæ, ¿e ca³e to s³ynne dziedziczenie za³atwiliœmy w jednej jedynej linijce, konkretnie po s³owie <SPAN CLASS=K>class</SPAN> i nazwie klasy. Wystarczy dodaæ dwukropek, <SPAN CLASS=Wazne>specyfikator dostêpu</SPAN> (tutaj <SPAN CLASS=K>public</SPAN> - o tym zaraz) i nazwê klasy, od której dziedziczymy cechy. No tak, zapis jest banalnie prosty, za to ile problemów siê z tym wi¹¿e... Na ca³y rozdzia³, jak siê oka¿e, ale po kolei.
</P>
<P>
Jeœli porównasz klasê <SPAN CLASS=T>MechPiesek</SPAN> z utworzon¹ póŸniej <SPAN CLASS=T>MechPsisko</SPAN>, to zauwa¿ysz, ¿e w tej drugiej brakuje trzech funkcji sk³adowych z sekcji publicznej. Nie musimy ich w tym drugim przypadku definiowaæ ani nawet deklarowaæ, poniewa¿ s¹ one dziedziczone po klasie <SPAN CLASS=T>MechPiesek</SPAN>. A wiêc jeœli utworzymy obiekt klasy <SPAN CLASS=T>MechPsisko</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
MechPsisko pies;<BR>
</TD></TR>
</TABLE>

<P>
...to mo¿emy zrobiæ coœ takiego:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
pies.szczekaj();<BR>
</TD></TR>
</TABLE>

<P>
...mimo, i¿ klasa <SPAN CLASS=T>MechPies</SPAN> nie zawiera JAWNEJ deklaracji funkcji <SPAN CLASS=T>szczekaj</SPAN>. Funkcjê tak¹ kompilator znajdzie sobie natomiast w sekcji publicznej klasy rodzicielskiej <SPAN CLASS=T>MechPiesek</SPAN>. Tutaj drobna uwaga. Nie daj siê zmyliæ, ¿e ma³y piesek stanowi tutaj coœ w rodzaju rodzica dla du¿ego pieska. Po prostu "ma³y" oznacza "maj¹cy ma³o funkcji sk³adowych", natomiast od du¿ego pieska jest i tak starszy :-).
</P>
<P>
Zauwa¿, ¿e klasa <SPAN CLASS=T>MechPsisko</SPAN> ma metodê <SPAN CLASS=T>atakuj_akwizytora</SPAN>. Ma³y piesek jest tylko maskotk¹ i do tego zwolennikiem pacyfizmu, wiêc dla niego nie mo¿emy wywo³aæ tej metody ;-). Poza tym miêdzy tymi dwiema klasami nie ma ró¿nic, choæ wygl¹daj¹ zupe³nie inaczej.
</P>
<P>
Pewnie ciekawi ciê, dlaczego w³aœciwie klasa <SPAN CLASS=T>MechPsisko</SPAN> dziedziczy METODY klasy <SPAN CLASS=T>MechPiesek</SPAN>, natomiast zmienne deklarowaliœmy w niej osobno. Otó¿ taki jest w³aœnie system ukrywania danych w C++. Specyfikator <SPAN CLASS=K>public</SPAN> po naszym "dwukropku dziedziczenia" oznacza, ¿e dziedziczymy TYLKO czêœæ publiczn¹ klasy <SPAN CLASS=T>MechPiesek</SPAN>, a wiêc te trzy funkcje typu <SPAN CLASS=K>void</SPAN>. Sekcja prywatna jest wy³¹czn¹ w³asnoœci¹ klasy <SPAN CLASS=T>MechPiesek</SPAN> i nawet <SPAN CLASS=T>MechPsisko</SPAN>, chocia¿ niby potomek, nie ma do niej dostêpu. Dlatego musieliœmy du¿emu psiakowi zdeklarowaæ <SPAN CLASS=T>imie</SPAN>, <SPAN CLASS=T>kolor</SPAN> i <SPAN CLASS=T>wielkosc</SPAN> niezale¿nie.
</P>

<H2>
6.2 Specyfikatory dziedziczenia
</H2>

<P>
Czy nie mo¿na by by³o zmieniæ tego specyfikatora <SPAN CLASS=T>public</SPAN> na <SPAN CLASS=T>private</SPAN>? Mo¿na, jak najbardziej. Sêk w tym, ¿e nie da to takiego efektu, jakiego oczekujemy. Jeœli damy <SPAN CLASS=T>private</SPAN>, to dalej bêdziemy dziedziczyli tylko czêœæ publiczn¹ klasy <SPAN CLASS=T>MechPiesek</SPAN>, z tym, ¿e w klasie <SPAN CLASS=T>MechPsisko</SPAN> odziedziczone funkcje bêd¹ ju¿ mia³y status prywatnych. A wiêc coœ takiego:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> MechPsisko : <SPAN CLASS=K>private</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> kolor;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> wielkosc;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> atakuj_akwizytora();<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;MechPsisko pies;<BR>
&nbsp;pies.szczekaj(); <SPAN CLASS=C>//b³¹d!</SPAN><BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
...spowoduje wywalenie komunikatu o b³êdzie, bo odziedziczona funkcja <SPAN CLASS=T>szczekaj</SPAN> dla klasy <SPAN CLASS=T>MechPiesek</SPAN> jest wprawdzie publiczna, ale dla <SPAN CLASS=T>MechPsisko</SPAN> - jest prywatna, a wiêc mo¿emy z niej korzystaæ tylko wewn¹trz klasy. Zmienne <SPAN CLASS=T>imie, kolor</SPAN> i <SPAN CLASS=T>wielkosc</SPAN> znowu tutaj zadeklarowaliœmy osobno, bo jak ju¿ mówiliœmy - nie zostan¹ one odziedziczone.
</P>
<P>
No wiêc jak, do cholery, zrobiæ, ¿eby dziedziczyæ równie¿ prywatne cechy klasy? Jedyny sposób to dodatkowy specyfikator, o którym do tej pory nie mówiliœmy. Zowie on siê <SPAN CLASS=K>protected</SPAN>. Daje on taki sam efekt, jak i <SPAN CLASS=K>private</SPAN>, ale jednoczeœnie pozwala na dziedziczenie poprzedzonych nim zmiennych i metod. Natomiast to, jaki status bêd¹ mia³y takie chronione zmienne i metody, to zale¿y od u¿ytego specyfikatora dziedziczenia. Mamy wiêc trzy przypadki:
</P>

<OL>
<LI>specyfikator <SPAN CLASS=K>public</SPAN>: cechy chronione w klasie macierzystej staj¹ siê cechami chronionymi w klasie potomnej (proste ;-) ).
<BR><BR>
<LI>specyfikator <SPAN CLASS=K>private</SPAN>: cechy chronione w klasie macierzystej staj¹ siê cechami prywatnymi w klasie potomnej (czyli od klasy potomnej ju¿ nie bêdzie mo¿na ich dalej odziedziczyæ)
<BR><BR>
<LI>specyfikator <SPAN CLASS=K>protected</SPAN>: cechy chronione (a tak¿e publiczne!) w klasie macierzystej staj¹ siê cechami chronionymi w klasie potomnej
</OL>

<P>
Bogatsi o tê wiedzê mo¿emy wreszcie skonstruowaæ nasz¹ psiarniê, wk³adaj¹c w to minimum programistycznego wysi³ku:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>protected</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>char</SPAN>* imie;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> kolor;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> wielkosc;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> wypisz_imie();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> szczekaj();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> aportuj();<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> MechPsisko : <SPAN CLASS=K>public</SPAN> MechPiesek<BR>
{<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> atakuj_akwizytora();<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Mo¿emy sprawdziæ, ¿e to dzia³a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;MechPsisko Burek;<BR>
<BR>
&nbsp;Burek.atakuj_akwizytora();<BR>
&nbsp;Burek.szczekaj(); <SPAN CLASS=C>//dzia³a, odziedziczone prawid³owo!</SPAN><BR>
&nbsp;Burek.aportuj(); <SPAN CLASS=C>//te¿ dzia³a!</SPAN><BR>
<SPAN CLASS=C> //int KolorPsa = Burek.kolor;</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeœli dopiszemy do deklaracji definicje funkcji:<SPAN CLASS=T> atakuj_akwizytora, szczekaj</SPAN> i <SPAN CLASS=T>aportuj</SPAN> (nawet puste), to powy¿szy przyk³ad w <SPAN CLASS=K>int</SPAN><SPAN CLASS=T> main</SPAN> zostanie skompilowany prawid³owo. Klasa <SPAN CLASS=T>MechPsisko</SPAN> wprawdzie "posiada jawnie" tylko jedn¹ z tych funkcji (<SPAN CLASS=T>atakuj_akwizytora</SPAN>), ale pozosta³e dziedziczy od klasy <SPAN CLASS=T>MechPiesek</SPAN>. Co wiêcej, dziedziczy równie¿ chronione zmienne <SPAN CLASS=T>imie, kolor</SPAN> i <SPAN CLASS=T>wielkosc</SPAN>, które pomimo to zachowuj¹ swój "prywatny" status: nie mo¿na uzyskaæ do nich dostêpu nigdzie poza klasami <SPAN CLASS=T>MechPiesek</SPAN> i <SPAN CLASS=T>MechPsisko</SPAN>. Mo¿esz to sprawdziæ, usuwaj¹c komentarz w ostatniej, b³êdnej linijce przyk³adu. A poniewa¿ dziedziczymy ze specyfikatorem <SPAN CLASS=K>public</SPAN>, wiêc w klasie <SPAN CLASS=T>MechPsisko</SPAN> wszystkie te trzy zmienne bêd¹ równie¿ chronione.
</P>

<H2>
6.2 Konstruktory i destruktory
</H2>

<P>
We wszystkich dotychczasowych przyk³adach tego nie widaæ, ale konstruktory i destruktory te¿ podlegaj¹ dziedziczeniu. A w³aœciwie to nie tyle s¹ one dziedziczone, co wywo³ywane póŸniej przez  konstruktory i destruktory klas potomnych. Zaraz to sobie zreszt¹ udowodnimy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#include &lt;iostream.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR>
</SPAN>
<BR>
<SPAN CLASS=K>class</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Rodzic()<BR>
&nbsp;{ cout << <SPAN CLASS=L>"Konstruktor klasy Rodzic"</SPAN> << endl; };<BR>
&nbsp;~Rodzic()<BR>
&nbsp;{ cout << <SPAN CLASS=L>"Destruktor klasy Rodzic"</SPAN> << endl; };<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> a;<BR>
};<BR>
<BR>
<SPAN CLASS=K>class</SPAN> Dzieciak : <SPAN CLASS=K>public</SPAN> Rodzic<BR>
{<BR>
<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;Dzieciak()<BR>
&nbsp;{ cout << <SPAN CLASS=L>"Konstruktor klasy Dzieciak"</SPAN> << endl; };<BR>
&nbsp;~Dzieciak()<BR>
&nbsp;{ cout << <SPAN CLASS=L>"Destruktor klasy Dzieciak"</SPAN> << endl; };<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> b;<BR>
};<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Dzieciak A;<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Efekt na ekranie bêdzie taki:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Konstruktor klasy Rodzic<BR>
Konstruktor klasy Dzieciak<BR>
Destruktor klasy Dzieciak<BR>
Destruktor klasy Rodzic<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Jak to zinterpretowaæ? Przede wszystkim widzimy, ¿e konstruktor i destruktor zosta³y "po¿yczone" od klasy <SPAN CLASS=T>Rodzic</SPAN>; pomimo ¿e nie mamy ¿adnego obiektu typu <SPAN CLASS=T>Rodzic</SPAN> w naszym programiku, to pokazuj¹ siê napisy, które œwiadcz¹ o tym, ¿e konstruktor i destruktor tej klasy s¹ wywo³ywane - dla obiektu <SPAN CLASS=T>A</SPAN>.
</P>
<P>
Po drugie: widaæ tutaj kolejnoœæ wywo³ywania konstruktorów i destruktorów w hierarchii dziedziczenia. Najpierw wywo³ywany jest konstruktor klasy macierzystej, potem konstruktor klasy potomnej. Z destruktorami musi byæ oczywiœcie odwrotnie.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs05a.html"><< Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html">Spis</A> &nbsp;
<A HREF="kurs06a.html">Nastêpna czêœæ kursu >></A> &nbsp;
</TD>
</TR>
</TABLE>

