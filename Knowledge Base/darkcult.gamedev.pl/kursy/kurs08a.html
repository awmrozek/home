<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Szablony, cz. 2</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs09.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<h2>
Specjalizacja szablonów funkcji
</h2>

<P>
Szablony s¹ bardzo elastycznym elementem jêzyka programowania. Tak elastycznym, ¿e a¿ strach - bior¹c pod uwagê, jak delikatna jest w C++ kwestia dopasowywania typów danych. O czym mówimy? WeŸmy jako przyk³ad nasz szablon funkcji <SPAN CLASS=T>Kwadrat</SPAN>. Mo¿emy dziêki niemu podnosiæ do kwadratu dowolne liczby ca³kowite - 8-bitowe, 16-bitowe, 32-bitowe, 64-bitowe, ze znakiem lub bez. Mo¿emy te¿ podnosiæ do kwadratu liczby zmiennoprzecinkowe - <SPAN CLASS=K>float, double, long double</SPAN>. Jednak gdybyœmy stworzyli sobie klasê <SPAN CLASS=T>Wektor</SPAN>, nawet jeœli by³aby to zwyk³a struktura zawieraj¹ca tylko dwie sk³adowe <SPAN CLASS=T>x</SPAN> i <SPAN CLASS=T>y</SPAN>, to kompilator by po prostu zg³upia³.
</P>
<P>
Po to w³aœnie s¹ specjalizacje szablonów. Pierwszym rodzajem specjalizacji, któremu siê przyjrzymy, jest "dodawanie" do szablonu nowych "sposobów" konkretyzacji (konkretyzacj¹ nazywa. Teoretycznie nasz szablon funkcji <SPAN CLASS=T>Kwadrat</SPAN> potrafi wygenerowaæ nieskoñczenie wiele konkretnych "wersji" funkcji <SPAN CLASS=T>Kwadrat</SPAN>, ale w praktyce tych "wersji" jest du¿o mniej - zaledwie kilkanaœcie, w wiêkszoœci wymienione w poprzednim akapicie. Dokonuj¹c specjalizacji szablonu wzglêdem typu danych <SPAN CLASS=T>Wektor</SPAN> dodajemy do tych kilkunastu mo¿liwoœci jeszcze jedn¹. Oto jak wygl¹da taka specjalizacja dla <SPAN CLASS=T>Wektor</SPAN>-a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> Wektor<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>int</SPAN> x,y;<BR>
&nbsp;<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;&nbsp;Wektor(<SPAN CLASS=K>int</SPAN> a=<SPAN CLASS=L>0</SPAN>, <SPAN CLASS=K>int</SPAN> b=<SPAN CLASS=L>0</SPAN>) { x=a; y=b; }<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Ogólna wersja szablonu funkcji Kwadrat</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;<BR>
TYP Kwadrat(TYP L)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> L*L;<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Specjalizacja funkcji Kwadrat dla klasy Wektor</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;&gt; Wektor Kwadrat(Wektor w)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> Wektor(w.x*w.x, w.y*w.y);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widzimy, tworzenie specjalizacji jest proste a¿ do bólu; po prostu robimy now¹ funkcjê o odpowiednim typie zwracanym i odpowiednich argumentach, tyle ¿e dodatkowo opatrujemy j¹ s³owem <SPAN CLASS=K>template</SPAN> oraz pustymi nawiasami trójk¹tnymi. To wystarczy, ¿eby kompilator po³apa³ siê, o co nam chodzi. Od tej pory kompilator napotkawszy kod w rodzaju:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Wektor v,v2;<BR>
v2 = Kwadrat(v);<BR>
</TD></TR>
</TABLE>

<P>
...nie bêdzie "na chama" generowa³ konkretyzacji funkcji <SPAN CLASS=T>Kwadrat</SPAN> dla klasy <SPAN CLASS=T>Wektor</SPAN> (której to konkretyzacji sam zrobiæ nie potrafi), lecz odnajdzie nasz¹ "specjalistyczn¹" definicjê i grzecznie j¹ zastosuje, a generowanie z ogólnego szablonu bêdzie traktowa³ jako ostatecznoœæ i skorzysta z niego dopiero wtedy, gdy argument funkcji <SPAN CLASS=T>Kwadrat</SPAN> nie bêdzie wektorem.
</P>

<P class=UWAGA>
Warto zapamiêtaæ sobie prost¹ regu³kê: szablon dla wiêkszoœci (argumentów), specjalizacja dla szczególnych przypadków.
</P>
<P>
Oczywiœcie, takich dodatkowych specjalizacji mo¿emy zrobiæ wiêcej ni¿ jedn¹. Na przyk³ad jeœli uznamy, ¿e funkcja <SPAN CLASS=T>Kwadrat</SPAN> jest nam potrzebna równie¿ do wektorów trójwymiarowych, bêdziemy musieli stworzyæ specjalizacjê naszego szablonu wzglêdem klasy trójwymiarowego wektora. Czyli w sumie nasz szablon wraz z dwiema dodanymi specjalizacjami bêdzie wygl¹da³ tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
//Ogólna wersja szablonu funkcji Kwadrat</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;<BR>
TYP Kwadrat(TYP L)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> L*L;<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Specjalizacja funkcji Kwadrat dla klasy Wektor</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;&gt; Wektor Kwadrat(Wektor w)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> Wektor(w.x*w.x, w.y*w.y);<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Specjalizacja funkcji Kwadrat dla klasy Wektor3D</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;&gt; Wektor3D Kwadrat(Wektor3D w)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> Wektor3D(w.x*w.x, w.y*w.y, w.z*w.z);<BR>
}<BR>
</TD></TR>
</TABLE>

<h2>
Specjalizacja czêœciowa szablonów funkcji
</h2>

<P>
Jeœli chcemy dodaæ jedn¹ czy dwie specjalizacje, to oczywiœcie nie ma problemu. Gorzej, jeœli jest ich wiêcej. Wówczas w³aœciwie tracimy ca³e poczucie komfortu, jakie daj¹ nam szablony, bowiem pod wzglêdem czasoch³onnoœci i nudy dodawanie kolejnych specjalizacji w zasadzie niczym siê nie ró¿ni od "zwyk³ego" przeci¹¿ania funkcji bez stosowania szablonów w ogóle. Dlatego te¿ programiœci powinni dostaæ (i rzeczywiœcie ostatnio dostali) do rêki jeszcze jedn¹ broñ, a mianowicie <SPAN CLASS=Wazne>czêœciow¹ specjalizacjê szablonu</SPAN>. Oznacza ona coœ w rodzaju pewnej œciœle okreœlonej grupy specjalizacji, tworzonych jednak¿e za jednym zamachem. 
</P>
<P>
Niestety, broñ ta jest na razie tak¹ nowoœci¹, ¿e obs³uguj¹ j¹ tylko niektóre kompilatory, i tak na przyk³ad domyœlny kompilator z Dev-C++ czêœciow¹ specjalizacjê owszem, rozpozna, ale wówczas odmówi kontynuowania kompilacji. Wspominam jednak o takim rodzaju specjalizacji, ¿eby by³o wiadomo, ¿e coœ takiego w ogóle istnieje, gdy¿ w niedalekiej przysz³oœci mo¿e siê ona okazaæ bardzo istotnym elementem jêzyka.
</P>

<h2>
Specjalizacja szablonu klasy
</h2>

<P>
Oczywiœcie, szablony klas te¿ mo¿emy specjalizowaæ. Odbywa siê to w bardzo podobny sposób, jak specjalizowanie szablonów funkcji. Po prostu tworzymy sobie oddzieln¹ klasê o tej samej nazwie (no, mo¿e nie do koñca tej samej, ale o tym zaraz), ale nieco innym dzia³aniu. Zreszt¹, to mo¿e byæ nawet zupe³nie inna klasa, która oprócz podobnej nazwy nie bêdzie mia³a nic wspólnego ze swoj¹ "ogóln¹ wersj¹". Wszystko zale¿y od intencji programisty.
</P>
<P>
Poniewa¿ nie przychodzi mi akurat do g³owy ¿aden sensowny powód, dla którego mo¿na by specjalizowaæ ca³¹ klasê <SPAN CLASS=T>Tablica</SPAN> (co nie znaczy oczywiœcie, ¿e taki powód nie istnieje w ogóle ;-)), a nowej klasy te¿ nie chce mi siê wymyœlaæ, wiêc tym razem przyk³ad bêdzie doœæ g³upi. Otó¿ postanowiliœmy zrobiæ koledze-programiœcie z³oœliwy kawa³. Do pracowicie przezeñ opracowanej szablonowej klasy <SPAN CLASS=T>Tablica</SPAN> dopiszemy frajerowi specjalizacjê, która bêdzie "dzia³a³a" zupe³nie inaczej, ni¿ to sobie ów kolega wymarzy³ ;-). Zamiast "prawdziwych" konstruktorów, operatorów i zwyk³ych metod, wstawimy do naszej wrednej specjalizacji atrapy, które bêd¹ w dodatku wyœwietlaæ ró¿ne dziwne komunikaty. Tak wiêc dla jednego z typów danych, które mo¿na by przechowywaæ w tej tablicy, zamiast spodziewanych operacji, potencjalny u¿ytkownik uœwiadczy ró¿nych niemi³ych niespodzianek ;-). Do dzie³a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
//ogólna, "normalna" wersja szablonu</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane, <SPAN CLASS=K>typename</SPAN> TIterator&gt;<BR>
<SPAN CLASS=K>class</SPAN> Tablica<BR>
{<BR>
<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;TDane* dane;<BR>
&nbsp;TIterator liczba;<BR>
&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Tablica();<BR>
&nbsp;~Tablica();<BR>
&nbsp;<SPAN CLASS=K>bool</SPAN> Dodaj(TDane* elem);<BR>
&nbsp;<SPAN CLASS=K>bool</SPAN> Alokuj(TIterator ile);<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Czysc();<BR>
&nbsp;<SPAN CLASS=C>// ...</SPAN><BR>
};<BR>
<BR>
<SPAN CLASS=C>//"z³oœliwa" specjalizacja</SPAN><BR>
<SPAN CLASS=K>template</SPAN>&lt;&gt; <SPAN CLASS=K>class</SPAN> Tablica&lt;string, <SPAN CLASS=K>long</SPAN>&gt;<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//prywatne sk³adowe nie bêd¹ nam w ogóle potrzebne...<BR>
&nbsp;//w koñcu ta klasa nie musi dzia³aæ jak nale¿y ;-)</SPAN><BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Tablica()  { cout &lt;&lt; <SPAN CLASS=L>"Blad konstruktora..."</SPAN> &lt;&lt; endl; }<BR>
&nbsp;~Tablica() { cout &lt;&lt; <SPAN CLASS=L>"Blad dealokacji..."</SPAN> &lt;&lt; endl; }<BR>
&nbsp;<SPAN CLASS=K>bool</SPAN> Dodaj(string elem) { cout &lt;&lt; <SPAN CLASS=L>"Nieprawidlowy element..."</SPAN> &lt;&lt; endl; <SPAN CLASS=K>return false</SPAN>; }<BR>
&nbsp;<SPAN CLASS=K>bool</SPAN> Alokuj(<SPAN CLASS=T>long</SPAN> ile)   { cout &lt;&lt; <SPAN CLASS=L>"Blad alokacji..."</SPAN> &lt;&lt; endl; <SPAN CLASS=K>return false</SPAN>; }<BR>
&nbsp;<SPAN CLASS=K>void</SPAN> Czysc() { cout &lt;&lt; <SPAN CLASS=L>"Nie mozna wyczyscic tablicy..."</SPAN> &lt;&lt; endl; }<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, podobnie do specjalizacji szablonu funkcji, tak¿e i tutaj poprzedzamy specjalizowan¹ wersjê fraz¹ <SPAN CLASS=K>template&lt;&gt;</SPAN>. Ró¿nica polega na tym, ¿e w nag³ówku klasy specjalizowanej musimy podaæ (w nawiasach trójk¹tnych, rzecz jasna), dla jakich parametrów szablonu jest ta specjalizacja.
</P>
<P>
Samo cia³o specjalizowanej klasy nie musi byæ w niczym podobne do "orygina³u", jak ju¿ wspomnia³em wczeœniej. Mo¿emy sobie w nim napisaæ, co nam siê ¿ywnie podoba i o to w³aœnie chodzi w idei specjalizowanych klas. W tym przyk³adzie zachowaliœmy jednak z grubsza strukturê "prawid³owej" klasy <SPAN CLASS=T>Tablica</SPAN> (w sensie, ¿e wystêpuj¹ w niej metody o takich samych nazwach), aby nasza "ofiara" nie zorientowa³a siê zbyt szybko, ¿e to tylko kawa³ ;-).
</P>

<P class=UWAGA>
Zauwa¿, ¿e w specjalizowanej wersji nie wystêpuj¹ nazwy parameterów szablonu (<SPAN CLASS=T>TDane, TIterator</SPAN>), tylko konkretne typy (<SPAN CLASS=T>string</SPAN>,<SPAN CLASS=K> long</SPAN>). Wersja specjalizowana dotyczy bowiem konkretnych typów, parametry zaœ - tylko wersji "ogólnej" szablonu. Jest to doœæ oczywiste, choæ dla osoby dopiero zaczynaj¹ce zabawê z szablonami mog¹ byæ tym faktem zaskoczone.
</P>
<P>
Jeœli teraz za³o¿ymy, ¿e mamy ju¿ wczeœniej zaimplementowany "prawid³owy" szablon klasy <SPAN CLASS=T>Tablica</SPAN>, to bêdzie on "dzia³aæ" dla wszystkich parametrów z wyj¹tkiem kombinacji <SPAN CLASS=T>&lt;string, <SPAN CLASS=K>long</SPAN>&gt;</SPAN>. Tak wiêc jeœli potencjalny u¿ytkownik klasy <SPAN CLASS=T>Tablica</SPAN> spróbuje stworzyæ tablicê elementów <SPAN CLASS=K>int</SPAN> z iteratorem <SPAN CLASS=K>int</SPAN>, to nie zauwa¿y podstêpu, gdy¿ zgodnie ze swoimi oczekiwaniami skorzysta z klasy, wygenerowanej z "prawid³owego" szablonu. Jeœli poda parametry <SPAN CLASS=T>&lt;string, <SPAN CLASS=K>int</SPAN>&gt;</SPAN>, to równie¿ wszystko bêdzie w porz¹dku. Dopiero jeœli poda <SPAN CLASS=T>&lt;string, <SPAN CLASS=K>long</SPAN>&gt;</SPAN>, zaczn¹ siê dziaæ zaplanowane przez nas cuda ;-). Popatrzmy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;stdlib.h&gt;<BR>
#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<SPAN CLASS=K>using namespace</SPAN> std;<BR>
<BR><SPAN CLASS=C>
\\&lt;-- deklaracja "normalnej" klasy Tablica<BR>
<BR>
\\&lt;-- "z³oœliwa" specjalizacja</SPAN><BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;Tablica&lt;string, <SPAN CLASS=K>long</SPAN>&gt; Test; <SPAN CLASS=C>//hehe ;-)</SPAN><BR>
&nbsp;string s = <SPAN CLASS=L>"bla"</SPAN>;<BR>
<BR>
&nbsp;Test.Dodaj(s);<BR>
&nbsp;Test.Czysc();<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Nasza ofiara kompiluje sobie powy¿szy program i...
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Blad konstruktora...<BR>
Nieprawidlowy element...<BR>
Nie mozna wyczyscic tablicy...<BR>
Naciœnij dowolny klawisz, aby kontynuowaæ . . .<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Dodatkowo po naciœniêciu klawisza poka¿e siê jeszcze napis <SPAN CLASS=L>"Blad dealokacji..."</SPAN> jako wynik niejawnego wywo³ania "fa³szywego" destruktora... Có¿, próba skorzystania z tej wersji klasy zakoñczy³a siê kompletnym fiaskiem. I o to nam w³aœnie chodzi³o ;-).
</P>

<h2>
Specjalizacja pojedynczych metod klasy
</h2>

<P>
Czasami, specjalizuj¹c jakiœ szablon klasy, nie potrzebujemy wcale wprowadzaæ tak drastycznych zmian w stosunku do "ogólnej wersji". Czêsto wystarczy³oby zmieniæ jedn¹, dwie metody, aby osi¹gn¹æ zamierzony cel. W takim wypadku pisanie pozosta³ych metod od nowa (a przecie¿ pamiêtamy, ¿e g³ównym celem szablonów jest wyeliminowanie zbêdnej pisaniny), czy nawet kopiowanie jej i nastêpnie odpowiednia modyfikacja tej jednej, dwóch metod to by³aby masa niepotrzebnej roboty i równie niepotrzebny wzrost objêtoœci kodu Ÿród³owego.
</P>

<P>
Szczêœliwie wcale nie musimy tego robiæ. Mamy bowiem mo¿liwoœæ napisania specjalizacji li jedynie jednej metody (lub dwóch, trzech...), jeœli tylko chcemy.
</P>
<P>
Za³ó¿my, ¿e przystosowaliœmy nasz¹ klasê <SPAN CLASS=T>Tablica</SPAN> jedynie do przechowywania elementów numerycznych (mimo i¿ niby jest to szablon). Potem nagle doznaliœmy oœwiecenia i przypomnia³o nam siê, ¿e potrzebujemy jeszcze przechowywaæ tam ³añcuchy typu <SPAN CLASS=T>string</SPAN>. Po krótkiej analizie kodu naszego szablonu, który wygl¹da...
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane&gt;<BR>
<SPAN CLASS=K>class</SPAN> Tablica<BR>
{<BR>
<SPAN CLASS=K>private:</SPAN><BR>
&nbsp;Dane* dane;<BR>
&nbsp;<SPAN CLASS=K>int</SPAN> liczba;<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Tablica() { dane = <SPAN CLASS=K>new</SPAN> TDane[<SPAN CLASS=L>1</SPAN>]; dane[<SPAN CLASS=L>0</SPAN>] = <SPAN CLASS=L>0</SPAN>; }<BR>
&nbsp;~Tablica() { <SPAN CLASS=K>delete[]</SPAN> dane; }<BR>
&nbsp;<SPAN CLASS=C>// ... reszta nieistotna ;-)</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
...dochodzimy do wniosku, ¿e jedynym elementem tego szablonu wymagaj¹cym modyfikacji na rzecz typu <SPAN CLASS=T>string</SPAN>, jest domyœlny konstruktor. Dla typów numerycznych alokuje on jeden element tablicy i inicjalizuje go zerem. Dla typu <SPAN CLASS=T>string</SPAN> taka operacja jest oczywiœcie nieprawid³owa. Dlatego te¿ w³aœnie domyœlny konstruktor powinniœmy specjalizowaæ dla <SPAN CLASS=T>&lt;string&gt;</SPAN> (dla u³atwienia pozbyliœmy siê  z szablonu parametryzowanego iteratora, który tutaj bêdzie zawsze typu <SPAN CLASS=K>int</SPAN>). Uczynimy to na zewn¹trz klasy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;&gt; Tablica&lt;string&gt;::Tablica()<BR>
{<BR>
&nbsp;dane = <SPAN CLASS=K>new</SPAN> string[<SPAN CLASS=L>1</SPAN>];<BR>
&nbsp;dane[<SPAN CLASS=L>0</SPAN>] = <SPAN CLASS=L>"pusty lancuch"</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Nag³ówek jest chyba ca³kowicie zrozumia³y - tradycyjnie zaczynamy od <SPAN CLASS=K>template</SPAN><SPAN CLASS=T>&lt;&gt;</SPAN> w celu zaznaczenia, ¿e nastêpuj¹cy po tym wyra¿eniu kod bêdzie specjalizacj¹ szablonu. Nastêpnie wyjaœniamy kompilatorowi, ¿e bêdzie to konstruktor klasy <SPAN CLASS=T>Tablica</SPAN> - z tym, ¿e tylko wówczas, gdy jako parametr szablonu wystêpuje <SPAN CLASS=T>string</SPAN> (innymi s³owy: jest to konstruktor klasy <SPAN CLASS=T>Tablica&lt;string&gt;</SPAN>, dla odró¿nienia od klasy <SPAN CLASS=T>Tablica&lt;kazdy_inny_typ&gt;</SPAN>). Cia³o nowego konstruktora wykonuje alokacjê pierwszego elementu (podobnie jak konstruktor dla typów numerycznych), ale nowo utworzony element inicjalizuje nie zerem, lecz napisem <SPAN CLASS=L>"pusty lancuch"</SPAN>.
</P>
<h2>
Specjalizacja czêœciowa szablonu klas
</h2>
<P>
Jak zapewne pamiêtasz, w przypadku czêœciowej specjalizacji szablonów funkcji musieliœmy siê obyæ smakiem. Dlatego te¿ pewnie siê zdziwisz, ¿e taka specjalizacja bêdzie ca³kowicie mo¿liwa wobec klas...
</P>
<P>
Przyk³adowy szablon bêdzie tym razem ju¿ ca³kowicie nie¿yciowy, za to prawdopodobnie du¿o prostszy do zrozumienia. Bêdzie to klasa nie robi¹ca zupe³nie nic po¿ytecznego, a tylko zaznaczaj¹ca sw¹ obecnoœæ w programie (coœ jakby politycy w pañstwie) przez wypisanie odpowiedniego komunikatu w konstruktorze:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD><SPAN CLASS=C>
#include &lt;stdlib.h&gt;<BR>
#include &lt;iostream.h&gt;</SPAN><BR>
<BR>
<BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;<BR>
<SPAN CLASS=K>class</SPAN> Klasa<BR>
{<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Tablica() { cout &lt;&lt; <SPAN CLASS=L>"Tutaj wersja ogolna klasy!"</SPAN> &lt;&lt; endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;<BR>
<SPAN CLASS=K>class</SPAN> Klasa&lt;TYP*&gt;<BR>
{<BR>
<SPAN CLASS=K>public:</SPAN><BR>
&nbsp;Tablica() { cout &lt;&lt; <SPAN CLASS=L>"Tutaj czesciowa specjalizacja!"</SPAN> &lt;&lt; endl; }<BR>
};<BR>
<BR>
<SPAN CLASS=K><SPAN CLASS=K>int</SPAN></SPAN> main()<BR>
{<BR>
&nbsp;Klasa&lt;<SPAN CLASS=K>int</SPAN>&gt; zm1;<BR>
&nbsp;Klasa&lt;<SPAN CLASS=K>float</SPAN>&gt; zm2;<BR>
&nbsp;Klasa&lt;<SPAN CLASS=K>float</SPAN>*&gt; zm3;<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>


<P>
Pierwsza deklaracja klasy w tym programie to wersja ogólna szablonu, natomiast druga klasa - to w³aœnie nasza czêœciowa specjalizacja. Dotyczy ona wskaŸników. Wszystkich wskaŸników, nie tylko jednego wybranego. Tak wiêc jeœli tak¹ specjalizacjê w programie umieœcimy, to kompilator bêdzie sprawdza³ wszystkie obiekty zadeklarowane jako <SPAN CLASS=T>Klasa</SPAN> i jeœli bêd¹ one dowolnego typu wskaŸnikowego, to kompilator wygeneruje dla nich konkretyzacjê, korzystaj¹c z tego drugiego szablonu, w przeciwnym wypadku - z pierwszego. Sprawdzane to jest w bloku <SPAN CLASS=T>main</SPAN>, gdzie mamy trzy deklaracje obiektów klasy <SPAN CLASS=T>Klasa</SPAN>. Dadz¹ one na ekranie taki wydruk:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD STYLE="background-color: black">
<SPAN CLASS=W>
Tutaj wersja ogolna klasy!<BR>
Tutaj wersja ogolna klasy!<BR>
Tutaj czesciowa specjalizacja!<BR>
Naciœnij dowolny klawisz, aby kontynuowaæ . . .<BR>
</SPAN>
</TD></TR>
</TABLE>

<P>
Myœlê, ¿e nale¿y siê jeszcze jedno ma³e wyjaœnienie. Otó¿ mo¿na by siê zastanawiaæ, czemu w nag³ówku specjalizacji mamy <SPAN CLASS=K>template</SPAN><SPAN CLASS=T>&lt;<SPAN CLASS=K>typename</SPAN> TYP&gt;</SPAN> (zupe³nie jak w "ogólnej wersji"), a nie samo <SPAN CLASS=K>template</SPAN><SPAN CLASS=T>&lt;&gt;</SPAN>. Otó¿ przypominam, ¿e mamy do czynienia ze specjalizacj¹ czêœciow¹, która w przeciwieñstwie do specjalizacji ca³kowitej (tej, któr¹ omawialiœmy wczeœniej) nie dotyczy jakiego jednego, konkretnego typu danych, lecz ca³ej ich grupy. Ba, wskaŸników jest nawet znacznie wiêcej, ni¿ "niewskaŸnikowych" typów (teoretycznie jest ich nieskoñczenie wiele). Dlatego parametr musi zostaæ, inaczej specjalizacja czêœciowa sta³aby siê specjalizacj¹ ca³kowit¹, co niekoniecznie jest sytuacj¹ po¿¹dan¹ ;-).
</P>

<h2>
Domyœlne parametry szablonu
</h2>

<P>
Na zakoñczenie jeszcze trochê o parametrach. Nieco wy¿ej mieliœmy szablon klasy <SPAN CLASS=T>Tablica</SPAN> z dwoma parametrami (<SPAN CLASS=T>TDane</SPAN> i <SPAN CLASS=T>TIterator</SPAN>). PóŸniej zrezygnowaliœmy z tego drugiego. Gdyby siê nad tym trochê zastanowiæ, to jasne siê stanie, ¿e ten drugi parametr jest znacznie "mniej potrzebny" ni¿ ten pierwszy. W gruncie rzeczy niemal w ka¿dym przypadku u¿ycia tablicy w zupe³noœci wystarczy nam iterator typu <SPAN CLASS=K>int</SPAN> (tablic posiadaj¹cych wiêcej, ni¿ 2 miliardy elementów raczej siê nie spotyka, natomiast stosowanie "mniejszych" typów w roli iteratora to doprawdy niewielka oszczêdnoœæ).
</P>
<P>
Tak wiêc jeœli mamy podobn¹ sytuacjê - "ma³o istotny" parametr, z którego jednak nie chcemy rezygnowaæ (¿eby szablon by³ bardziej elastyczny), wówczas mo¿emy zastosowaæ domyœlne parametry szablonu. Dzia³aj¹ one na bardzo podobnych zasadach, jak w przypadku argumentów funkcji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TDane, <SPAN CLASS=K>typename</SPAN> TIterator = <SPAN CLASS=K>unsigned int</SPAN>&gt;<BR>
<SPAN CLASS=K>class</SPAN> Tablica<BR>
{<SPAN CLASS=C><BR>
 //...</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Chyba ¿adnych komentarzy do tego przyk³adu nie trzeba - po prostu parametr <SPAN CLASS=T>TIterator</SPAN> sta³ siê odt¹d nieobowi¹zkowy i mo¿emy zadeklarowaæ obiekt typu <SPAN CLASS=T>Tablica</SPAN> podaj¹c tylko jeden typ-parametr - typ elementu.
</P>

<P class=UWAGA>
Oczywiœcie parametry domyœlne szablonu obowi¹zuj¹ te¿ te same ograniczenia, co w przypadku argumentów domyœlnych funkcji, tj. parametry z wartoœci¹ domyœln¹ (czyli opcjonalne) nie mog¹ poprzedzaæ ¿adnych parametrów obowi¹zkowych.
</P>
<P>
Kolejna cecha parametrów domyœlnych "zapo¿yczona" z funkcji dotyczy przypadku, gdy wszystkie parametry s¹ opcjonalne i u¿ytkownik szablonu nie poda ¿adnego. Wówczas, podobnie jak w przypadku wywo³ywania funkcji bez podawania argumentów, nie wolno zapomnieæ o pustej parze nawiasów (w tym przypadku chodzi rzecz jasna o nawiasy trójk¹tne).
</P>
<P>
Teraz ma³a ciekawostka. W przypadku listy argumentów funkcji nie mogliœmy inicjalizowaæ jednego argumentu drugim, poniewa¿ kompilator by siê na nas wydar³, ¿e ów drugi argument nie zosta³ jeszcze zadeklarowany (mimo, i¿ niby wystêpuje wczeœniej na liœcie). W przypadku szablonów jest to jak najbardziej mo¿liwe:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>template</SPAN>&lt;<SPAN CLASS=K>typename</SPAN> TYP1, <SPAN CLASS=K>typename</SPAN> TYP2 = TYP1&gt;<BR>
<SPAN CLASS=K>class</SPAN> Klasa<BR>
{<BR><SPAN CLASS=C>
 //...</SPAN><BR>
};<BR>
</TD></TR>
</TABLE>

<P>
W przypadku funkcji takie coœ raczej nie by³o nam niezbêdne, gdy¿ mogliœmy bez problemu dokonaæ zmian wartoœci argumentów ju¿ w ciele funkcji. W przypadku szablonów taka zmiana mo¿liwa nie jest (kompilator w ogóle nie zrozumie o co nam chodzi i og³osi "parse error"), dlatego te¿ musia³a siê pojawiæ jakaœ inna droga do ujednolicenia niektórych parametrów w pewnych szczególnych sytuacjach.
</P>
<P>
Wreszcie na koniec warto wspomnieæ, ¿e parametry domyœlne mog¹ miec tylko szablony klas - NIE istnieje mo¿liwoœæ tworzenia szablonów funkcji z parametrami opcjonalnymi. Nie jest to raczej jednak podyktowane istnieniem jakichœ barier w jêzyku, które by tak¹ mo¿liwoœæ wyklucza³y. Tak wiêc jeœli bêdziemy siê du¿o modliæ do bóstw o parametry opcjonalne i sk³adaæ od czasu do czasu ofiary ca³opalne z lamerów, to byæ mo¿e nasze proœby zostan¹ wys³uchane i kiedyœ ten brakuj¹cy element zaistnieje w Standardzie ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kurs08.html">&lt;&lt; Poprzednia czêœæ kursu</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../cpp.html"> Spis</A> &nbsp;
<A HREF="kurs09.html">Nastêpna czêœæ kursu &gt;&gt;</A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>