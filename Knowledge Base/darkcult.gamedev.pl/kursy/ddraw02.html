<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Animacja w DirectDraw</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw01.html">&lt;&lt;Obiekt g³ówny i powierzchnie</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw03.html">Bezpoœredni dostêp... &gt;&gt;</A>
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>
Animacja w DirectDraw
</H1>

<P>
Wyœwietlanie nieruchomych obrazków, czym zajmowaliœmy siê w poprzedniej czêœci tego kursu, to nie jest powód, dla którego stworzono DirectX ;-). Do takiej zabawy w zupe³noœci wystarczy "go³e" WinAPI. Byæ mo¿e jednak zauwa¿y³eœ, ¿e animacja ju¿ tam nieco kuleje, i to nawet przy takiej malutkiej pi³eczce, a co dopiero kiedy musielibyœmy poruszaæ obiektem o rozmiarach ca³ego ekranu? No w³aœnie, zgroza. I po to jest DirectX. Warto by wreszcie wykorzystaæ jego mo¿liwoœci...
</P>
<P>
Kulkom damy ju¿ spokój. Dla odmiany zrobimy sobie napis, wiruj¹cy na kolorowym tle. Napis robimy sobie sami, umieszczaj¹c kolejne klatki w jednym pliku, obok siebie:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/ddanim.gif" ALT="Kolejne klatki animacji w jednej bitmapie">
</P>

<P>
Animuj¹c nasz¹ pi³eczkê mieliœmy bardzo proste zadanie: by³a tylko jedna bitmapa, któr¹ wystarczy³o wyœwietlaæ w ró¿nych miejscach ekranu, ¿eby stworzyæ wra¿enie ruchu. Tym razem wyœwietlamy ci¹gle w tym samym miejscu, ale musimy te¿ odmalowywaæ t³o po ka¿dej klatce, no i za ka¿dym razem rysujemy inny fragment bitmapy.
</P>
<P>
¯eby wiedzieæ, któr¹ z tych klatek w danym momencie rysujemy, potrzeba nam oczywiœcie zmiennej. Dobrze te¿ bêdzie mieæ strukturê <SPAN CLASS=T>RECT</SPAN> która wska¿e konkretnie, który fragment ca³ej bitmapy bêdziemy wyœwietlaæ. Nazwijmy tê strukturê <SPAN CLASS=Wazne>kadrem</SPAN>, poniewa¿ tak¹ w³aœnie pe³ni rolê. Tym razem wszystkie klatki bêdziemy wyœwietlaæ zawsze w tym samym miejscu, ale dla porz¹dku deklarujemy sobie drug¹ strukturê <SPAN CLASS=T>RECT</SPAN>, która bêdzie pokazywa³a miejsce na ekranie, gdzie wyl¹duje ka¿da kolejna klatka.
</P>
<P>
Teraz kwestia odmierzania czasu. W kursie WinAPI u¿yliœmy w tym celu timera tworzonego funkcj¹ <SPAN CLASS=T>SetTimer</SPAN>, a o up³ywaj¹cym czasie sygnalizowa³ nam komunikat <SPAN CLASS=T>WM_TIMER</SPAN>. Wspomnia³em te¿, ¿e to kiepskie rozwi¹zanie. Generalnie dok³adne mierzenie up³ywu czasu w systemie wielow¹tkowym, jakim jest Windows, to bardzo skomplikowane zagadnienie; rozwi¹zanie zadowalaj¹ce profesjonalnych twórców gier to ustawienie timera w osobnym w¹tku, jednak tego na razie nie bêdziemy robiæ, bo co tu gadaæ, proste to nie jest. Wykorzystamy za to inny, te¿ nienajgorszy sposób.
</P>
<P>
Mowa o funkcji <SPAN CLASS=T>GetTickCount</SPAN>. Zwraca ona liczbê milisekund, które up³ynê³y od chwili uruchomienia Windowsa (a wiêc przy okazji dowiedzieliœmy siê, jak sprawdziæ, ile brat siedzi przy kompie ;-)). Nie ma ¿adnych argumentów i jest typu <SPAN CLASS=T>DWORD</SPAN>. Dlatego bêdziemy potrzebowali dwóch zmiennych tego w³aœnie typu, ¿eby aktualny czas zapamiêtaæ do naszych niecnych celów. Przyda siê te¿ kilka sta³ych oraz zmienne do zapamiêtania wymiarów pojedynczej klatki. Ogólnie nasze podstawowe deklaracje bêd¹ wygl¹da³y tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>const</SPAN> WORD MaxKlatek = <SPAN CLASS=L>9</SPAN>;<BR>
<SPAN CLASS=K>const</SPAN> WORD CEL_X = <SPAN CLASS=L>75</SPAN>, CEL_Y = <SPAN CLASS=L>10</SPAN>;<BR>
DWORD StaryCzas = <SPAN CLASS=L>0</SPAN>, NowyCzas;<BR>
WORD Klatka = <SPAN CLASS=L>0</SPAN>, Szer, Wys;<BR>
RECT Kadr, Cel, Tlo;<BR>
<BR>
LPDIRECTDRAW lpDD = NULL;<BR>
LPDIRECTDRAWSURFACE lpEkran = NULL;<BR>
LPDIRECTDRAWSURFACE lpBufor = NULL;<BR>
LPDIRECTDRAWSURFACE lpObrazek = NULL;<BR>
LPDIRECTDRAWSURFACE lpTlo = NULL;<BR>
</TD></TR>
</TABLE>

<P>
Powy¿sze zmienne powinny byæ globalne, czyli umieszczone na zewn¹trz <SPAN CLASS=T>WinMain</SPAN>. Mamy tu a¿ cztery powierzchnie: <SPAN CLASS=T>lpEkran</SPAN> bêdzie powierzchni¹ g³ówn¹, do <SPAN CLASS=T>lpObrazek</SPAN> za³adujemy bitmapê z klatkami animacji, a do <SPAN CLASS=T>lpTlo</SPAN>... t³o :-). Teraz bêdzie nam potrzebny g³ówny obiekt <SPAN CLASS=T>DirectDraw</SPAN>, zwarty i gotowy do pracy ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>if</SPAN>(DirectDrawCreate(NULL, &lpDD, NULL) != DD_OK)<BR>
{<BR>
&nbsp;MessageBox(hwnd,<SPAN CLASS=L>"B³¹d przy tworzeniu obiektu DD","Fatalnie!"</SPAN>,MB_ICONSTOP);<BR>
&nbsp;<SPAN CLASS=C>//lpDD->Release();</SPAN><BR>
&nbsp;<SPAN CLASS=K>return</SPAN> FALSE;<BR>
}<BR>
lpDD->SetCooperativeLevel(hwnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);<BR>
lpDD->SetDisplayMode(<SPAN CLASS=L>800, 600, 16</SPAN>);<BR>
</TD></TR>
</TABLE>

<P>
Ustawi³em tutaj tryb 16-bitowy, poniewa¿ moja karta nie obs³uguje innych :D. Jeœli chcesz albo jeœli musisz, zmieñ <SPAN CLASS=L>16</SPAN> na <SPAN CLASS=L>32</SPAN> (albo na cokolwiek innego, ale wtedy bêdziesz siê sam póŸniej mêczy³ z kluczowaniem kolorów :-P).
</P>
<P>
Mamy gotowy obiekt DD, wypada³oby zawczasu zadbaæ równie¿ o jego prawid³owe zwolnienie. Najlepiej stwórzmy sobie w tym celu osobn¹ funkcjê, która przy okazji bêdzie nam zwalnia³a wszystkie powierzchnie - o ile istniej¹. Wywo³anie tej funkcji wstawimy sobie póŸniej w miejsce wykomentowanej instrukcji <SPAN CLASS=T>lpDD->Release()</SPAN> (powy¿ej).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> Sprzatanie()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpEkran != NULL) { lpEkran->Release(); lpEkran = NULL; }<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpObrazek != NULL) { lpObrazek->Release(); lpObrazek = NULL; }<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpTlo != NULL) { lpTlo->Release(); lpTlo = NULL; }<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpDD != NULL) { lpDD->Release(); lpDD = NULL; }<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Od tej pory wywo³ujemy <SPAN CLASS=T>Sprzatanie</SPAN>, kiedy tylko coœ zwi¹zanego z DD nam siê nie powiedzie, np. nie uda siê utworzyæ powierzchni. Oprócz tego oczywiœcie musimy posprz¹taæ przy zakoñczeniu programu, a wiêc najlepiej wstawiæ <SPAN CLASS=T>Sprzatanie</SPAN> w obs³udze komunikatu <SPAN CLASS=T>WM_DESTROY</SPAN>.
</P>
<P>
Nasze bitmapy (t³o i "w³aœciw¹" animacjê) nale¿a³oby teraz gdzieœ wczytaæ. To oczywiœcie pikuœ dla ciebie, poniewa¿ przeczyta³eœ bardzo uwa¿nie kurs WinAPI ;-). Tak samo uwa¿nie przeœledzi³eœ poprzedni¹ czêœæ kursu DirectDraw i potrafisz przenieœæ grafikê ze zwyk³ego kontekstu <SPAN CLASS=T>HDC</SPAN> na powierzchniê DD. Teraz mamy a¿ dwie bitmapy do wczytania, wiêc ¿eby nie produkowaæ nadmiernych iloœci kodu, napiszemy sobie porêczn¹ funkcyjkê, której bêdzie wystarczy³o podaæ nazwê pliku BMP, a ona zwróci nam wskaŸnik do gotowej powierzchni:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
LPDIRECTDRAWSURFACE WyczarujPowierzchnie(LPCSTR NazwaPliku)<BR>
{<BR>
&nbsp;LPDIRECTDRAWSURFACE temp = NULL;<BR>
&nbsp;HBITMAP hbmBitmapa, hbmOld;<BR>
&nbsp;BITMAP bmp;<BR>
&nbsp;HDC hdc, hdcTmp;<BR>
<BR>
&nbsp;hbmBitmapa = (HBITMAP)LoadImage(NULL, NazwaPliku, IMAGE_BITMAP, <SPAN CLASS=L>0, 0</SPAN>, LR_LOADFROMFILE);<BR>
&nbsp;GetObject(hbmBitmapa, <SPAN CLASS=K>sizeof</SPAN>(bmp), &bmp);<BR>
<BR>
&nbsp;hdcTemp = CreateCompatibleDC(NULL);<BR>
&nbsp;hbmOld = (HBITMAP)SelectObject(hdcTemp, hbmBitmapa);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//Tworzenie powierzchni</SPAN><BR>
&nbsp;DDSURFACEDESC ddsd;<BR>
&nbsp;ddsd.dwSize = sizeof(ddsd);<BR>
&nbsp;ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;<BR>
&nbsp;ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;<BR>
&nbsp;ddsd.dwWidth = bmp.bmWidth;<BR>
&nbsp;ddsd.dwHeight = bmp.bmHeight;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(lpDD->CreateSurface(&ddsd, &temp, NULL) == DD_OK)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//Kopiowanie z kontekstu na powierzchniê</SPAN><BR>
&nbsp;&nbsp;temp->GetDC(&hdc);<BR>
&nbsp;&nbsp;BitBlt(hdc, <SPAN CLASS=L>0, 0</SPAN>, bmp.bmWidth, bmp.bmHeight, hdcTemp, <SPAN CLASS=L>0, 0</SPAN>, SRCCOPY);<BR>
&nbsp;&nbsp;temp->ReleaseDC(hdc);<BR>
&nbsp;}<BR>
<BR>
&nbsp;<SPAN CLASS=C>//Tego ju¿ nie potrzebujemy</SPAN><BR>
&nbsp;SelectObject(hdcTemp, hbmOld);<BR>
&nbsp;DeleteDC(hdcTemp);<BR>
&nbsp;DeleteObject(hbmBitmapa);<BR>
<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> temp;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mamy nasz¹ funkcjê, która jest na tyle przydatna, ¿e dziêki niej stworzymy sobie dwie powierzchnie w dwóch linijkach, i na tyle g³upia, ¿e nie bêdzie siê zastanawia³a, czy tworzona powierzchnia to zwyk³a bitmapa, czy klatki animacji. Tak wiêc nie pobierzemy ju¿ sobie informacji o wymiarach bitmap z pliku. Wstawiamy wiêc "na chama" gotowe wartoœci do naszych prostok¹tów, a wczeœniej korzystamy z tego, coœmy tak pracowicie przed chwil¹ wklepywali i tworzymy dwie pomocnicze powierzchnie:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//Utworzenie powierzchni</SPAN><BR>
lpTlo = WyczarujPowierzchnie(<SPAN CLASS=L>"back.bmp"</SPAN>);<BR>
lpObrazek = WyczarujPowierzchnie(<SPAN CLASS=L>"obrazek.bmp"</SPAN>);<BR>
<SPAN CLASS=K>if</SPAN>(lpTlo == NULL || lpObrazek == NULL)<BR>
{<BR>
&nbsp;MessageBox(hwnd,<SPAN CLASS=L>"Nici z utworzenia powierzchni","O ¿esz!"</SPAN>,MB_ICONSTOP);<BR>
&nbsp;Sprzatanie()<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> FALSE;<BR>
}<BR>
<BR>
<SPAN CLASS=C>//Uzupe³niamy dane o prostok¹tach</SPAN><BR>
SetRect(&Tlo, <SPAN CLASS=L>0, 0, 300, 150</SPAN>);<BR>
Szer = <SPAN CLASS=L>150</SPAN>;<BR>
Wys  = <SPAN CLASS=L>135</SPAN>;<BR>
SetRect(&Kadr, <SPAN CLASS=L>0, 0</SPAN>, Szer, Wys);<BR>
SetRect(&Cel, CEL_X, CEL_Y, CEL_X + Szer, CEL_Y + Wys);<BR>
</TD></TR>
</TABLE>

<P>
Z powierzchniami, które bêd¹ przechowywaæ nasze bitmapy, siê uporaliœmy. Teraz pora siê zaj¹æ mechanizmem animacji. Skoro korzystamy z <SPAN CLASS=T>GetTickCount</SPAN>, to pêtla komunikatów w obecnej postaci nie przyda nam siê w samym procesie animacji, a wrêcz bêdzie przeszkadzaæ. Dlatego czeka j¹ ma³y remont:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>while</SPAN>(msg.message != WM_QUIT)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(PeekMessage(&msg,NULL,<SPAN CLASS=L>0,0</SPAN>,PM_REMOVE))<BR>
&nbsp;{<BR>
&nbsp;&nbsp;TranslateMessage(&msg);<BR>
&nbsp;&nbsp;DispatchMessage(&msg);<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//Rysowanie klatek bêdzie tutaj...</SPAN><BR>
&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Warunek pêtli zosta³ podobny - wychodzimy z niej, kiedy user zamknie okno (bêdziemy dzia³aæ w trybie pe³noekranowym, wiêc bêdzie siê to da³o zrobiæ praktycznie tylko wciskaj¹c Alt+F4). Zmieni³a siê zaœ funkcja, któr¹ u¿ywamy do pobierania komunikatu z kolejki. <SPAN CLASS=T>PeekMessage</SPAN> (w odró¿nieniu od <SPAN CLASS=T>GetMessage</SPAN>) pobiera komunikaty "w locie", nie zatrzymuj¹c siê, jeœli kolejka jest pusta. Dziêki temu w momencie, kiedy nie s¹ akurat obs³ugiwane jakieœ Bardzo Wa¿ne Komunikaty (czyli w powy¿szym bloku <SPAN CLASS=K>else</SPAN>), mo¿emy sobie spokojnie rysowaæ obrazki. Dodatkowo parametr <SPAN CLASS=T>PM_REMOVE</SPAN> okreœla, ¿e ka¿dy pobrany komunikat bêdzie jednoczeœnie usuwany z kolejki, no bo na co ma tam czekaæ jak g³upi? ;-)
</P>
<P>
Zastanówmy siê, co wpisaæ w ten blok <SPAN CLASS=K>else</SPAN>. Przede wszystkim musimy tam ca³y czas sprawdzaæ, czy ju¿ czas :-). Na kolejn¹ klatkê, oczywiœcie. Za³ó¿my, ¿e czas bêdzie na ni¹ co <SPAN CLASS=L>100</SPAN> milisekund. Mechanizm zmiany klatek jest bardzo prosty:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
NowyCzas = GetTickCount();<BR>
<SPAN CLASS=K>if</SPAN>(StaryCzas + <SPAN CLASS=L>100</SPAN> &lt;= NowyCzas)<BR>
{<BR>
&nbsp;Renderuj();<BR>
&nbsp;<SPAN CLASS=C>//Nowa klatko, pora na ciebie!</SPAN><BR>
&nbsp;++Klatka;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(Klatka &gt;= MaxKlatek) Klatka = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;StaryCzas = NowyCzas;<BR>
&nbsp;<SPAN CLASS=C>//<-- Tutaj bêdziemy kadrowaæ bitmapê...</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Poniewa¿ kolejne klatki znajduj¹ siê w pliku obok siebie i maj¹ dok³adnie te same wymiary, kadrowanie to czynnoœæ banalna:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
Kadr.left = Klatka * Szer;<BR>
Kadr.right = Kadr.left + Szer;<BR>
</TD></TR>
</TABLE>

<P>
W pionie kadru oczywiœnie nie musimy ruszaæ, poniewa¿ klatki mamy w bitmapce u³o¿one poziomo.
</P>
<P>
Pora na najwa¿niejszy etap: utworzenie powierzchni ekranu. Moglibyœmy to zrobiæ analogicznie, jak w poprzedniej czêœci kursu, jednak taka powierzchnia jest raczej ma³o przydatna do animacji, poniewa¿ nie daje mo¿liwoœci podwójnego buforowania. Musielibyœmy utworzyæ osobno jakiœ bufor, w nim wykonywaæ wszystkie operacje graficzne, a nastêpnie kopiowaæ jego zawartoœæ na powierzchniê ekranu; mo¿na i tak, ale to ma³o efektywny sposób. Znacznie lepiej bêdzie skorzystaæ ze specjalnego mechanizmu udostêpnionego w DirectDraw: tworzenia <SPAN CLASS=Wazne>³añcucha powierzchni</SPAN>.
</P>
<P>
£añcuch taki mo¿e siê sk³adaæ z dowolnej liczby powierzchni, z których jedna jest g³ówna i pe³ni rolê powierzchni ekranu. Tylko jedna powierzchnia w ³añcuchu mo¿e byæ w danym momencie g³ówn¹, a wiêc widoczn¹ na ekranie. Specjaln¹ instrukcj¹ mo¿na jednak zmieniæ aktualn¹ g³ówn¹ powierzchniê na nastêpn¹ w ³añcuchu. Kolejnoœæ ustalamy przy tworzeniu ³añcucha. Oczywiœcie jeœli mamy w tym ³añcuchu tylko dwie powierzchnie (a tak w³aœnie bêdzie w poni¿szym przyk³adzie), to mo¿e byæ tylko jedna kolejnoœæ. Oto jak zrobiæ takie cudo:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DDSURFACEDESC ddsd;<BR>
ddsd.dwSize = <SPAN CLASS=K>sizeof</SPAN>(ddsd);<BR>
ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;<BR>
ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_COMPLEX | DDSCAPS_FLIP;<BR>
ddsd.dwBackBufferCount = <SPAN CLASS=L>1</SPAN>;<BR>
<SPAN CLASS=K>if</SPAN>(lpDD->CreateSurface(&ddsd,&lpEkran,NULL) != DD_OK)<BR>
{<BR>
&nbsp;MessageBox(hwnd,<SPAN CLASS=L>"Buforów niestety nie bêdzie...","Co za pech!"</SPAN>,MB_ICONSTOP);<BR>
&nbsp;Sprzatanie()<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> FALSE;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Wiêc co my tu mamy? Jak pewnie wiesz, pole <SPAN CLASS=T>dwFlags</SPAN> okreœla, które z pozosta³ych pól struktury <SPAN CLASS=T>ddsd</SPAN> s¹ prawid³owe. Tym sposobem aktywowaliœmy sobie pole <SPAN CLASS=T>dwBackBufferCount</SPAN>, które okreœla, ile tylnych buforów potrzebujemy do ³añcucha. Nasz ³añcuch ma siê sk³adaæ z dwóch buforów, jeden jest powierzchni¹ g³ówn¹, wiêc pozostaje dok³adnie <SPAN CLASS=L>1</SPAN>, co te¿ wpisujemy we wspomniane pole. Z kolei pole <SPAN CLASS=T>ddsCaps.dwCaps</SPAN> okreœla nam dodatkowe w³aœciwoœci naszej powierzchni. Sta³¹ <SPAN CLASS=T>DDSCAPS_PRIMARYSURFACE</SPAN> ju¿ znamy, nowoœci to: <SPAN CLASS=T>DDSCAPS_COMPLEX</SPAN> (oznacza, ¿e tworzymy ³añcuch powierzchni) oraz <SPAN CLASS=T>DDSCAPS_FLIP</SPAN> (oznacza, ¿e powierzchnie w ³añcuchu mo¿na ze sob¹ zamieniaæ).
</P>
<P>
Mamy wiêc nasz ³añcuch, tylko jak po nim rysowaæ? Na razie dysponujemy tylko wskaŸnikiem <SPAN CLASS=T>lpEkran</SPAN>, a wiêc mo¿emy tylko wyœwietlaæ obrazki bezpoœrednio na ekranie. A chcieliœmy mieæ podwójne buforowanie, czyli potrzebny nam bêdzie jeszcze wskaŸnik na tylny bufor, czyli ten chwilowo schowany w ³añcuchu :-). ¯eby wyd³ubaæ z ³añcucha odpowiedni wskaŸnik, skorzystamy z us³ug oferowanych przez funkcjê <SPAN CLASS=T>GetAttachedSurface</SPAN>. Przyda nam siê te¿ (kolejny raz) struktura <SPAN CLASS=T>ddsd</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
ddsd.ddsCaps.dwCaps = DDSCAPS_BACKBUFFER;<BR>
lpEkran->GetAttachedSurface(&ddsd.ddsCaps, &lpBufor);<BR>
</TD></TR>
</TABLE>

<P>
Funkcja <SPAN CLASS=T>GetAttachedSurface</SPAN> sprawdza pole <SPAN CLASS=T>ddsCaps.dwCaps</SPAN> i w zale¿noœci od tego, co jest tam wpisane, zwraca wskaŸnik do odpowiedniej powierzchni z ³añcucha.
</P>
<P>
Trzeba by siê teraz zaj¹æ przezroczystoœci¹ klatek. Gdybyœmy wykorzystywali tylko windowsowy GUI, by³oby z tym sporo roboty, bo musielibyœmy najpierw sporz¹dziæ maskê. W DirectX tego nie ma, ale za to jest problem z kolorami. Bêdzie nam potrzebna funkcja, która przekonwertuje podane wartoœci RGB na format obs³ugiwany przez DirectX. Co gorsza, kolor 16-bitowy jest zupe³nie ró¿ny od 32-bitowego, wiêc w zale¿noœci od tego, jaki tryb sobie ustawi³eœ przy tworzeniu obiektu g³ównego DD, powinieneœ wybraæ jedn¹ z poni¿szych funkcji:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
WORD Kolor16(BYTE r, BYTE g, BYTE b)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> ((r &gt;&gt; <SPAN CLASS=L>3</SPAN>) &lt;&lt; <SPAN CLASS=L>11</SPAN>) | ((g &gt;&gt; <SPAN CLASS=L>2</SPAN>) &lt;&lt; <SPAN CLASS=L>5</SPAN>) | (b &gt;&gt; <SPAN CLASS=L>3</SPAN>);<BR>
}<BR>
<BR>
DWORD Kolor32(BYTE r, BYTE g, BYTE b)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0xFF000000</SPAN> | (r &lt;&lt; <SPAN CLASS=L>16</SPAN>) | (g &lt;&lt; <SPAN CLASS=L>8</SPAN>) | b;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Wygl¹da mo¿e groŸnie, ale to tylko prosta zabawa w przestawianie bitów. Dziwne liczby w funkcji <SPAN CLASS=T>Kolor16</SPAN> bior¹ siê st¹d, ¿e w kolorze 16-bitowym mamy po <SPAN CLASS=L>5</SPAN> bitów przeznaczonych na sk³adnik czerwony i niebieski, zaœ <SPAN CLASS=L>6</SPAN> bitów na sk³adnik zielony. Z kolei funkcja <SPAN CLASS=T>Kolor32</SPAN> w powy¿szej postaci nie daje nam mo¿liwoœci ustawienia wartoœci sk³adnika alfa (ustawia go zawsze na maksa, czyli <SPAN CLASS=L>255</SPAN>). Po prostu na razie nie jest on nam potrzebny. No dobra, pogadaliœmy o kolorkach, a teraz do rzeczy, czyli do kluczowania:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DDCOLORKEY ddck;<BR>
ddck.dwColorSpaceLowValue = ddck.dwColorSpaceHighValue = Kolor16(<SPAN CLASS=L>255,0,255</SPAN>);<BR>
lpObrazek->SetColorKey(DDCKEY_SRCBLT,&ddck);<BR>
</TD></TR>
</TABLE>

<P>
Aby dany zakres kolorów danej powierzchni nie by³ wyœwietlany, nale¿y po prostu wywo³aæ funkcjê <SPAN CLASS=T>SetColorKey</SPAN>, wpisuj¹c uprzednio odpowiednie kolory do pól: <SPAN CLASS=T>dwColorSpaceLowValue</SPAN> (dolna granica zakresu kolorów) i <SPAN CLASS=T>dwColorSpaceHighValue</SPAN> (górna granica) struktury typu <SPAN CLASS=T>DDCOLORKEY</SPAN>. My chcemy wyeliminowaæ tylko jeden kolor, a mianowicie ró¿owy, dlatego dolna granica mo¿e byæ równa górnej. 
</P>
<P>
Mamy, co chcieliœmy, pozostaje ju¿ tylko napisaæ serce programu - funkcjê <SPAN CLASS=T>Renderuj</SPAN>. To ju¿ doprawdy najprostsza czêœæ ca³ego zadania:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> Renderuj()<BR>
{<BR>
&nbsp;lpBufor->Blt(&Tlo,lpTlo,&Tlo,DDBLT_WAIT,NULL);<BR>
&nbsp;lpBufor->Blt(&Cel,lpObrazek,&Kadr,DDBLT_KEYSRC | DDBLT_WAIT,NULL);<BR>
&nbsp;lpEkran->Flip(NULL,DDFLIP_WAIT);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Pierwsza instrukcja maluje t³o. Zauwa¿, ¿e za ka¿dym razem kopiujemy je w ca³oœci, chocia¿ animacja zamazuje tylko fragment t³a. Animacji to zbytnio nie spowalnia... Skorygowanie tego drobiazgu pozostawiam tobie. Druga instrukcja rysuje aktualn¹ klatkê. Tutaj powinieneœ zwróciæ uwagê na now¹ flagê - <SPAN CLASS=T>DDBLT_KEYSRC</SPAN>. Jak siê zapewne domyœlasz, s³u¿y ona do powiadomienia funkcji <SPAN CLASS=T>Blt</SPAN>, ¿e ta ma skorzystaæ z kluczowania kolorów. Wreszcie, na koñcu mamy now¹ metodê - <SPAN CLASS=T>Flip</SPAN>. U¿ywamy jej do zamienienia ze sob¹ buforów wchodz¹cych w sk³ad ³añcucha - w naszym przypadku przedniego z tylnym. Dziêki tej operacji obrazek, pracowicie rysowany w tylnym buforze ma szanse ujrzeæ œwiat³o dzienne ;-).
</P>
<P>
To wszystko na razie. Jeœli szukasz jakichœ przyk³adów do tej czêœci kursu i szukasz ich w dziale Download, to s³usznie czynisz :-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="ddraw01.html">&lt;&lt;Obiekt g³ówny i powierzchnie</A> &nbsp;
<A HREF="../directx.html">Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="ddraw03.html">Bezpoœredni dostêp... &gt;&gt;</A>
</TD>
</TR>
</TABLE>

</HTML>