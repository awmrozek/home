<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Sortowanie b¹belkowe</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="algsort.html"><< Sortowanie naturalne</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis </A> &nbsp;
<A HREF="droga.html">Najkrótsza droga >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Metoda b¹belkowa</H1>

<P>
Jeœli chodzi o sortowanie tablic, istnieje metoda trochê szybsza, ni¿ przez zamianê parami. Zowie siê ona (doœæ zabawnie) metod¹ b¹belkow¹. Na fizyce p³ynów znam siê mniej wiêcej tak samo, jak na fizyce w ogóle (czyli wcale), jednak podobno z b¹belkami jest tak, ¿e du¿e b¹ble id¹c do góry wypieraj¹ ma³e b¹belki, zaœ z kolei du¿e b¹ble napotykaj¹c na swej drodze jeszcze wiêksze b¹bliska, zatrzymuj¹ siê. St¹d nazwa metody, która opiera siê w³aœnie na tym, ¿e dokonujemy przemieszczenia danej liczby w tablicy, dopóki nie dojdziemy do jeszcze wiêkszej liczby.
</P>
<P>
W praktyce algorytm b¹belkowy wygl¹da bardzo podobnie do algorytmu porz¹dkowania naturalnego. Tym razem jednak nie liczymy zamienianych par, lecz zapamiêtujemy numer ostatnio zamienianej pary, a po ka¿dym przejœciu przez tablicê dodatkowo zapamiêtujemy ten numer w zmiennej, któr¹ tutaj nazwiemy <SPAN CLASS=T>kres</SPAN>. Wyznacza ona granicê, do której przegl¹damy pary. Granica ta w miarê postêpu sortowania bêdzie siê zmniejsza³a, a¿ dojdzie do samego pocz¹tku tablicy. W ten sposób nie musimy za ka¿dym razem przegl¹daæ ca³ej tablicy, lecz jedynie do miejsca które oznaczyliœmy ostatnio zmienn¹ <SPAN CLASS=T>kres</SPAN>. Tutaj w³aœnie kryje siê przewaga "b¹belków" nad standardowym sortowaniem.
</P>
<P>
Rzuæ okiem na rysunek. Mamy tu tak¹ sam¹ tablicê <SPAN CLASS=L>6</SPAN> liczb, jak w przyk³adzie do sortowania naturalnego. Pierwszy przebieg pêtli <SPAN CLASS=K>for</SPAN> równie¿ daje takie same rezultaty, ale tym razem zamiast liczyæ zamiany, zapamiêtujemy w zmiennej <SPAN CLASS=T>ost</SPAN> numer ostatniej zamienianej pary. W pierwszym przebiegu zamieniamy miejscami nastêpuj¹ce pary: <SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>3</SPAN>, <SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>7</SPAN>, <SPAN CLASS=L>7</SPAN> i <SPAN CLASS=L>4</SPAN> (czyli para <SPAN CLASS=L>2</SPAN>-ga, <SPAN CLASS=L>3</SPAN>-cia i <SPAN CLASS=L>4</SPAN>-ta). Przy ka¿dej takiej zamianie do <SPAN CLASS=T>ost</SPAN> wpisujemy numer pary, a wiêc przy wyjœciu z pêtli <SPAN CLASS=K>for</SPAN> <SPAN CLASS=T>ost</SPAN> wynosi <SPAN CLASS=L>4</SPAN> (czwart¹ parê zamienialiœmy jako ostatni¹). Zapamiêtujemy <SPAN CLASS=T>ost</SPAN> jako nowy <SPAN CLASS=T>kres</SPAN> przegl¹dania, po czym wykonujemy II przebieg. Tym razem liczb <SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>11</SPAN> na koñcu tablicy w ogóle nie bierzemy pod uwagê - mamy 100% pewnoœci, ¿e s¹ one ju¿ na w³aœciwym miejscu. Dlatego oddzieli³em je na rysunku niebiesk¹ kresk¹.
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/sortbab.gif" ALT="Schemat sortowania b¹belkowego">
</P>

<P>
W drugim przejœciu nastêpuje ju¿ tylko jedna zamiana: czwórki z siódemk¹, czyli para numer <SPAN CLASS=L>3</SPAN>. Taka te¿ bêdzie ostateczna wartoœæ <SPAN CLASS=T>ost</SPAN> po wyjœciu z pêtli <SPAN CLASS=K>for</SPAN> i taka bêdzie nowa wartoœæ zmiennej <SPAN CLASS=T>kres</SPAN>. W III przebieg wchodzimy ju¿ z uporz¹dkowan¹ tablic¹, ale 100% pewnoœci mamy tylko co do liczb od <SPAN CLASS=L>7</SPAN> wzwy¿ - kolejnoœæ mniejszych trzeba jeszcze raz sprawdziæ. Tym razem zamian brak, wiêc <SPAN CLASS=T>ost == </SPAN><SPAN CLASS=L>0</SPAN>, co jest warunkiem koñca algorytmu. Mo¿emy sobie pogratulowaæ, tablica jest piêknie uporz¹dkowana.
</P>

<P>
¯eby zrealizowaæ to jako program, bêdziemy potrzebowali dwóch nowych zmiennych, czyli wspomnianych ju¿ <SPAN CLASS=T>ost</SPAN> i <SPAN CLASS=T>kres</SPAN>. Musz¹ one byæ tego samego typu, co <SPAN CLASS=T>n</SPAN>. Zmiennej <SPAN CLASS=T>kres</SPAN> nadajemy wartoœæ pocz¹tkow¹ <SPAN CLASS=T>n</SPAN>, co oznacza, ¿e w pierwszym przebiegu przegl¹damy <SPAN CLASS=Wazne>wszystkie</SPAN> pary. W miejscu, gdzie w algorytmie sortowania naturalnego zwiêkszaliœmy <SPAN CLASS=T>licznik</SPAN>, tutaj wykonujemy wstawienie numeru zamienianej pary (czyli <SPAN CLASS=T>i</SPAN>) do zmiennej <SPAN CLASS=T>ost</SPAN>. Oczywiœcie <SPAN CLASS=T>ost</SPAN> nale¿y wyzerowaæ tu¿ przed wejœciem w pêtlê <SPAN CLASS=K>for</SPAN>. Po wyjœciu z <SPAN CLASS=K>for</SPAN> natomiat wartoœæ <SPAN CLASS=T>ost</SPAN> zapamiêtujemy w zmiennej <SPAN CLASS=T>kres</SPAN>. Warunek wykonywania pêtli <SPAN CLASS=K>do-while</SPAN> zamieniamy na <SPAN CLASS=T>ost&gt;</SPAN><SPAN CLASS=L>0</SPAN> (lub po prostu na samo <SPAN CLASS=T>ost</SPAN>, co w tym przypadku na jedno wyjdzie). To wszystko...
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> SortBabelki(WORD* Tab, DWORD n)<BR>
{<BR>
&nbsp;DWORD k=<SPAN CLASS=L>0</SPAN>, kres = n;<BR>
&nbsp;WORD temp;<BR>
&nbsp;<SPAN CLASS=K>do</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;k = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(DWORD i=<SPAN CLASS=L>0</SPAN>; i&lt;kres-<SPAN CLASS=L>1<SPAN CLASS=T>; i++)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(Tab[i] &gt; Tab[i+<SPAN CLASS=L>1</SPAN>])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;temp = Tab[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tab[i] = Tab[i+<SPAN CLASS=L>1</SPAN>];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tab[i+<SPAN CLASS=L>1</SPAN>] = temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;k = i;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;kres = k + <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(k&gt;<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Metoda b¹belkowa jest skuteczniejsza od naturalnej tylko wtedy, gdy tablica jest od pocz¹tku czêœciowo posortowana (czyli w praktyce prawie zawsze ;-)). W skrajnym przypadku, gdy mamy tablicê doskonale nieuporz¹dkowan¹ (czyli uporz¹dkowan¹ w kolejnoœci odwrotnej, ni¿ chcemy ;-)), algorytm b¹belkowy zabierze tyle samo czasu procesorowi, co naturalny. W przypadku du¿ej tablicy o elementach generowanych losowo sortowanie b¹belkowe zajmuje œrednio ok. <SPAN CLASS=L>5/8</SPAN> czasu, w którym trwa³oby sortowanie naturalne, a wiêc ró¿nica jest doœæ spora. Konkluzja jest prosta: jeœli nie chcesz zar¿¹æ swojego procka, stosuj b¹belki ;-)
</P>



<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="algsort.html"><< Sortowanie naturalne</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis </A> &nbsp;
<A HREF="droga.html">Najkrótsza droga >></A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>