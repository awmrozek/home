<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Kolejka</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="droga.html"><< Najkrótsza droga &nbsp;
<A HREF="../algorytm.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="stos.html">Stos >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Kolejka</H1>

<P>
Kolejka jest to specjalny rodzaj struktury danych, który pozwala na przechowywanie dynamicznych (dodawanych lub usuwanych w miarê wykonywania programu) danych bez wzglêdu na stopieñ sfragmentowania pamiêci. Kolejka jest dobr¹ alternatyw¹ dla rekurencji, która nawiasem mówi¹c korzysta ze <SPAN CLASS=Wazne>stosu</SPAN>, a wiêc równie¿ pewnej odmiany kolejki. Nam przyda siê na przyk³ad do algorytmu wyszukiwania najkrótszej drogi w labiryncie.
</P>
<P>
Jeœli wiesz o co chodzi we wspomnianym algorytmie, to idea kolejki wydaje ci siê pewnie oczywista. Bierzemy punkt, badamy wszystkie <SPAN CLASS=L>8</SPAN> otaczaj¹cych go punktów, nastêpnie badamy otoczenie ka¿dego z tych oœmiu punktów itd. Zrobienie tego przy pomocy rekurencji jest dziecinnie proste, jednak my nie lubimy rekurencji (przeci¹¿a procesor i ogólnie jest niebezpieczna). Musimy wiêc gdzieœ zapamiêtywaæ kolejne punkty do sprawdzenia. Mo¿na by skorzystaæ ze zwyk³ej tablicy dynamicznej, jednak jest to bardzo kiepskie rozwi¹zanie. Za ka¿dym razem, gdy chcielibyœmy zapamiêtaæ nowy punkt w tablicy, musielibyœmy zaalokowaæ nowy obszar pamiêci, przenieœæ do niego "stare" dane, dopisaæ na koñcu nowy element, wreszcie zwolniæ "stary" obszar pamiêci. Wszystko to bardzo czasoch³onne, no a przy du¿ej liczbie elementów moglibyœmy napotkaæ k³opoty z fragmentacj¹ pamiêci. Co gorsza, równie¿ usuwanie elementów z tablicy by³oby tak k³opotliwe...
</P>
<P>
Dziêki kolejce wszystko to przestaje byæ problemem. Ka¿dy element kolejki ma "przyklejony" wskaŸnik do nastêpnego elementu, dziêki czemu kolejka mo¿e byæ rozproszona dos³ownie po ca³ej pamiêci naszego komputera. Wystarczy, ¿e zapamiêtamy gdzieœ adres pierwszego elementu i ju¿ "po nitce do k³êbka" potrafimy znaleŸæ wszystkie pozosta³e elementy. Przedstawia to rysunek:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/kolejka.gif" ALT="Schemat kolejki">
</P>

<P>
Na rysunku mamy <SPAN CLASS=Wazne>elementy kolejki</SPAN>, sk³adaj¹ce siê z elementu w³aœciwego (mo¿e on byæ dowolnego typu) oraz <SPAN CLASS=Wazne>wskaŸnika na nastêpny element</SPAN>. Bez wzglêdu na to, ile elementów jest w kolejce, znamy tylko wskaŸnik do pierwszego elementu, do pozosta³ych musimy "dojœæ".
</P>
<P>
Taki rodzaj kolejki nazywa siê w ¿argonie programistów FIFO (First In First Out), poniewa¿ pierwszy element, który zostanie dodany do kolejki tylko jako pierwszy mo¿e zostaæ usuniêty. Dok³adnie tak samo "dzia³a" kolejka w sklepie: o ile nie wpakuje siê jakiœ kombatant albo kobieta w ci¹¿y, to klienci bêd¹ obs³ugiwani w takiej kolejnoœci, w jakiej weszli do sklepu ;-).
</P>
<P>
Jeœli jeszcze nie zd¹¿y³eœ tego wydedukowaæ, przedstawiê jak wygl¹da schemat uzyskiwania dostêpu do np. pi¹tego elementu kolejki. Znamy tylko adres pierwszego elementu, ale ten pierwszy element posiada "przyklejony" adres drugiego elementu. Pobieramy ten adres i w ten sposób mamy dany drugi element i adres (wskaŸnik) trzeciego. Pod adresem trzeciego elementu mamy te¿ wskaŸnik na czwarty element, a pod czwartym - na pi¹ty. Jak widaæ, uzyskanie dostêpu do ostatniego elementu mo¿e byæ czasoch³onne, dlatego nale¿y tak konstruowaæ algorytmy wykorzystuj¹ce kolejkê, aby raz pobrany element nie by³ ju¿ wiêcej potrzebny, wtedy mo¿na go od razu usun¹æ i dziêki temu element, którego w danej chwili potrzebujemy, zawsze bêdzie pierwszy i dostêp do niego bêdzie natychmiastowy :-). Jeœli zaœ to nam nie odpowiada, mo¿emy jeszcze przerobiæ nasz¹ kolejkê na stos, czyli innymi s³owy kolejkê LIFO (Last In First Out), która funkcjonuje w dok³adnie odwrotnym kierunku.
</P>

<H2>
How to do it?
</H2>

<P>
Zastanówmy siê najpierw nad prywatn¹ sekcj¹ naszej klasy <SPAN CLASS=T>cKOLEJKA</SPAN>. Przede wszystkim powinna ona zawieraæ deklaracjê <SPAN CLASS=T>struktury elementu</SPAN> kolejki. Za³o¿ymy sobie, ¿e dane elementu bêd¹ typu <SPAN CLASS=T>NOWY_TYP</SPAN>. Struktura pojedynczego elementu powinna zawieraæ jedn¹ zmienn¹ typu <SPAN CLASS=T>NOWY_TYP</SPAN> oraz jedn¹ typu <SPAN CLASS=T>NOWY TYP*</SPAN> - wskaŸnik na nastêpny element w kolejce.
</P>
<P>
Skoro mamy ju¿ strukturê elementu (nazwaliœmy j¹ sobie <SPAN CLASS=T>tELEM</SPAN>), deklarujemy dwa wskaŸniki do elementów: <SPAN CLASS=T>Pierwszy</SPAN> i <SPAN CLASS=T>Ostatni</SPAN>. WskaŸnik na pierwszy element bêdzie nam potrzebny, ¿eby odnaleŸæ pozosta³e elementy w kolejce; wskaŸnik na ostatni element wykorzystywany jest, kiedy dodajemy nowy element do kolejki. Ostatni¹ rzecz¹ w sekcji prywatnej jest licznik elementów w kolejce (tutaj <SPAN CLASS=T>elcount</SPAN>), który wprawdzie nie jest wykorzystywany bezpoœrednio przez klasê, ale mo¿e byæ zwrócony na zewn¹trz przez funkcjê <SPAN CLASS=T>LiczbaEl</SPAN> (o tym póŸniej).
</P>
<P>
Konstruktor i destruktor maj¹ proste zadania. Pierwszy tylko zeruje zmienn¹ <SPAN CLASS=T>elcount</SPAN> oraz oba wskaŸniki. Destruktor zwalnia zajêt¹ pamiêæ, wywo³uj¹c funkcjê <SPAN CLASS=T>Usun</SPAN> (usuniêcie pierwszego elementu kolejki) tak d³ugo, a¿ kolejka bêdzie pusta.
</P>
<P>
Dzia³ania funkcji <SPAN CLASS=T>Dodaj</SPAN> chyba nie trzeba objaœniaæ - do szczegó³ów dojdziemy póŸniej. Funkcja <SPAN CLASS=T>LiczbaEl</SPAN>, jak ju¿ mówiliœmy, zwraca wartoœæ zmiennej <SPAN CLASS=T>elcount</SPAN>. Wreszcie - funkcja <SPAN CLASS=T>Status</SPAN>. S³u¿y ona do uzyskania danych dowolnego elementu kolejki w dowolnym czasie. Oczywiœcie dojœcie do ostatniego elementu zajmie wiêcej czasu, ni¿ do pierwszego - taka jest idea kolejki. W³aœciwie przy wiêkszoœci zadañ, do których zwykle zaprzêga siê kolejkê, funkcja taka jest ca³kowicie zbêdna, ale te¿ raczej nie powinna zaszkodziæ ;-). Dorzuci³em j¹ g³ównie w celach edukacyjnych, aby pokazaæ, jak przejœæ przez wszystkie elementy kolejki nie usuwaj¹c nic po drodze.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>// Plik kolejka.h</SPAN><BR>
<BR>
<SPAN CLASS=K>class</SPAN> cKOLEJKA<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private:<BR>
&nbsp;&nbsp;struct</SPAN> tELEM<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;NOWY_TYP Dane;<BR>
&nbsp;&nbsp;&nbsp;tELEM* Next;<BR>
&nbsp;&nbsp;} *Pierwszy, *Ostatni;<BR>
&nbsp;&nbsp;DWORD elcount;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;cKOLEJKA();<BR>
&nbsp;&nbsp;~cKOLEJKA();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Dodaj(NOWY_TYP elem);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Usun(NOWY_TYP* databuf);<BR>
&nbsp;&nbsp;DWORD LiczbaEl();<BR>
&nbsp;&nbsp;NOWY_TYP Status(DWORD index);<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
Czas przyjrzeæ siê w³aœciwemu kodowi Ÿród³owemu. Najpierw konstruktor i destruktor:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>// Plik kolejka.cpp</SPAN><BR>
<BR>
cKOLEJKA::cKOLEJKA()<BR>
{<BR>
&nbsp;elcount=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;Pierwszy = Ostatni = NULL;<BR>
}<BR>
<BR>
cKOLEJKA::~cKOLEJKA()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(DWORD i=<SPAN CLASS=L>0</SPAN>; i&lt;elcount; i++)<BR>
&nbsp;Usun(NULL);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jak widaæ, oba s¹ doœæ banalne. Nawet nie ma co omawiaæ, wiêc przechodzimy dalej, czyli do dodawania elementu:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> cKOLEJKA::Dodaj(NOWY_TYP elem)<BR>
{<BR>
&nbsp;tELEM* Cur = <SPAN CLASS=K>new</SPAN> tELEM;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(++elcount==<SPAN CLASS=L>1</SPAN>)<BR>
&nbsp;&nbsp;Pierwszy = Cur;<BR>
&nbsp;<SPAN CLASS=K>else</SPAN><BR>
&nbsp;&nbsp;Ostatni->Next = Cur;<BR>
&nbsp;Cur->Dane = elem;<BR>
&nbsp;Cur->Next = NULL;<BR>
&nbsp;Ostatni = Cur;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Mamy tu pomocniczy wskaŸnik <SPAN CLASS=T>Cur</SPAN>, pod którym alokujemy pamiêæ na nowy element. Jeœli dodajemy pierwszy element do listy, to jego adres l¹duje w zmiennej <SPAN CLASS=T>Pierwszy</SPAN>. W przeciwnym wypadku pos³ugujemy siê wskaŸnikiem <SPAN CLASS=T>Ostatni</SPAN>, który przechowuje nam adres ostatniego (poprzednio dodanego) elementu w kolejce. Adres tego elementu jest nam potrzebny, aby we wskaŸniku <SPAN CLASS=T>Next</SPAN> tego elementu umieœciæ adres elementu, który w³aœnie dodajemy. Natomiast wskaŸnik <SPAN CLASS=T>Next</SPAN> elementu, który dodajemy, ustawiamy oczywiœcie na <SPAN CLASS=T>NULL</SPAN>, poniewa¿ nastêpny po aktualnie dodawanym elemencie nie istnieje. Wreszcie - zapamiêtujemy nowy adres ostatniego elementu. Wszystko to mo¿e siê wydawaæ trochê dziwne, ale jednak jakoœ dzia³a ;-).
</P>
<P>
Teraz bierzemy siê za usuwanie elementu. Usuwaæ mo¿emy tylko pierwszy element kolejki - gdybyœmy usunêli któryœ ze œrodka, to element poprzedzaj¹cy ten usuniêty nadal wskazywa³by na obszar, który nale¿a³ wczeœniej do usuniêtego w³aœnie elementu, a w dodatku utracilibyœmy dostêp do wszystkich do elementów dodanych PO elemencie usuniêtym. Mo¿na by temu zaradziæ, przepisuj¹c wskaŸnik do elementu PO usuniêtym do elementu PRZED usuniêtym. Problem w tym, ¿e nie mo¿emy uzyskaæ elementu PRZED usuniêtym bez przechodzenia przez ca³¹ kolejkê od pocz¹tku, co wymaga³oby prawdopodobnie zbyt wiele czasu. Dlatego zreszt¹ nasza kolejka nosi nazwê jednokierunkowej.
</P>
<P>
Druga wa¿na rzecz wi¹¿¹ca siê z usuwaniem: zazwyczaj jeœli ju¿ usuwamy element, to raczej tylko wtedy, gdy chcemy go wykorzystaæ. Warto po³¹czyæ te dwie czynnoœci w jedn¹. Dlatego nasza funkcja <SPAN CLASS=T>Usun</SPAN> przyjmuje jako argument wskaŸnik do bufora, do którego zapisuje wartoœæ zmiennej <SPAN CLASS=T>Dane</SPAN> usuwanego elementu. Jeœli jako argument podaje <SPAN CLASS=T>NULL</SPAN>, wtedy oczywiœcie wartoœæ zmiennej nie jest nigdzie zapisywana (patrz kod destruktora klasy):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> cKOLEJKA::Usun(NOWY_TYP* databuf)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(elcount&lt;<SPAN CLASS=L>1</SPAN>)<SPAN CLASS=K> return</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(databuf!=NULL) *databuf=Pierwszy->Dane; <SPAN CLASS=C>//zwróæ usuwany element</SPAN><BR>
&nbsp;tELEM *tmp = Pierwszy->Next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS=C>//zapamiêtaj drugi element</SPAN><BR>
&nbsp;<SPAN CLASS=K>delete</SPAN> Pierwszy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS=C>//skasuj pierwszy element</SPAN><BR>
&nbsp;Pierwszy = tmp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//drugi element staje siê pierwszym</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(--elcount==<SPAN CLASS=L>0</SPAN>) Pierwszy = NULL;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Jeœli mamy ju¿ sprawdzone, czy kolejka w ogóle zawiera jakieœ elementy oraz gdy zwróciliœmy wartoœæ usuwanego elementu i zmniejszyliœmy licznik, mo¿emy przyst¹piæ do w³aœciwego usuwania. Polega ono na takiej ma³ej roszadzie: zapamiêtujemy najpierw adres drugiego elementu (po usuniêciu pierwszego drugi stanie siê pierwszym :-)), zwalniamy pamiêæ zajêt¹ przez obecny pierwszy element, po czym adres dawnego drugiego elementu wpisujemy do wskaŸnika <SPAN CLASS=T>Pierwszy</SPAN>. To wszystko.
</P>
<P>
Funkcja <SPAN CLASS=T>LiczbaEl</SPAN> nie nale¿y do skomplikowanych:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
DWORD cKOLEJKA::LiczbaEl() { <SPAN CLASS=K>return</SPAN> elcount; }<BR>
</TD></TR>
</TABLE>

<P>
Wreszcie - funkcja <SPAN CLASS=T>Status</SPAN>. Ma ona podawaæ wartoœæ elementu o indeksie <SPAN CLASS=T>index</SPAN>. Aby to zrobiæ, musimy przejœæ kolejno przez wszystkie elementy, pocz¹wszy od pierwszego. Wykonujemy to zadanie za pomoc¹ tymczasowego wskaŸnika <SPAN CLASS=T>Cur</SPAN>, który wskazuje na ten element kolejki, do którego aktualnie mamy dostêp. Inicjalnie jest to pierwszy element kolejki, nastêpnie pobieramy "rekurencyjnie" wskaŸniki do nastêpnych elementów, a¿ napotkamy element o indeksie równym <SPAN CLASS=T>index</SPAN>. Jeœli dojdziemy do koñca kolejki, co rozpoznawane jest tutaj w ten sposób, ¿e zmienna wskaŸnikowa <SPAN CLASS=T>Cur</SPAN> przyjmuje wartoœæ <SPAN CLASS=T>NULL</SPAN> (sk³adowa <SPAN CLASS=T>Next</SPAN> ostatniego elementu kolejki zawsze powinna byæ równa <SPAN CLASS=T>NULL</SPAN>).
</P>
<P>
Kryje siê tu drobny zgrzyt. Mianowicie funkcja <SPAN CLASS=T>Status</SPAN> jest tu skonstruowana trochê topornie, bo zawsze musi zwracaæ jak¹œ wartoœæ typu <SPAN CLASS=T>NOWY_TYP</SPAN>. Na wypadek, gdyby argument <SPAN CLASS=T>index</SPAN> zawiera³ indeks nieistniej¹cego argumentu, zwracamy jak¹œ tam wartoœæ zerow¹, ale i tak u¿ytkownik naszej kolejki musi sam zadbaæ, ¿eby wartoœæ <SPAN CLASS=T>index</SPAN> by³a prawid³owa (tj. mniejsza od liczby elementów kolejki), bo zwykle nie sposób odró¿niæ, czy zwrócone zero to prawid³owa wartoœæ elementu czy nie.
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
NOWY_TYP cKOLEJKA::Status(DWORD index)<BR>
{<BR>
&nbsp;tELEM* Cur = Pierwszy;<BR>
&nbsp;DWORD licznik=<SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(Cur!=NULL)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(licznik++==index) <SPAN CLASS=K>return</SPAN> Cur->Dane;<BR>
&nbsp;&nbsp;Cur = Cur->Next;<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> NOWY_TYP(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Ca³y ten kod z³o¿ony do kupy daje nam w pe³ni dzia³aj¹c¹ kolejkê. Mo¿na jeszcze dodaæ do tego kilka przydatnych rzeczy, jak na przyk³ad funkcjê <SPAN CLASS=T>UsunWszystko</SPAN>, która bêdzie spe³nia³a podobne zadanie, jak destruktor - szybko usuwa³a wszystkie elementy z kolejki na raz. Z tym jednak poradzisz sobie bez problemu sam, prawda? ;-)
</P>
<P>
W zale¿noœci od tego, co w³aœciwie chcesz wrzucaæ do kolejki, musisz oczywiœcie zmieniæ wszystkie ci¹gi znaków <SPAN CLASS=T>NOWY_TYP</SPAN> na nazwê typu zmiennej, któr¹ chcesz dodawaæ do kolejki. Jeszcze lepiej zrobiæ uniwersalny szablon kolejki, ale to równie¿ zostawiam ci jako pracê domow¹ :-).
</P>
<P>
Na koniec ma³y programik przyk³adowy, demonstruj¹cy dzia³anie kolejki w praktyce. Bêdzie to kolejka elementów typu <SPAN CLASS=K>int</SPAN>. Za³ó¿my, ¿e ca³y powy¿szy kod kolejki mamy ju¿ w pliku <SPAN CLASS=C>kolejka.cpp</SPAN>, natomiast prototyp klasy - w pliku <SPAN CLASS=C>kolejka.h</SPAN>:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>#include &lt;stdio.h&gt;<BR>
#include &lt;iostream.h&gt;<BR>
#include "kolejka.h"</SPAN><BR>
<BR>
cKOLEJKA Kolejka;<BR>
<BR>
<SPAN CLASS=K>void</SPAN> Wypisz()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//wypisujemy stan kolejki na ekran</SPAN><BR>
&nbsp;cout << <SPAN CLASS=L>"Aktualny stan kolejki: "</SPAN> << endl;<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;Kolejka.LiczbaEl(); i++)<BR>
&nbsp;&nbsp;cout << <SPAN CLASS=L>"Element "</SPAN> << i << <SPAN CLASS=L>": "</SPAN> << Kolejka.Status(i) << endl;<BR>
}<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=C>//dodajemy jakies trzy liczby do kolejki...</SPAN><BR>
&nbsp;Kolejka.Dodaj(<SPAN CLASS=L>11</SPAN>);<BR>
&nbsp;Kolejka.Dodaj(<SPAN CLASS=L>25</SPAN>);<BR>
&nbsp;Kolejka.Dodaj(<SPAN CLASS=L>34</SPAN>);<BR>
<BR>
&nbsp;<SPAN CLASS=C>//pokazujemy aktualny stan</SPAN><BR>
&nbsp;Wypisz();<BR>
<BR>
&nbsp;<SPAN CLASS=C>//usuwamy pierwszy element</SPAN><BR>
&nbsp;<SPAN CLASS=K>int</SPAN> element;<BR>
&nbsp;Kolejka.Usun(&element);<BR>
&nbsp;cout << <SPAN CLASS=L>"Usunieto pierwszy element o wartosci "</SPAN> << element << endl;<BR>
<BR>
&nbsp;<SPAN CLASS=C>//ponownie wypisujemy stan - tym razem beda 2 liczby</SPAN><BR>
&nbsp;Wypisz();<BR>
<BR>
&nbsp;<SPAN CLASS=C>//nie musimy czyscic kolejki - zrobi to za nas destruktor</SPAN><BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Kolejka, zw³aszcza w po³¹czeniu ze stosem (szczegó³y w dalszej czêœci tego kursu) to bardzo przydatne narzêdzie w rêkach programisty. Szybko przekonasz siê, ¿e wrêcz nieodzowne. Zapewne wkrótce wszystko co tylko siê da, bêdziesz wrzuca³ do kolejki ;-). I prawdopodobnie bardzo dobrze :-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="droga.html"><< Najkrótsza droga &nbsp;
<A HREF="../algorytm.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="stos.html">Stos >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>