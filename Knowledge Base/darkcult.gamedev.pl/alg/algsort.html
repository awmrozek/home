<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Sortowanie naturalne</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../algorytm.html"><< Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="algbabel.html">Sortowanie b¹belkowe >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Sortowanie tablic</H1>

<P>
Sortowanie to bardzo czêsto pojawiaj¹cy siê problem. Nie jest to nic wielkiego, jeœli mamy posortowaæ jak¹œ malutk¹ tablicê - wystarczy wtedy stworzyæ drug¹, pomocnicz¹ tablicê, po czym kolejno wyszukiwaæ najwiêkszy (lub najmniejszy) element pierwszej tablicy, wpisywaæ go do tablicy pomocniczej, po czym usuwaæ z pierwszej tablicy.
</P>
<P>
Gorzej, jeœli sortujemy tablicê bardzo du¿¹. Wtedy utworzenie tablicy pomocniczej bêdzie siê wi¹za³o z du¿¹ strat¹ pamiêci operacyjnej. Jak posortowaæ tablicê bez zu¿ywania dodatkowego miejsca w pamiêci?
</P>
<P>
Najprostszym sposobem jest sortowanie <SPAN CLASS=Wazne>przez zamianê parami</SPAN>, zwane równie¿ <SPAN CLASS=Wazne>metod¹ naturaln¹</SPAN> (bo nie zawiera cholesterolu ;-)). Zasada jest raczej banalna: bierzemy kolejne dwa elementy tablicy i porównujemy ze sob¹. Jeœli drugi element jest wiêkszy od pierwszego, to zamieniamy je miejscami (to oczywiœcie odnosi siê do przypadku, jeœli chcemy posortowaæ elementy w kolejnoœci rosn¹cej, w przeciwnym wypadku s³owo "wiêkszy" nale¿y zast¹piæ przez "mniejszy"). Ka¿d¹ tak¹ zamianê liczymy w specjalnej zmiennej. Jeœli dojdziemy do koñca tablicy i licznik zamian wynosi 0, to znaczy ¿e tablica jest uporz¹dkowana. Jeœli licznik jest wiêkszy od zera, to rozpoczynamy przegl¹danie par od pocz¹tku, i tak a¿ do skutku.
</P>
<P>
Najlepiej widaæ to na konkretnym przyk³adzie na rysunku. Mamy tu tablicê <SPAN CLASS=L>6</SPAN> liczb, które chcemy uporz¹dkowaæ rosn¹co. Pierwsza i ostatnia s¹ na w³aœciwych miejscach, ale œrodkowa czwórka z ca³¹ z³oœliwoœci¹ usadowi³y siê nie tam, gdzie trzeba. No to my j¹ tu zaraz... ;-) Najpierw porównujemy pierwsze dwie liczby, czyli: <SPAN CLASS=L>1</SPAN> i <SPAN CLASS=L>9</SPAN>. Poniewa¿ <SPAN CLASS=L>1</SPAN> < <SPAN CLASS=L>9</SPAN>, to nie robimy nic i przechodzimy do nastêpnej pary (<SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>3</SPAN>). Tutaj ju¿ nie jest tak ró¿owo: kolejnoœæ jest niew³aœciwa, wiêc zamieniamy te dwie liczby parami. Idziemy dalej: teraz na trzeciej pozycji jest nie <SPAN CLASS=L>3</SPAN>, lecz <SPAN CLASS=L>9</SPAN> (zamieniliœmy), wiêc nasza nastêpna para to <SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>7</SPAN>. Znów nieporz¹dek, znów zamiana. Kolejna para to <SPAN CLASS=L>7</SPAN> i <SPAN CLASS=L>4</SPAN> - zamieniamy. Wreszcie - <SPAN CLASS=L>7</SPAN> i <SPAN CLASS=L>11</SPAN>, kolejnoœæ OK, nic nie robimy. W ten sposób doszliœmy do sytuacji, opisanej na rysunku jako "I przejœcie". By³y w sumie <SPAN CLASS=L>3</SPAN> zamiany, które objê³y ³¹cznie <SPAN CLASS=L>4</SPAN> elementy tablicy (zaznaczone na rysunku ¿ó³tymi kropkami).
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/sortnat.gif" ALT="Schemat zamiany parami">
</P>

<P>
Teraz sprawy wygl¹daj¹ du¿o lepiej, ni¿ na pocz¹tku: wszystkie liczby s¹ na w³aœciwych pozycjach, tylko <SPAN CLASS=L>4</SPAN> siê gdzieœ zab³¹ka³a. Zerujemy wiêc licznik zamian i powtarzamy sprawdzanie parami od pocz¹tku: <SPAN CLASS=L>1</SPAN> i <SPAN CLASS=L>3</SPAN> - OK, <SPAN CLASS=L>3</SPAN> i <SPAN CLASS=L>7</SPAN> - OK, <SPAN CLASS=L>7</SPAN> i <SPAN CLASS=L>4</SPAN> - Ÿle. Zamieniamy, jedziemy dalej. <SPAN CLASS=L>7</SPAN> i <SPAN CLASS=L>9</SPAN> - OK, <SPAN CLASS=L>9</SPAN> i <SPAN CLASS=L>11</SPAN> - OK, drugie przejœcie zakoñczone. By³a tylko <SPAN CLASS=L>1</SPAN> zamiana. Jak widaæ, tablica jest ju¿ uporz¹dkowana, ale algorytm przecie¿ o tym nie wie. Nie ma rady, zerujemy licznik zamian i znowu przegl¹damy pary. Tym razem dojdziemy do samego koñca bez dokonania jakiejkolwiek zamiany, bo wszystko ju¿ jest na w³aœciwym miejscu. Licznik zamian wynosi <SPAN CLASS=L>0</SPAN>, wiêc koñczymy algorytm. Hurrra, koniec! ;-)
</P>

<P>
Wiemy ju¿, jak cholerstwo dzia³a, czas na implementacjê. Za³ó¿my, ¿e nasza tablica bêdzie typu <SPAN CLASS=T>WORD</SPAN>. Robimy funkcjê o nazwie <SPAN CLASS=T>SortArray</SPAN> (czy jak tam j¹ sobie nazwiesz). Bêdzie ona typu <SPAN CLASS=K>void</SPAN> (nie musi nic zwracaæ) i bêdzie mia³a <SPAN CLASS=L>2</SPAN> argumenty: <SPAN CLASS=T>Tab</SPAN> - wskaŸnik do tablicy (typu <SPAN CLASS=T>WORD</SPAN>), któr¹ sortujemy oraz <SPAN CLASS=T>n</SPAN> - liczba elementów tablicy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> SortArray(WORD* Tab, DWORD n)<BR>
{<BR>
<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Bêdziemy z pewnoœci¹ potrzebowali jednej zmiennej jako licznika dokonywanych zamian - powinna ona byæ tego samego typu, co liczba elementów tablicy, czyli w tym przypadku <SPAN CLASS=T>DWORD</SPAN>. Ca³oœæ realizujemy w pêtli <SPAN CLASS=K>do-while</SPAN>, w której warunkiem wykonywania bêdzie ró¿na od <SPAN CLASS=L>0</SPAN> wartoœæ licznika zamian (tutaj zmienna <SPAN CLASS=T>licznik</SPAN>).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
void SortArray(WORD* Tab, DWORD n)<BR>
{<BR>
&nbsp;DWORD licznik;<BR>
<BR>
&nbsp<SPAN CLASS=K>do</SPAN><BR>
<BR> 
&nbsp<SPAN CLASS=K>while</SPAN>(licznik);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Ka¿de kolejne przejrzenie par bêdzie siê odbywa³o w pêtli <SPAN CLASS=K>for</SPAN>. Zauwa¿, ¿e liczba przegl¹danych par za ka¿dym razem wynosi <SPAN CLASS=T>n-</SPAN><SPAN CLASS=L>1</SPAN>. Przegl¹danie polega oczywiœcie na umieszczeniu odpowiedniej instrukcji <SPAN CLASS=K>if</SPAN>. Jeœli warunek w <SPAN CLASS=K>if</SPAN>-ie jest spe³niony, dokonujemy zamiany liczb w aktualnej parze (do tego potrzebujemy pomocniczej zmiennej <SPAN CLASS=T>temp</SPAN>, która musi byæ tego samego typu, co elementy tablicy, czyli tutaj <SPAN CLASS=T>WORD</SPAN>). Ka¿da zamiana powoduje zwiêkszenie wartoœci zmiennej licznik o <SPAN CLASS=L>1</SPAN>. Zauwa¿, ¿e przed ka¿dym przejrzeniem par (czyli tu¿ przed pêtl¹ <SPAN CLASS=K>for</SPAN>) musimy wyzerowaæ tê zmienn¹. Koñcowy kod wygl¹da tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> SortArray(WORD* Tab, DWORD n)<BR>
{<BR>
&nbsp;DWORD licznik;<BR>
&nbsp;WORD temp;<BR>
&nbsp;<SPAN CLASS=K>do</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;licznik = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;&nbsp;<SPAN CLASS=K>for</SPAN>(DWORD i=<SPAN CLASS=K>0</SPAN>; i&lt;n-<SPAN CLASS=L>1</SPAN>; i++)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(Tab[i] &gt; Tab[i+<SPAN CLASS=L>1</SPAN>])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;temp = Tab[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tab[i] = Tab[i+<SPAN CLASS=L>1</SPAN>];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tab[i+<SPAN CLASS=L>1</SPAN>] = temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;licznik++;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(licznik);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Oczywiœcie powy¿sz¹ funkcjê <SPAN CLASS=T>SortArray</SPAN> mo¿na dostosowaæ do innego ni¿ <SPAN CLASS=T>WORD</SPAN> typu tablic, wystarczy pozmieniaæ typy zmiennych <SPAN CLASS=T>Tab</SPAN> oraz <SPAN CLASS=T>temp</SPAN> (ewentualnie <SPAN CLASS=T>n</SPAN> i <SPAN CLASS=T>licznik</SPAN>, jeœli trzeba, chocia¿ typ <SPAN CLASS=T>DWORD</SPAN> powinien wystarczyæ). A ju¿ najlepiej skorzystaæ z szablonów funkcji.	
</P>
<P>
Aby zmieniæ kolejnoœæ sortowania (na malej¹c¹), wystarczy zamiast operatora <SPAN CLASS=T>&gt;</SPAN> daæ <SPAN CLASS=T>&lt;</SPAN>.
</P>
<P>
Jest to najprostsza metoda sortowania, ale niekoniecznie najwydajniejsza. Jeœli chcesz przyspieszyæ dzia³anie funkcji sortuj¹cej, zapoznaj siê z algorytmem <SPAN CLASS=Wazne>sortowania b¹belkowego</SPAN>.
</P>


<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="../algorytm.html"><< Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="algbabel.html">Sortowanie b¹belkowe >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>