<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Stos</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kolejka.html"><< Kolejka &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis </A> &nbsp;
<A HREF="selekcja.html">Selekcja >> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Stos</H1>

<P>
Stos dzia³a podobnie jak kolejka, ale pobieranie elementów odbywa siê w odwrotnym kierunku, tzn. element dodany jako pierwszy bêdzie pobrany ze stosu jako ostatni. Najczêœciej porównuje siê to z kilkoma talerzami, ustawionymi jeden na drugim: nie mo¿esz wzi¹æ ostatniego, dopóki nie zdejmiesz wszystkich ustawionych na wierzchu. Oczywiœcie gdyby siê uprzeæ, mo¿na by to zrobiæ, ale ryzykujesz, ¿e bêdziesz mia³ co zbieraæ przez najbli¿sz¹ godzinê ;-). W programowaniu taki upór te¿ mo¿e siê nie op³aciæ, tote¿ bêdziemy pobieraæ elementy ze stosu tak, jak Pan Bóg przykaza³ ;-).
</P>
<P>
Intuicja podpowiada, ¿e implementacja stosu powinna byæ analogiczna do kolejki i tu siê cholera jedna nie myli; niemniej s¹ pewne drobne ró¿nice:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>class</SPAN> cSTOS<BR>
{<BR>
&nbsp;<SPAN CLASS=K>private</SPAN>:<BR>
&nbsp;&nbsp;<SPAN CLASS=K>struct</SPAN> tELEM<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;NOWY_TYP Dane;<BR>
&nbsp;&nbsp;&nbsp;tELEM* Prev;<BR>
&nbsp;&nbsp;} *Ostatni;<BR>
&nbsp;&nbsp;DWORD elcount;<BR>
&nbsp;<SPAN CLASS=K>public</SPAN>:<BR>
&nbsp;&nbsp;cSTOS();<BR>
&nbsp;&nbsp;~cSTOS();<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Dodaj(NOWY_TYP elem);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>void</SPAN> Usun(NOWY_TYP* databuf);<BR>
&nbsp;&nbsp;DWORD LiczbaEl();<BR>
&nbsp;&nbsp;NOWY_TYP Status(DWORD index);<BR>
};<BR>
</TD></TR>
</TABLE>

<P>
S¹ ró¿nice, ale na razie widaæ tylko jedn¹ (oprócz nazwy wskaŸnika w strukturze - <SPAN CLASS=T>Prev</SPAN> zamiast <SPAN CLASS=T>Next</SPAN>, co jednak oczywiœcie ma znikome znaczenie dla kompilatora). Otó¿ nie musimy tym razem nigdzie pamiêtaæ adresu pierwszego elementu! Jak pamiêtamy, w implementacji kolejki adres pierwszego elementu s³u¿y³ nam do odnajdywania pozosta³ych elementów w pamiêci, natomiast adres ostatniego umo¿liwia³ dodawanie elementów. W stosie obie te role spe³nia adres ostatniego elementu, poniewa¿ zarówno dodawanie jak i usuwanie dotyczy zawsze tylko jego.
</P>
<P>
Bior¹c pod uwagê to wszystko mo¿na wywnioskowaæ (i s³usznie), ¿e konstruktor i destruktor stosu nie ró¿ni¹ siê niczym od ich odpowiedników w kolejce, z tym ¿e oczywiœcie konstruktor nie musi zerowaæ wskaŸnika na pierwszy element, poniewa¿ wskaŸnika tego tutaj nie ma ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
cSTOS::cSTOS() { elcount=<SPAN CLASS=L>0</SPAN>; Ostatni = NULL; }<BR>
<BR>
cSTOS::~cSTOS()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> i=<SPAN CLASS=L>0</SPAN>; i&lt;elcount; i++)<BR>
&nbsp;&nbsp;Usun(NULL);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Funkcja umieszczaj¹ca element na stosie trochê nam siê upraszcza:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>void</SPAN> cSTOS::Dodaj(NOWY_TYP elem)<BR>
{<BR>
&nbsp;tELEM* Cur = <SPAN CLASS=K>new</SPAN> tELEM;<BR>
&nbsp;Cur->Prev = (++elcount==<SPAN CLASS=L>1</SPAN>) ? NULL : Ostatni;<BR>
&nbsp;Cur->Dane = elem;<BR>
&nbsp;Ostatni = Cur;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Pozosta³e funkcje sk³adowe s¹ niemal identyczne z tymi w kolejce:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
void cSTOS::Usun(NOWY_TYP* databuf)<BR>
{<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(elcount&lt;<SPAN CLASS=L>1</SPAN>) <SPAN CLASS=K>return</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(databuf!=NULL) *databuf=Ostatni->Dane; <SPAN CLASS=C>//zwróæ usuwany element</SPAN><BR>
&nbsp;tELEM *tmp = Ostatni->Prev; <SPAN CLASS=C>//zapamiêtaj przedostatni element</SPAN><BR>
&nbsp;<SPAN CLASS=K>delete</SPAN> Ostatni; <SPAN CLASS=C>//skasuj go</SPAN><BR>
&nbsp;Ostatni = tmp; &nbsp;<SPAN CLASS=C>//przedostatni element staje siê ostatnim</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(--elcount==<SPAN CLASS=L>0</SPAN>) Ostatni = NULL; <BR>
}<BR>
<BR>
DWORD cSTOS::LiczbaEl() { <SPAN CLASS=K>return</SPAN> elcount; }<BR>
<BR>
NOWY_TYP cSTOS::Status(DWORD index)<BR>
{<BR>
&nbsp;tELEM* Cur = Ostatni;<BR>
&nbsp;DWORD licznik=elcount;<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(Cur!=NULL)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(--licznik==index) <SPAN CLASS=K>return</SPAN> Cur->Dane;<BR>
&nbsp;&nbsp;Cur = Cur->Prev;<BR>
&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> NOWY_TYP(<SPAN CLASS=L>0</SPAN>);<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
That's all. Programu przyk³adowego nie bêdzie, bo mi siê nie chce pisaæ ;-). Zreszt¹ i tak by³by on identyczny z tym do kolejki, tylko dzia³a³by trochê inaczej - liczby podane w takiej samej kolejnoœci by³yby wypisywane na ekranie "od koñca". Ponadto dzia³anie kolejki nieŸle ilustruje algorytm poszukiwania najkrótszej trasy w labiryncie, który to algorytm równie¿ omawiam na tej stronce.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="kolejka.html"><< Kolejka &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis >></A> &nbsp;
<A HREF="selekcja.html">Selekcja >> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>