<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Najkrótsza droga</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="algbabel.html"><< Sortowanie b¹belkowe &nbsp;
<A HREF="../algorytm.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kolejka.html">Kolejka >></A></TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Najkrótsza droga w labiryncie</H1>

<P>
Oto jedna z najczêstszych przeszkód, które staj¹ m³odym twórcom gier na drodze do niechybnego sukcesu: poszukiwanie drogi w³aœnie ;-). Jak sprawiæ, by potworki i inne bestyje w naszej wspania³ej grze nie sta³y jak s³upy soli tudzie¿ nie b³¹ka³y siê po jakichœ mrocznych zak¹tkach bez celu? Otó¿ jeœli ju¿ okreœlimy, gdzie dany potworek ma iœæ - a najczêœciej ma iœæ ku naszej skromnej postaci, z zamiarami przyjaznymi inaczej ma siê rozumieæ - musimy zastosowaæ odpowiedni algorytm, aby w miarê szybko znaleŸæ najkrótsz¹ drogê z miejsca, gdzie potworek aktualnie siê znajduje do miejsca gdzie znajduje siê potencjalny obiad potworka.
</P>
<P>
Metoda, któr¹ tutaj przedstawiê, jest jedn¹ z najprostszych, a zarazem jedn¹ z najlepszych. Jest doœæ szybka, zawsze znajduje drogê (o ile takowa istnieje, oczywiœcie) i w dodatku zawsze jest to droga najkrótsza. W odmêtach sieci mo¿na wprawdzie znaleŸæ bardziej zaawansowane algorytmy, które na ogó³ s¹ nieco szybsze, ale maj¹ mnóstwo innych wad, np. nie zawsze znajduj¹ najkrótsz¹ trasê albo wykrzaczaj¹ siê przy pewnych specyficznych labiryntach.
</P>
<P>
Nasz algorytm mo¿na by obrazowo nazwaæ "przeszukaj wszystkie punkty". Za³ó¿my, ¿e szukamy najkrótszej drogi z punktu A do punktu B. Bierzemy wiêc punkcik A; badamy wszystkie 8 otaczaj¹cych go punktów, nastêpnie dla ka¿dego z tej ósemki badamy rekurencyjnie kolejne 8 punktów itd., a¿ napotkamy punkt B.
</P>
<P>
Algorytm sk³ada siê z dwóch etapów: oznaczenie kwadratów na mapie (zaraz sobie wyt³umaczymy, na czym to dok³adnie polega) oraz wybranie spoœród nich "w³aœciwych" kwadratów i "z³o¿enie" z nich drogi. Oba etapy wrzucamy do jednej funkcji o nazwie np. <SPAN CLASS=T>SzukajDrogi</SPAN> i nastêpuj¹cym prototypie:
</P>
<P>
<SPAN CLASS=K>bool</SPAN><SPAN CLASS=T> SzukajDrogi(POINT& A, POINT& B, WORD** Mapa, WORD max_x, WORD max_y);</SPAN>
</P>
<P>
Jak nietrudno siê domyœliæ, funkcja szuka drogi miêdzy danymi punktami <SPAN CLASS=T>A</SPAN> i <SPAN CLASS=T>B</SPAN> (bêd¹ one typu <SPAN CLASS=T>POINT</SPAN> - jeœli przypadkiem nie wiesz, jest to prosta struktura, sk³adaj¹ca siê z dwóch pól: <SPAN CLASS=T>x</SPAN> i <SPAN CLASS=T>y</SPAN>, co wystarczy nam do zapamiêtania pojedynczego kwadratu), opieraj¹c siê o podan¹ mapê labiryntu <SPAN CLASS=T>Mapa</SPAN> o wymiarach <SPAN CLASS=T>max_x</SPAN> na <SPAN CLASS=T>max_y</SPAN>.
</P>
<P>
Za³ó¿my, ¿e mapa labiryntu ma ona postaæ tablicy dwuwymiarowej typu <SPAN CLASS=T>WORD</SPAN> (patrz prototyp funkcji <SPAN CLASS=T>SzukajDrogi</SPAN>). Na jej podstawie za ka¿dym razem, gdy zaczynamy szukanie trasy, musimy sobie stworzyæ now¹ tablicê. Tablica ta powinna zawieraæ na razie tylko dwie wartoœci, np. <SPAN CLASS=L>1</SPAN> w miejscach, gdzie jest œciana labiryntu i <SPAN CLASS=L>0</SPAN> w miejscach, przez które mo¿na przejœæ. W miarê poszukiwania w³aœciwej drogi bêdziemy wpisywaæ do tej tablicy jeszcze inne wartoœci, dlatego powinna ona byæ (tak jak <SPAN CLASS=T>Mapa</SPAN>) co najmniej typu <SPAN CLASS=T>WORD</SPAN>, co daje nam teoretycznie mo¿liwoœæ operowania na labiryntach o powierzchni do 65 tys. kwadratów, czyli np. o wymiarach 256x256 kwadratów, co na ogó³ powinno wystarczyæ.
</P>
<P>
Sposób sporz¹dzenia takiej zerojedynkowej, tymczasowej mapki ilustruje ten rysunek:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/labirynt.gif" ALT="Labirynt z zer i jedynek...">
</P>

<P>
Natomiast tutaj mamy przyk³adowy kod:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>//alokacja tablicy 2-wymiarowej</SPAN><BR>
WORD** Tab = <SPAN CLASS=K>new</SPAN> WORD*[max_y];<BR>
<SPAN CLASS=K>for</SPAN>(WORD i=<SPAN CLASS=L>0</SPAN>; i&lt;max_y; i++)<BR>
&nbsp;Tab[i] = <SPAN CLASS=K>new</SPAN> WORD[max_x];<BR>
<BR>
<SPAN CLASS=C>//wype³nianie zerami i jedynkami</SPAN><BR>
<SPAN CLASS=K>for</SPAN>(WORD y=<SPAN CLASS=L>0</SPAN>; y&lt;max_y; y++)<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(WORD x=<SPAN CLASS=L>0</SPAN>; x&lt;max_x; x++)<BR>
&nbsp;&nbsp;Tab[y][x] = (Mapa[y][x]&gt;<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>1</SPAN> : <SPAN CLASS=L>0</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Mamy wiêc pomocnicz¹ tablicê z map¹ obszarów, przez które mo¿na przejœæ i przez które przejœæ nie mo¿na. Pora wyt³umaczyæ, jak dok³adnie bêdzie wygl¹da³o badanie kolejnych kwadratów. Otó¿ bierzemy pierwszy kwadrat otaczaj¹cy kwadrat <SPAN CLASS=T>A</SPAN>; jeœli mapa dla tego kwadratu zawiera wartoœæ <SPAN CLASS=L>0</SPAN>, to wpisujemy do mapy wartoœæ <SPAN CLASS=T>licznik</SPAN>, przy czym <SPAN CLASS=T>licznik</SPAN> pocz¹tkowo równy jest <SPAN CLASS=L>2</SPAN>. Po zbadaniu wszystkich oœmiu kwadratów otaczaj¹cych <SPAN CLASS=T>A</SPAN> zwiêkszamy licznik o <SPAN CLASS=L>1</SPAN> i kontynuujemy badanie dla ka¿dego z tych <SPAN CLASS=L>8</SPAN> kwadratów. Jeœli w ten sposób dojdziemy do momentu, ¿e badanym kwadratem bêdzie <SPAN CLASS=T>B</SPAN>, to znaczy ¿e siê uda³o i znaleŸliœmy drogê. Nasza mapa, czyli tablica <SPAN CLASS=T>Tab</SPAN> powinna wtedy wygl¹daæ mniej wiêcej tak:
</P>

<P ALIGN=CENTER>
<IMG SRC="../gfx/droga.gif" ALT="Etap 1. poszukiwañ: oznaczamy kwadraty na mapie">
</P> 

<P>
W taki sposób tablica bêdzie wygl¹da³a przy zastosowaniu kolejki do oznaczania punktów (o tym powiemy sobie trochê póŸniej). Jeœli zaœ u¿yjemy do tego celu funkcji rekurencyjnej, to algorytm na skrzy¿owaniu w pobli¿u œrodka labiryntu w ogóle nie wejdzie w odnogi prowadz¹ce do lewego dolnego rogu! Tak wiêc rekurencja w tym przypadku da nieco lepszy wynik (tzn. szybciej znajdzie drogê), ale z kolei gdyby punkt B le¿a³ w lewym dolnym rogu labiryntu, to rekurencja przegra³aby z kolejk¹. Dlatego te¿ nie myœl sobie, ¿e któraœ z tych dwóch wersji algorytmu jest generalnie lepsza - wszystko zale¿y od konkretnego labiryntu.
</P>
<P>
Zauwa¿, ¿e nie zbadaliœmy WSZYSTKICH punktów labiryntu. Musielibyœmy trafiæ na jakiœ wyj¹tkowo zakrêcone korytarze, ¿eby by³a taka koniecznoœæ. Na ogó³ omawiany algorytm przeszukuje niewiele wiêcej punktów, ni¿ naprawdê potrzeba i w tym jego si³a.
</P>
<P>
Jeœli mamy ju¿ oznaczone wszystkie potrzebne kwadraty na mapie, pozostaje nam tylko wybraæ te w³aœciwe, tak aby uzyskaæ drogê najkrótsz¹ z mo¿liwych. Zaczynamy od koñca, czyli od punktu <SPAN CLASS=T>B</SPAN>. Najwiêksza wartoœæ <SPAN CLASS=T>licznik</SPAN>a jak¹ umieœciliœmy w naszej mapie-tablicy to <SPAN CLASS=L>16</SPAN>, a wiêc szukamy dowolnego kwadratu s¹siaduj¹cego z <SPAN CLASS=T>B</SPAN>, który ma wartoœæ <SPAN CLASS=L>16</SPAN>. Nastêpnie bierzemy ten kwadrat i szukamy jego dowolnego s¹siada o wartoœci <SPAN CLASS=L>15</SPAN>. Potem - s¹siada o wartoœci <SPAN CLASS=L>14</SPAN> i tak dalej. Postêpuj¹c w ten sposób na pewno dotrzemy wreszcie do punktu <SPAN CLASS=T>B</SPAN>. Jeœli zapamiêtywaliœmy kolejne kwadraty, to otrzymaliœmy jedn¹ z najkrótszych dróg z <SPAN CLASS=T>A</SPAN> do <SPAN CLASS=T>B</SPAN>.
</P>

<H2>
Etap 1 - oznaczanie punktów
</H2>

<P>
Pora zastanowiæ siê, jak to zrobiæ w praktyce. Generalnie mamy do wyboru dwie mo¿liwoœci: z rekurencj¹ lub bez. Jak mówi reklama - wolê beeez. Wprawdzie wersja z rekurencj¹, jest znacznie prostsza w implementacji, ale przecie¿ nie bêdziemy iœæ na ³atwiznê, prawda? ;-)
</P>
<P>
Zaczniemy od napisania prostej funkcji, obliczaj¹cej wspó³rzêdne "s¹siada" podanego punktu. Jak ju¿ wspomnia³em, ka¿dy kwadrat ma oœmiu s¹siadów. Przyjmujemy, ¿e pierwszy "s¹siad" to ten w lewym górnym rogu, drugi - na górze, trzeci - w prawym górnym rogu itd., zgodnie z ruchem wskazówek zegara:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
POINT Sasiad(POINT& Punkt, WORD NrSasiada)<BR>
{<BR>
&nbsp;POINT tmp;<BR>
&nbsp;<SPAN CLASS=K>switch</SPAN>(NrSasiada)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>0</SPAN>: tmp.x = Punkt.x-<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y-<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>1</SPAN>: tmp.x = Punkt.x; &nbsp;&nbsp;tmp.y = Punkt.y-<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>2</SPAN>: tmp.x = Punkt.x+<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y-<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>3</SPAN>: tmp.x = Punkt.x+<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y; &nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>4</SPAN>: tmp.x = Punkt.x+<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y+<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>5</SPAN>: tmp.x = Punkt.x; &nbsp;&nbsp;tmp.y = Punkt.y+<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>6</SPAN>: tmp.x = Punkt.x-<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y+<SPAN CLASS=L>1</SPAN>; <SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>case</SPAN> <SPAN CLASS=L>7</SPAN>: tmp.x = Punkt.x-<SPAN CLASS=L>1</SPAN>; tmp.y = Punkt.y;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> tmp;<BR>
}<BR>
</TD></TR>
</TABLE>

<P>
Teraz w³aœciwa czêœæ algorytmu. Bêdzie nam potrzebna <SPAN CLASS=Wazne>kolejka</SPAN>. Za³ó¿my, ¿e ju¿ czyta³eœ o niej w dziale Algorytmy, wiesz jak j¹ zrobiæ i w dodatku masz j¹ gotow¹ do u¿ycia w osobnym pliku (ma to byæ kolejka elementów typu <SPAN CLASS=T>POINT</SPAN>, rzecz jasna) . Wystarczy wtedy do³¹czyæ jakiœ nag³ówek, np. <SPAN CLASS=C>kolejka.h</SPAN> i jedziemy.
</P>
<P>
Co oprócz kolejki punktów bêdzie nam potrzebne? Po pierwsze - zmienna logiczna <SPAN CLASS=T>Gol</SPAN>, która bêdzie nam mówi³a, czy droga zosta³a znaleziona i czy wobec tego jest sens przechodziæ do drugiego etapu. Nastêpnie potrzebowaæ bêdziemy trzech zmiennych typu <SPAN CLASS=T>POINT</SPAN>. Pierwsza zmienna, nazwijmy j¹ <SPAN CLASS=T>CurP</SPAN>, bêdzie oznacza³a aktualnie badany kwadrat. Przeznaczenia pozosta³ych dwóch dowiesz siê w swoim czasie. Wreszcie potrzebne nam bêd¹ dwa liczniki: pierwszy typu <SPAN CLASS=T>WORD</SPAN>, nazwijmy go <SPAN CLASS=T>NbrCount</SPAN>, bêdzie oznacza³ liczbê "s¹siadów" danego kwadratu, czyli punktów, w które mo¿na siê przemieœciæ (nie-œciana ;-)). Drugi licznik, te¿ <SPAN CLASS=T>WORD</SPAN>, bêdziemy zwiêkszaæ przechodz¹c do ka¿dego kolejnego punktu.
</P>
<P>
Z lenistwa zak³adam, ¿e mamy ju¿ przygotowan¹ mapê zer i jedynek. Nasz <SPAN CLASS=T>licznik</SPAN> ustawiamy na <SPAN CLASS=L>3</SPAN> - tak¹ liczbê jako pierwsz¹ bêdziemy wpisywaæ do mapy (punkt <SPAN CLASS=T>A</SPAN> oznaczamy na mapie od razu dwójk¹). 
</P>
<P>
Jeszcze jedna rzecz godna szczególnej uwagi. Do tablicy <SPAN CLASS=T>Tab</SPAN> mamy wpisywaæ kolejne wartoœci licznika, ale w którym momencie ten licznik zwiêkszaæ? Otó¿ numerujemy sobie  równoodleg³e kwadraty po kolei, tzn. wszystkie kwadraty oznaczone np. liczb¹ <SPAN CLASS=L>15</SPAN> oznaczane s¹ jeden po drugim, po czym nastêpuje oznaczanie kwadratów nastêpn¹ liczb¹, <SPAN CLASS=L>16</SPAN> i tak dalej. Tak wiêc poszczególne wartoœci licznika wystêpuj¹ w algorytmie pod rz¹d, z tym ¿e zmienna jest liczba kwadratów, które oznacza siê dan¹ wartoœci¹.
</P>
<P>
Innymi s³owy (bo nieco sprawê zawik³a³em ;-)), bior¹c przebieg algorytmu taki, jak na rysunku, mamy 3 kwadraty z wartoœci¹ <SPAN CLASS=L>3</SPAN>, 5 kwadratów z wartoœci¹ <SPAN CLASS=L>4</SPAN>, 1 kwadrat z wartoœci¹ <SPAN CLASS=L>5</SPAN>, 2 kwadraty z wartoœci¹ <SPAN CLASS=L>6</SPAN> itd. W³aœnie w takiej kolejnoœci punkty bêd¹ pobierane z kolejki i w takiej kolejnoœci bêd¹ oznaczane. A wiêc potencjalnie mamy w kolejce od <SPAN CLASS=L>0</SPAN> do <SPAN CLASS=L>8</SPAN> kwadratów z dan¹ wartoœci¹ licznika. Problem w tym, powtarzam, ¿eby wiedzieæ, w którym momencie zwiêkszyæ ten licznik...
</P>
<P>
Mo¿emy siê tu pos³u¿yæ tzw. <SPAN CLASS=Wazne>metod¹ wartownika</SPAN>. Polega ona na tym, ¿e wrzucamy do kolejki punkt o jakichœ nietypowych wspó³rzêdnych, np. <SPAN CLASS=L>(-2,-2)</SPAN>. Teraz uk³adamy algorytm w ten sposób, ¿e gdy "wyci¹gnie" on z kolejki punkt o wspó³rzêdnych <SPAN CLASS=L>(-2,-2)</SPAN> (czyli naszego "wartownika"), to bez wahania zwiêksza <SPAN CLASS=T>licznik</SPAN>, po czym przechodzi do badania nastêpnego punktu w kolejce. Dodatkowo, jeœli "wartownik" jest OSTATNIM punktem w kolejce, to oznacza, ¿e zabrnêliœmy w œlep¹ uliczkê, czyli droga z <SPAN CLASS=T>A</SPAN> do <SPAN CLASS=T>B</SPAN> niestety nie istnieje.
</P>
<P>
Starczy glêdzenia, piszemy:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>bool</SPAN> Gol = <SPAN CLASS=K>false</SPAN>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//czy droga istnieje?</SPAN><BR>
cKOLEJKA Kolejka;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//kolejka punktów</SPAN><BR>
POINT CurP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//aktualnie badany punkt</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//pomocnicza zmienna</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Warta(<SPAN CLASS=L>-2</SPAN>,<SPAN CLASS=L>-2</SPAN>);&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>// "wartownik"</SPAN><BR>
WORD NbrCount,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//liczba "prawid³owych" s¹siadów badanego punktu</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;licznik = <SPAN CLASS=L>3</SPAN>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//licznik badanych punktów</SPAN><BR>
WORD** Tab;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//tablica pomocnicza</SPAN><BR>
<BR><SPAN CLASS=C>
//<-- tu wklejamy kod tworzenia i wype³niania Tab<BR></SPAN>
<BR>
Kolejka.Dodaj(A);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=C>//Pierwszy punkt poszukiwañ to A</SPAN><BR>
Kolejka.Dodaj(Warta); <SPAN CLASS=C>//Pierwszy wartownik musi byæ postawiony na zewn¹trz pêtli</SPAN><BR>
Mapa[A.Y][A.X] = <SPAN CLASS=L>2</SPAN>;&nbsp;&nbsp; <SPAN CLASS=C>//Punkt A jest jedynym na mapie oznaczonym liczb¹ 2</SPAN><BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;Kolejka.Usun(&CurP);&nbsp; <SPAN CLASS=C>//WeŸ kolejny punkt i zarazem usuñ go z kolejki</SPAN><BR>
&nbsp;<SPAN CLASS=K>if</SPAN>(CurP.x == Warta.x) <SPAN CLASS=C>//Jeœli bie¿¹cy punkt to "wartownik"...</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;<SPAN CLASS=C>//...to zwiêksz licznik i bierz nastêpny punkt</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=C>//...chyba ¿e wartownik jest ostatnim punktem w kolejce</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(Kolejka.LiczbaEl()==<SPAN CLASS=L>0</SPAN>) <SPAN CLASS=K>break</SPAN>; <SPAN CLASS=C>// (tzn. nie ma drogi)</SPAN><BR>
&nbsp;&nbsp;++licznik;<BR>
&nbsp;&nbsp;Kolejka.Dodaj(Warta); <SPAN CLASS=C>//Postaw "wartownika"</SPAN><BR>
&nbsp;&nbsp;<SPAN CLASS=K>continue</SPAN>;<BR>
&nbsp;}<BR>
&nbsp;NbrCount = <SPAN CLASS=L>0</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(WORD i=<SPAN CLASS=L>0</SPAN>; i<<SPAN CLASS=L>8</SPAN>; i++) <SPAN CLASS=C>//zbadaj otoczenie bie¿¹cego punktu</SPAN><BR>
&nbsp;{<BR>
&nbsp;&nbsp;tmpP = Sasiad(CurP, i);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(tmp.xP>=<SPAN CLASS=L>0</SPAN> && tmpP.y>=<SPAN CLASS=L>0</SPAN> && tmpP.x < max_x && tmpP.y < max_y)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(tmpP.x == B.x && tmpP.y == B.y) <SPAN CLASS=C>//Osi¹gnêliœmy nasz cel...</SPAN><BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Gol = <SPAN CLASS=K>true</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>break</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>else if</SPAN>(Tab[tmpP.y][tmpP.x] == <SPAN CLASS=L>0</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;{ <SPAN CLASS=C>//zakolejkuj punkt do przysz³ego zbadania</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Kolejka.Dodaj(tmpP);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tab[tmpP.y][tmpP.x] = licznik;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;++NbrCount;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>(!Gol);<BR>
</TD></TR>
</TABLE>

<H2>
Etap 2 - wybór drogi
</H2>

<P>
W ten sposób mamy oznaczone odpowiednie kwadraty na mapie, pozostaje tylko z³o¿yæ je w konkretn¹ drogê. Robimy to, jak ju¿ wczeœniej powiedzia³em, od punktu <SPAN CLASS=T>B</SPAN>. Spoœród oœmiu s¹siadów kwadratu aktualnie badanego musimy wybraæ taki, który jest na mapie oznaczony liczb¹ o <SPAN CLASS=L>1</SPAN> mniejsz¹, ni¿ aktualnie badany kwadrat. Zwykle takich s¹siadów jest wiêcej ni¿ jeden, dlatego musimy spoœród nich wybraæ. Jest to wybór dowolny - i tak na pewno otrzymamy w ten sposób drogê najkrótsz¹, jednak sposób wyboru kolejnych kwadratów wp³ynie na ogólny kszta³t trasy. I tak na przyk³ad wybieraj¹c kwadraty po³o¿one mo¿liwie najbli¿ej lewego górnego rogu zgodnie z kierunkiem ruchu zegara (w takim kierunku wybieraliœmy kolejnych "s¹siadów" do badania w pierwszej czêœci algorytmu) otrzymujemy trasê doœæ dziwn¹, poruszaj¹cy siê po takiej trasie potworek bêdzie sprawia³ wra¿enie, jakby wiatr znosi³ go na lew¹. Z kolei losowy wybór punktów sprawi, ¿e potwór bêdzie siê "zatacza³", krocz¹c przez kolejne punkty drogi. 
</P>
<P>
Co natomiast bêdzie, jeœli uczynimy kierunek wyboru odwrotnym do ruchu wskazówek zegara? Otó¿ wtedy potwór bêdzie zasuwa³ prosto przed siebie! Ten ostatni styl poruszania siê chyba najbardziej nam pasuje, wiêc zastosujemy go w przyk³adowym kodzie. 
</P>
<P>
Wprowadzamy sobie ma³¹, pomocnicz¹ tablicê <SPAN CLASS=T>Mniejszy</SPAN>, do której bêdziemy wpisywaæ <SPAN CLASS=L>1</SPAN>, jeœli dany z oœmiu "s¹siadów" ma wartoœæ licznika o <SPAN CLASS=L>1</SPAN> mniejsz¹ ni¿ aktualny kwadrat. Natomiast zmienna <SPAN CLASS=T>Wyb</SPAN> bêdzie zawiera³a liczbê od <SPAN CLASS=L>0</SPAN> do <SPAN CLASS=L>7</SPAN> - numer wybranego "s¹siada", tego, którego ostatecznie dodamy do drogi.
</P>
<P>
Nasza wynikowa droga bêdzie zapisywana w ten sposób, ¿e kolejne punkty (zmienne typu <SPAN CLASS=T>POINT</SPAN>) bêdziemy odk³adaæ na <SPAN CLASS=Wazne>stos</SPAN>. O stosie nale¿a³o by oczywiœcie wczeœniej sobie poczytaæ w osobnym artykule dzia³u Algorytmy ;-). A jeœli ju¿ tam by³eœ - do dzie³a:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
cSTOS Droga;<BR>
WORD Mniejszy[<SPAN CLASS=L>8</SPAN>], Wyb;<BR>
POINT CurP = {B.x, B.y}, <SPAN CLASS=C>//zaczynamy od B</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp;<BR>
<SPAN CLASS=K>do</SPAN><BR>
{<BR>
&nbsp;ZeroMemory(Mniejszy, <SPAN CLASS=L>8</SPAN>*<SPAN CLASS=L>2</SPAN>);<SPAN CLASS=C> //wyzeruj tablicê Mniejszy</SPAN><BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(WORD i=<SPAN CLASS=L>0</SPAN>; i&lt;<SPAN CLASS=L>8</SPAN>; i++)<BR>
&nbsp;{<BR>
&nbsp;&nbsp;tmp = Sasiad(CurP, i);<BR>
&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(tmp.x&gt;=<SPAN CLASS=L>0</SPAN> && tmp.y&gt;=<SPAN CLASS=L>0</SPAN> && tmp.x &lt; max_x && tmp.y &lt; max_y)<BR>
&nbsp;&nbsp;&nbsp;<SPAN CLASS=K>if</SPAN>(Tab[tmp.y][tmp.x] == licznik-<SPAN CLASS=L>1</SPAN>) <SPAN CLASS=C>//zaznacz, ¿e ten punkt bierzemy pod uwagê</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Mniejszy[i] = <SPAN CLASS=L>1</SPAN>;<BR>
&nbsp;}<BR>
&nbsp;Wyb=<SPAN CLASS=L>8</SPAN>;<BR>
&nbsp;<SPAN CLASS=K>while</SPAN>(Mniejszy[--Wyb]!=<SPAN CLASS=L>1</SPAN>);<BR>
&nbsp;<SPAN CLASS=C>//dodaj go do drogi</SPAN><BR>
&nbsp;CurP = Sasiad(CurP, Wyb+<SPAN CLASS=C>1</SPAN>);<BR>
&nbsp;Droga.Dodaj(CurP);<BR>
}<BR>
<SPAN CLASS=K>while</SPAN>(--licznik&gt;<SPAN CLASS=L>3</SPAN>);<BR>
<BR>
<SPAN CLASS=K>return true</SPAN>; <SPAN CLASS=C>//szczêœliwy powrót z funkcji SzukajDrogi :-)<BR></SPAN>
</TD></TR>
</TABLE>

<P>
O zwolnieniu pamiêci zajmowanej przez tablicê <SPAN CLASS=T>Tab</SPAN> pamiêtasz, prawda...?
</P>

<H2>
Optymalizacje
</H2>

<P>
Przedstawiona realizacja algorytmu szukania drogi nieŸle sprawdza siê np. w grach turowych, ale spróbujcie sobie wykorzystaæ j¹ w czasie rzeczywistym, kiedy szukanie drogi odbywa siê wiele razy na sekundê... Mogi³a. Dlatego te¿ warto wiedzieæ, jak mo¿na ów algorytm udoskonaliæ w razie potrzeby.
</P>
<P>
Zanim dobierzemy siê do kodu funkcji <SPAN CLASS=T>SzukajDrogi</SPAN>, zastanówmy siê, czy w ogóle musimy ca³y czas funkcjê tê wywo³ywaæ. Za³ó¿my, ¿e mamy potwora, który nas wywêszy³ z danej odleg³oœci. Na pocz¹tku, gdy wredniak nas jeszcze nie widzia³, musieliœmy u¿yæ funkcji szukania drogi, aby pokazaæ mu, jak powinien siê poruszaæ. Jeœli poruszymy siê o 1 kwadrat w dowolnym kierunku, a nastêpnie bêdziemy czekaæ, a¿ potwór podejdzie do nas wed³ug wczeœniej wytyczonej trasy (zak³adaj¹c, ¿e trasa ta nie bêdzie w miêdzyczasie modyfikowana), to zauwa¿ymy, ¿e drañ zatrzyma siê w odleg³oœci 1 kwadratu od nas, stanie jak wryty i bêdzie siê gapi³ jak cielê na malowane wrota. Poruszyliœmy siê tylko o 1 kwadrat i wystarczy³o, ¿eby go zmyliæ! W³aœnie dlatego teoretycznie powinniœmy wykonywaæ poszukiwanie drogi po ka¿dej jednostce czasowej, aby potwór CA£Y CZAS wiedzia³, jak do nas dojœæ.
</P>
<P>
Ale czy nie proœciej by³oby mu wskazaæ drogê tylko raz, a póŸniej tylko dodawaæ do niej na koñcu pojedyncze punkty, w miarê jak bêdziemy siê poruszaæ nasz¹ postaci¹? 
</P>
<P>
W ten sposób zaoszczêdzimy najwiêcej. Czasami jednak mo¿e siê i tak zdarzyæ, ¿e musimy wyszukiwaæ drogê korzystaj¹c mimo wszystko z naszej funkcji. Mo¿e siê tak staæ np. w przypadku, gdy czêœæ poprzednio wytyczonej trasy zostanie zawalona przez lawinê albo zagrodzona przez innego stwora. Wówczas mo¿emy uciec siê do innych algorytmów, mniej pewnych ale za to szybszych. Nie zawsze musz¹ one odnaleŸæ najkrótsz¹ drogê, ale zrobi¹ to w krótszym czasie. Podobne dzia³anie bêdzie mia³o ograniczanie obszaru poszukiwañ. Jeœli nie bêdziemy przeszukiwaæ CA£EGO labiryntu, a tylko ten jego obszar, w którym NAJPRAWDOPODOBNIEJ znajduje siê droga miêdzy dwoma kluczowymi punktami, wówczas mo¿emy zabrn¹æ w œlepy zau³ek, ale w WIÊKSZOŒCI przypadków znajdziemy drogê i to szybciej.
</P>
<P>
Ostatnia z optymalizacji, które mi akurat przychodz¹ do g³owy (co nie znaczy oczywiœcie, ¿e inne ju¿ nie istniej¹ ;-)), dotyczy ju¿ drobnych szczegó³ów algorytmu, jak np. korzystanie z referencji podczas przekazywania argumentów do wykorzystywanych funkcji. A najlepiej w ogóle zrezygnowaæ z dodatkowych funkcji, takich jak np. przedstawiona wy¿ej funkcja <SPAN CLASS=T>Sasiad</SPAN>. Pozwala ona skróciæ kod ¿ród³owy, ale jej ci¹g³e wywo³ywanie mo¿e doœæ znacznie spowolniæ ca³y proces szukania drogi, wiêc lepiej umieœciæ ci¹g instrukcji, z jakiego siê ta funkcja sk³ada, bezpoœrednio w algorytmie szukania trasy.
</P>
<H2>
PathFinder
</H2>
<P>
Napisa³em fajny programik, który pokazuje algorytm szukania drogi w praktyce. Wczytuje on sobie przyk³adowo labirynt z pliku, ale mo¿esz ten labirynt w ka¿dej chwili zmieniæ "rêcznie", przestawiæ punkty A i B oraz kazaæ koputerowi znaleŸæ drogê miêdzy nimi. Œcie¿ka mo¿e byæ wybierana trzema stylami, o których mimochodem wspomnia³em gdzieœ powy¿ej. Dziêki PathFinderowi ³atwiej bêdziesz siê orientowa³ w problematyce wszelkich zawik³anych korytarzy labiryntów.
</P>
<P>
Programik w wersji Ÿród³owej oraz skompilowanej znajdziesz oczywiœcie w dziale Download.
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="algbabel.html"><< Sortowanie b¹belkowe &nbsp;
<A HREF="../algorytm.html"> Spis</A> &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="kolejka.html">Kolejka >></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>
