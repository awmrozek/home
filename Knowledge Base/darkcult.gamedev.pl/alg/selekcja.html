<script type="text/javascript" language="JavaScript"><!--  document.write (unescape ('%3cscript type="text/javascript" '+' src="http://kropka.onet.pl/_s/kropka/r.js?id=B8XlFCO1yU.kxYbVHvZDL8Q8HSeKoi8AdrFAxSxBYoj.s7&t=1&z=0&k=0&RR='+(new Date()).getTime()+'"%3e%3c/script%3e'));  //--></script> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=windows-1250">
<META NAME="Language" CONTENT="pl">
<META NAME="Author" CONTENT="Twój nocny koszmar">
<META NAME="Generator" CONTENT="Notatnik :-)">

<TITLE>Dark Cult of C++ - Selekcja</TITLE>
<LINK REL=stylesheet HREF="kurs.css" TYPE="text/css">
</HEAD>

<BODY STYLE="font-family: Verdana; font-size: 9pt; color: #CCCCCC; background-color: #464646;">

<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="stos.html"><< Stos &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis >></A> &nbsp;
</TD>
</TR>
</TABLE>
<HR COLOR=GRAY WIDTH=90% SIZE=1>

<H1>Selekcja</H1>

<P>
To, co sobie tu zaraz omówimy, bêdzie raczej nie tyle algorytmem, co formu³¹ matematyczn¹, w dodatku raczej bardzo prost¹, ale zawsze warto wiedzieæ, jak do tej formu³y dojœæ. Choæby dlatego, ¿eby potrafiæ j¹ póŸniej zmodyfikowaæ do w³asnych celów. A przydaæ siê ona mo¿e miêdzy innymi w algorytmie wyszukiwania drogi.
</P>
<P>
Problem, którym siê zajmiemy, to wybór (selekcja) elementów ze zbioru. Za³ó¿my, ¿e mamy jak¹œ listê. Wybranie z niej po kolei wszystkich elementów to banalne zadanie, tak samo wybór w kolejnoœci odwrotnej. £atwo jest te¿ wybraæ do drugi lub co pi¹ty element. Ale jak zrobiæ, ¿eby elementy wybierane by³y np. od œrodka listy ku jej krañcom? No w³aœnie...
</P>

<H2>
1. Selekcja naprzemienna
</H2>

<P>
¯eby dok³adnie wiedzieæ, o jaki wybór chodzi, przyjrzyj siê takiej liœcie:
</P>

<OL START=0>
<LI>nietoperz
<LI>pies
<LI>kaczka
<LI>byk
<LI>skurczybyk
<LI>szczur
<LI>kot
<LI>królik
</OL>

<P>
Jeœli uznamy, ¿e element numer <SPAN CLASS=L>4.</SPAN> (skurczybyczek ;-)) jest œrodkiem tej listy, to nasza kolejnoœæ bêdzie nastêpuj¹ca: skurczybyk, byk, szczur, kaczka, kot, pies, królik, nietoperz. Mo¿emy sobie tê kolejnoœæ przedstawiæ w tabelce, gdzie <SPAN CLASS=T>x</SPAN> bêdzie kolejn¹ liczb¹ ca³kowit¹, a <SPAN CLASS=T>f</SPAN> - numerem elementu na liœcie:
</P>

<CENTER>
<TABLE BORDER>
<TR>
<TH>x</TH><TD CLASS=TDW>0</TD><TD CLASS=TDW>1</TD><TD CLASS=TDW>2</TD><TD CLASS=TDW>3</TD><TD CLASS=TDW>4</TD><TD CLASS=TDW>5</TD><TD CLASS=TDW>6</TD><TD CLASS=TDW>7</TD>
</TR>
<TR>
<TH>f(x)</TH><TD CLASS=TDW>4</TD><TD CLASS=TDW>3</TD><TD CLASS=TDW>5</TD><TD CLASS=TDW>2</TD><TD CLASS=TDW>6</TD><TD CLASS=TDW>1</TD><TD CLASS=TDW>7</TD><TD CLASS=TDW>0</TD>
</TR>
</TABLE>
</CENTER>

<P>
Wszystko, co musimy zrobiæ, to znaleŸæ zale¿noœæ miêdzy <SPAN CLASS=T>f</SPAN> a <SPAN CLASS=T>x</SPAN>, czyli wyznaczyæ funkcjê <SPAN CLASS=Wazne><I>f(x)</I></SPAN>. Prawda, ¿e niewiele? :-). Na pierwszy rzut oka mog³oby siê wydawaæ, ¿e nie ma ¿adnej zale¿noœci. Ale gdyby trochê rozpisaæ wartoœci <SPAN CLASS=T>f</SPAN>, zale¿noœæ zaraz by siê znalaz³a. Przedstawimy teraz zmienn¹ <SPAN CLASS=T>f</SPAN> jako odleg³oœæ danej liczby od "œrodka" listy:
</P>

<CENTER>
<TABLE BORDER>
<TR>
<TH>x</TH><TD CLASS=TDW>0</TD><TD CLASS=TDW>1</TD><TD CLASS=TDW>2</TD><TD CLASS=TDW>3</TD><TD CLASS=TDW>4</TD><TD CLASS=TDW>5</TD><TD CLASS=TDW>6</TD><TD CLASS=TDW>7</TD>
</TR>
<TR>
<TH>f(x)</TH><TD CLASS=TDW>4+0</TD><TD CLASS=TDW>4-1</TD><TD CLASS=TDW>4+1</TD><TD CLASS=TDW>4-2</TD><TD CLASS=TDW>4+2</TD><TD CLASS=TDW>4-3</TD><TD CLASS=TDW>4+3</TD><TD CLASS=TDW>4-4</TD>
</TR>
</TABLE>
</CENTER>

<P>
I co, widaæ ju¿ zale¿noœæ? Okazuje siê, ¿e odleg³oœæ kolejnych liczb od czwórki to kolejne liczby ca³kowite, tylko ¿e wzrastaj¹ tylko dla co drugiego argumentu <SPAN CLASS=T>x</SPAN>, a poza tym "ca³y czas" zmieniaj¹ znak. W sumie jest to oczywisty fakt, z którego powinniœmy zdaæ sobie sprawê na samym pocz¹tku rozwa¿añ, ale wiadomo, ¿e konkretne liczby bardziej dzia³aj¹ na wyobraŸniê :-). Pozostaje nam wiêc wyznaczyæ wzór funkcji <I>f(x)</I>:
</P>
<P ALIGN=CENTER>
<I>
f(x) = 4 + znak(x) * n(x)
</I>
</P>
<P>
Zmienna znak powinna wynosiæ <SPAN CLASS=L>-1</SPAN> dla argumentów <SPAN CLASS=T>x</SPAN> równych <SPAN CLASS=L>1, 3, 5, 7</SPAN> oraz <SPAN CLASS=L>1</SPAN> dla argumentów <SPAN CLASS=L>0, 2, 4, 6</SPAN>. Nie trzeba byæ wybitnie inteligentnym, by powi¹zaæ te liczby: pierwszy zestaw to liczby nieparzyste, drugi - parzyste. Poniewa¿ przeczyta³eœ bardzo uwa¿nie mój kurs C++, wiesz, ¿e parzystoœæ liczby sprawdzamy poprzez resztê z dzielenia przez <SPAN CLASS=T>2</SPAN> (modulo). A wiêc mo¿emy sobie przedstawiæ znak jako kolejn¹ funkcjê zmiennej <SPAN CLASS=T>x</SPAN>:
</P>

<P ALIGN=CENTER>
<I>

<TABLE><TR><TD ROWSPAN=2 CLASS=NOT>znak(x) = </TD><TD ROWSPAN=2 CLASS=NOT><IMG SRC="../gfx/klamra.gif"></TD><TD CLASS=NOT>-1 dla x mod 2 == 1</TD></TR><TR><TD CLASS=NOT>1 dla x mod 2 == 0</TD></TR></TABLE>


</I>
</P>

<P>
To zapis matematyczny, dla komputera równie ma³o zrozumia³y, co dla uczniów nielubi¹cych matmy :-). ¯eby kompilator coœ z tego zakuma³, powinniœmy napisaæ:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
znak = (x%<SPAN CLASS=L>2</SPAN>==<SPAN CLASS=L>0</SPAN>) ? <SPAN CLASS=L>1</SPAN> : <SPAN CLASS=L>-1</SPAN>;
</TD></TR>
</TABLE>

<P>
...albo w prostszej (i szybszej) postaci:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
znak = -(i%<SPAN CLASS=L>2</SPAN> * <SPAN CLASS=L>2</SPAN> - <SPAN CLASS=L>1</SPAN>);
</TD></TR>
</TABLE>

<P>
Brakuje nam do szczêœcia jeszcze tylko zmiennej <SPAN CLASS=T>n</SPAN>, któr¹ równie¿ musimy przedstawiæ jako funkcjê. Powinna ona przybieraæ wartoœci kolejnych liczb ca³kowitych, tyle ¿e zwiêkszaj¹cych siê wy³¹cznie dla argumentów <SPAN CLASS=T>x</SPAN> nieparzystych:
</P>

<P ALIGN=CENTER>
<I>
n(x) = (x+1) div 2
</I>
</P>

<P>
S³owo <SPAN CLASS=Wazne>div</SPAN> (po¿yczone z Pascala :-P) oznacza dzielenie ca³kowite, czyli bez uwzglêdniania reszty. W kodzie u¿yjemy oczywiœcie zwyk³ego operatora dzielenia, a powy¿ej napisa³em <SPAN CLASS=Wazne>div</SPAN> tylko dlatego, by wzór by³ matematycznie poprawny. Do <SPAN CLASS=T>x</SPAN> dodajemy <SPAN CLASS=L>1</SPAN>, poniewa¿ chcemy, ¿eby dla <SPAN CLASS=T>x=</SPAN><SPAN CLASS=L>0</SPAN> wartoœæ <SPAN CLASS=T>n</SPAN> wynosi³a <SPAN CLASS=L>0</SPAN>, a dla jedynki ju¿ <SPAN CLASS=L>1</SPAN>. W kodzie bêdzie to wygl¹da³o po prostu tak:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
n = (x+<SPAN CLASS=L>1</SPAN>)/<SPAN CLASS=L>2</SPAN>;
</TD></TR>
</TABLE>

<P>
Mamy ju¿ wszystkie funkcje sk³adowe naszej formu³y, pozostaje je tylko powstawiaæ do ogólnego wzoru. Nasz¹ czwórkê zast¹pimy sobie zmienn¹ œrodek, ¿eby wzór nadawa³ siê dla list o innych liczbach elementów:
</P>

<P ALIGN=CENTER>
<I>
f(x) = œrodek - (x mod 2 * 2 - 1) * (x+1) div 2
</I>
</P>

<P>
Jak wykorzystaæ tê formu³kê w programie? Bardzo prosto:
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=C>
#include &lt;stdio.h&gt;<BR>
#include &lt;stdlib.h&gt;<BR>
</SPAN>
<BR>
<SPAN CLASS=K>const int</SPAN> elem = <SPAN CLASS=L>8</SPAN>;<BR>
<SPAN CLASS=K>const int</SPAN> srodek = <SPAN CLASS=L>4</SPAN>;<BR>
<BR>
<SPAN CLASS=K>int</SPAN> f(<SPAN CLASS=K>int</SPAN> i) { <SPAN CLASS=K>return</SPAN> srodek-(i%<SPAN CLASS=L>2</SPAN>*<SPAN CLASS=L>2</SPAN>-<SPAN CLASS=L>1</SPAN>)*(i+<SPAN CLASS=L>1</SPAN>)/<SPAN CLASS=L>2</SPAN>; }<BR>
<BR>
<SPAN CLASS=K>int</SPAN> main()<BR>
{<BR>
&nbsp;<SPAN CLASS=K>for</SPAN>(<SPAN CLASS=K>int</SPAN> x=<SPAN CLASS=L>0</SPAN>; x&lt;elem; ++x)<BR>
&nbsp;&nbsp;printf(<SPAN CLASS=L>"Element nr %d: %d"</SPAN>, x, f(x));<BR>
<BR>
&nbsp;system(<SPAN CLASS=L>"pause"</SPAN>);<BR>
&nbsp;<SPAN CLASS=K>return</SPAN> <SPAN CLASS=L>0</SPAN>;<BR>
}<BR>
</TD></TR>
</TABLE>


<H2>
2. Ró¿a wiatrów
</H2>

<P>
Jeœli zagl¹da³eœ ju¿ do opisu algorytmu wyszukiwania drogi, to zapewne przypominasz sobie, ¿e drugi etap takiego wyszukiwania polega na wybieraniu jednego spoœród kilku (w skrajnych przypadkach oœmiu) alternatywnych punktów. Alternatywnych, bo którykolwiek byœmy wybrali, zawsze trafimy po nim do docelowego punktu i to w dodatku zawsze bêdzie najkrótsza trasa. Jedynym kryterium takiego wyboru by³o coœ, co nazwaliœmy sobie <SPAN CLASS=Wazne>stylem poruszania</SPAN>. W moim przyk³adowym programiku <SPAN CLASS=Wazne>PathFinder</SPAN> zaimplementowane by³y trzy takie "style": Prostak, Lewus i Pijak. Nie wiem czy zwróci³eœ na to uwagê, ale Prostak nie zawsze kierowa³ siê prosto. Gdyby postawiæ punkt B po lewej stronie punktu A, to Prostak niczym nie ró¿ni³by siê od Lewusa...
</P>
<P>
¯eby potworek czy inna istota, korzystaj¹ca z tego algorytmu, porusza³a siê "normalnie", czyli prosto do celu, bez zygzakowania i innych cudów, przy wyborze punktów musia³aby preferowaæ kierunki: pó³nocny, po³udniowy, zachodni i wschodni, a dopiero gdyby nie by³o innej mo¿liwoœci - pozosta³e 4 kierunki (pó³nocny zachód itd.). A wiêc (zerknij na klawiaturê numeryczn¹) jeœli potwór to <SPAN CLASS=L>5</SPAN>, preferowane kierunki to: <SPAN CLASS=L>8, 6, 2, 4</SPAN>. Jeœli potwór nie mo¿e siê ruszyæ w ¿adnym z tych kierunków, powinien wybraæ <SPAN CLASS=L>7, 9, 3</SPAN> lub <SPAN CLASS=L>1</SPAN>. W ten sposób potwór bêdzie siê porusza³ tak prosto, jakby by³ zdeklarowanym abstynentem ;-).
</P>
<P>
Tylko jak to teraz wprowadziæ w ¿ycie? Mo¿emy pos³u¿yæ siê tabelk¹, tak jak przy selekcji elementów z listy, ale tym razem sytuacja jest na tyle prosta, ¿e mo¿emy siê obejœæ bez tego. Argumenty pozostaj¹ te same (jest to "stopieñ preferencji" danego kierunku, czyli jak bardzo potworek jest sk³onny wybraæ w³aœnie ten kierunek), natomiast <SPAN CLASS=T>f</SPAN> to numer punktu-s¹siada, <SPAN CLASS=L>0</SPAN> oznacza - popatrz na numpada - siódemkê, <SPAN CLASS=L>1</SPAN> ósemkê, <SPAN CLASS=L>2</SPAN> dziewi¹tkê, <SPAN CLASS=L>3</SPAN> szóstkê itd. W porównaniu z zadaniem z pierwszego rozdzia³u, to jest banalne. Argumentom od <SPAN CLASS=L>0</SPAN> do <SPAN CLASS=L>3</SPAN> w³¹cznie przypisujemy kolejne liczby nieparzyste, a argumentom <SPAN CLASS=L>4-7</SPAN> przypisujemy parzyste (o ile uznamy, ¿e <SPAN CLASS=L>0</SPAN> te¿ jest parzyste). Wzór funkcji <I>f(x)</I> bêdzie wiêc taki:
</P>

<P ALIGN=CENTER>
<I>
<TABLE><TR><TD ROWSPAN=2 CLASS=NOT>f(x) = </TD><TD ROWSPAN=2 CLASS=NOT><IMG SRC="../gfx/klamra.gif"></TD><TD CLASS=NOT>x*2 + 1 dla x<=3</TD></TR><TR><TD CLASS=NOT>(x-4)*2 dla x>3</TD></TR></TABLE>
</I>
</P>

<P>
Jak ju¿ wiesz, tego rodzaju wzory implementujemy przy wykorzystaniu operatora <SPAN CLASS=T>?:</SPAN>. Niestety, tym razem raczej nie znajdziemy prostszej postaci, ale zreszt¹ ta jest te¿ wystarczaj¹co prosta ;-).
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
wyb = (x&gt;<SPAN CLASS=L>3</SPAN>) ? (x-<SPAN CLASS=L>4</SPAN>)*<SPAN CLASS=L>2</SPAN> : x*<SPAN CLASS=L>2</SPAN>+<SPAN CLASS=L>1</SPAN>;
</TD></TR>
</TABLE>

<P>
Maj¹c gotow¹ formu³kê mo¿emy sobie od razu zdefiniowaæ nowy styl konstruowania trasy. Nazwiemy sobie go <SPAN CLASS=Wazne>ró¿¹ wiatrów</SPAN>, poniewa¿ w ró¿y wiatrów "proste" kierunki s¹ oznaczone wiêkszymi grotami (s¹ wa¿niejsze), a "skoœne" mniejszymi (mniej wa¿ne):
</P>

<TABLE BORDER WIDTH=100%>
<TR><TD>
<SPAN CLASS=K>case</SPAN> STYL_ROZAWIATROW:<BR>
{<BR>
&nbsp;wyb = (x&gt;<SPAN CLASS=L>3</SPAN>) ? (x-<SPAN CLASS=L>4</SPAN>)*<SPAN CLASS=L>2</SPAN> : x*<SPAN CLASS=L>2</SPAN>+<SPAN CLASS=L>1</SPAN>;<BR>
}<BR>
<SPAN CLASS=K>break</SPAN>;<BR>
</TD></TR>
</TABLE>

<P>
Proponujê wstawiæ ten kod do PathFindera i wypróbowaæ go. Oczywiœcie bêdzie trzeba dostawiæ jeszcze jednego RadioButtona, ale to dla ciebie przecie¿ ¿adny problem, nie? Jeœli niczego nie skaszani³eœ, mo¿esz podziwiaæ efekty: jak by nie ustawiæ wzglêdem siebie punkty A i B, droga pomiêdzy nimi zawsze bêdzie "równa", a po skosie bêdziemy chodziæ jedynie wtedy, gdy nie bêdzie innej mo¿liwoœci. To dopiero prostactwo co siê zowie ;-).
</P>

<HR COLOR=GRAY WIDTH=90% SIZE=1>
<TABLE ALIGN=CENTER>
<TR>
<TD CLASS=TDN>
<A HREF="stos.html"><< Stos &nbsp;
<A HREF="../index.html" TARGET="_top">Strona g³ówna</A> &nbsp;
<A HREF="../algorytm.html"> Spis >></A> &nbsp;
</TD>
</TR>
</TABLE>

</BODY>
</HTML>