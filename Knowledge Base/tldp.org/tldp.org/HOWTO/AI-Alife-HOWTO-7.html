<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Programming languages</TITLE>
 <LINK HREF="AI-Alife-HOWTO-8.html" REL=next>
 <LINK HREF="AI-Alife-HOWTO-6.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc7" REL=contents>
</HEAD>
<BODY>
<A HREF="AI-Alife-HOWTO-8.html">Next</A>
<A HREF="AI-Alife-HOWTO-6.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc7">Contents</A>
<HR>
<H2><A NAME="Programming languages"></A> <A NAME="s7">7.</A> <A HREF="AI-Alife-HOWTO.html#toc7">Programming languages</A>    </H2>


<P>While any programming language can be used for artificial
intelligence/life research, these are programming languages which
are used extensively for, if not specifically made for, artificial
intelligence programming.  </P>

<P>
<DL>
<P>
<A NAME="Alloy"></A> </P>
<DT><B>Alloy</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://alloy.mit.edu/">http://alloy.mit.edu/</A></LI>
</UL>
</P>
<P>The Alloy Analyzer is a tool for analyzing models written in Alloy, a
simple structural modeling language based on first-order logic. The
tool can generate instances of invariants, simulate the execution of
operations (even those defined implicitly), and check user-specified
properties of a model. Alloy and its analyzer have been used primarily
to explore abstract software designs. Its use in analyzing code for
conformance to a specification and as an automatic test case generator
are being investigated in ongoing research projects.</P>

<P>
<A NAME="APRIL"></A> </P>
<DT><B>APRIL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/networkagent/">sourceforge.net/projects/networkagent/</A></LI>
</UL>
</P>
<P>APRIL is a symbolic programming language that is designed for writing
mobile, distributed and agent-based systems especially in an Internet
environment. It has advanced features such as a macro sub-language,
asynchronous message sending and receiving, code mobility, pattern
matching, higher-order functions and strong typing. The language is
compiled to byte-code which is then interpreted by the APRIL
runtime-engine.  APRIL now requires the InterAgent Communications Model
(ICM) to be installed before it can be installed. [Ed. ICM can be found
at the same web site]</P>

<P>
<A NAME="Ciao Prolog"></A> </P>
<DT><B>Ciao Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.clip.dia.fi.upm.es/Software/Ciao/">www.clip.dia.fi.upm.es/Software/Ciao/</A></LI>
</UL>
</P>
<P>Ciao is a complete Prolog system subsuming ISO-Prolog with a novel
modular design which allows both restricting and extending the
language. Ciao extensions currently include feature terms (records),
higher-order, functions, constraints, objects, persistent predicates, a
good base for distributed execution (agents), and concurrency.
Libraries also support WWW programming, sockets, and external
interfaces (C, Java, TCL/Tk, relational databases, etc.). An
Emacs-based environment, a stand-alone compiler, and a toplevel shell
are also provided.</P>

<P>
<A NAME="Curry"></A> </P>
<DT><B>Curry</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatik.uni-kiel.de/~mh/curry/">http://www.informatik.uni-kiel.de/~mh/curry/</A></LI>
</UL>
</P>
<P>Curry is a universal programming language aiming to amalgamate the most
important declarative programming paradigms, namely functional
programming and logic programming. Moreover, it also covers the most
important operational principles developed in the area of integrated
functional logic languages: "residuation" and "narrowing" (there is an
older survey and a newer survey on functional logic programming).</P>
<P>Curry combines in a seamless way features from functional programming
(nested expressions, higher-order functions, lazy evaluation), logic
programming (logical variables, partial data structures, built-in
search), and concurrent programming (concurrent evaluation of
expressions with synchronization on logical variables). Moreover, Curry
provides additional features in comparison to the pure languages
(compared to functional programming: search, computing with partial
information; compared to logic programming: more efficient evaluation
due to the deterministic and demand-driven evaluation of functions). </P>

<P>
<A NAME="DHARMI"></A> </P>
<DT><B>DHARMI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://megazone.bigpanda.com/~wolf/DHARMI/">http://megazone.bigpanda.com/~wolf/DHARMI/</A></LI>
</UL>
</P>
<P>DHARMI is a high level spatial, tinker-toy like language who's
components are transparently administered by a background
process called the Habitat. As the name suggests, the language
was designed to make modelling prototypes and handle living
data. Programs can be modified while running. This is accomplished
by blurring the distinction between source code, program,
and data.</P>

<P>
<A NAME="ECLiPSe"></A> </P>
<DT><B>ECLiPSe</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://eclipse.crosscoreop.com/eclipse/">eclipse.crosscoreop.com/eclipse/</A></LI>
</UL>
</P>
<P>ECLiPSe is a software system for the cost-effective development and
deployment of constraint programming applications, e.g. in the areas of
planning, scheduling, resource allocation, timetabling, transport etc.
It is also ideal for teaching most aspects of combinatorial problem
solving, e.g.  problem modelling, constraint programming, mathematical
programming, and search techniques. It contains several constraint
solver libraries, a high-level modelling and control language,
interfaces to third-party solvers, an integrated development
environment and interfaces for embedding into host environments.</P>

<P>
<A NAME="ECoLisp"></A> </P>
<DT><B>ECoLisp</B><DD><P>
<UL>
<LI>Web site (???): 
<A HREF="http://www.di.unipi.it/~attardi/software.html">www.di.unipi.it/~attardi/software.html</A></LI>
</UL>
</P>

<P>ECoLisp (Embeddable Common Lisp) is an implementation of
Common Lisp designed for being embeddable into C based
applications. ECL uses standard C calling conventions for Lisp
compiled functions, which allows C programs to easily call
Lisp functions and viceversa. No foreign function interface is
required: data can be exchanged between C and Lisp with no
need for conversion. ECL is based on a Common Runtime Support
(CRS) which provides basic facilities for memory managment,
dynamic loading and dumping of binary images, support for
multiple threads of execution. The CRS is built into a library
that can be linked with the code of the application. ECL is
modular: main modules are the program development tools (top
level, debugger, trace, stepper), the compiler, and CLOS. A
native implementation of CLOS is available in ECL: one can
configure ECL with or without CLOS. A runtime version of ECL
can be built with just the modules which are required by the
application. The ECL compiler compiles from Lisp to C, and
then invokes the GCC compiler to produce binaries.</P>

<P>
<A NAME="ESTEREL"></A> </P>
<DT><B>ESTEREL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-sop.inria.fr/meije/esterel/">www-sop.inria.fr/meije/esterel/</A></LI>
</UL>
</P>
<P>Esterel is both a programming language, dedicated to programming
reactive systems, and a compiler which translates Esterel programs into
finite-state machines. It is particularly well-suited to programming
reactive systems, including real-time systems and control automata.</P>
<P>Only the binary is available for the language compiler. :P</P>

<P>
<A NAME="Godel"></A> </P>
<DT><B>G&ouml;del</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cs.bris.ac.uk/~bowers/goedel.html">www.cs.bris.ac.uk/~bowers/goedel.html</A></LI>
</UL>
</P>
<P>G&ouml;del is a declarative, general-purpose programming language
in the family of logic programming languages.  It is a strongly typed
language, the type system being based on many-sorted logic with
parametric polymorphism.  It has a module system.  G&ouml;del supports
infinite precision integers, infinite precision rationals, and also
floating-point numbers.  It can solve constraints over finite domains
of integers and also linear rational constraints. It supports
processing of finite sets.  It also has a flexible computation rule
and a pruning operator which generalizes the commit of the concurrent
logic programming languages.  Considerable emphasis is placed on
G&ouml;del's meta- logical facilities which provide significant
support for meta-programs that do analysis, transformation,
compilation, verification, debugging, and so on.</P>

<P>
<A NAME="CLisp"></A> </P>
<DT><B>CLisp (Lisp)</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://clisp.sourceforge.net/">clisp.sourceforge.net</A></LI>
<LI>Alt Web site: 
<A HREF="http://clisp.cons.org/">clisp.cons.org</A></LI>
</UL>
</P>
<P>CLISP is a Common Lisp implementation by Bruno Haible and Michael
Stoll.  It mostly supports the Lisp described by 
<A HREF="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html">Common LISP: The Language (2nd edition)</A>
and the ANSI Common Lisp
standard.  CLISP includes an interpreter, a byte-compiler, a large
subset of CLOS (Object-Oriented Lisp) , a foreign language interface
and, for some machines, a screen editor.</P>
<P>The user interface language (English, German, French) is chosen at
run time.  Major packages that run in CLISP include CLX &amp; Garnet.
CLISP needs only 2 MB of memory.</P>

<P>
<A NAME="CMU CL"></A> </P>
<DT><B>CMU Common Lisp</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cons.org/cmucl/">www.cons.org/cmucl/</A></LI>
<LI>Linux Installation: 
<A HREF="http://www.telent.net/lisp/howto.html">www.telent.net/lisp/howto.html</A></LI>
</UL>
</P>

<P>CMU Common Lisp is a public domain "industrial strength" Common
Lisp programming environment. Many of the X3j13 changes have been
incorporated into CMU CL. Wherever possible, this has been done so as
to transparently allow the use of either CLtL1 or proposed ANSI
CL. Probably the new features most interesting to users are SETF
functions, LOOP and the WITH-COMPILATION-UNIT macro.</P>

<P>
<A NAME="Gnu-CL"></A> </P>
<DT><B>GCL (Lisp)</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.ma.utexas.edu/pub/gcl/">ftp.ma.utexas.edu/pub/gcl/</A></LI>
</UL>
</P>
<P>GNU Common Lisp (GCL) has a compiler and interpreter for Common
Lisp.  It used to be known as Kyoto Common Lisp.  It is very portable
and extremely efficient on a wide class of applications.  It compares
favorably in performance with commercial Lisps on several large
theorem-prover and symbolic algebra systems. It supports the CLtL1
specification but is moving towards the proposed ANSI definition.  GCL
compiles to C and then uses the native optimizing C compilers (e.g.,
GCC).  A function with a fixed number of args and one value turns into
a C function of the same number of args, returning one value, so GCL
is maximally efficient on such calls.  It has a conservative garbage
collector which allows great freedom for the C compiler to put Lisp
values in arbitrary registers.</P>

<P>It has a source level Lisp debugger for interpreted code, with display
of source code in an Emacs window.  Its profiling tools (based on the
C profiling tools) count function calls and the time spent in each
function.  </P>

<P>
<A NAME="GNU Prolog"></A> </P>
<DT><B>GNU Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://gnu-prolog.inria.fr/">gnu-prolog.inria.fr</A></LI>
<LI>Web site: 
<A HREF="http://pauillac.inria.fr/~diaz/gnu-prolog/">pauillac.inria.fr/~diaz/gnu-prolog/</A></LI>
</UL>
</P>

<P>GNU Prolog is a free Prolog compiler with constraint solving over
finite domains developed by Daniel Diaz.</P>
<P>GNU Prolog accepts Prolog+constraint programs and produces native
binaries (like gcc does from a C source). The obtained executable is
then stand-alone. The size of this executable can be quite small since
GNU Prolog can avoid to link the code of most unused built-in
predicates. The performances of GNU Prolog are very encouraging
(comparable to commercial systems). </P>
<P>Beside the native-code compilation, GNU Prolog offers a classical
interactive interpreter (top-level) with a debugger.</P>
<P>The Prolog part conforms to the ISO standard for Prolog with many
extensions very useful in practice (global variables, OS interface,
sockets,...). </P>
<P>GNU Prolog also includes an efficient constraint solver over Finite
Domains (FD). This opens contraint logic pogramming to the user
combining the power of constraint programming to the declarativity of
logic programming.</P>

<P>
<A NAME="IBAL"></A> </P>
<DT><B>IBAL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.eecs.harvard.edu/~avi/IBAL/">www.eecs.harvard.edu/~avi/IBAL/</A></LI>
</UL>
</P>
<P>IBAL (pronounced "eyeball") is a general-purpose language for
probabilistic modeling, parameter estimation and decision making. It
generalizes Bayesian networks, hidden Markov models, stochastic context
free grammars, Markov decision processes, and allows many new
possibilities. It also provides a convenient programming-language
framework with libraries, automatic type checking and so on.</P>

<P>
<A NAME="lush"></A> </P>
<DT><B>lush</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lush.sourceforge.net/">lush.sourceforge.net</A></LI>
</UL>
</P>
<P>Lush is an object-oriented programming language designed for
researchers, experimenters, and engineers interested in large-scale
numerical and graphic applications. Lush is designed to be used in
situations where one would want to combine the flexibility of a
high-level, weakly-typed interpreted language, with the efficiency of a
strongly-typed, natively-compiled language, and with the easy
integration of code written in C, C++, or other languages.</P>

<P>
<A NAME="Maude"></A> </P>
<DT><B>Maude</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://maude.cs.uiuc.edu/">maude.cs.uiuc.edu</A></LI>
</UL>
</P>
<P>Maude is a high-performance reflective language and system supporting
both equational and rewriting logic specification and programming for a
wide range of applications. Maude has been influenced in important ways
by the OBJ3 language, which can be regarded as an equational logic
sublanguage. Besides supporting equational specification and
programming, Maude also supports rewriting logic computation. </P>

<P>
<A NAME="Mercury"></A> </P>
<DT><B>Mercury</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cs.mu.oz.au/research/mercury/">http://www.cs.mu.oz.au/research/mercury/</A></LI>
</UL>
</P>
<P>Mercury is a new, purely declarative logic programming language.  Like
Prolog and other existing logic programming languages, it is a very
high-level language that allows programmers to concentrate on the
problem rather than the low-level details such as memory management.
Unlike Prolog, which is oriented towards exploratory programming,
Mercury is designed for the construction of large, reliable, efficient
software systems by teams of programmers. As a consequence, programming
in Mercury has a different flavor than programming in Prolog.</P>

<P>
<A NAME="Mozart"></A> </P>
<DT><B>Mozart</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.mozart-oz.org/">http://www.mozart-oz.org/</A></LI>
</UL>
</P>
<P>The Mozart system provides state-of-the-art support in two areas:
open distributed computing and constraint-based inference. Mozart
implements Oz, a concurrent object-oriented language with dataflow
synchronization.  Oz combines concurrent and distributed programming
with logical constraint-based inference, making it a unique choice
for developing multi-agent systems. Mozart is an ideal platform for
both general-purpose distributed applications as well as for hard
problems requiring sophisticated optimization and inferencing
abilities. We have developed applications in scheduling and
time-tabling, in placement and configuration, in natural language and
knowledge representation, multi-agent systems and sophisticated
collaborative tools.      </P>

<P>
<A NAME="SWI Prolog"></A> </P>
<DT><B>SWI Prolog</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.swi-prolog.org/">http://www.swi-prolog.org/</A></LI>
</UL>
</P>
<P>SWI is a free version of prolog in the Edinburgh Prolog family. It is
licensed under the LGPL with many nice features for an AI researcher,
such as; a large library of built-in predicates, a module system,
garbage collection, a two-way interface with the C/C++ language,
coroutines, multi-threading, multiple constraint library, the XPCE
graphics toolkit, plus many more.</P>

<P>
<A NAME="Push"></A> </P>
<DT><B>Push</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hampshire.edu/lspector/push.html">hampshire.edu/lspector/push.html</A></LI>
</UL>
</P>
<P>Push is a programming language intended primarily for use in
evolutionary computation systems (such as genetic programming systems),
as the language in which evolving programs are expressed. Push has an
unusually simple syntax, which facilitates the development (or
evolution) of mutation and recombination operators that generate and
manipulate programs. Despite this simple syntax, Push provides more
expressive power than most other program representations that are used
for program evolution.</P>
<P>Includes several libraries/systems for working with GP (all info on the
Push page). PushGP is a genetic programming system that evolves
programs in the Push programming language. Pushpop is an
"autoconstructive evolution" system that also evolves Push programs.
SwarmEvolve 2.0 is an autoconstuctive evolution system in which flying
agents, controlled by Push programs, evolve in a 3D environment.</P>

<P>
<A NAME="Kali Scheme"></A> </P>
<DT><B>Kali Scheme</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://community.schemewiki.org/kali-scheme/">http://community.schemewiki.org/kali-scheme/</A></LI>
</UL>
</P>
<P>Kali Scheme is a distributed implementation of Scheme that
permits efficient transmission of higher-order objects such as
closures and continuations. The integration of distributed
communication facilities within a higher-order programming
language engenders a number of new abstractions and paradigms
for distributed computing. Among these are user-specified
load-balancing and migration policies for threads,
incrementally-linked distributed computations, agents, and
parameterized client-server applications. Kali Scheme supports
concurrency and communication using first-class procedures and
continuations. It integrates procedures and continuations into a
message-based distributed framework that allows any Scheme
object (including code vectors) to be sent and received in a
message.</P>

<P>
<A NAME="RScheme"></A> </P>
<DT><B>RScheme</B><DD><P>
<UL>
<LI>Web site:
<A HREF="http://www.rscheme.org/">www.rscheme.org</A></LI>
</UL>
</P>
<P>RScheme is an object-oriented, extended version of the Scheme
dialect of Lisp. RScheme is freely redistributable, and offers
reasonable performance despite being extraordinarily portable.
RScheme can be compiled to C, and the C can then compiled with a
normal C compiler to generate machine code. By default, however,
RScheme compiles to bytecodes which are interpreted by a
(runtime) virtual machine. This ensures that compilation is fast
and keeps code size down. In general, we recommend using the
(default) bytecode code generation system, and only compiling
your time-critical code to machine code. This allows a nice
adjustment of space/time tradeoffs.  (see web site for details)</P>

<P>
<A NAME="Scheme 48"></A> </P>
<DT><B>Scheme 48</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://s48.org/">http://s48.org/</A></LI>
</UL>
</P>
<P>Scheme 48 is a Scheme implementation based on a virtual machine
architecture. Scheme 48 is designed to be straightforward, flexible,
reliable, and fast. It should be easily portable to 32-bit
byte-addressed machines that have POSIX and ANSI C support.  In
addition to the usual Scheme built-in procedures and a development
environment, library software includes support for hygienic macros (as
described in the Revised^4 Scheme report), multitasking, records,
exception handling, hash tables, arrays, weak pointers, and FORMAT.
Scheme 48 implements and exploits an experimental module system
loosely derived from Standard ML and Scheme Xerox.  The development
environment supports interactive changes to modules and interfaces.</P>

<P>
<A NAME="SCM"></A> </P>
<DT><B>SCM (<B>Scheme</B>) </B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-swiss.ai.mit.edu/~jaffer/SCM.html">www-swiss.ai.mit.edu/~jaffer/SCM.html</A></LI>
</UL>
</P>
<P>SCM conforms to the Revised^4 Report on the Algorithmic Language
Scheme and the IEEE P1178 specification. Scm is written in C. It uses
the following utilities (all available at the ftp site).
<UL>
<LI>SLIB (Standard Scheme Library) is a portable Scheme
library which is intended to provide compatibility and utility
functions for all standard Scheme implementations, including
SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
Scheme48, T3.1, and VSCM, and is available as the file
slib2c0.tar.gz. Written by Aubrey Jaffer.  </LI>
<LI>JACAL is a symbolic math system written in Scheme, and is
available as the file jacal1a7.tar.gz.</LI>
<LI>Interfaces to standard libraries including REGEX string 
regular expression matching and the CURSES screen management 
package.</LI>
<LI>Available add-on packages including an interactive debugger, 
database, X-window graphics, BGI graphics, Motif, and 
Open-Windows packages.</LI>
<LI>A compiler (HOBBIT, available separately) and dynamic linking
of compiled modules.</LI>
</UL>
</P>

<P>
<A NAME="Shift"></A> </P>
<DT><B>Shift</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.path.berkeley.edu/shift/">http://www.path.berkeley.edu/shift/</A></LI>
</UL>
</P>
<P>Shift is a programming language for describing dynamic
networks of hybrid automata.  Such systems consist of
components which can be created, interconnected and destroyed
as the system evolves. Components exhibit hybrid behavior,
consisting of continuous-time phases separated by
discrete-event transitions. Components may evolve
independently, or they may interact through their inputs,
outputs and exported events. The interaction network itself
may evolve.</P>

<P>
<A NAME="STELLA"></A> </P>
<DT><B>STELLA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.isi.edu/isd/LOOM/Stella/">http://www.isi.edu/isd/LOOM/Stella/</A></LI>
</UL>
</P>
<P>STELLA is a strongly typed, object-oriented, Lisp-like language,
designed to facilitate symbolic programming tasks in artificial
intelligence applications. STELLA preserves those features of Common
Lisp deemed essential for symbolic programming such as built-in support
for dynamic data structures, heterogeneous collections, first-class
symbols, powerful iteration constructs, name spaces, an object-oriented
type system with a meta-object protocol, exception handling, and
language extensibility through macros, but without compromising
execution speed, interoperability with non-STELLA programs, and
platform independence. STELLA programs are translated into a target
language such as C++, Common Lisp, or Java, and then compiled with the
native target language compiler to generate executable code. The
language constructs of STELLA are restricted to those that can be
translated directly into native constructs of the intended target
languages, thus enabling the generation of highly efficient as well as
readable code.</P>

<P>
<A NAME="YAP Prolog"></A> </P>
<DT><B>YAP Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ncc.up.pt/~vsc/Yap/">http://www.ncc.up.pt/~vsc/Yap/</A></LI>
<LI>Sourceforge site: 
<A HREF="http://sourceforge.net/projects/yap/">http://sourceforge.net/projects/yap/</A></LI>
</UL>
</P>
<P>YAP is a high-performance Prolog compiler developed at  
LIACC/Universidade do Porto. Its Prolog engine is based in the WAM
(Warren Abstract Machine), with several optimizations for better
performance. YAP follows the Edinburgh tradition, and is largely
compatible with DEC-10 Prolog, Quintus Prolog, and especially 
with C-Prolog. Work on the more recent version of YAP strives at
several goals:</P>
<P>
<UL>
<LI>Portability: The whole system is now written in C. YAP
compiles in popular 32 bit machines, such as Suns and 
Linux PCs, and in a 64 bit machines, the Alphas running
OSF Unix and Linux. </LI>
<LI>Performance: We have optimised the emulator to obtain
performance comparable to or better than well-known Prolog
systems. In fact, the current version of YAP performs 
better than the original one, written in assembly language.</LI>
<LI>Robustness: We have tested the system with a large array 
of Prolog applications.</LI>
<LI>Extensibility: YAP was designed internally from the
beginning to encapsulate manipulation of terms. These
principles were used, for example, to implement a simple
and powerful C-interface. The new version of YAP extends
these principles to accomodate extensions to the 
unification algorithm, that we believe will be useful to
implement extensions such as constraint programming.</LI>
<LI>Completeness: YAP has for a long time provided most
builtins expected from a Edinburgh Prolog implementation.
These include I/O functionality, data-base operations, 
and modules. Work on YAP aims now at being compatible with
the Prolog standard. </LI>
<LI>Openess: We would like to make new development of YAP
open to the user community. </LI>
<LI>Research: YAP has been a vehicle for research within and
outside our group. Currently research is going on on 
parallelisation and tabulation, and we have started work
to support constraint handling. </LI>
</UL>
</P>

</DL>
</P>



<HR>
<A HREF="AI-Alife-HOWTO-8.html">Next</A>
<A HREF="AI-Alife-HOWTO-6.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc7">Contents</A>
</BODY>
</HTML>
