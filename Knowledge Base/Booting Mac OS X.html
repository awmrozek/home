<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0066)http://osxbook.com/book/bonus/ancient/whatismacosx//arch_boot.html -->
<html><!-- InstanceBegin template="/Templates/osxbook.dwt" codeOutsideHTMLIsLocked="false" --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="Author" content="Amit Singh">

<!-- InstanceBeginEditable name="editable-region-keywords" -->
<!--***zzzEDIT***-->
<meta name="Keywords" content="Mac OS X Internals, 0321278542, Apple History, History of Apple&#39;s Operating Systems, Mac OS, Classic, Rhapsody, NEXTSTEP, OPENSTEP, BeOS, Windows, Mach, Accent, RIG, dyld, Open Firmware, EFI, Extensible Firmware Interface, Virtual Memory, Processes, Process Management, Scheduling, Processors, BSD, I/O Kit, Device Drivers, Object-oriented, Interrupts, Motion Sensor, HFS+, File Systems, Interprocess Communication, Mach Ports">
<meta name="Description" content="Mac OS X Internals">
<!-- InstanceEndEditable -->

<link rel="home" href="http://www.osxbook.com/" title="Home">

<!-- InstanceBeginEditable name="editable-region-stylesheet" -->
<!--***zzzEDIT***-->
<link rel="stylesheet" type="text/css" href="./Booting Mac OS X_files/osxbook.css" media="all">
<style type="text/css">
<!-- page-custom styles -->
</style>
<!-- InstanceEndEditable -->

<!-- InstanceBeginEditable name="editable-region-shortcut" -->
<!--****zzzEDIT****-->
<link rel="shortcut icon" href="http://osxbook.com/favicon.ico">
<!-- InstanceEndEditable -->

<!-- InstanceBeginEditable name="editable-region-head" -->
<!-- t-head -->
<!--****zzzEDIT****-->
<title>Booting Mac OS X</title>
<!-- InstanceEndEditable -->

</head>

<body id="www-osxbook-com">

<!-- InstanceBeginEditable name="editable-region-body" -->
<!--****zzzEDIT****-->
<a href="http://osxbook.com/" title="Home" style="text-decoration: none;"><h1 id="sitemast" style="background: url(/images/logo_osxbook.jpg) no-repeat center top; line-height: 183px;">&nbsp;</h1></a>
<!-- InstanceEndEditable -->

<!-- GOOGLE_SEARCH_BEGIN -->
<div class="google_search">
<center>
<form method="get" action="http://www.google.com/custom" target="_top">
<table style="background-color: rgb(96%,96%,94%);">
<tbody><tr><td nowrap="nowrap" valign="top" align="right">

<label for="sbi" style="display: none">Enter your search terms</label>
<input type="text" name="q" size="31" maxlength="255" value="" id="sbi">
<label for="sbb" style="display: none">Submit search form</label>
<input type="submit" name="sa" value="Google Search" id="sbb">
<input type="hidden" name="client" value="pub-6436753395229860">
<input type="hidden" name="forid" value="1">
<input type="hidden" name="ie" value="ISO-8859-1">
<input type="hidden" name="oe" value="ISO-8859-1">
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:336699;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;FORID:1">
<input type="hidden" name="hl" value="en">
</td></tr></tbody></table>
</form>
</center>
</div>
<!-- GOOGLE_SEARCH_END -->

<!-- InstanceBeginEditable name="editable-region-navbar-padding" -->
<!--****zzzEDIT****-->
<div id="sidebar">
<!-- InstanceEndEditable -->

  <h4 class="oldbl" id="sidetop">The Book</h4>
  <div class="sublinks">

    <a href="http://osxbook.com/book/preface/" title="Mac OS X Internals: Preface">
    Preface
    </a> <b>|</b>

    <a href="http://osxbook.com/book/toc/" title="Mac OS X Internals: Table of Contents">
    Table of Contents
    </a> <b>|</b>


    <a href="http://osxbook.com/book/reviews/" title="Mac OS X Internals: Read Reviews">
    Read Reviews
    </a> <b>|</b>
	

    <a href="http://osxbook.com/book/src/" title="Mac OS X Internals: Viewable Source Code">
    Source Code
    </a> <b>|</b>

    <a href="http://osxbook.com/book/errata/" title="Mac OS X Internals: Errata">
    Errata
    </a> <b>|</b>

    <a href="http://osxbook.com/book/buy/" title="Mac OS X Internals: Buy Now">
    Buy Now 
    </a> <b>|</b>

  </div>

  <h4 class="oldbl" id="sidetop">The Book — Extras</h4>
  <div class="sublinks">

    <a href="http://osxbook.com/book/bonus/" title="Mac OS X Internals: Bonus Content">
    Bonus Content
    </a> <b>|</b>
	
    <a href="http://osxbook.com/book/faq/" title="Mac OS X Internals: Frequently Asked Questions">
    FAQ
    </a> <b>|</b>

  </div>

  <h4 class="oldbl" id="sidetop">Software</h4>
  <div class="sublinks">
    <a href="http://osxbook.com/software/" title="Mac OS X Internals: Downloadable Software">
    Downloads
    </a> <b>|</b>
	<a href="http://osxbook.com/software/bugs/" title="Bug Reports">
    Bug Reports
    </a> <b>|</b>
  </div>

  <h4 class="oldbl" id="sidetop">Meta</h4>
  <div class="sublinks">

    <a href="http://osxbook.com/blog/" title="The Mac OS X Internals Blog">
    Blog
    </a> <b>|</b>

    <a href="http://osxbook.com/forums/" title="The Mac OS X Internals Forums">
    Forums
    </a> <b>|</b>

    <a href="http://osxbook.com/" title="www.osxbook.com">
    Home
    </a> <b>|</b>

  </div>

  <h4 class="oldbl" id="sidetop">About</h4>
  <div class="sublinks">

    <a href="http://osxbook.com/about/" title="About Amit Singh">
    About the Author
    </a> <b>|</b>

    <a href="http://osxbook.com/resume/" title="Amit Singh&#39;s Résumé">
    Résumé
    </a> <b>|</b>

    <a href="http://osxbook.com/contact/" title="Contact Amit Singh">
    Contact
    </a> <b>|</b>

  </div>

  <h4 class="oldbl" id="sidetop">elsewhere</h4>
  <div class="sublinks">
    <a href="http://www.kernelthread.com/" title="Visit www.kernelthread.com">
    kernelthread.com
    </a> <b>|</b>
  </div>

<!-- GOOGLE_ADSENSE_BEGIN -->
<div class="google_adsense">
<br><br>
<h4 class="oldbl" id="sidetop">adsense</h4>
<div class="sublinks">
<script type="text/javascript"><!--
google_ad_client = "pub-6436753395229860";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_channel ="";
google_color_border = "EAEAF4";
google_color_bg = "EDEDED";
google_color_link = "1C1C7F";
google_color_url = "2C2C99";
google_color_text = "000000";
//--></script>
<script type="text/javascript" src="./Booting Mac OS X_files/f.txt">
</script>
<br>
<script type="text/javascript" src="./Booting Mac OS X_files/f.txt">
</script>
</div>
</div>
<!-- GOOGLE_ADSENSE_END -->

<!-- GOOGLE_ANALYTICS_BEGIN -->
<script src="./Booting Mac OS X_files/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-238650-1";
urchinTracker();
</script>
<!-- GOOGLE_ANALYTICS_END -->

</div>

<div id="main">

<!-- InstanceBeginEditable name="editable-region-main" -->
<!--****zzzEDIT****-->
<!-- t-main -->
<!-- InstanceEndEditable -->
<h1>What is Mac OS X?</h1>
<cite>
© Amit Singh. All Rights Reserved.
<span id="date">Written in December 2003</span></cite><br><br>

<h2 id="osx">Booting Mac OS X</h2>
<p id="paperbox">
<img src="./Booting Mac OS X_files/boot.gif" width="48" height="48" style="float: left; margin-top: .5em; margin-right: .5em;">

This page contains a brief description of the Mac's firmware (analogous to the PC BIOS in many respects), the bootloader, and the typical Mac OS X boot up sequence. There are significant differences between how older (68k, "Old World" PowerMacs) and newer (everything currently, but essentially "New World" machines with Open Firmware 3.x that <em>load</em> ROM from a file) boot. The discussion here applies to the newer systems.
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
The firmware is not part of Mac OS X, but it plays an important role in the operation of the machine, and is useful in debugging. Hence, we discuss it here.
</p>

<h3>Open Firmware</h3>
<h5 id="osx">Background</h5>
<p id="paperbox">
Open Firmware (<em>IEEE-1275 Standard for Boot Firmware: Core Requirements and Practices</em>) is a non-proprietary, platform (CPU and system) independent boot firmware. Similar to a PC's BIOS, Open Firmware is stored in ROM and is the first stored program to be executed upon power-up.
</p>
<p id="paperbox">
An Open Firmware implementation is based on the Forth programming language, in particular, the FCode dialect (FCode is an ANS Forth compliant dialect that supports compilation of FCode source to bytecode). Apple and Sun are two prominent computer system makers that use implementations of Open Firmware in their systems (Sun's trademark is called <em>OpenBoot</em>). The <a href="http://bananajr6000.apple.com/1275/home.html">Open Firmware Working Group</a>'s home page is hosted at various places, including Apple and Sun.
</p>
<p id="paperbox">
Thus, the firmware is implemented in Forth, and stored in the ROM as FCode bytecode. Device drivers that are required during system startup are also implemented similarly. Such drivers usually exist in the expansion ROM of expansion cards that are needed before the operating system has loaded.
</p>

<h5 id="osx">Interaction</h5>
<p id="paperbox">
You can enter Open Firmware by pressing the key combination <code>cmd-opt-O-F</code> just as you power on a Macintosh. The <code>cmd</code> key is the one with the Apple logo, and the <code>opt</code> (option) key is the same as the <code>alt</code> key. You should see a welcome message and some other verbiage, and should be dropped into a prompt like the following:
</p>
<p id="xcodebox">
<code>
    ok
   0 &gt;
</code>
</p>
<p id="paperbox">
You can continue booting the machine by typing <code>mac-boot</code>, or shut it down by typing <code>shut-down</code>.
</p>
<p id="paperbox">
Even though this Forth "shell" supports reasonable (for a BIOS) command line editing (you can use <code>ctrl-a</code> to go to the beginning of a line, <code>ctrl-e</code> to go to the end, <code>ctrl-u</code> to erase a line, the up-arrow key for history, etc.), you would find it more convenient (particularly if you are trying to <em>write</em> any code in the firmware) to access a Mac's Open Firmware from another (arbitrary) computer, over the network. Here is the command sequence to do this (everything is typed at the Open Firmware prompt, unless stated otherwise):
</p>
<p id="xcodebox">
<code>
    0 &gt; dev /packages/telnet
</code>
</p>
<p id="paperbox" style="background-color: #EAEAF4; padding: .5em; border: 1px solid red;">
Note that upon success, Open Firmware prints the string "<code>ok</code>" on the <em>same line</em> as you press &lt;return&gt;. In the examples on this page, if you see <code>ok</code>, remember that it is printed by Open Firmware and you are not supposed to type it in (it's not a valid Open Firmware word anyway).
</p>
<p id="paperbox">
If your Mac's Open Firmware includes the <code>telnet</code> package, you would see:
</p>
<p id="xcodebox">
<code>
    0 &gt; dev /packages/telnet  ok
</code>
</p>
<p id="paperbox">
If you do get an <code>ok</code>, you can run a TELNET server on it:
</p>
<p id="xcodebox">
<code>
    " enet:telnet,10.0.0.1" io
</code>
</p>
<p id="paperbox">
This would run a TELNET server on the machine with IP address <code>10.0.0.1</code> (you can and should choose any appropriate address). Thereafter, you can connect to Open Firmware on this machine using a TELNET client - say, from a Windows machine. See <a href="http://osxbook.com/mac/apme/hanoi/" title="The Towers of Hanoi in Open Firmware"><em>The Towers of Hanoi in Open Firmware</em></a> for a programming example.
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
Note that current (at least G4 and above) Apple computers come with Ethernet ports that are auto-sensing and self-configuring, so you do <em>not</em> need a cross-over cable to connect it directly to another computer (no hub is required, etc.).
</p>

<h5 id="osx">Examples</h5>

<p id="paperbox">
<strong>1.</strong> The following command prints the device tree:
</p>
<p id="xcodebox">
<code>
0 &gt; dev / ls
ff880d90: /cpus
ff881068:   /PowerPC,750@0
ff881488:    /l2-cache
ff882148: /chosen
ff882388: /memory@0
ff882650: /openprom
ff882828:  /client-services
...
More [&lt;space&gt;,&lt;cr&gt;,q,a] ? _
</code>
</p>

<p id="paperbox">
<strong>2.</strong> The following command gives you information about installed RAM:
</p>
<p id="xcodebox">
<code>
0 &gt; dev /memory .properties ok
name                       memory
device_type                memory
reg                        00000000  10000000
                           10000000  10000000
slot-names                 00000003
                           SODIMM0/J25LOWER
                           SODIMM1/J25UPPER
...
dimm-types                 DDR SDRAM
                           DDR SDRAM
dimm-speeds                PC2700U-25330
                           PC2700U-25330
...
</code>
</p>
<p id="paperbox">
The machine in the above command (a PowerBook G4 15, although that is not relevant) has two PC2700 DDR SDRAM chips installed. The two pairs of numbers against <code>reg</code> are specify the starting address and size of the chips. Thus, the first RAM chip starts at address <code>0x0000000</code> and has a size <code>0x10000000</code> (which is 256 MB). The second chip starts at <code>0x1000000</code> (256 MB) and has a size 256 MB. The total RAM is thus 512 MB.
</p>
<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
If you need to <em>reduce</em> the installed RAM size (as seen by Mac OS X) for any reason, without actually having to remove a RAM stick (or you want to simulate an arbitrary size that's less than the total installed RAM), you can actually <em>delete</em> the <code>reg</code> entry using the <code>delete-property</code> command, and specify your own <code>reg</code>. Referring to the previous example of the 512 MB PowerBook, the following command essentially <em>disables</em> the second RAM stick (note that this change is <em>not</em> written to NVRAM - it is transient - once you reboot, the other chip will be detected and used as before):
</p>
<p id="xcodebox">
<code>
0 &gt; " reg" delete-property  ok
0 &gt; 0 encode-int 10000000 encode-int encode+ " reg" property  ok
</code>
</p>
<p id="paperbox" style="background-color: #F4EAEA; border: 1px solid red; padding: .5em;">
It must be kept in mind though that the reg properties can change from machine to machine, or more likely with architectural changes (for example, the format changed with the PowerMac G5). A less adventurous and more appropriate way to limit visible RAM is to use the <code>maxmem</code> boot argument, such as at the shell prompt:
</p>
<p id="xcodebox">
<code>
# nvram boot-args="maxmem=128"
</code>
</p>

<p id="paperbox">
<strong>3.</strong> The following command sequence shows you various information on the machine's CPU(s):
</p>
<p id="xcodebox">
<code>
0 &gt; dev /  ok
0 &gt; dev /cpus  ok
0 &gt; ls
ff886d58:  /PowerPC,G4@0
ff8871f8:    /l2-cache
 ok
0 &gt; dev PowerPC,G4@0  ok
0 &gt; .properties
name                       cpu
reg                        00000000
cpu-version                80020101
state                      running
clock-frequency            4a817c7b
bus-frequency              09ef21aa
...
</code>
</p>
<p id="paperbox">
The rest of the output contains various cache sizes, the processor's graphics capabilities (Altivec, support for certain instructions, ...), and so on. You can think of this as analogous to <code>/proc/cpuinfo</code> on Linux.
</p>

<p id="paperbox">
<strong>4.</strong> The following command lists files in the root directory of the disk (partition) referred to by the "alias" <code>hd</code>
</p>
<p id="xcodebox">
<code>
0 &gt; dir hd:\

        Size/            GMT                  File/Dir
        bytes       date         time         Name
         6148     12/25/ 3      4:25:25       .DS_Store
          156      9/12/ 3     20:41:59       .hidden
       589824     12/25/ 3      6:45: 6       .hotfiles.btree
...
</code>
</p>

<p id="paperbox">
<strong>5.</strong> The following command expands the alias <code>hd</code>, and gives you the complete path of the device in the tree (type <code>devalias</code> by itself to see a list of current aliases, along with what they refer to):
</p>
<p id="xcodebox">
<code>
0 &gt; devalias hd /pci@f4000000/ata-6@d/disk@0 ok
</code>
</p>

<p id="paperbox">
<strong>6.</strong> You can load a file (kernel) using the <code>load</code> command, and boot it using the <code>boot</code> command. As stated earlier, <code>mac-boot</code> and <code>shut-down</code> are predefined to boot the machine normally, or shut it down, respectively. You can get and set variables (options) using the <code>printenv</code> and <code>setenv</code> commands. These variables are stored in the non-volatile memory (NVRAM) of Open Firmware. For example, if you want your email address to be used as the "OEM banner", you should do the following:
</p>
<p id="xcodebox">
<code>
0 &gt; setenv oem-banner you@your.email.address
0 &gt; setenv oem-banner? true
</code>
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
You do not actually need to drop into Open Firmware to set the NVRAM variables. You can access (get and set) these from within Mac OS X via the <code>nvram</code> command line utility.
</p>

<p id="paperbox">
To sum up, Open Firmware is a powerful tool for controlling, debugging, and exploring the computer.
</p>

<h5 id="osx">Operation</h5>
<p id="paperbox">
When an Open Firmware equipped Macintosh (all current Apple systems at the time of this writing) is powered on, hardware is diagnosed (by some POST code) and initialized. The first entity to control the CPU thereafter is the firmware. Open Firmware (which runs with interrupts disabled) builds a device tree, probes slots for devices, queries PCI devices and assigns them address space appropriately, and then looks for the default boot device (unless one was specified explicitly). The following "snag" keys let the user specify a boot device as the system is powered on:
</p>
<p id="xcodebox">
<code>
C     device referred to by the 'cd' alias, a CD-ROM drive
D     device referred to by the 'hd' alias, a hard disk drive
N     device referred to by the 'enet' alias, a network card
Z     device referred to by the 'zip' alias, a ZIP drive
</code>
</p>
<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
It is worth noting that pressing <code>T</code> while your Mac powers on would boot it into what's called the <em>FireWire Target Disk Mode</em>. Essentially, your Mac becomes a fancy external FireWire disk drive.
</p>
<p id="paperbox">
You can also specify the complete pathname of a device, or have the machine boot over the network using TFTP:
</p>
<p id="xcodebox">
<code>
boot enet:&lt;server IP&gt;,&lt;file&gt;,&lt;my IP&gt;;&lt;subnet&gt;,;&lt;gateway IP&gt;
</code>
</p>
<p id="paperbox">
If Open Firmware fails to find a boot device, a <em>blinking folder</em> is displayed.
</p>
<p id="paperbox">
Open Firmware then loads a file of type <code>tbxi</code> (ToolBox ROM Image, for historical reasons) from the system partition. Note that this would have been the file called "<code>Mac OS ROM</code>" in the System Folder on Mac OS 9, while OS X loads <code>/System/Library/CoreServices/BootX</code>, which is the bootloader as well. BootX is then executed and Control is then passed to it.
</p>
<p id="paperbox">
Note that Open Firmware can directly load ELF, XCOFF and "bootinfo" (any supported format with an XML header) binaries, but not Mach-O, the native executable format on Mac OS X. BootX can load Mach-O binaries.
</p>

<h3>Bootloader</h3>
<p id="paperbox">
BootX (<code>/System/Library/CoreServices/BootX</code>) is the default bootloader on Mac OS X.
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
BootX is also the name of an open source bootloader (different from Apple's BootX) that allows dual-booting Mac OS and Linux on "Old World" machines.
</p>

<p id="paperbox">
BootX can load kernels from various filesystems: HFS+, HFS, UFS, ext2, and TFTP (network, abstracted to look like a filesystem). In addition to Mach-O, BootX can also load ELF kernels, although Mac OS X does not use this feature. To reiterate, BootX can load ELF kernels from an ext2 partition!
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
The "Old World" Macs had various issues with the implementation of Open Firmware, which in turn caused many booting problems for Apple engineers, and even more problems for the PowerPC Linux port. Now, Apple had access to the firmware's source. They solved most of the problems either via NVRAM patches, or by integrating required changes into BootX itself (in the instances where the changes could not be implemented as patches). As BootX matured, Apple added support for ext2 and ELF with the goal of making the platform more amenable to PowerPC Linux.
</p>

<p id="paperbox">
The sequence of events when BootX starts executing (after being handed control by Open Firmware) is described below:
</p>
<ul style="list-style: square; text-align: justify;">
<li>BootX first initializes the Open Firmware client interface (that it would use to talk to the firmware), and retrieves the firmware version.
</li>
<li>
It then creates a pseudo-device called <code>sl_words</code> ('sl' implies <em>secondary loader</em>) in the firmware, and defines various FORTH words in it (it is here that code for the spinning cursor is set up).
</li>
<li>
BootX looks up the <code>options</code> device in the firmware, which contains various variables (that you can see and set using the <code>printenv</code> and <code>setenv</code> commands in Open Firmware).
</li>
</ul>
<p id="xcodebox">
<code>
0 &gt; dev /options .properties
name                options
little-endian?      false
real-mode?          false
auto-boot?          true
diag-switch?        false
...
boot-command        mac-boot
...
</code>
</p>
<ul style="list-style: square; text-align: justify;">
<li>
BootX looks up the <code>chosen</code> device, which contains handles for entities such as the boot input/output devices, memory, the MMU, the PMU, the CPU, the PIC, etc. For example, the following command at the Open Firmware prompt shows you the contents of <code>chosen</code>:
</li>
</ul>

<p id="xcodebox">
<code>
0 &gt; dev /chosen  ok
0 &gt; .properties
name                chosen
stdin               ffbc6e40
stdout              ffbc6600
memory              ffbdd600
mmu                 ...
...
</code>
</p>

<ul style="list-style: square; text-align: justify;">
<li>
BootX initializes handles to the MMU and memory using <code>chosen</code>.
</li>
<li>
BootX initializes handles to the boot display and the keyboard (if present).
</li>
<li>
BootX checks if the "security mode" is "none", or 
</li>
<li>
BootX checks if the "verbose" (<code>cmd-v</code>) or "single user" (<code>cmd-s</code>) flags were specified, and sets the "output level" accordingly.
</li>
<li>BootX checks if the system is booting in "Safe Mode".</li>
<li>BootX claims memory for various purposes.</li>
<li>BootX finds all displays and sets them up. It does this by searching for nodes of type "display" in the device tree. The primary display is referred to by the <code>screen</code> alias. For example, you can try this at the Open Firmware prompt:</li>
</ul>
<p id="xcodebox">
<code>
0 &gt; dev screen  ok
0 &gt; .properties
name            ATY,Bee_A
compatible      ATY,Bee
width           00000400
height          00000300
linebytes       00000400
depth           00000008
display-type    4c434400
device_type     display
character-set   ISO859-1
...
</code>
</p>
<ul style="list-style: square; text-align: justify;">
<li>While opening the display(s), BootX also sets the screen color to the familiar whitish gray.</li>
<li>BootX looks up the boot device, boot arguments, etc., and determines where to get the kernel from (via a network device, from a block device, etc.), whence the path to the kernel file (<code>mach_kernel</code>) is constructed. If booting from a block device (which is the usual case), the path to the kext cache (see <code>kextcache(8)</code>) is calculated, along with the extensions directory (usually <code>/System/Library/Extensions</code>).
</li>
</ul>
<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
Mac OS X uses a few kinds of "kext" (kernel extension) caches to speed up loading of kexts. Kernel caches are kept in the directory <code>/System/Library/Caches/com.apple.kernelcaches</code>. The cache files are named <code>kernelcache.XXXXXXXX</code>, where the suffix is a 32-bit <code>adler</code> checksum (the same algorithm as used by Gzip).
</p>
<ul style="list-style: square; text-align: justify;">
<li>At this point, BootX draws the Apple logo splash screen, and starts the spinning cursor. If booting from a network device, a spinning globe is drawn instead.</li>
<li>Depending on various conditions, BootX tries to retrieve and load the kernel cache file.
</li>
<li>
The next step is to "decode" the kernel. If the kernel header indicates a compressed kernel, BootX tries to decompress it (typical LZSS compression is used, as you compress this kind of data once but expand it many times). Since the kernel binary can potentially be a "fat" binary (code for multiple architectures residing in the same binary), BootX checks if it indeed is (fat), and if so, "thins" it (figures out the PowerPC code).
</li>
<li>
BootX attempts to decode the file (possibly "thinned") as a Mach-O binary. If this fails, BootX also tries to decode it as ELF.
</li>
<li>
If the above fails, BootX gives up, draws the failed boot picture, and goes into an infinite loop.
</li>
<li>
If BootX is successful so far, it saves filesystem cache hits, misses and evicts,  sets up various boot arguments and values (such as whether this is a graphical or verbose boot, whether there are some flags to be passed to the kernel, the size of installed RAM), and also calls a recursive function to flatten the device tree.
</li>
<li>
Finally, BootX "calls" the kernel, immediately before which it "quiesces" Open Firmware, an operation as a result of which any asynchronous tasks in the firmware, timers, or DMA get stopped, etc.
</li>
</ul>

<p id="paperbox">
</p>

<h3>System Startup</h3>
<p id="paperbox">
Mac OS X user level startup is neither pure BSD style, nor SYSV style, although the presence of <code>/etc/rc</code> indicates a BSD heritage. In fact, various things are unsurprisingly similar to NEXTSTEP.
</p>
<p id="paperbox">
The next section, <a href="http://osxbook.com/book/bonus/ancient/whatismacosx//arch_xnu.html" title="XNU: The Kernel"><em>XNU: The Kernel</em></a>, describes some of the things the kernel does as it comes up. <a href="http://osxbook.com/book/bonus/ancient/whatismacosx//arch_startup.html" title="Mac OS X System Startup"><em>Mac OS X System Startup</em></a> continues with a description of (mostly) user-level startup.
</p>

<h3>BootCache</h3>
<p id="paperbox">
Mac OS X uses a boot-time optimization (effectively a smart readahead) called "BootCache" that monitors the pattern of incoming read requests to a block device (the boot disk), and sorts the pattern into a "playlist" (it also measures the cache hit rate and stores the request pattern into a "history list" for being adaptive in future).
</p>
<p id="paperbox">
The loadable (sorted) read pattern is stored in <code>/var/db/BootCache.playlist</code>. Once this is loaded, the cache comes into effect.
</p>
<p id="paperbox">
Note that this feature requires <em>at least</em> 128 MB of physical RAM before it is enabled (automatically).
</p>

<p id="paperbox" style="background-color: #EAEAF4; border: 1px solid rgb(65%,65%,85%); padding: .5em;">
<code>/System/Library/Extensions/BootCache.kext</code> is the location of the kernel extension implementing the cache while <code>Contents/Resources/BootCacheControl</code> within that directory is the user-level control utility (it lets you load the playlist, among other things). The effectiveness of BootCache can be gauged from the following: in a recent update to "Panther", a reference to BootCacheControl was broken. BootCache is started (via the control utility) in <code>/etc/rc</code>, and a prefetch tag is inserted (unless the system is booting in safe mode). <code>/etc/rc</code> looks for <code>BootCacheControl</code> in the "kext" directory, as well as in <code>/usr/sbin</code>, and finds it in the former (it doesn't exist in the latter). However, another program (possibly <code>loginwindow.app</code>) accesses <code>/usr/sbin/BootCacheControl</code> directly, and does not find it. For what it's worth, making <code>BootCacheControl</code> available in <code>/usr/sbin</code>, say via a symlink, reduces the boot time (measured from clicking on the "Restart" confirmation button to the point where <em>absolutely</em> everything has shown up on the system menu) from 135 seconds to 60 seconds on one of my machines!
</p>

<div class="gonav">
<table class="gonav">
  <tbody><tr>
    <td class="gol">
      <code>&lt;&lt;&lt;</code> <a href="http://osxbook.com/book/bonus/ancient/whatismacosx//arch.html" title="Architecture of Mac OS X">Architecture of Mac OS X</a>
    </td>
    <td class="gom">
      <a href="http://osxbook.com/book/bonus/ancient/whatismacosx//index.html" title="What is Mac OS X?"><code>main</code></a>
    </td>
    <td class="gor">
      <a href="http://osxbook.com/book/bonus/ancient/whatismacosx//arch_xnu.html" title="XNU: The Kernel">XNU: The Kernel</a> <code>&gt;&gt;&gt;</code>
    </td>
  </tr>
</tbody></table>
</div>

<!-- InstanceEndEditable -->

</div>

<div id="footer">
  <p>
  All contents of this site, unless otherwise noted, are ©1994-2014 <strong>Amit Singh</strong>. All Rights Reserved. <a href="http://osxbook.com/legalese/">Terms of Use</a>
  </p>
</div>

<!-- InstanceEnd -->
</body></html>