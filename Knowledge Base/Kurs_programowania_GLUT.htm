<http://4programmers.net/d1ef85dbc2eb861b21673afd3a86fa44/>

 
Logowanie <http://4programmers.net/ucp.php?mode=login> | Rejestracja
<http://4programmers.net/ucp.php?mode=register> | Forum
<http://forum.4programmers.net/> | Pomoc <http://4programmers.net/Pomoc>
| Reklama <http://4programmers.net/Reklama> | Szukaj
<http://4programmers.net/search.php> Szukaj

Strona g³ówna - programowanie <http://4programmers.net/>
Strona g³ówna <http://4programmers.net/> :: Z pogranicza
<http://4programmers.net/Z_pogranicza>	 


  Kurs programowania GLUT
  <http://4programmers.net/Z_pogranicza/Kurs_programowania_GLUT>

    * Edytuj
      <http://4programmers.net/text.php?mode=edit&subject=Z_pogranicza/Kurs_programowania_GLUT>
    * Historia <http://4programmers.net/text.php?mode=history&id=519>

Kurs programowania w GLUT
Neuro 2004
------------------------------------------------------------------------
*Spis tre¶ci*

     1 PRZEDMOWA <#id-PRZEDMOWA>
     2 WSTÊP <#id-WSTÊP>
          2.1 Przegl±d Funkcji <#id-Przegl±d-Funkcji>
     3 START <#id-START>
          3.1 KOMPILACJA <#id-KOMPILACJA>
               3.1.1 KOMPILACJA OS/2 <#id-KOMPILACJA-OS/2>
               3.1.2 KOMPILACJA WINDOWS <#id-KOMPILACJA-WINDOWS>
          3.2 PIERWSZY PROGRAM <#id-PIERWSZY-PROGRAM>
          3.3 INTERAKCJA <#id-INTERAKCJA>
          3.4 OKNO <#id-OKNO>
          3.5 WY¦WIETLANIE <#id-WY¦WIETLANIE>
          3.6 MENU <#id-MENU>
          3.7 TIMER <#id-TIMER>
          3.8 MODELE <#id-MODELE>
          3.9 PISANIE <#id-PISANIE>
          3.10 TRYB GRY <#id-TRYB-GRY>
          3.11 INFORMACJE <#id-INFORMACJE>
          3.12 MAPY KOLORÓW <#id-MAPY-KOLORÓW>
          3.13 WARSTWY <#id-WARSTWY>
          3.14 VIDEO <#id-VIDEO>
          3.15 DODATKI <#id-DODATKI>
------------------------------------------------------------------------


  PRZEDMOWA


Art. Bêdzie mia³ sporo braków i wiele niedomówieñ, bo zamierzam pisaæ go
tak jak to robiono na NeHe (polecam, ostatnio nawet powstaje polskie
t³umaczenie). Bêdê opiera³ siê na plikach nag³ówkowych i dokumentacji.
Czê¶ci funkcji niestety nie przetestuje bo po prostu nie jest to mo¿liwe
na sprzêcie który posiadam. No to do dzie³a...


  WSTÊP


GLUT (ang. OpenGL Utility Toolkit) to API (interfejs programowania
aplikacji) dla OpenGL (biblioteka graficzna, jak by kto¶ nie wiedzia³ ;)
). Ostatnia wersja to zdaje siê 3.7 (wysz³a gdzie¶ ko³o 98 roku, wiêc to
niez³y staroæ, ale na szczê¶cie projekt rozwijany jest pod innymi
nazwami m.in. freeglut). Glut jest zaimplementowany na kilka platform
sprzêtowych (Windows,Linux,MacOS), i powsta³y pliki nag³ówkowe dla C,
Delphi, Ady i Fortrana (zwykle za³±czane tylko do C, ale pozosta³e mo¿na
znale¿æ w Internecie). Jego zalet± jest przeno¶no¶æ tzn. np. program
napisany na Linux'ie mo¿e bez wiêkszych przeróbek zostaæ skompilowany
pod Windows, i ³atwo¶æ obs³ugi - krótkie logicznie zbudowane funkcje.
GLUT s³u¿y do utworzenia okna, prostego GUI (graficzny interfejs
u¿ytkownika) i interakcji z u¿ytkownikiem (mycha, klawiatura, joystick).
Dziêki u¿yciu GLUT'a unikamy u¿ywania API przystosoanego do danego
systemu operacyjnego (Windows - WGL z WinAPi, OWL, Linux - GLX z
XWindow, GTK, QT).


    Przegl±d Funkcji


UWAGA ! Poni¿sza lista dotyczy freeglut i posiada pewne niezgodno¶ci z GLUT.

   1. Initialization Functions (Inicjalizajca)
         1. glutInit
         2. glutInitWindowPosition, glutInitWindowSize
         3. glutInitDisplayMode
         4. glutInitDisplayString
   2. Event Processing Functions (Zdarzenia)
         1. glutMainLoop
         2. glutMainLoopEvent
         3. glutLeaveMainLoop
   3. Window Functions (Funkcje dotycz±ce okien)
         1. glutCreateWindow
         2. glutCreateSubwindow
         3. glutDestroyWindow
         4. glutSetWindow, glutGetWindow
         5. glutSetWindowTitle, glutSetIconTitlew
         6. glutReshapeWindow
         7. glutPositionWindow
         8. glutShowWindow, glutHideWindow, glutIconifyWindow
         9. glutPushWindow, glutPopWindow
        10. glutFullScreen
   4. Display Functions (Wy¶wietlanie)
         1. glutPostRedisplay
         2. glutPostWindowRedisplay
         3. glutSwapBuffers
   5. Mouse Cursor Functions (Kursor myszy)
         1. glutSetCursor
         2. glutWarpPointer
   6. Overlay Functions (Warstwy)
         1. glutEstablishOverlay
         2. glutRemoveOverlay
         3. glutUseLayer
         4. glutPostOverlayRedisplay
         5. glutPostWindowOverlayRedisplay
         6. glutShowOverlay, glutHideOverlay
   7. Menu Functions (Menu)
         1. glutCreateMenu
         2. glutDestroyMenu
         3. glutGetMenu, glutSetMenu
         4. glutAddMenuEntry
         5. glutAddSubMenu
         6. glutChangeToMenuEntry
         7. glutChangeToSubMenu
         8. glutRemoveMenuItem
         9. glutAttachMenu, glutDetachMenu
   8. Global Callback Registration Functions (Globalne funkcje typu
      zwrotnego)
         1. glutTimerFunc
         2. glutIdleFunc
   9. Window-Specific Callback Registration Functions (Ustalane dla okna
      funkcje typu zwrotnego)
         1. glutDisplayFunc
         2. glutOverlayDisplayFunc
         3. glutReshapeFunc
         4. glutKeyboardFunc
         5. glutSpecialFunc
         6. glutKeyboardUpFunc
         7. glutSpecialUpFunc
         8. glutMotionFunc, glutPassiveMotionFunc
         9. glutVisibilityFunc
        10. glutEntryFunc
        11. glutJoystickFunc
        12. glutSpaceballMotionFunc
        13. glutSpaceballRotateFunc
        14. glutSpaceballButtonFunc
        15. glutButtonBoxFunc
        16. glutDialsFunc
        17. glutTabletMotionFunc
        18. glutTabletButtonFunc
        19. glutMenuStatusFunc
        20. glutWindowStatusFunc
  10. State Setting and Retrieval Functions (Pobranie stanu okna)
         1. glutSetOption
         2. glutGet
         3. glutDeviceGet
         4. glutGetModifiers
         5. glutLayerGet
         6. glutExtensionSupported
         7. glutGetProcAddress
  11. Font Rendering Functions (Wy¶wietlanie czcionek)
         1. glutBitmapCharacter
         2. glutBitmapString
         3. glutBitmapWidth
         4. glutBitmapLength
         5. glutBitmapHeight
         6. glutStrokeCharacter
         7. glutStrokeString
         8. glutStrokeWidth
         9. glutStrokeLength
        10. glutStrokeHeight
  12. Geometric Object Rendering Functions (Obiekty geometryczne)
         1. glutWireSphere, glutSolidSphere
         2. glutWireTorus, glutSolidTorus
         3. glutWireCone, glutSolidCone
         4. glutWireCube, glutSolidCube
         5. glutWireTetrahedron, glutSolidTetrahedron
         6. glutWireOctahedron, glutSolidOctahedron
         7. glutWireDodecahedron, glutSolidDodecahedron
         8. glutWireIcosahedron, glutSolidIcosahedron
         9. glutWireRhombicDodecahedron, glutSolidRhombicDodecahedron
        10. glutWireTeapot, glutSolidTeapot
  13. Game Mode Functions (Tryb gry)
         1. glutGameModeString
         2. glutEnterGameMode, glutLeaveGameMode
         3. glutGameModeGet
  14. Video Resize Functions (Zmiana Video)
         1. glutVideoResizeGet
         2. glutSetupVideoResizing, glutStopVideoResizing
         3. glutVideoResize
         4. glutVideoPan
  15. Color Map Functions (Mapy kolorów)
         1. glutSetColor, glutGetColor
         2. glutCopyColormap
  16. Miscellaneous Functions (Pozosta³e)
         1. glutIgnoreKeyRepeat, glutSetKeyRepeat
         2. glutForceJoystickFunc
         3. glutReportErrors


  START


Dobra, zaczynamy. Ja bêdê pisa³ pod Linux'a (Mandrake 9.2) i kompilowa³
przy u¿yciu gcc (wiêc jak siê mo¿na by³o domy¶liæ bêdê u¿ywa³ C). Co
jest wymagane? Znajomo¶æ C i OpenGL ofcourse. Je¶li idzie o soft to:
jaki¶ Linux z gcc, OpenGL i GLUT, albo Windows + odpowiedni kompilator +
biblioteki. Potem mo¿e napiszê uzupe³nienie na Windows, ale jeszcze zobaczê.
UWAGA ! W niektórych dystrybucjach Linux'a GLUT nie jest standardowo
instalowany (u mnie trzeba by³o wybraæ samodzielnie pakiety, prze³±czyæ
widok na listê i dopiero znale¥æ co¶ w stylu libMESA-GLUT (z "devel" to
pliki nag³ówkowe) czy coæ takiego [MESA - to taka wersja OpenGL]).
Powiniene¶ obs³ugiwaæ jako tako Linux'a wiêc:
xterm, aterm, gnome-terminal, kterm - terminale (tu siê pisze komendy):
cd - polecenie zmieñ katalog (.. aby przejsc do gory, / aby przejsc na
szczyt drzewa)
np.
cd /root/glut - przechodzi do katalogu /root/glut
mc - najlepszy tekstowy mened¿er plików
kwrite, gedit itp. - edytory textu (w tym bêdziemy pisaæ)


    KOMPILACJA


Do kompilacji bêdzie nam potrzebny plik "makefile" (oczywi¶cie bez
cudzys³owiu). Nie znam siê na tworzeniu makefile wiêc po prostu otwórz
jaki¶ edytor i wpisz (skopiuj):

INCLUDE = -I/usr/include/
LIBDIR  = -L/usr/X11R6/lib

COMPILERFLAGS = -Wall
CC = gcc
CFLAGS = $(COMPILERFLAGS) $(INCLUDE)
LIBRARIES = -lX11 -lXi -lXmu -lglut -lGL -lGLU -lm

# for all, set the targets to be every lesson1.c-lesson13.c
# file, removing the .c extension.  That is, at this point,
# it would produce lesson1, lesson2, lesson3,...,lesson13 targets.
#
all: $(basename $(wildcard lesson[1-9].c lesson1[0-3].c))

# same as for all, except set the targets to be
# lessonX.tar.gz from lessonX.c.  This is really
# only used to build smaller tutorial .tar.gz files
# to send to nehe.
#
dist: $(foreach file,$(basename $(wildcard lesson[1-9].c
lesson1[0-3].c)),$(file).tar.gz)

# to produce, say, lesson1.tar.gz:
#
# 1. remove lesson1.tar.gz
# 2. build lesson1.tar containing README, makefile, lesson1.c,
Data/lesson1/*.
# 3. gzip lesson1.tar.
#
lesson%.tar.gz :
        tar cvf $(subst .tar.gz,.tar,$@) README makefile $(subst
.tar.gz,.c,$@) $(wildcard Data/$(subst .tar.gz,,$@)/*); \
        gzip $(subst .tar.gz,.tar,$@);

# to produce, say, lesson1:
#
# 1. compile the thing.  uses the variables defined above.
#
lesson% : lesson%.o
        $(CC) $(CFLAGS) -o $@ $(LIBDIR) $< $(LIBRARIES)

# to clean up:
# delete all of the lessonX files.
clean:
        rm $(wildcard lesson[1-9] lesson1[0-3])

# to clean up the distributions:
# delete all of the lessonX.tar.gz files.
distclean:
        rm $(wildcard lesson[1-9].tar.gz lesson1[0-3].tar.gz)

Pierwsze linijki okre¶laj± katalog plików nag³ówkowych i bibliotek
(trzeba dodaæ glut, GLU, GL), dalej ustawienia kompilatora i co ma byæ
wykonywane.

Ok. teraz zapisz to w jakim¶ katalogu (np. /_glut).

Dziêki temu plikowi ("makefile"), aby skompilowaæ jaki¶ kod wystarczy,
¿e zapiszemy go w tym samym katalogu (co zapisany zosta³ makefile),
nazwiemy "lesson1.c" i po wpisaniu w terminalu (po przej¶ciu do
odpowiedniego katalogu poleceniem cd) "make" (ewentualnie z parametrem
"makefile"), otrzymamy skompilowany plik wykonywalny, który mo¿emy
uruchomiæ poleceniem "./lesson1" lub klikaj±c w jakiej¶ przegl±darce
plików (np. nautilus, konqueror ew. mc).


      KOMPILACJA OS/2


Zamieszczam metodê kompilacji pod zapomniany nieco system OS/2. Mo¿e siê
to komu¶ przyda... Nie testowa³em bo go nie mam.
1. W programie dopisujemy standardowe nag³ówki:
#include <GL/gl.h>
#include <GL/glut.h>
 

2. I kompilujemy z wiersza poleceñ:
cc -fullwarn -O2 -s -o crisscross crisscross.c -lc -lglut -lGL -lGLU
-lX11 -lXmu -lXi -lXext -lm
Gdzie:

   1. fullwarn- extra sprawdzanie
   2. O2- optymalizacja
   3. s - stripped of debug info
   4. c - biblioteka C
   5. glut- biblioteka I/O glut (zast±piæ "-lglut" z "libglut.a" je¶li
      skopiowane lokalnie)
   6. GL - biblioteka OpenGL
   7. GLU - biblioteka OpenGL Utility
   8. X11, Xmu, Xext, Xi - biblioteka X window
   9. m - matematyka


      KOMPILACJA WINDOWS


Aby korzystaæ z GLUT pod Windows najpierw nale¿y ¶ciagn±æ odpowiednie
biblioteki z Internetu. Wystarczy wpsiaæ w dowolnej wyszukiwarce
"download GLUT" i wybraæ pierwsz± stronê z brzegu. Zwykle wszytsko jest
w postaci pliku zip. Nale¿y go wypakowaæ, a nastêpnie skopiowaæ
odpowiednie pliki. Na windows aby uruchomiæ program korzystaj±cy z GLUT
nale¿y za³±czaæ zawsze do programu bibliotekê GLUT32.dll. Jednak na
swoje potrzeby wystarczy przekopiowaæ dll'a do folderu systemowego
(C:\Windows czy C:\Windows\System32). Plik glut32.lib nale¿y
przekopiowaæ do folderu lib w katalogu z kompilatorem, a plik glut.h do
folderu GL w include. I to tyle (dla Dev-Cpp i MSVC) Na Borlandzie
sprawa wygl±da inaczej - aby skompilowaæ program nale¿y dodaæ oczywi¶cie
GLUT do u¿ywanych bibliotek. Mo¿emy to zrobiæ np. dopisuj±c w kodzie
programu wiersz:
#pragma comment(lib,"glut32.LIB")
 


    PIERWSZY PROGRAM



//Có¿, nie jest to "Hello world !", ale co¶ bardzo zbli¿onego ;)
#include <GL/glut.h>    // Header File For The GLUT Library
//#include <GL/gl.h>        // Header File For The OpenGL32 Library
//#include <GL/glu.h>        // Header File For The GLu32 Library
/* The number of our GLUT window */
int <http://4programmers.net/C/Int> window;
/* A general OpenGL initialization function.  Sets all of the initial
parameters. */
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                // This Will
Clear The Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_SMOOTH);                        // Enables Smooth
Color Shading
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);     
  // Calculate The Aspect Ratio Of The Window
  glMatrixMode(GL_MODELVIEW);
}


/* The function called when our window is resized (which shouldn't
happen, because we're fullscreen) */
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);
  glMatrixMode(GL_MODELVIEW);
}

/* The main drawing function. */
void <http://4programmers.net/C/Void> DrawGLScene()
{
glutSetWindow(window);                                        //Set
active window

  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
  //Tutaj wstawiamy kod rysuj±cy scenê
  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}

int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  /* Initialize GLUT state - glut will take any command line arguments
that pertain to it or
     X Windows - look at its documentation at
http://reality.sgi.com/mjk/spec3/spec3.html */
  glutInit(&argc, argv);

  /* Select type of Display mode:
     Double buffer
     RGBA color
     Alpha components supported
     Depth buffered for automatic clipping */
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
//W przypadku b³êdów po odpaleniu usun±æ  GLUT_ALPHA |

  /* get a 640 x 480 window */
  glutInitWindowSize(640, 480);

  /* the window starts at the upper left corner of the screen */
  glutInitWindowPosition(0, 0);

  /* Open a window */
  window = glutCreateWindow("GLUT TUTORIAL #1");

  /* Register the function to do all our OpenGL drawing. */
  glutDisplayFunc(&DrawGLScene);

  /* Go fullscreen.  This is as soon as possible. */
  glutFullScreen();

  /* Even if there are no events, redraw our gl scene. */
  glutIdleFunc(&DrawGLScene);

  /* Register the function called when our window is resized. */
  glutReshapeFunc(&ReSizeGLScene);

  /* Initialize our window. */
  InitGL(640, 480);

  /* Start Event Processing Engine */
  glutMainLoop();

  /* shut down our window */
  glutDestroyWindow(window);

  return <http://4programmers.net/C/Return> 1;
}

Sporo tego prawda... Ale chwila popatrzmy:
#include <GL/glut.h>    // Header File For The GLUT Library
#include <GL/gl.h>        // Header File For The OpenGL32 Library
#include <GL/glu.h>        // Header File For The GLu32 Library
 

to tylko do³±czenie plików nag³ówkowych kolejno: GLUT, OpenGL, GL
utilities (rozszerzenie OpenGL). Te dwa ostatnie nie s± konieczne bo s±
ju¿ do³±czone w nag³ówkach GLUT.
Deklaracja "int window" potrzebna jest do zapamiêtania numeru okna glut
na którym potem bêdziemy wykonywaæ operacje. Procedury InitGL i
ReSizeGLScene zawieraj± jedynie procedury, które nale¿± do OpenGL i nie
bêdê ich tutaj opisywa³.
Wystarczy, ¿e powiem, i¿ InitGL zawiera inicjalizacjê wy¶wietlania
grafiki, a ReSizeGLScene zmianê perspektywy i obszaru rysowania po
zmianie rozmiaru okna. Ich parametry to szeroko¶æ i wysoko¶æ okna.
Procedura DrawGLScene() s³u¿y do wy¶wietlania sceny. Jedyn± now±
procedur± jest glutSwapBuffers(); która s³u¿y do opró¿nienia buffor'ów,
czyli po ludzku do wy¶wietlenia sceny OpenGL w oknie GLUT'a.
OK. Teraz g³ówna funkcja (main):
glutInit(&argc, argv); // inicjalizuje GLUT z parametrami podanymi dla
programu (zaimplementowane s± wszystkie parametry systemu XWindow
[czytaæ w dokumentacji])
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
//Ustala tryb wy¶wietlania GLUT, jako sumê logiczn± podanych parametrów:
mo¿liwe opcje:
GLUT_RGB                //Kolor RGB<
GLUT_RGBA                //Kolor RGBa
GLUT_INDEX                //Tryb indexowania
GLUT_SINGLE                //Pojedynczy buffer
GLUT_DOUBLE                //Podwójny<
GLUT_ACCUM                //?
GLUT_ALPHA                //Kolor alpha (przezroczysto¶æ)
GLUT_DEPTH                //Bufor automatycznego przycinania
GLUT_STENCIL                //Stencil buffer (czytaj w OpenGL)
GLUT_MULTISAMPLE        //?
GLUT_STEREO                //?
GLUT_LUMINANCE                //?
glutInitWindowSize(640, 480); //Ustawia rozmiar okna na 640x480

glutInitWindowPosition(0, 0); //Ustawia pozycjê okna na 0x0 (lewy górny róg)

window = glutCreateWindow("GLUT TUTORIAL");        //Tworzy okno z
tytu³em "GLUT TUTORIAL" i zwraca jego numer do zmiennej window
glutDisplayFunc(&DrawGLScene);                        //Ustala funkcjê
wy¶wietlania - podajemy adres do dowolnej funkcji, tutaj mamy
wswska¥niko DrawGLScene UWAGA ! Funkcja przypisuje wy¶wietlanie okna
aktywnego (tutaj: to które zosta³o utworzone ostatnio)

glutFullScreen();                                //Ustala tryb
pe³noekranowy - mo¿na spokojne wy³±czyæ

glutIdleFunc(&DrawGLScene);                        //Gdy nic siê nie
dzieje to uruchamia funkcjê podan± w parametrze, tutaj znowu mamy
DrawGLScene - (dziêki temu mo¿na przesuwaæ, zmieniaæ rozmiar itd. okna).

glutReshapeFunc(&ReSizeGLScene);                //Ustala funkcjê zmiany
rozmiaru okna, która powinna mieæ dwa parametry typu int do których
zostan± przekazane szeroko¶æ i wysoko¶æ okna  - tutaj podali¶my funkcjê
ReSizeGLScene

Dalej mamy wywo³anie funkcji InitGL(); której dzia³anie opisa³em wy¿ej.

I przedostatnia nowa funkcja:
glutMainLoop(); //G³ówna pêtla programu, wy¶wietla i obs³uguje okno oraz
odpowiada za interakcjê z u¿ytkownikiem.

Funkcja:
glutDestroyWindow(window);
niszczy okno GLUT, którego numer podajemy w parametrze (co¶ jak uchwyt w
WinApi).

Nooo. Jako¶ przesz³o.


    INTERAKCJA



OK. Teraz zajmiemy siê komunikacj± z u¿ytkownikiem:

glutKeyboardFunc(&keyPressed); //Ustala jaka funkcjê zostanie wywo³ana
po wci¶niêciu klawisza (tutaj keyPressed). Jej parametry to jedna
zmienna typu unsigned char, która zawiera klawisz jaki zosta³ wci¶niêty
oraz dwa parametry typu int które zawieraj± wspó³rzêdne myszki po
wci±niêiciu klawisza. Przyk³adowa funkcja:

void <http://4programmers.net/C/Void> keyPressed(unsigned
<http://4programmers.net/C/Unsigned> char
<http://4programmers.net/C/Char> key, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{

    /* If 'x' is pressed, kill everything. */
    if <http://4programmers.net/C/If> (key == 'x')
    {
      /* shut down our window */
      glutDestroyWindow(window);

      /* exit the program...normal termination. */
      exit(0);
    }
}


Analogiczn± do powy¿szej jest funkcja:

glutKeyboardUpFunc(&keyUp);

Ró¿ni siê ona od tamtej tylko tym, ¿e wywo³uje funkcjê dan± w parametrze
dopiero po puszczeniu klawisza

Kolejn± podobn± funkcj± jest:

glutSpecialUpFunc(&specialKeyUp);

której parametr zostanie wywo³any po puszczeniu klawisza specjalnego.
Parametry identyczne jak wy¿ej za wyj±tkiem pierwszego, który jest typu int.

I dalej:

glutSpecialFunc(&specialKeyPressed); //analogicznie jak w
glutKeyboardFunc, z poprawk± na pierwszy parametr ;) .

UWAGA ! Niektóre omawiane funkcje mog± nie dzia³aæ w starszych wersjach API.

Istniej± predefiniowane klawisze, których znaczenia nie trudno siê domy¶liæ:
klawisz:                        jego numer:
 GLUT_KEY_F1                        1
 GLUT_KEY_F2                        2
 GLUT_KEY_F3                        3
 GLUT_KEY_F4                        4
 GLUT_KEY_F5                        5
 GLUT_KEY_F6                        6
 GLUT_KEY_F7                        7
 GLUT_KEY_F8                        8
 GLUT_KEY_F9                        9
 GLUT_KEY_F10                        10
 GLUT_KEY_F11                        11
 GLUT_KEY_F12                        12

 GLUT_KEY_LEFT                        100
 GLUT_KEY_UP                        101
 GLUT_KEY_RIGHT                        102
 GLUT_KEY_DOWN                        103
 GLUT_KEY_PAGE_UP                104
 GLUT_KEY_PAGE_DOWN                105
 GLUT_KEY_HOME                        106
 GLUT_KEY_END                        107
 GLUT_KEY_INSERT                108


Za obs³ugê myszy odpowiedzialna jest funkcja:

glutMouseFunc(&mButtonPressed);

która przyjmuje za parametr funkcjê  która powinna mieæ cztery parametry
(wszystkie typu int):
1. klawisz myszki

przedefinowane klawisze mychy:
 GLUT_LEFT_BUTTON        //lewy
 GLUT_MIDDLE_BUTTON        //¶rodkowy
 GLUT_RIGHT_BUTTON        //prawy

2. stan klawisza myszki

przedefinowane stany klawiszy mychy:
 GLUT_DOWN                        //wci¶niêty
 GLUT_UP                        //puszczony

3/4. wspó³rzêdne myszki.

Przyk³adowa funkcja (wymaga dodania nag³ówka stdio.h):

void <http://4programmers.net/C/Void> mButtonPressed(int
<http://4programmers.net/C/Int> button, int
<http://4programmers.net/C/Int> state, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{
 switch <http://4programmers.net/C/Switch>(button)
 {
  case <http://4programmers.net/C/Case> GLUT_LEFT_BUTTON:
   printf <http://4programmers.net/C/Printf>("Lewy");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_MIDDLE_BUTTON:
   printf <http://4programmers.net/C/Printf>("Srodkowy");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_RIGHT_BUTTON:
   printf <http://4programmers.net/C/Printf>("Prawy");
  break <http://4programmers.net/C/Break>;
 }

 switch <http://4programmers.net/C/Switch>(state)
 {
  case <http://4programmers.net/C/Case> GLUT_DOWN:
   printf <http://4programmers.net/C/Printf>(" w dol\n");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_UP:
   printf <http://4programmers.net/C/Printf>(" w gore\n");
  break <http://4programmers.net/C/Break>;
 }

 printf <http://4programmers.net/C/Printf>("X: %i  Y: %i\n",x,y);
}


Do zmiany po³o¿enia kursora myszki s³u¿y funkcja:

glutWarpPointer(100,50); //której parametry to dwa int'y oznaczaj±ce
po³o¿enie do którego przesunææ kuror (x i y)

Uzupe³niaj±cymi dzia³anie mychy s± funkcje:

glutMotionFunc(&ruchMychyP);
glutPassiveMotionFunc(&ruchMychyBez);

które ustalaj± funkcje wywo³ywane po wykonaniu ruchu myszki:
glutMotionFunc - gdy wci¶niêty jest jaki¶ klawisz
glutPassiveMotionFunc - gdy ¿aden nie jest wci¶niêty

Przyk³adowe funkcje podane w parametrze (ich parametry to wspó³rzêdne
myszki):

void <http://4programmers.net/C/Void> ruchMychyP(int
<http://4programmers.net/C/Int> x,int <http://4programmers.net/C/Int> y)
{
 printf <http://4programmers.net/C/Printf>("Przesunieto myche z
wcisnietym przyciskiem (%i,%i)\n",x,y);
}

void <http://4programmers.net/C/Void> ruchMychyBez(int
<http://4programmers.net/C/Int> x,int <http://4programmers.net/C/Int> y)
{
 printf <http://4programmers.net/C/Printf>("Przesunieto myche
(%i,%i)\n",x,y);
}


Za wejcie i wyjscie myszki z obszaru [aktywnego] okna odpowiedzialna
jest funkcja:

glutEntryFunc(&mouseEntry);

która przyporz±dkowuje funkcjê wywo³ywan± w momencie wej¶cia i wyj¶cia
myszki z obszaru okna. Funkcja ta ma w parametrze zmienn± typu int,
której przypisanay jest stan:

GLUT_LEFT        //Mycha opu¶ci³a obszar okna
GLUT_ENTERED        //Mycha "wlaz³a" w okno

void <http://4programmers.net/C/Void> mouseEntry(int
<http://4programmers.net/C/Int> state)
{
 if <http://4programmers.net/C/If> (state==GLUT_LEFT) printf
<http://4programmers.net/C/Printf>("Wejscie mychy: %i tj. mycha out
\n",state);
 else <http://4programmers.net/C/Else> printf
<http://4programmers.net/C/Printf>("Wejscie mychy: %i tj. mycha
in\n",state);
}


Inne urz±dzenia

GLUT pozwala te¿ na obs³ugê innych niekonwencjonalnych urz±dzeñ.
Niestety niektóre nie s± obs³ugiwane przez Windows. Funkcje do ich
obs³ugi to:

(wszystkie s± typu callback, czyli wymagaj± podania w parametrze adresu
do funkcji która bêdzie wywo³ywana po okre¶lonym zdarzeniu, tak jak
niektóre z wy¿ej wymienionych):

-Spaceball (cokolwiek to jest)
GLUTAPI void GLUTAPIENTRY glutSpaceballMotionFunc(void (GLUTCALLBACK
*func)(int x, int y, int z)); //Wywo³ane po ruchu
GLUTAPI void GLUTAPIENTRY glutSpaceballRotateFunc(void (GLUTCALLBACK
*func)(int x, int y, int z)); //Wywo³ane po obrocie
GLUTAPI void GLUTAPIENTRY glutSpaceballButtonFunc(void (GLUTCALLBACK
*func)(int button, int state)); //Wywo³ane po wci¶niêciu przycisku

-ButtonBox (??)
GLUTAPI void GLUTAPIENTRY glutButtonBoxFunc(void (GLUTCALLBACK
*func)(int button, int state)); //Przycisk
GLUTAPI void GLUTAPIENTRY glutDialsFunc(void (GLUTCALLBACK *func)(int
dial, int value));        //Zmienia pod³±czenia do aktywnego okna (tak
napisali na http://pyopengl.sourceforge.net/ - co to znaczy? nie wiem !)

-Tablet
GLUTAPI void GLUTAPIENTRY glutTabletMotionFunc(void (GLUTCALLBACK
*func)(int x, int y)); //Ruch
GLUTAPI void GLUTAPIENTRY glutTabletButtonFunc(void (GLUTCALLBACK
*func)(int button, int state, int x, int y)); //Przycisk

Przyk³ad:

ustawienie (w main):

glutSpaceballMotionFunc(&ruchSpaceball);

funkcja:

void <http://4programmers.net/C/Void> ruchSpaceball(int
<http://4programmers.net/C/Int> posx, int
<http://4programmers.net/C/Int> posy, int
<http://4programmers.net/C/Int> posz)
{
 printf <http://4programmers.net/C/Printf>("Polozenie spaceball: x: %i 
y: %i  z: %i",posx,posy,posz);
}


Noooo. wreszcie zosta³o jeszcze ostatnie urz±dzonko. Ostatnie nie znaczy
najmniej istotne. Joystick. Niestety obs³uga tego kontrolera w wersji
3.7 nie jest jeszcze dopracowana (braki na Linuxie i korzystanie z MMApi
na Windowsie) to jednak warto zapoznaæ siê z jego obs³ug±. Zw³aszcza, ¿e
jest ³atwa i krótka:

GLUTAPI void GLUTAPIENTRY glutJoystickFunc(void (GLUTCALLBACK
*func)(unsigned int buttonMask, int x, int y, int z), int pollInterval);

Funkcja glutJoystickFunc przyjmuje dwa parametry: adres funkcji do
której zwracany bêdzie stan urz±dzenia i czas co jaki bêdzie to
nastêpowa³o (w milisekundach). Funkcja do której bêdzie zwracany stan ma
z kolei cztery parametry: wci¶niête przyciski (jako suma ich warto¶ci) i
wychylenie w ka¿d± stronê. Wychylenie mo¿e mieæ warto¶æ od -1000 do
1000, a w stanie normalnym wynosi 0. Predefiniowane przyciski to:

Przycisk:                        Warto¶æ:
GLUT_JOYSTICK_BUTTON_A                1
GLUT_JOYSTICK_BUTTON_B                2
GLUT_JOYSTICK_BUTTON_C                4
GLUT_JOYSTICK_BUTTON_D                8

Przyk³adowe wywo³anie (UWAGA ! Nie testowane):

glutJoystickFunc(&joyFunc,100);

Przyk³adowa funkcja:

void <http://4programmers.net/C/Void> joyFunc(unsigned
<http://4programmers.net/C/Unsigned> int <http://4programmers.net/C/Int>
btn,int <http://4programmers.net/C/Int> x,int
<http://4programmers.net/C/Int> y, int <http://4programmers.net/C/Int> z)
{
 if <http://4programmers.net/C/If> (GLUT_JOYSTICK_BUTTON_A ||
GLUT_JOYSTICK_BUTTON_B) printf
<http://4programmers.net/C/Printf>("przyciski A i B\n");
 printf <http://4programmers.net/C/Printf>("X: %i  Y: %i  Z: %i\n",x,y,z);
}


Do wymuszenia zwracania stanu joysticka s³u¿y funkcja (nie testowane !):

glutForceJoystickFunc();

I to tyle...

UZUPE£NIENIE&nbsp;

Do obs³ugi klawiatury s³u¿± dwie dodatkowe funkcje:

void glutIgnoreKeyRepeat  (int ignore  );
int glutSetKeyRepeat  (int repeatMode );

S³u¿± one do obs³ugi powtarzalno¶ci klawiszy. Ich dzia³anie niestety
jest determinowane przez system i ró¿nie funkcjonuje na ró¿nych platformach.

Funkcja glutIgnoreKeyRepeat okre¶la czy powtróki wci¶niêcia klawisza s±
relacjonowane do aktualnego okna. Jest jeden parametr, który przyjmuje
jedynie dwie warto¶ci 0 (auto-powtórki bêd± reportowane) i 1 (powtórki
nie bêd± reportowane).

Druga funkcja (glutSetKeyRepeat) zmienia tryb powtarzania klawiszy.  W
parametrze podajemy tryb. Mo¿liwe s± warto¶ci:
GLUT_KEY_REPEAT_OFF        //wy³±cza powtarzanie klawiszy (je¶li tylko
jest to mo¿liwe)
GLUT_KEY_REPEAT_ON         //w³±cza
GLUT_KEY_REPEAT_DEFAULT        //resetuje do domy¶lnego stanu&nbsp;

Funkcja zwraca stan GLUT jako liczbê typu int.
UWAGA ! Na Win32 powy¿sze funkcje nie dzia³aj±. No có¿, nie mo¿na mieæ
wszystkiego :(.

Podsumowuj±cy kod:
 o pozwala obracaæ myszk± figurê
 o zmieniaæ kolor kwadratu przy u¿yciu klawiszy '+' i '-'

#include <GL/glut.h>    // Header File For The GLUT Library
//#include <GL/gl.h>        // Header File For The OpenGL32 Library
//#include <GL/glu.h>        // Header File For The GLu32 Library

/* The number of our GLUT window */
int <http://4programmers.net/C/Int> window;

//Zmienne przechowuj±ce
float <http://4programmers.net/C/Float> r=0,g=0,b=0.7;        //kolor "t³a"
int <http://4programmers.net/C/Int> ox,oy;                //wspó³rzêdne
myszki
float <http://4programmers.net/C/Float> rx,ry;                //obroty
obiektu


/* A general OpenGL initialization function.  Sets all of the initial
parameters. */
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                // This Will
Clear The Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_FLAT);                        // Enables Smooth Color
Shading

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);     
  // Calculate The Aspect Ratio Of The Window

  glMatrixMode(GL_MODELVIEW);
}


/* The function called when our window is resized (which shouldn't
happen, because we're fullscreen) */
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);
  glMatrixMode(GL_MODELVIEW);
}

/* The main drawing function. */
void <http://4programmers.net/C/Void> DrawGLScene()
{
glutSetWindow(window);        //Ustala aktywne okno

  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
  //Tutaj wstawiamy kod rysuj±cy scenê

        glTranslatef(0,0,-5);

        glPushMatrix();
        //quasi-t³o
        glTranslatef(0,0,-3);
        glColor3f(r,g,b);
        glBegin(GL_QUADS);
         glVertex3f(-10,-10,0);
         glVertex3f(-10, 10,0);
         glVertex3f( 10, 10,0);
         glVertex3f( 10,-10,0);
        glEnd();

        glPopMatrix();


        //Figura
        glRotatef(ry,1,0,0);
        glRotatef(rx,0,1,0);
        glBegin(GL_TRIANGLES);

        glColor3f(1,1,0);
         glVertex3f(0,1,0);
         glVertex3f(-1,-1,1);
         glVertex3f( 1,-1,1);

        glColor3f(1,0,0);
         glVertex3f(0,1,0);
         glVertex3f( 1,-1,1);
         glVertex3f( 1,-1,-1);

        glColor3f(0,1,0);
         glVertex3f(0,1,0);
         glVertex3f( 1,-1,-1);
         glVertex3f(-1,-1,-1);

        glColor3f(0,0,1);
         glVertex3f(0,1,0);
         glVertex3f(-1,-1,1);
         glVertex3f(-1,-1,-1);

        glEnd();



  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}


//Funkcja wywo³ywana po wci¶niêciu klawisza
void <http://4programmers.net/C/Void> keyPressed(unsigned
<http://4programmers.net/C/Unsigned> char
<http://4programmers.net/C/Char> key, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{
        switch <http://4programmers.net/C/Switch> (key)&nbsp;
        {
          case <http://4programmers.net/C/Case> '-':               
//U¿ywamy klawisza '-' do przyciemnienia "t³a"
           if <http://4programmers.net/C/If>(r<1)r+=0.1;
           if <http://4programmers.net/C/If>(g<1)g+=0.1;
           if <http://4programmers.net/C/If>(b<1)b+=0.1;
         break <http://4programmers.net/C/Break>;
         case <http://4programmers.net/C/Case> '+':               
//U¿ywamy klawisza '+' do rozja¶nienia "t³a"
          if <http://4programmers.net/C/If>(r>0)r-=0.1;
          if <http://4programmers.net/C/If>(g>0)g-=0.1;
          if <http://4programmers.net/C/If>(b>0)b-=0.1;
         break <http://4programmers.net/C/Break>;
        }

    /* If 'x' is pressed, kill everything. */
    if <http://4programmers.net/C/If> (key == 'x')
    {
      /* shut down our window */
      glutDestroyWindow(window);

      /* exit the program...normal termination. */
      exit(0);
    }
}

//Funkcja wykonywana gdy przesuniêto mychê z wci¶niêtym przyciskiem
void <http://4programmers.net/C/Void> ruchMychyP(int
<http://4programmers.net/C/Int> x,int <http://4programmers.net/C/Int> y)
{
 rx+=(x-ox)*0.25;
 ry+=(oy-y)*0.25;
 ox=x;
 oy=y;
}

//Funckja wywo³ana po wci¶niêciu klawisza&nbsp;
void <http://4programmers.net/C/Void> mButtonPressed(int
<http://4programmers.net/C/Int> button, int
<http://4programmers.net/C/Int> state, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{
 ox=x;
 oy=y;
}

int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  /* Initialize GLUT state - glut will take any command line arguments
that pertain to it or
     X Windows - look at its documentation at
http://reality.sgi.com/mjk/spec3/spec3.html */
  glutInit(&argc, argv);

  /* Select type of Display mode:
     Double buffer
     RGBA color
     Alpha components supported
     Depth buffered for automatic clipping */
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);

  /* get a 640 x 480 window */
  glutInitWindowSize(640, 480);

  /* the window starts at the upper left corner of the screen */
  glutInitWindowPosition(0, 0);

  /* Open a window */
  window = glutCreateWindow("GLUT TUTORIAL #2");

  /* Register the function to do all our OpenGL drawing. */
  glutDisplayFunc(&DrawGLScene);


  /* Register the function called when our window is resized. */
  glutReshapeFunc(&ReSizeGLScene);

  //Ustalenie funkcji
  glutKeyboardFunc(&keyPressed);        // która zostanie wywo³ana po
wci¶niêciu klawisza
  glutMotionFunc(&ruchMychyP);                // po ruchu myszki z
przyciskiem
  glutMouseFunc(&mButtonPressed);        // po wci¶niêciu przycisku

  //Inicjalizacja OpenGL
  InitGL(640, 480);

  /* Even if there are no events, redraw our gl scene. */
  glutIdleFunc(&DrawGLScene);


  /* Start Event Processing Engine */
  glutMainLoop();

  /* shut down our window */
  glutDestroyWindow(window);

  return <http://4programmers.net/C/Return> 1;
}


    OKNO



Podstawowe funkcje obs³ugi okien (oddzia³owuj± na aktualnie aktywne):

glutSetWindowTitle("TYTUL");        //Zmienia tytu³ okna. Jeden parametr
typu const char*.
glutPositionWindow(10, 10);        //Zmienia pozycjê okna. Dwa parametry
typu int (okre¶laj± lewy górny róg okna)
glutReshapeWindow(int width, int height);        //Zmienia rozmiar okna.
Pierwszy parametr to szeroko¶æ, drugi to wysoko¶æ

GLUT umo¿liwia tworzenie "pod-okien" s³u¿y do tego funkcja:

int glutCreateSubWindow(window,10,10,100,100); //Zwraca uchwyt do nowo
utworzonego pod-okna. Pierwszy parametr to numer (uchwyt) do
okna-"rodzica" czyli tego w którym bêdzie zawarte nowo utworzone. Dwa
kolejne parametry to po³o¿enie, dwa ostatnie to szeroko¶æ i wysoko¶æ.
Wszystkie s± typu int. UWAGA ! Do ka¿dego nowo utworzonego okna nale¿y
przypisaæ funkcje jakie bêd± u¿ywane. Najwa¿niejsz± i konieczn± jest
glutDispayFunc.

przyk³ad:

int subwindow;

subwindow=glutCreateSubWindow(window,10,10,100,100);
glutDisplayFunc(&DrawSubWindowGLScene);

Do pobrania aktywnego okna s³u¿y funkcja:

int glutGetWindow(void); //która zwraca uchwyt (nr) bie¿±cego okna

Do zmiany aktywnego okna s³u¿y funkcja:

glutSetWindow(int win); // w parametrze podajemy uchwyt okna które ma
byæ aktywne

Do sterowania oknem s³u¿± funkcje:

glutIconifyWindow(void);                //Minimalizuje okno (aktywne)
glutShowWindow(void);                        //Pokazuje okno (aktywne)
glutHideWindow(void);                        //Ukrywa okno (aktywne)

glutPopWindow(void);                        //Funkcja pobiera okno ze stosu
glutPushWindow(void);                        //Funkcja k³adzie okno na stos

Dzia³anie dwóch powy¿szych funkcji jest analogiczne jak dzia³anie funkcji
glPopMatrix();
glPuchMatrix();
w OpenGL. Najlepiej spróbowaæ samemu.

Dodatkow± funkcjê pozwalaj±c± kontrolowaæ stan okna (ustala siê jak
wszystkie dla bie¿±cego aktywnego okna) jest:

glutVisibilityFunc

która ustala funckjê wywo³ywan± po ukryciu (ew. minimalizacji) i po
ukazaniu (ew. przywróceniu) okna.
Mo¿liwe warto¶ci parametru w wywo³anej funkcji to :

GLUT_NOT_VISIBLE        //Okno niewidoczne
GLUT_VISIBLE                //Okno widoczne

Przyk³ad:

wywo³anie (w main() ):

glutVisibilityFunc(&oknoWidok)

funkcja:

void oknoWidok(int state)
{
 if (state==GLUT_VISIBLE) printf(" okno widoczne \n"); else printf("okno
niewidoczne \n");
}


Do pobrania aktualnego stanu okna s³u¿y funkcja:
glutWindowStatusFunc
która przyjmuje jeden parametr - adres do funkcji która zostanie
uruchomiona w przypadku zmiany stanu okna. Mo¿liwe warto?ci parametru
funkcji to:

nazwa:                                warto¶æ:
 GLUT_HIDDEN                        0
 GLUT_FULLY_RETAINED                1
 GLUT_PARTIALLY_RETAINED        2
 GLUT_FULLY_COVERED                3


Przyk³ad:

glutWindowStatusFunc(&winStatus);

i funkcja:

void <http://4programmers.net/C/Void> winStatus(int
<http://4programmers.net/C/Int> state)
{
 printf <http://4programmers.net/C/Printf>("Nast±pi³a zmiana stanu na:");
 switch <http://4programmers.net/C/Switch> (state)
 {
  case <http://4programmers.net/C/Case> GLUT_HIDDEN:
   printf <http://4programmers.net/C/Printf>("HIDDEN\n");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_FULLY_RETAINED:
   printf <http://4programmers.net/C/Printf>("FULLY_RETAINED\n");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_PARTIALLY_RETAINED:
   printf <http://4programmers.net/C/Printf>("PARTIALLY_RETAINED\n");
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> GLUT_FULLY_COVERED:
   printf <http://4programmers.net/C/Printf>("FULLY_COVERED\n");
  break <http://4programmers.net/C/Break>;
 }
}




No i na koniec ma³y przyk³adzik. Generuje okno z przesuwaj±cym siê
napisem na belce, które mo¿na przesuwaæ klikaj±c w jego dowolnym miejscu
i pod okno o tej samej w³a¶ciwo¶ci. UWAGA! Zastosowa³em procedurkê
glutGet która jest opisana w dalszej czê¶ci tekstu.

#include <GL/glut.h>    // Nag³ówek do GLUT
//#include <GL/gl.h>         //Pozosta³e nag³ówki (nie konieczne gdy¿
zawarte ju¿ w GLUT)
//#include <GL/glu.h>

//G³ówne okno
int <http://4programmers.net/C/Int> window;

//Pod-okno
int <http://4programmers.net/C/Int> subwindow;


//Wspó³rzêdne myszki
int <http://4programmers.net/C/Int> mx,my;


//Inicjalizacja OpenGL
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                // This Will
Clear The Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_SMOOTH);                        // Enables Smooth
Color Shading

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,10.0f);     
  // Calculate The Aspect Ratio Of The Window

  glMatrixMode(GL_MODELVIEW);
}


//Zmiana rozmiaru
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,10.0f);
  glMatrixMode(GL_MODELVIEW);
}

//Zmienne do przewijania napisu na pasku&nbsp;
char <http://4programmers.net/C/Char> txt[]="GLUT TUTORIAL #3 ";       
//Text
char <http://4programmers.net/C/Char> txtlen=17;                       
//D³ugo¶æ textu
char <http://4programmers.net/C/Char> snap[20];                       
//Pomocnicza

//Funkcja, powi±zana z timer'em, odpowiedzialna za przesuwanie napisu na
pasku
void <http://4programmers.net/C/Void> scrollBar(int
<http://4programmers.net/C/Int> scroll)
{
unsigned <http://4programmers.net/C/Unsigned> short
<http://4programmers.net/C/Short> int <http://4programmers.net/C/Int>
i;        //Zmienna pomocnicza

 //Wygenerowanie napisu na pasek
 for <http://4programmers.net/C/For> (i=0; i<txtlen; i++)
 if <http://4programmers.net/C/If> (i+scroll<txtlen)
 snap[i]=txt[i+scroll]; else <http://4programmers.net/C/Else>
 snap[i]=txt[i+scroll-txtlen];

 snap[txtlen]='\0';

 glutSetWindow(window);                        //Zmiana aktywnego okna
 glutSetWindowTitle(snap);                //Zmiana napisu na pasku tytu³owym

 //Utrzymanie timer'a w ruchu
 if <http://4programmers.net/C/If> (scroll>=txtlen)
   glutTimerFunc (1000,&scrollBar,0); else <http://4programmers.net/C/Else>
   glutTimerFunc (1000,&scrollBar,scroll+1);
}




int <http://4programmers.net/C/Int> rot=0;

//G³ówna funkcja rysuj±ca
void <http://4programmers.net/C/Void> DrawGLScene()
{

  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
  glTranslatef(0,0,-1);
      glRotatef(rot++,0,0,1);
        glBegin(GL_TRIANGLES);
        glColor3f(1,0,0);
         glVertex3f(0,0.4,0);
        glColor3f(0,1,0);
         glVertex3f(-0.4,-0.25,0);
        glColor3f(0,0,1);
         glVertex3f( 0.4,-0.25,0);
        glEnd();

  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}


//Rysuje scenê z pod-okna
void <http://4programmers.net/C/Void> DrawSubWindowGLScene()
{
  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //Scena OpenGL
  glTranslatef(0,0,-1);
      glRotatef(rot,1,0,1);
        glBegin(GL_QUADS);
                glColor3f(1,0,0);
         glVertex3f(-0.4,-0.4,0);
                glColor3f(0,1,0);
         glVertex3f( 0.4,-0.4,0);
                glColor3f(0,0,1);
         glVertex3f( 0.4, 0.4,0);
                glColor3f(0,1,1);
         glVertex3f(-0.4, 0.4,0);
        glEnd();

  glutSwapBuffers();

}

//Funkcja rysuj±ca sceny w obu oknach
void <http://4programmers.net/C/Void> DrawAll()
{

 glutSetWindow(window);                                //Zmiana
aktywnego okna
 DrawGLScene();

 glutSetWindow(subwindow);                        //Zmiana aktywnego okna
 DrawSubWindowGLScene();
}

//Funckja wywo³ana po przesuniêciu myszki z wci¶niêtym klawiszem
void <http://4programmers.net/C/Void> mBtnMove(int
<http://4programmers.net/C/Int> x,int <http://4programmers.net/C/Int> y)
{
 int <http://4programmers.net/C/Int> lx,ly;
  lx=glutGet(GLUT_WINDOW_X);        //pobiera po³o¿enie x aktywnego okna
  ly=glutGet(GLUT_WINDOW_Y);        //pobiera po³o¿enie y aktywnego okna
  glutPositionWindow(x-mx+lx,y-my+ly);        //Zmienie po³o¿enie okna
}

//Funckja wywo³ana po wci¶niêciu klawisza
void <http://4programmers.net/C/Void> mButtonPressed(int
<http://4programmers.net/C/Int> button, int
<http://4programmers.net/C/Int> state, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{
 mx=x;
 my=y;
}


//Funckja wywo³ana po przesuniêciu myszki z wci¶niêtym klawiszem dla
pod-okna
void <http://4programmers.net/C/Void> mSBtnMove(int
<http://4programmers.net/C/Int> x,int <http://4programmers.net/C/Int> y)
{&nbsp;
int <http://4programmers.net/C/Int> ax,ay,kx,ky;

  kx=glutGet(GLUT_WINDOW_X);        //pobiera po³o¿enie x aktywnego pod-okna
  ky=glutGet(GLUT_WINDOW_Y);        //pobiera po³o¿enie y aktywnego pod-okna
        glutSetWindow(window);        //Zmienia aktywne okno
  ax=glutGet(GLUT_WINDOW_X);        //pobiera po³o¿enie x aktywnego okna
  ay=glutGet(GLUT_WINDOW_Y);        //pobiera po³o¿enie y aktywnego okna
        glutSetWindow(subwindow);//Zmienia aktywne okno
         glutPositionWindow(kx+x-mx-ax,ky+y-my-ay);        //Zmienie
po³o¿enie pod-okna
}

//Funckja wywo³ana po wci¶niêciu klawisza dla pod-okna
void <http://4programmers.net/C/Void> mSButtonPressed(int
<http://4programmers.net/C/Int> button, int
<http://4programmers.net/C/Int> state, int
<http://4programmers.net/C/Int> x, int <http://4programmers.net/C/Int> y)
{
 mx=x;
 my=y;
}


//Podstawowa funkcja ka¿dego programu
int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  glutInit(&argc, argv);        //Inicjalizacja GLUT
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA |
GLUT_DEPTH);        //Ustalenie trybu wy¶wietlania

  //Inicjalizacja i ustawienia dla okna renderingu
  glutInitWindowSize(640, 480);                //rozmiar
  glutInitWindowPosition(0, 0);         //po³o¿enie
  window = glutCreateWindow("GLUT TUTORIAL #3");//utworzenie okna
  glutDisplayFunc(&DrawGLScene);         //funkcja wy¶wietlania
  glutReshapeFunc(&ReSizeGLScene);        //zmiana rozmiaru
  InitGL(640, 480);                        //Inicjalizacja OpenGL

  //Funkcje callback dla okna g³ównego
  glutTimerFunc (500,&scrollBar,0);        //Przesuwanie napisu na pasku
  glutMotionFunc(&mBtnMove);                // po ruchu myszki z przyciskiem
  glutMouseFunc(&mButtonPressed);        // po wci¶niêciu przycisku

  subwindow=glutCreateSubWindow(window,270,190,100,100);       
//Utworzenie pod-okna
  glutDisplayFunc(&DrawSubWindowGLScene);                       
//Ustalenie funkcji wy¶wietlania
  InitGL(100, 100);                        //Inicjalizacja OpenGL dla
pod-okna (mo¿e byæ zupe³nie inna)

  //Funkcje callback dla pod-okna
  glutMotionFunc(&mSBtnMove);                // po ruchu myszki z
przyciskiem
  glutMouseFunc(&mSButtonPressed);        // po wci¶niêciu przycisku


  glutIdleFunc(&DrawAll);                //Funkcja wywo³ana w przypadku
braku ¿adnych zdarzeñ


  glutMainLoop();                        //G³ówna pêtla

  glutDestroyWindow(window);                //Usuniêcie okna
  return <http://4programmers.net/C/Return> 1;
}


    WY¦WIETLANIE



Oprócz wy¿ej wymienionej funkcji: glutDisplayFunc zwi±zane z
wy¶wietlaniem s±:

glutPostRedisplay();

i

glutPostWindowRedisplay(int win);

s³u¿± one do niezale¿nego od pêtli wy¶wietlenia zawarto¶ci okna.
Pierwsza dzia³a na aktywne okno, druga na to do którego uchwyt (którego
numer) podali¶my w parametrze.

oraz funkcja:

glutInitDisplayString&nbsp;

której dzia³anie opisane jest dalej (czyt. dodatki).


    MENU



GLUT umo¿liwia utworzenie menu tekstowego typu pop-up, czyli takiego,
które zostanie ukazane po wci¶niêciu klawisza myszki.
Do utworzenia menu lub pod-menu s³u¿y funkcja:

glutCreateMenu(&selectMessage); //za parametr przyjmuje ona adres do
funkcji (z parametrem int) i zwraca numer utworzonego menu (jego uchwyt)

Przyk³ad u¿ycia:

int submenu1 = glutCreateMenu(&selectMessage);

gdzie funkcja selectMessage ma postaæ np.

void selectMessage(int i)
{
 printf("Pozycja z menu: %i\n",i);
}

do dodania pozycji do menu s³u¿y funkcja:

glutAddMenuEntry("abc", 1); //przyjmuje ona dwa parametry: typu const
char * który zawiera opis pozycji menu i drugi który jest jej numerem
(gdy wci¶niemy tê pozycjê to zostanie wywo³ana funkcja ustalona przy
utworzeniu menu, której parametrem bêdzie w³a¶nie ten numer)

UWAGA ! GLUT jest maszyn± stanu (podobnie jak OpenGL). W uproszczeniu
znaczy to, ¿e to co zrobili¶my ostatnio (i nie tylko) jest zapisane. Tak
wiêc u¿ywaj±c funkcji glutAddMenuEntry dodamy pozycjê do ostatnio
utworzonego menu (lub tego które zmienili¶my ostatnio na aktywne).
Do zmiany aktywnego menu s³u¿y funkcja:

glutSetMenu(submenu1); //gdzie podajemy jeden parametr typu int i jest
to numer (uchwyt) menu, które ustawiamy na aktywne


Podobnie do funkcji glutAddMenuEntry dzia³a funkcja:

glutAddSubMenu("Color", submenu2); //która s³u¿y do dodania do aktywnego
menu, pod-menu, pierwszy parametr (const char *) to opis jaki zostanie
nadany menu, drugi to numer/uchwyt menu, które dodajemy.

Do ustalenia klawisza myszki po wci¶niêciu którego uruchomi siê menu
s³u¿y funkcja:

glutAttachMenu(GLUT_LEFT_BUTTON); //której parametrem jest przycisk
mychy, jeden z trzech:

 GLUT_LEFT_BUTTON                //lewy
 GLUT_MIDDLE_BUTTON                //¶rodkowy
 GLUT_RIGHT_BUTTON                //prawy

i która ustawia aktywne menu do pokazania po wci¶niêciu klawisza.

Przyk³adowy kod:

 tworzy menu z pozycjami: 9 by 15 , Times Roman 10 , Times Roman 24 i
dwoma pod-menu:
 Messages (pozycje: abc i ABC) i Color (pozycje: Green, Red, White),
które zostanie wywo³ane po wci¶niêciu lewego przycisku  myszki

//Do main
int <http://4programmers.net/C/Int> submenu1, submenu2;

submenu1 = glutCreateMenu(selectMessage);

submenu2 = glutCreateMenu(selectColor);
glutAddMenuEntry("Green", 1);
glutAddMenuEntry("Red", 2);
glutAddMenuEntry("White", 3);

glutSetMenu(submenu1);
glutAddMenuEntry("abc", 1);
glutAddMenuEntry("ABC", 2);

glutCreateMenu(selectFont);
glutAddMenuEntry("9 by 15", 0);
glutAddMenuEntry("Times Roman 10", 1);
glutAddMenuEntry("Times Roman 24", 2);
glutAddSubMenu("Messages", submenu1);
glutAddSubMenu("Color", submenu2);

glutAttachMenu(GLUT_LEFT_BUTTON);


//luzem

void <http://4programmers.net/C/Void> selectMessage(int
<http://4programmers.net/C/Int> i)
{
 printf <http://4programmers.net/C/Printf>("msg nr %i\n",i);
}

void <http://4programmers.net/C/Void> selectColor(int
<http://4programmers.net/C/Int> i)
{
 printf <http://4programmers.net/C/Printf>("color nr %i\n",i);
}

void <http://4programmers.net/C/Void> selectFont(int
<http://4programmers.net/C/Int> i)
{
 printf <http://4programmers.net/C/Printf>("font nr %i\n",i);
}



OK. Kolejna funkcja:

int glutGetMenu();

nie ma parametrów i s³u¿y do pobrania uchwytu aktywnego okna, który to
zwraca.

Przyk³ad

int aktywne_menu;
aktywne_menu=glutGetMenu();

Do usuniêcia menu s³u¿y funkcja:
glutDestroyMenu(int menu);
której parametrem jest uchwyt do menu, które chcemy usun±æ.

Aby rozkojarzyæ przycisk myszki z menu s³u¿y funkcja:

glutDetachMenu(GLUT_LEFT_BUTTON);

której parametr jest analogiczny jak w glutAttachMenu.

Do usuniêcia pozycji z menu s³u¿y funkcja:
glutRemoveMenuItem(int); //która ma jeden parametr, za który podajemy
numer pozycji z aktywnego menu, któr± chcemy usun±æ.
Funkcja dzia³a zarówno na pozycje jak i pod-menu.

Do zmiany pozycji menu s³u¿y funkcja:

glutChangeToMenuEntry(int item, const char *label, int value);

Pierwszy parametr to nr pozycji, któr± zmieniamy, drugi to opis na jaki
zmieniamy bie¿±cy opis pozycji. Ostatni to warto¶æ jaka zostanie
przekazana do funkcji ustalonej przy tworzeniu menu (ofcourse po
wybraniu pozycji z menu przez u¿ytkownika).

Analogiczn± do powy¿szej, ale odpowiadaj±c± za zmianê pod-menu jest funkcja:

glutChangeToSubMenu(int item, const char *label, int submenu);

Zmienia siê jedynie ostatni parametr. Podajemy numer (uchwyt)
utworzonego menu, które zast±pi pod-menu lub pozycjê na pozycji podanej
w pierwszym parametrze.

Ufff. Do podstawowych funkcji obs³ugi menu s³u¿± jeszcze dwa polecenia:

glutMenuStateFunc(void (GLUTCALLBACK *func)(int state));
glutMenuStatusFunc(void (GLUTCALLBACK *func)(int status, int x, int y));

Pierwsza s³u¿y do przypisania (wybrania, analogicznie jak np. po
wci¶niêciu klawisza) funkcji która zostanie wywo³ana po zmianie stanu
przez menu. Funkcja do której adres podamy powinna mieæ jeden parametr
typu int, do którego zostanie przekazany obecny stan menu. Mo¿liwe warto¶ci:

0 czyli GLUT_MENU_NOT_IN_USE
i
1 czyli GLUT_MENU_IN_USE

Przyk³adowa funkcja

void menuState(int state)
{
 printf("stan menu: %i\n",state);
}

i przyk³adowe przypisanie

glutMenuStateFunc(&menuState);

Druga czyli glutMenuStatusFunc ró¿ni siê od pierwszej tym jedynie, ¿e
zwraca do funkcji oprócz stanu wspó³rzêdne (x i y) myszki, co jest
praktycznie równoznaczne po³o¿eniu menu.


No i oczywi¶cie na koniec ma³y przyk³ad. Pozwala sterowaæ tym co jest
pokazywane na ekranie za pomoc± menu.

#include <GL/glut.h>    // Nag³ówek do GLUT
//#include <GL/gl.h>         //Pozosta³e nag³ówki (nie konieczne gdy¿
zawarte ju¿ w GLUT)
//#include <GL/glu.h>

//G³ówne okno
int <http://4programmers.net/C/Int> window;

//Zmienne s³u¿±ce przy wy¶wietlanie
#define triangle 1
#define quad 2
int <http://4programmers.net/C/Int> color=4,figure=triangle,showing=1;

//Uchwyty menu
int <http://4programmers.net/C/Int> submenu1, submenu2;

//Inicjalizacja OpenGL
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                // This Will
Clear The Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_SMOOTH);                        // Enables Smooth
Color Shading

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,500.0f);     
  // Calculate The Aspect Ratio Of The Window

  glMatrixMode(GL_MODELVIEW);
  glEnable(GL_COLOR_MATERIAL);
}


//Zmiana rozmiaru
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,500.0f);
  glMatrixMode(GL_MODELVIEW);
}


//G³ówna funkcja rysuj±ca
void <http://4programmers.net/C/Void> DrawGLScene()
{
glutSetWindow(window);
  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
if <http://4programmers.net/C/If> (showing)
{
 glTranslatef(0,0,-1);
   switch <http://4programmers.net/C/Switch> (color)
   {
    case <http://4programmers.net/C/Case> 1:
                glColor3f(1,0,0);
        break <http://4programmers.net/C/Break>;
    case <http://4programmers.net/C/Case> 2:
                glColor3f(0,1,0);
        break <http://4programmers.net/C/Break>;
    case <http://4programmers.net/C/Case> 3:
                glColor3f(0,0,1);
        break <http://4programmers.net/C/Break>;
    case <http://4programmers.net/C/Case> 4:
                glColor3f(1,1,1);
        break <http://4programmers.net/C/Break>;
   }

 if <http://4programmers.net/C/If> (figure==triangle)
 {&nbsp;
  glBegin(GL_TRIANGLES);
        glVertex3f(0,0.2,0);
        glVertex3f(0.2,-0.2,0);
        glVertex3f(-0.2,-0.2,0);
  glEnd();
 } else <http://4programmers.net/C/Else>
 {&nbsp;
  glBegin(GL_QUADS);
        glVertex3f(-0.1,-0.1,0);
        glVertex3f(0.1,-0.1,0);
        glVertex3f(0.1,0.1,0);
        glVertex3f(-0.1,0.1,0);
  glEnd();
 }
}
  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}

//Funkcje wywo³ywane po wybraniu pozycji z menu:

void <http://4programmers.net/C/Void> selectShowing(int
<http://4programmers.net/C/Int> i)
{
 showing=i;
 if <http://4programmers.net/C/If> (i==0)
 glutChangeToMenuEntry(2,"Rysuj", 1); else <http://4programmers.net/C/Else>
 glutChangeToMenuEntry(2,"Ukryj", 0);
}


void <http://4programmers.net/C/Void> selectFigure(int
<http://4programmers.net/C/Int> i)
{
 switch <http://4programmers.net/C/Switch> (i)
 {
  case <http://4programmers.net/C/Case> 1:
   figure=triangle;
  break <http://4programmers.net/C/Break>;
  case <http://4programmers.net/C/Case> 2:
   figure=quad;
  break <http://4programmers.net/C/Break>;
 }
}


void <http://4programmers.net/C/Void> selectColor(int
<http://4programmers.net/C/Int> i)
{
 color=i;
}


//Podstawowa funkcja ka¿dego programu
int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  glutInit(&argc, argv);        //Inicjalizacja GLUT
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA |
GLUT_DEPTH);        //Ustalenie trybu wy¶wietlania

  //Inicjalizacja i ustawienia dla okna renderingu;
  glutInitWindowSize(480, 480);                //rozmiar
  glutInitWindowPosition(0, 0);         //po³o¿enie
  window = glutCreateWindow("GLUT TUTORIAL #4");//utworzenie okna
  glutDisplayFunc(&DrawGLScene);         //funkcja wy¶wietlania
  glutReshapeFunc(&ReSizeGLScene);        //zmiana rozmiaru
  InitGL(480, 480);                        //Inicjalizacja OpenGL


        //Tworzymy menu i pod-menu'a oraz przy tym ustalamy wywo³ywane
po wybraniu pozycji funkcje
        submenu1 = glutCreateMenu(selectFigure);

        submenu2 = glutCreateMenu(selectColor);
        glutAddMenuEntry("Czerwony", 1);
        glutAddMenuEntry("Zielony", 2);
        glutAddMenuEntry("Niebieski", 3);
        glutAddMenuEntry("Bia³y", 4);

        glutSetMenu(submenu1);                //przyk³adowe u¿ycie
funkcji setmenu do prze³±czenia siê na pocz±tkowe pod-menu
        glutAddMenuEntry("Trójk±t", 1);
        glutAddMenuEntry("Kwadrat", 2);
;
        glutCreateMenu(selectShowing);
        glutAddSubMenu("Figura", submenu1);
        glutAddMenuEntry("Ukryj", 0);
        glutAddSubMenu("Kolor", submenu2);

        //Kojarzymy lewy przycisk z menu
        glutAttachMenu(GLUT_LEFT_BUTTON);
        glutAttachMenu(GLUT_RIGHT_BUTTON);        //prawy zreszt± te¿...

  glutIdleFunc(&DrawGLScene);                //Funkcja wywo³ana w
przypadku braku ¿adnych zdarzeñ

  glutMainLoop();                        //G³ówna pêtla

  glutDestroyWindow(window);                //Usuniêcie okna
  return <http://4programmers.net/C/Return> 1;
}



    TIMER



Timer jest to zegarek który za okre¶lony czas wywo³uje pewn± funkcjê.
Do obs³ugi timera w GLUT s³u¿y funkcja:

glutTimerFunc(unsigned int millis, void (GLUTCALLBACK *func)(int value),
int value);

przyjmuje ona trzy parametry:
millis - czas za który zostanie wywo³ana funkcja (w milisekundach)
funkcja (która musi mieæ parametr int)
warto¶æ jaka zostanie przekazana do parametru powy¿szej funkcji.

Przyk³ad:

 glutTimerFunc (1000,&timerFunc,22); //Co sekundê wywo³uje funkcjê
timerFunc z parametrem 22

Aby powtórzyæ lub wywo³ywaæ dzia³anie timer'a nale¿y procedurê ponownie
uruchomiæ.

Przyk³adowy kod: mierzy liczbê klatek na sekundê i pokazuje na wykresie
(czerwone trójk±ty oznaczaj± setki , skala jest od 0 do 500).
#include <GL/glut.h>    // Nag³ówek do GLUT
//#include <GL/gl.h>         //Pozosta³e nag³ówki (nie konieczne gdy¿
zawarte ju¿ w GLUT)
//#include <GL/glu.h>

//G³ówne okno
int <http://4programmers.net/C/Int> window;

//Liczba klatek na sek. i aktualna
int <http://4programmers.net/C/Int> fps=0,sfps=0;

//Inicjalizacja OpenGL
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(0.7f, 0.7f, 0.7f, 0.0f);                // This Will
Clear The Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  //glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_FLAT);                        // Enables Smooth Color
Shading

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,6.4,0.1f,500.0f);        // Calculate The Aspect
Ratio Of The Window

  glMatrixMode(GL_MODELVIEW);
  glEnable(GL_COLOR_MATERIAL);
}


//Zmiana rozmiaru
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,6.4,0.1f,500.0f);
  glMatrixMode(GL_MODELVIEW);
}


 //Rysuje trójk±t (przy podzia³ce)
 void <http://4programmers.net/C/Void> DrawTri(float
<http://4programmers.net/C/Float> fx)
 {&nbsp;
  glVertex3f(fx,0.16,0);
  glVertex3f(fx+0.04,0.36,0);
  glVertex3f(fx-0.04,0.36,0);
 }

//G³ówna funkcja rysuj±ca
void <http://4programmers.net/C/Void> DrawGLScene()
{
fps++;                //Zliczaj fps

glutSetWindow(window);
  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
  glTranslatef(0,0,-1);
        //T³o
        glColor3f(1,1,1);
        glBegin(GL_QUADS);
         glVertex3f(-2.55,-0.15,0);
         glVertex3f(-2.55, 0.15,0);
         glVertex3f( 2.55, 0.15,0);
         glVertex3f( 2.55,-0.15,0);
        glEnd();

        //Skala
        glTranslatef(0,0,0.005);
        glColor3f(0,1,0);
        glBegin(GL_QUADS);
         glVertex3f(-2.5,-0.1,0);
         glVertex3f(-2.5, 0.1,0);
         glVertex3f(-2.5+sfps*0.01, 0.1,0);
         glVertex3f(-2.5+sfps*0.01,-0.1,0);
        glEnd();

        //Podzia³ka
        glBegin(GL_TRIANGLES);
          glColor3f(1,0,0);
         DrawTri(-2.5);        //0
         DrawTri(-1.5);        //100
         DrawTri(-0.5); //200
         DrawTri(0.5); //300
         DrawTri(1.5); //400
         DrawTri(2.5); //500
           glColor3f(1,1,1);
         DrawTri(-2);//50 = 0.25
         DrawTri(-1);//150
         DrawTri(0);//250
         DrawTri(1); //350
         DrawTri(2);   //450
         glEnd();

  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}

//Funkcja wywo³ywana przez timer
void <http://4programmers.net/C/Void> timerFunc(int
<http://4programmers.net/C/Int> i)
{
 sfps=fps;
 fps=0;
 //powtórz wywo³ywanie
 glutTimerFunc (1000,&timerFunc,0);    //Co sekundê wywo³uje funkcjê
timerFunc
}

//Podstawowa funkcja ka¿dego programu
int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  glutInit(&argc, argv);        //Inicjalizacja GLUT
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA |
GLUT_DEPTH);        //Ustalenie trybu wy¶wietlania

  //Inicjalizacja i ustawienia dla okna renderingu
  glutInitWindowSize(640, 100);                //rozmiar
  glutInitWindowPosition(0, 0);         //po³o¿enie
  window = glutCreateWindow("GLUT TUTORIAL #5");//utworzenie okna
  glutDisplayFunc(&DrawGLScene);         //funkcja wy¶wietlania
  glutReshapeFunc(&ReSizeGLScene);        //zmiana rozmiaru
  InitGL(640, 100);                        //Inicjalizacja OpenGL


  glutTimerFunc (1000,&timerFunc,0);    //Co sekundê wywo³uje funkcjê
timerFunc

  glutIdleFunc(&DrawGLScene);                //Funkcja wywo³ana w
przypadku braku ¿adnych zdarzeñ


  glutMainLoop();                        //G³ówna pêtla

  glutDestroyWindow(window);                //Usuniêcie okna
  return <http://4programmers.net/C/Return> 1;
}


    MODELE



GLUT zawiera te¿ funkcje do rysowania prostych modeli:

 - glutWireSphere(GLdouble radius, GLint slices, GLint
stacks);                //siatka kuli
 - glutSolidSphere(GLdouble radius, GLint slices, GLint
stacks);        //kula

 - glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint
stacks);        //sto¿ek - siatka
 - glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint
stacks);        //sto¿ek

 - glutWireCube(GLdouble
size);                                                //siatka sze¶cianu
 - glutSolidCube(GLdouble
size);                                        //sze¶cian

 - glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint
sides, GLint rings);                //siatka torusa
 - glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint
sides, GLint rings);        //torus

 - glutWireDodecahedron(void);                        //siatka
dwunasto¶cianu
 - glutSolidDodecahedron(void);                        //dwunasto¶cian

 - glutWireTeapot(GLdouble size);                //siatka czajnika
 - glutSolidTeapot(GLdouble size);                //czajnik

 - glutWireOctahedron(void);                        //siatka o¶mioboku
 - glutSolidOctahedron(void);                        //o¶miobok

 - glutWireTetrahedron(void);                        //czworo¶cian - siatka
 - glutSolidTetrahedron(void);                        //czworo¶cian

 - glutWireIcosahedron(void);                        //znowu wielo¶cian
- siatka
 - glutSolidIcosahedron(void);                        //wielo¶cian

Przyk³adowo:

glutSolidTorus(0.5,3,20,20);

rysuje torus (taki p±czek ;) ). Tym razem nie bêdzie przyk³adziku, bo
ca³o¶æ jest zbyt oczywista. Wystarczy wstawiæ funkcjê do DrawGLScene i tyle.


    PISANIE



GLUT udostêpnia mo¿liwo¶æ pisania bitmapowymi czcionkami. Niestety
umo¿liwia pisanie tylko jednego znaku na raz. s³u¿y do tego funkcja:

glutBitmapCharacter(void *font, int character);

Mo¿liwe typy czcionki (pierwszy parametr):

GLUT_BITMAP_9_BY_15
GLUT_BITMAP_8_BY_13
GLUT_BITMAP_TIMES_ROMAN_10
GLUT_BITMAP_TIMES_ROMAN_24
GLUT_BITMAP_HELVETICA_10
GLUT_BITMAP_HELVETICA_12
GLUT_BITMAP_HELVETICA_18

Drugi parametr umo¿liwia podanie jednego znaku (np. 'a','1' lub '@').

Funkcja:

int glutBitmapWidth(void *font, int character);

umo¿liwia pobranie (zwraca warto¶æ) szeroko¶ci znaku w danej czcionce.
Parametry identyczne jak wy¿ej.

Przyk³adowe wykorzystanie, wypisuje okre¶lony tekst na ekranie w
okre¶lonej pozycji (wymaga dodania modu³u string.h:
"#include " na pocz±tku do obs³ugi strlen)

float <http://4programmers.net/C/Float> glutPrint(float
<http://4programmers.net/C/Float> x,float
<http://4programmers.net/C/Float> y,void
<http://4programmers.net/C/Void> *font,char
<http://4programmers.net/C/Char> *txt,float
<http://4programmers.net/C/Float> scale)
{ int <http://4programmers.net/C/Int> i;
  int <http://4programmers.net/C/Int> len=strlen(txt);
 for <http://4programmers.net/C/For> (i=0; i<len; i++)
 {
  glRasterPos2f(x,y);
  glutBitmapCharacter(font, txt[i]);
  x+=glutBitmapWidth(font,txt[i])*scale;
 }
}



Podobne dzia³anie do powy¿szych maj± funkcje (ró¿ni siê to, ¿e nie
u¿ywaj± czcionek bitmapowych):

glutStrokeCharacter(void *font, int character)
int glutStrokeWidth(void *font, int character);

Mo¿liwe typy czcionki dla powy¿szych funkcji to:

GLUT_STROKE_ROMAN
GLUT_STROKE_MONO_ROMAN

Ostatnimi funkcjami z tej grupy s±:

int glutBitmapLength(void *font, const unsigned char *string);
int glutStrokeLength(void *font, const unsigned char *string);

które podaj± "d³ugo¶æ" (zwracana jako int) ci±gu znaków (podanego w
drugim parametrze) w okre¶lonej czcionce (pierwszy parametr). Z nazwy
mo¿na wywnioskowaæ, które dotycz± czcionek bitmapowych, a które nie ;) .

Prosty przyk³ad na zakoñczenie:
 * przewijaj±ca siê lista autorów
 * obliczanie fps
Oczywi¶cie poni¿szy kod jest strasznie nie-efektywny i wymaga
zooptymalizowania (nawet na podstawowym poziomie), ale przecie¿ ma byæ
jedynie demonstracj±...

#include <GL/glut.h>    // Nag³ówek do GLUT
//#include <GL/gl.h>         //Pozosta³e nag³ówki (nie konieczne gdy¿
zawarte ju¿ w GLUT)
//#include <GL/glu.h>

#include <stdio.h>        //Standardowa obs³uga we/wy

//G³ówne okno
int <http://4programmers.net/C/Int> window;

//Liczba klatek na sek. i aktualna
int <http://4programmers.net/C/Int> fps=0,sfps=0;

//Przewijane napisu
char <http://4programmers.net/C/Char>* txt[]={"     
ABOUT","____________","","","Program ten","jest
czescia","kursu","programowania","GLUT","(GL Utility Toolkit)","     
 by","Neuromancer","      2004","____________"};
#define txtcount 14//liczba pozycji w tek¶cie
float <http://4programmers.net/C/Float> starty=-1;         //startowa
pozycja przewijanego text'u

//Inicjalizacja OpenGL
void <http://4programmers.net/C/Void> InitGL(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)                // We call this
right after our OpenGL window is created.
{
  glClearColor(1, 1, 1, 0.0f);                // This Will Clear The
Background Color To Black
  glClearDepth(1.0);                                // Enables Clearing
Of The Depth Buffer
  glDepthFunc(GL_LESS);                                // The Type Of
Depth Test To Do
  glEnable(GL_DEPTH_TEST);                        // Enables Depth Testing
  glShadeModel(GL_FLAT);                        // Enables Smooth Color
Shading

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                                // Reset The
Projection Matrix

  gluPerspective(45.0f,64/48,0.1f,500.0f);        // Calculate The
Aspect Ratio Of The Window

  glMatrixMode(GL_MODELVIEW);
  glEnable(GL_COLOR_MATERIAL);
}


//Zmiana rozmiaru
void <http://4programmers.net/C/Void> ReSizeGLScene(int
<http://4programmers.net/C/Int> Width, int
<http://4programmers.net/C/Int> Height)
{
  if <http://4programmers.net/C/If> (Height==0)                         
      // Prevent A Divide By Zero If The Window Is Too Small
    Height=1;

  glViewport(0, 0, Width, Height);                // Reset The Current
Viewport And Perspective Transformation

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  gluPerspective(45.0f,64/48,0.1f,500.0f);
  glMatrixMode(GL_MODELVIEW);
}

//Konwersja
char <http://4programmers.net/C/Char> ascii[25];
FILE*f;

void <http://4programmers.net/C/Void> itoa(int
<http://4programmers.net/C/Int> i)
{

 f=fopen("tmp.tmp","w");
  fprintf(f,"%i\n",i);
 fclose(f);

 f=fopen("tmp.tmp","r");
  fscanf(f,"%s\n",&ascii);
 fclose(f);
}

//Warto¶æ bezwzglêdna
float <http://4programmers.net/C/Float> abstract(float
<http://4programmers.net/C/Float> f)
{
 if <http://4programmers.net/C/If> (f>=0) return
<http://4programmers.net/C/Return> f; else
<http://4programmers.net/C/Else> return
<http://4programmers.net/C/Return> -f;
}

//Pisze czcionk± bitmapow±
float <http://4programmers.net/C/Float> glutPrint(float
<http://4programmers.net/C/Float> x,float
<http://4programmers.net/C/Float> y,void
<http://4programmers.net/C/Void> *font,char
<http://4programmers.net/C/Char> *txt,float
<http://4programmers.net/C/Float> scale)
{ int <http://4programmers.net/C/Int> i;
  int <http://4programmers.net/C/Int> len=strlen(txt);
 for <http://4programmers.net/C/For> (i=0; i<len; i++)
 {
  glRasterPos2f(x,y);
  glutBitmapCharacter(font, txt[i]);
  x+=glutBitmapWidth(font,txt[i])*scale;
 }
}

//G³ówna funkcja rysuj±ca
void <http://4programmers.net/C/Void> DrawGLScene()
{
int <http://4programmers.net/C/Int> i;
float <http://4programmers.net/C/Float> y;

fps++;                //Zliczaj fps

glutSetWindow(window);
  glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);        // Clear
The Screen And The Depth Buffer
  glLoadIdentity();                                // Reset The View
  //OpenGL scene goes here///////////////////////////////////////
  glTranslatef(0,0,-2.5);
  glColor3f(0,0,0);

   //FPS
   itoa(sfps);
   strcat(ascii," fps");
   glutPrint(-0.8,-0.8,GLUT_BITMAP_9_BY_15,ascii,0.005);

   y=starty;
   for <http://4programmers.net/C/For> (i=0; i<txtcount; i++)
   {&nbsp;
    if <http://4programmers.net/C/If> (y<1) //Je¶li napis jest widoczny
(w strefie 1>y>-1) to&nbsp;
    {
     glColor3f(0+abstract(y),0+abstract(y),0+abstract(y)); //Ustal kolor
     glutPrint(-0.4,y,GLUT_BITMAP_TIMES_ROMAN_24,txt[i],0.004);       
//Napisz go
    }
    y-=0.3;                //Przejd¥ ni¿ej ("nastêpny wiersz")
    if <http://4programmers.net/C/If> (y<-1) break
<http://4programmers.net/C/Break>;        //Je¶li ju¿ nic wiêcej nie
widaæ to przerwij rysowanie
   }

   starty+=0.005;                //Przewijaj ca³o¶æ
   if <http://4programmers.net/C/If> (starty>6) starty=-1;       
//Zresetuj po pewnym czasie

  ///////////////////////////////////////////////////////////////
  // swap the buffers to display, since double buffering is used.
  glutSwapBuffers();
}

//Funkcja wywo³ywana przez timer
void <http://4programmers.net/C/Void> timerFunc(int
<http://4programmers.net/C/Int> i)
{
 sfps=fps;
 fps=0;
 //powtórz wywo³ywanie
 glutTimerFunc (1000,&timerFunc,0);    //Co sekundê wywo³uje funkcjê
timerFunc
}

//Podstawowa funkcja ka¿dego programu
int <http://4programmers.net/C/Int> main(int
<http://4programmers.net/C/Int> argc, char
<http://4programmers.net/C/Char> **argv)
{
  glutInit(&argc, argv);        //Inicjalizacja GLUT
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA |
GLUT_DEPTH);        //Ustalenie trybu wy¶wietlania

  //Inicjalizacja i ustawienia dla okna renderingu
  glutInitWindowSize(640, 480);                //rozmiar
  glutInitWindowPosition(0, 0);         //po³o¿enie
  window = glutCreateWindow("GLUT TUTORIAL #6");//utworzenie okna
  glutDisplayFunc(&DrawGLScene);         //funkcja wy¶wietlania
  glutReshapeFunc(&ReSizeGLScene);        //zmiana rozmiaru
  InitGL(640, 480);                        //Inicjalizacja OpenGL


  glutTimerFunc (1000,&timerFunc,0);    //Co sekundê wywo³uje funkcjê
timerFunc

  glutIdleFunc(&DrawGLScene);                //Funkcja wywo³ana w
przypadku braku ¿adnych zdarzeñ


  glutMainLoop();                        //G³ówna pêtla

  glutDestroyWindow(window);                //Usuniêcie okna
  return <http://4programmers.net/C/Return> 1;
}



    TRYB GRY



GLUT posiada co¶ takiego jak tryb gry (GAME MODE). Obs³uguj± go funkcje:


void  glutGameModeString(const char *string);        //Ustala ci±g
znaków game mode (?), prawdopodobnie parametry
int  glutEnterGameMode(void);                        //W³±cza tryb game
mode. Zwraca warto¶æ int.
void  glutLeaveGameMode(void);                        //Wy³±cza
int  glutGameModeGet(GLenum mode);                //Pobiera ustawienia
trybu. Zwraca int. Mo¿liwe warto¶ci to:

GLUT_GAME_MODE_ACTIVE           0
GLUT_GAME_MODE_POSSIBLE         1
GLUT_GAME_MODE_WIDTH            2
GLUT_GAME_MODE_HEIGHT           3
GLUT_GAME_MODE_PIXEL_DEPTH      4
GLUT_GAME_MODE_REFRESH_RATE     5
GLUT_GAME_MODE_DISPLAY_CHANGED  6

Przyznam siê szczerze, ¿e nie wiem có¿ ów tajemniczy tryb powoduje. Jest
on innowacj±.


    INFORMACJE



GLUT zawiera tez funkcje pozwalajace nie tylko pobrac biezacy stan jego
komponentow, ale takze rozszezenia systemu i inne.&nbsp;

Pierwsz± tego typu funkcj± jest:
int glutGet(GLenum type);&nbsp;
Jak widaæ zwraca warto¶æ typu int, a w parametrze pobiera to czego
warto¶æ bêdzie zwracaæ. Mo¿liwe warto¶ci parametru:

//predefiniowana nazwa                warto¶æ                zwraca
 GLUT_WINDOW_X                        100                x aktywnego okna
 GLUT_WINDOW_Y                        101                y aktywnego okna
 GLUT_WINDOW_WIDTH                102                szeroko¶æ -"-
 GLUT_WINDOW_HEIGHT                103                wysoko¶æ  -"-
 GLUT_WINDOW_BUFFER_SIZE        104                rozmiar bufora
renderowania
 GLUT_WINDOW_STENCIL_SIZE        105                rozmiar bufora
Stencil (patrz. OpenGl)
 GLUT_WINDOW_DEPTH_SIZE                106                rozmiar bufora
g³êbi
 GLUT_WINDOW_RED_SIZE                107                rozmiary buforów
poszczególnych kolorów (?)
 GLUT_WINDOW_GREEN_SIZE                108
 GLUT_WINDOW_BLUE_SIZE                109
 GLUT_WINDOW_ALPHA_SIZE                110
 GLUT_WINDOW_ACCUM_RED_SIZE        111
 GLUT_WINDOW_ACCUM_GREEN_SIZE        112
 GLUT_WINDOW_ACCUM_BLUE_SIZE        113
 GLUT_WINDOW_ACCUM_ALPHA_SIZE        114
 GLUT_WINDOW_DOUBLEBUFFER        115                rozmiar podwójnego
bufora render
 GLUT_WINDOW_RGBA                116                rgba okna (?)
 GLUT_WINDOW_PARENT                117                rodzic bie¿±cego okna
 GLUT_WINDOW_NUM_CHILDREN        118                numer dziecka (?)
 GLUT_WINDOW_COLORMAP_SIZE        119                ?
 GLUT_WINDOW_NUM_SAMPLES        120                ?
 GLUT_WINDOW_STEREO                121                ?
 GLUT_WINDOW_CURSOR                122                bie¿±cy kursor
 GLUT_SCREEN_WIDTH                200                szeroko¶æ ekranu
 GLUT_SCREEN_HEIGHT                201                wysoko¶æ ekranu
 GLUT_SCREEN_WIDTH_MM                202                ?
 GLUT_SCREEN_HEIGHT_MM                203                ?
 GLUT__NUM_ITEMS                300                ?
 GLUT_DISPLAY_MODE_POSSIBLE        400                mo¿liwy tryb
wy¶wietlania
 GLUT_INIT_WINDOW_X                500                zainicjowane x okna
 GLUT_INIT_WINDOW_Y                501                zainicjowane y okna
 GLUT_INIT_WINDOW_WIDTH                502                zainicjowana
szeroko¶æ okna
 GLUT_INIT_WINDOW_HEIGHT        503                zainicjowana wysoko¶æ
okna
 GLUT_INIT_DISPLAY_MODE                504                zainicjowany
tryb wy¶wietlania okna
 GLUT_ELAPSED_TIME                700                czas jaki pozosta³ (?)
 GLUT_WINDOW_FORMAT_ID                123                format id okna (?)


Drug± funkcj± jest:
int glutDeviceGet(GLenum type); //której dzia³anie i wykorzystanie jest
identyczne jak powy¿szej, a s³u¿y do pobrania informacji o urz±dzeniu.
Mo¿liwe warto¶ci parametru to:

//predefinowana warto¶æ                warto¶æ                zwraca
 GLUT_HAS_KEYBOARD                600                czy jest klawiatura
 GLUT_HAS_MOUSE                        601                -"- myszka
 GLUT_HAS_SPACEBALL                602                -"- spaceball
(cokolwiek to jest ;) )
 GLUT_HAS_DIAL_AND_BUTTON_BOX        603                -"- button box
 GLUT_HAS_TABLET                604                -"- tablet
 GLUT_NUM_MOUSE_BUTTONS                605                ile mycha ma
przycisków
 GLUT_NUM_SPACEBALL_BUTTONS        606                ile spaceball -"-
 GLUT_NUM_BUTTON_BOX_BUTTONS        607                ile button box
-"-&nbsp;
 GLUT_NUM_DIALS                        608                ?
 GLUT_NUM_TABLET_BUTTONS        609                -"- tablet -"-
 GLUT_DEVICE_IGNORE_KEY_REPEAT  610                czy urz±dzenie
ignoruje powtarzanie klawiszy
 GLUT_DEVICE_KEY_REPEAT         611                czy urz±dzenie nie
ignoruje powtarzania klawiszy
 GLUT_HAS_JOYSTICK                612                czy jest joy&nbsp;
 GLUT_OWNS_JOYSTICK                613                ?
 GLUT_JOYSTICK_BUTTONS                614                info o
przyciskach joy'a (?)
 GLUT_JOYSTICK_AXES                615                ?
 GLUT_JOYSTICK_POLL_RATE        616                ?


Do pobrania obs³ugiwanych rozszerzeñ s³u¿y funkcja:

int glutExtensionSupported(const char *name);

w której rozszerzenia podajemy w parametrze jako ci±gi znakowe.

Kolejn± funkcj± jest:

int glutGetModifiers(void);

która zwraca warto¶æ typu int, bêd±c± sum± logiczn± nastêpuj±cych warto¶ci:

//predefiniowana                warto¶æ
 GLUT_ACTIVE_SHIFT               1
 GLUT_ACTIVE_CTRL                2
 GLUT_ACTIVE_ALT                 4

Dziêki tej funkcji, mo¿emy pobraæ w dowolnym momencie stan klawiszy
specjalnych. Brak przyk³adziku jedynie z powodu oczywisto¶ci
przedstawionych funkcji.


    MAPY KOLORÓW



Do obs³ugi tego s³u¿± trzy funkcje:

glutCopyColormap
glutSetColor
glutGetColor


Funkcja&nbsp;
void glutCopyColormap (int win);
kopiuje mapê kolorów z okna podanego w paramerze (warstwy) do aktualnego.

Funkcja&nbsp;
void glutSetColor(int cell, GLfloat red, GLfloat green, GLfloat blue);
zmienia sk³adowe koloru. Pierwszy parametr to index (typ int), kolejne
trzy to ju¿ float, które s± sk³adowymi RGB (ka¿da mo¿e mieæ warto¶æ od 0
do 1).

Przyk³adowy kod (do main):

int <http://4programmers.net/C/Int> win1, win2;                         
      //Deklaracja okien

glutInitDisplayMode(GLUT_INDEX);        //Inicjalizacja trybu
indexowania ISTOTNE ! aby pamiêtaæ o jego ustaleniu
win1 = glutCreateWindow("first color index win");        //Utworzenie
pierwszego okna
glutSetColor(0, 0.0, 0.0, 0.0); /* black */                //Modyfikacje
kolorów z mapy kolorów z pierwszego okna
glutSetColor(1, 0.5, 0.5, 0.5); /* gray */
glutSetColor(2, 1.0, 1.0, 1.0); /* black */
glutSetColor(3, 1.0, 0.0, 0.0); /* red */
win2 = glutCreateWindow("second color index win");        //Utworzenie
drugiego okna
glutCopyColormap(win1);                                       
//Skopiowanie mapy kolorów dla drugiego okna
 

Ostatni funkcja s³u¿y (jak nietrudno siê domy¶liæ) s³u¿y do pobrania
sk³adowych danego koloru, z bie¿±cej mapy kolorów.
Jej deklaracja to:

GLfloat glutGetColor(int cell, int component);

jak widaæ zwraca ona warto¶æ float, która jest w³a¶nie warto¶ci±
sk³adowej. W parametrach podejmy index (liczony od zera) koloru, a
nastêpnie któr± sk³adow± chcemy pobraæ:
 GLUT_RED                //czerwona&nbsp;
 GLUT_GREEN                //zielona
 GLUT_BLUE                //niebieska

W przypadku przezroczysto¶ci koloru (lub innej modyfikacji) funkcja
zwraca warto¶æ -1.


    WARSTWY



Czyli: wracamy do rozmów o cebuli ;).

Niestety jestem z nich marny. Zwyczajnie siê na nich nie znam. Ale jak
mus to mus.

OK. Pierwsza funkcja to:

glutEstablishOverlay();

nie przyjmuje parametrów i nic te¿ nie zwraca. S³u¿y do "ustalania"
warstwowo¶ci dla okna (o ile to mo¿liwe). Tryb wy¶wietlania ustalamy
przez "initial display mode". Po wywo³aniu funkcji pierwsza istniej±ca
warstwa jest usuwana, a pokazywana jest kolejna.

Funkcja:
glutRemoveOverlay(); //bez parametrów
s³u¿y do usuwania jednej warstwy z aktywnego okna.

Funkcja:
void glutUseLayer(GLenum layer);
ustawia tryb warstwowania dla okna.

Mo¿liwe warto¶ci parametru layer:
GLUT_NORMAL - normalny plan
GLUT_OVERLAY - kolejna warstwa

Funkcja:
void glutPostOverlayRedisplay(void);&nbsp;
ma dzia³anie jak glutPostRedisplay, tyle, ¿e odnosi siê do warstw.

Do ukrywania i pokazywania warstw s³u¿± funkcje:

void glutShowOverlay(void);
void glutHideOverlay(void);

Funkcja:

void glutOverlayDisplayFunc(void (*func)(void));

jest typu callback i w parametrze podajemy funkcjê, która bêdzie u¿ywana
do wy¶wietlania sceny na warstwie (dzia³anie jak w glutDisplayFunc).

Funkcje:

void glutPostOverlayRedisplay(void);
void glutPostWindowOverlayRedisplay(int win);

s± ju¿ zupe³nie oczywiste. Pierwsza powoduje niezale¿ne od DisplayFunc
wy¶wietlenie scenki. Druga robi to samo tyle, ¿e w parametrze podajemy
dla którego okna to zrobimy (warstwa bie¿±ca dla danego).

Do pobrania ustawieñ warst s³u¿y funkcja:

int glutLayerGet(int); //która jak widaæ ma w parametrze int, mo¿liwe
warto¶ci to:

//Predefiniowana warto¶æ znaczenie
GLUT_OVERLAY_POSSIBLE 800 //mo¿liwe u¿ycie warstw
GLUT_LAYER_IN_USE 801 //czy u¿ywane s± warstwy
GLUT_HAS_OVERLAY 802 //czy s± warstwy
GLUT_TRANSPARENT_INDEX 803 //index przezrczysto¶ci (?)
GLUT_NORMAL_DAMAGED 804 //?
GLUT_OVERLAY_DAMAGED 805 //?

i zwraca int'a.

Mo¿e i nie jest to wszystko zbyt zrozumia³e, ale mo¿e kod u³atwi
zrozumienie:

Zmienne:
int <http://4programmers.net/C/Int> overlaySupport; //Zmienna u¿yta do
sprawdzenia obs³ugi warstw
int <http://4programmers.net/C/Int> transparent, red, white;
//Przezroczysto¶æ, czerwony, bia³y
 

Do main:
glutInitDisplayMode(GLUT_SINGLE | GLUT_INDEX); //Inicjalizacja wy¶wietlania<
overlaySupport = glutLayerGet(GLUT_OVERLAY_POSSIBLE); //Sprawdzenie czy
warstwy s± obs³ugiwane
if <http://4programmers.net/C/If> (overlaySupport) //Je¶li tak to
{
glutEstablishOverlay();&nbsp;
glutHideOverlay();

transparent = glutLayerGet(GLUT_TRANSPARENT_INDEX); //Pobranie index'u
przezroczysto¶ci
glClearIndex(transparent);&nbsp;
red = (transparent + 1) % glutGet(GLUT_WINDOW_COLORMAP_SIZE);&nbsp;
white = (transparent + 2) % glutGet(GLUT_WINDOW_COLORMAP_SIZE);
glutSetColor(red, 1.0, 0.0, 0.0); /* Red. */
glutSetColor(white, 1.0, 1.0, 1.0); /* White. */

glutOverlayDisplayFunc(redrawOverlay); //Ustalenie funkcji wy¶wietlaj±cej
glutReshapeFunc(reshape); //Ustalenie funkcji przy zmianie rozmiaru okna
} else <http://4programmers.net/C/Else> //Je¶li warstwy nie chodz± to
{
printf <http://4programmers.net/C/Printf>("Sorry, no nifty overlay (try
an SGI workstation)!\n"); //wy¶wietl komunikat
}


Funkcja zmiany rozmiaru okna:

void <http://4programmers.net/C/Void> reshape(int
<http://4programmers.net/C/Int> w, int <http://4programmers.net/C/Int> h)
{
if <http://4programmers.net/C/If> (overlaySupport) //Je¶li obs³ugiwane
s± warstwy
{
glutUseLayer(GLUT_OVERLAY); /* Setup overlay to have X style coordinate
system. */
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D(0, w, 0, h);
glScalef(1, -1, 1);
glTranslatef(0, -h, 0);
glMatrixMode(GL_MODELVIEW);
glutUseLayer(GLUT_NORMAL);
}
glViewport(0, 0, w, h);
}


UWAGA ! Niestety, u mnie wstawka do programu powy¿szego kodu, daje
niemi³y efekt:

"Sorry, no nifty overlay (try an SGI workstation)!"

wiêc (jak siê pewnie domy¶li³e¶), ¿adna z powy¿szych funkcji nie by³a
testowana i upewnienie siê co do ich dzia³ania pozostaje w kompetencji
czytaj±cego :( .


    VIDEO



Pierwsz± omówion± funkcj± z tej grupy jest:

int glutVideoResizeGet         ( GLenum param );

jak widaæ przyjumuje ona jeden parametr. Mo¿liwe warto¶ci dla parametru to:

// Predefiniowane:                warto¶æ:         dzia³anie:
 GLUT_VIDEO_RESIZE_POSSIBLE        900                //Parametr,przy
którym funkcja zwraca 0 gdy zmiana vid. nie jest obs³ugiwana (i wtedy
pozosta³e parametry s± bezu¿yteczne), lub 1 gdy jest obs³ugiwane

 GLUT_VIDEO_RESIZE_IN_USE        901                //Zwracaj± pozosta³e
informacje o vid.
 GLUT_VIDEO_RESIZE_X_DELTA        902
 GLUT_VIDEO_RESIZE_Y_DELTA        903
 GLUT_VIDEO_RESIZE_WIDTH_DELTA        904
 GLUT_VIDEO_RESIZE_HEIGHT_DELTA        905
 GLUT_VIDEO_RESIZE_X                906
 GLUT_VIDEO_RESIZE_Y                907
 GLUT_VIDEO_RESIZE_WIDTH        908
 GLUT_VIDEO_RESIZE_HEIGHT        909

 void  glutSetupVideoResizing(void);                //Uruchamia
ustalanie rozmiaru vid.
 void  glutStopVideoResizing(void);                //Koñczy owo¿
 void  glutVideoResize(int x, int y, int width, int
height);        //Zmienia rozmiar vid.
 void  glutVideoPan(int x, int y, int width, int height);        //?

Nie to, ¿eby mi siê nie chcia³o, ale có¿, nie s±dzê aby to by³o istotne,
a nie czujê siê najlepiej w tym temacie.


    DODATKI



No i na koniec kilka uzupe³niaj±cych ca³o¶æ funkcji:

glutSetCursor(2); //Funkcja pozwala na zmianê kursora mychy, w
parametrze podajemy numer oznaczaj±cy jaki kursor z systemu (ró¿ne dla
Windows'a, Linux'a, Mac'a)

Predefiniowane kursory:

//predefiniowane                warto¶æ                wygl±d
 GLUT_CURSOR_RIGHT_ARROW        0                strza³ka w prawo
 GLUT_CURSOR_LEFT_ARROW                1                strza³ka w lewo
 GLUT_CURSOR_INFO                2                informacja
 GLUT_CURSOR_DESTROY                3                zniszcz
 GLUT_CURSOR_HELP                4                pomoc
 GLUT_CURSOR_CYCLE                5                kó³ko
 GLUT_CURSOR_SPRAY                6                spray
 GLUT_CURSOR_WAIT                7                czekaj
 GLUT_CURSOR_TEXT                8                text
 GLUT_CURSOR_CROSSHAIR                9                krzy¿yk
 GLUT_CURSOR_UP_DOWN                10                góra, dó³ //zmiana
rozmiaru
 GLUT_CURSOR_LEFT_RIGHT                11                prawo,
lewo  //zmiana rozmiaru
 GLUT_CURSOR_TOP_SIDE                12                góra  //zmiana
rozmiaru
 GLUT_CURSOR_BOTTOM_SIDE        13                dó³  //zmiana rozmiaru
 GLUT_CURSOR_LEFT_SIDE                14                lewo  //zmiana
rozmiaru
 GLUT_CURSOR_RIGHT_SIDE                15                prawo  //zmiana
rozmiaru
 GLUT_CURSOR_TOP_LEFT_CORNER        16                górny lewy
róg  //zmiana rozmiaru
 GLUT_CURSOR_TOP_RIGHT_CORNER        17                górny prawy
róg  //zmiana rozmiaru
 GLUT_CURSOR_BOTTOM_RIGHT_CORNER 18                dolny prawy
róg  //zmiana rozmiaru
 GLUT_CURSOR_BOTTOM_LEFT_CORNER        19                dolny lewy
róg  //zmiana rozmiaru
 GLUT_CURSOR_INHERIT                100                ?
 GLUT_CURSOR_NONE                101                brak kursora
 GLUT_CURSOR_FULL_CROSSHAIR        102                wype³niony krzy¿yk


glutSetIconTitle("Napis na pasku");        //Pozwala na zmianê napisu na
belce okna na pasku. Przyjmuje jeden parametr typu const char*


glutReportErrors();                        //GLUT wy¶wietla raporty o
b³êdach (w oknie konsoli)


W GLUT istnieje funkcja:

void* glutGetProcAddress ( const char * procName );

której dzia³anie jest identyczne jak funkcji:

glXGetProcAddress();        //Na systemie X-Window (Linux)
wglGetProcAddress();        //Na Windows-GL (Windows)

S³u¿y ona do pobrania wska¥nika (zwraca go) do adresu funkcji, której
nazwê podajemy w parametrze.


Funkcja:

glutInitDisplayString

s³u¿u do ustawienia trybu wy¶wietlania przez string'a podanego w
parametrze. Specyfikacja funkcji w C wygl±da nastêpuj±co:

void glutInitDisplayString(char *string);

Opis dzia³ania (kopia z dokumentacji):

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
The initial display mode description string is used when creating
top-level windows, subwindows, and overlays to determine the OpenGL
display mode for the to-be-created window or overlay.

The string is a list of zero or more capability descriptions separated
by spaces and tabs. Each capability description
is a capability name that is optionally followed by a comparator and a
numeric value. For example, "double"
and "depth>=12" are both valid criteria.

The capability descriptions are translated into a set of criteria used
to select the appropriate frame buffer
configuration.


The criteria are matched in strict left to right order of precdence.
That is, the first specified criteria (leftmost)
takes precedence over the later criteria for non-exact criteria (greater
than, less than, etc. comparators). Exact
criteria (equal, not equal compartors) must match exactly so precedence
is not relevant.



The numeric value is an integer that is parsed according to ANSI C's
strtol(str, strptr,
0) behavior. This means that decimal, octal (leading 0), and hexidecimal
values (leading 0x) are accepeted.



The valid compartors are:
[Dozwolonymi symbolami s±:]&nbsp;


=


Equal. [równe]


!=


Not equal. [nie równe]


<


Less than and preferring larger difference (the least is best). [mniejsze]


>


Greater than and preferring larger differences (the most is best). [wiêksze]


<=


Less than or equal and preferring larger difference (the least is best).
[mniejsze lub równe]


>= [wiêksze lub równe]


Greater than or equal and preferring more instead of less. This
comparator is useful for allocating
resources like color precsion or depth buffer precision where the
maximum precison is generally preferred.
Contrast with the tilde (~) comprator.

~

Greater than or equal but preferring less instead of more. This
compartor is useful for allocating
resources such as stencil bits or auxillary color buffers where you
would rather not over allocate. When
the compartor and numeric value are not specified, each capability name
has a different default (one
default is to require a a compartor and numeric value).



The valid capability names are:
[Dozwolonymi typami nazw s±:]

alpha


Alpha color buffer precision in bits. Default is ">=1".


acca


Red, green, blue, and alpha accumulation buffer precision in bits.
Default is ">=1" for red,
green, blue, and alpha capabilities.


acc


Red, green, and green accumulation buffer precision in bits and zero
bits of alpha accumulation buffer
precision. Default is ">=1" for red, green, and blue capabilities, and
"~0" for the
alpha capability.


blue


Blue color buffer precision in bits. Default is ">=1".


buffer


Number of bits in the color index color buffer. Default is ">=1".


conformant


Boolean indicating if the frame buffer configuration is conformant or
not. Conformance information is based
on GLX's EXT_visual_rating extension if supported. If the extension is
not supported, all visuals are
assumed conformat. Default is "=1".


depth


Number of bits of precsion in the depth buffer. Default is ">=12".


double


Boolean indicating if the color buffer is double buffered. Default is "=1".


green


Green color buffer precision in bits. Default is ">=1".


index


Boolean if the color model is color index or not. True is color index.
Default is ">=1".


num


A special capability name indicating where the value represents the Nth
frame buffer configuration matching
the description string. When not specified, glutInitDisplayString also
returns the first (best matching)
configuration. num requires a compartor and numeric value.


red


Red color buffer precision in bits. Default is ">=1".


rgba


Number of bits of red, green, blue, and alpha in the RGBA color buffer.
Default is ">=1" for
red, green, blue, and alpha capabilities, and "=1" for the RGBA color
model capability.


rgb


Number of bits of red, green, and blue in the RGBA color buffer and zero
bits of alpha color buffer
precision. Default is ">=1" for the red, green, and blue capabilities,
and "~0" for
alpha capability, and "=1" for the RGBA color model capability.


luminance



Number of bits of red in the RGBA and zero bits of green, blue (alpha
not specified) of color buffer
precision. Default is ">=1" for the red capabilitis, and "=0" for the
green and blue
capabilities, and "=1" for the RGBA color model capability, and, for
X11, "=1" for the
StaticGray ("xstaticgray") capability.



SGI InfiniteReality (and other future machines) support a 16-bit
luminance (single channel) display mode
(an additional 16-bit alpha channel can also be requested). The red
channel maps to gray scale and green
and blue channels are not available. A 16-bit precision luminance
display mode is often appropriate for
medical imaging applications. Do not expect many machines to support
extended precision luminance display
modes.


stencil


Number of bits in the stencil buffer.


single


Boolean indicate the color buffer is single buffered. Double buffer
capability "=1".


stereo


Boolean indicating the color buffer is supports OpenGL-style stereo.
Default is "=1".


samples


Indicates the number of multisamples to use based on GLX's
SGIS_multisample extension (for antialiasing).
Default is "<=4". This default means that a GLUT application can request
multipsampling if
available by simply specifying "samples".


slow


Boolean indicating if the frame buffer configuration is slow or not. For
the X11 implementation of GLUT,
slowness information is based on GLX's EXT_visual_rating extension if
supported. If the EXT_visual_rating
extension is not supported, all visuals are assumed fast. For the Win32
implementation of GLUT, slowness is
based on if the underlying Pixel Format Descriptor (PFD) is marked
"generic" and not
"accelerated". This implies that Microsoft's relatively slow software
OpenGL implementation is
used by this PFD. Note that slowness is a relative designation relative
to other frame buffer
configurations available. The intent of the slow capability is to help
programs avoid frame buffer
configurations that are slower (but perhaps higher precision) for the
current machine. Default is
">=0" if not comparator and numeric value are provided. This default
means that slow visuals
are used in preference to fast visuals, but fast visuals will still be
allowed.


win32pfd


Only recognized on GLUT implementations for Win32, this capability name
matches the Win32 Pixel Format
Descriptor by numer. win32pfd requires a compartor and numeric value.


xvisual


Only recongized on GLUT implementations for the X Window System, this
capability name matches the X visual
ID by number. xvisual requires a compartor and numeric value.


xstaticgray


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type StaticGray. Default is "=1".


xgrayscale


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type GrayScale. Default is "=1".


xstaticcolor


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type StaticColor. Default is "=1".


xpseudocolor


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type PsuedoColor. Default is "=1".


xtruecolor


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type TrueColor. Default is "=1".


xdirectcolor


Only recongized on GLUT implementations for the X Window System, boolean
indicating if the frame buffer
configuration's X visual is of type DirectColor. Default is "=1".



Unspecifed capability descriptions will result in unspecified criteria
being generated. These unspecified criteria help
glutInitDisplayString behave sensibly with terse display mode
description strings. For example, if
no "slow" capability description is provided, fast frame buffer
configurations will be choosen in preference
to slow frame buffer configurations, but slow frame buffer
configurations will still be choosen if no better fast frame
buffer configuration is available.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Przyk³adowe u¿ycie:
glutInitDisplayString("stencil~2 rgb double depth>=16 samples");
//ustala okno w trybie RGBA, z g³êbi± 16 lub wiêcej bitów, z czym¶
zwanym "mutlisampling" i 2 bitami na stencil buffer.



No to by by³o na tyle. Zdaje siê, ¿e opisa³em (jako-tako) wszystkie
istotne funkcje w wersji 3.7, wiêc je¶li traficie na jakie¶ inne to
prawdopodobnie bêd± nale¿a³y ju¿ do nowszych implementacji lub (co
bardziej prawdopodobne) do innego wydania biblioteki GLUT. Standardowa
formu³ka: czytajcie ¥ród³a i arty oraz piszcie ile siê tylko da. W
przypadku niejasno¶ci najlepiej (o ile na przeszkodzie nie stoi jêzyk)
poszukaæ na stronach angielskojêzycznych, bo tam jest sporo materia³ów,
czego niestety nie mo¿na powiedzieæ o polskiej sieci (mnie nie uda³o siê
znale¥æ ¿adnego opracowania tematu w naszym ojczystym jêzyku, co
nawiasem mówi±c by³o jednym z powodów napisania tego art'a).&nbsp;

Zdajê sobie sprawê, ¿e w tek¶cie jest du¿o b³êdów i dlatego proszê o
ocenê i "konstruktywne" uzupe³nienia na mój e-mail.
 
W temacie mam zamiar jeszcze napisaæ podsumowuj±cy kod. Ale chwilowo s±
pewne problemy...

No i co¶ na co wszyscy niezadowoleni czekali:
wersja wej¶ciowa tego art'a <bin/GLUTcourse.txt>
Kategoria <http://4programmers.net/text.php>: Z pogranicza
<http://4programmers.net/Z_pogranicza>	
Informacje
Ostatnia modyfikacja 	12-07-2007 18:29 	Ostatni autor 	Stogu
<http://4programmers.net/ucp.php?id=23026>
Ilo¶æ wy¶wietleñ 	22014 	Wersja 	3

Komentarz
*Stogu* <http://4programmers.net/ucp.php?id=23026> dnia /07-07-2007 16:50/
Dodane formatowanie, menu, usun±³em wiêkszo¶æ niepotrzebnych odstêpów
itp, poprawi³em znaki. Od razu lepiej :P
*neuromancer* <http://4programmers.net/ucp.php?id=5389> dnia /11-01-2005
07:48/
UWAGA !!!
jak by by³y problemy z uruchomieniem (freeglut) to usun±æ
GLUT_ALPHA
z
glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
*AklimX* <http://4programmers.net/ucp.php?id=2945> dnia /20-08-2004 22:13/
ciekawe czy orygina³ te¿ tak beznadziejnei wygl±da³ ;>
*mcbury* <http://4programmers.net/ucp.php?id=3128> dnia /16-08-2004 19:39/
we¶ sformatuj to koles %*(%*$$%$ !
*AklimX* <http://4programmers.net/ucp.php?id=2945> dnia /11-08-2004 10:00/
Masz to poprawiæ, bo beznadziejnie to wygl±da. Wyrzuæ chocia¿ te bia³e
dziury
*neuromancer* <http://4programmers.net/ucp.php?id=5389> dnia /10-08-2004
20:15/
Fakt. Formatowanie by siê przyda³o.  Ale pisa³em w gedit'cie i potem z
odsy³aczami by³oby kupê roboty, chocia¿ mo¿e siê postaram i poprawiê :).
Co do tego angielskiego to jeszcze pomy¶lê. A co do kodowania to... to
nie wiem coo .. :)
*kagn_danas* <http://4programmers.net/ucp.php?id=5108> dnia /10-08-2004
11:37/
podoba sie bardzo
*Marooned* <http://4programmers.net/ucp.php?id=652> dnia /10-08-2004 04:38/
i polskie literki posz³y w las... - dodaj do tego jaki¶ spis tre¶ci
(jako linki) i zdecyduj siê na jeden jêzyk w artykule
*xeryph* <http://4programmers.net/ucp.php?id=4978> dnia /09-08-2004 21:57/
nom :\ do formatowania mozna sie doczepic...
(duzo bialych miejsc)
*WeeR* <http://4programmers.net/ucp.php?id=3084> dnia /09-08-2004 20:35/
Tak, tylko ¿e po³owa tekstu jest po angielsku ... mog³e¶ chocia¿ troche
przet³umaczyæ...
*AklimX* <http://4programmers.net/ucp.php?id=2945> dnia /09-08-2004 17:22/
Napracowa³e¶ siê i to sporo. Moja uwaga: rozumiem, ¿e chcia³e¶ napisaæ
czarno na bia³ym, ale kto to bêdzie czyta³ (¿adnych odno¶ników, spisu
tre¶ci, tylko tekst i tekst przez ponad 80 stron)
*neuromancer* <http://4programmers.net/ucp.php?id=5389> dnia /09-08-2004
17:06/
Mam nadziejê, ¿e sie spodoba ...

Katalog <http://4programmers.net/text.php>

    * Delphi <http://4programmers.net/Delphi>
    * Artyku³y <http://4programmers.net/Delphi/Artyku³y>
    * Kompendium <http://4programmers.net/Delphi/Kompendium>
    * Gotowce <http://4programmers.net/Delphi/Gotowce>
    * FAQ <http://4programmers.net/Delphi/FAQ>
    * .NET <http://4programmers.net/Delphi/.NET>
    * Turbo Pascal <http://4programmers.net/Turbo_Pascal>
    * FAQ <http://4programmers.net/Turbo_Pascal/FAQ>
    * PHP <http://4programmers.net/PHP>
    * FAQ <http://4programmers.net/PHP/FAQ>
    * Java <http://4programmers.net/Java>
    * FAQ <http://4programmers.net/Java/FAQ>

    * C/C++ <http://4programmers.net/C>
    * Artyku³y <http://4programmers.net/C/Artyku³y>
    * FAQ <http://4programmers.net/C/FAQ>
    * C# <http://4programmers.net/C_sharp>
    * Wprowadzenie <http://4programmers.net/C_sharp/Wprowadzenie>
    * Assembler <http://4programmers.net/Assembler>
    * FAQ <http://4programmers.net/Assembler/FAQ>
    * (X)HTML <http://4programmers.net/(X)HTML>
    * CSS <http://4programmers.net/CSS>
    * JavaScript <http://4programmers.net/JavaScript>
    * Z pogranicza <http://4programmers.net/Z_pogranicza>
    * Recenzje <http://4programmers.net/Recenzje>
    * Algorytmy <http://4programmers.net/Algorytmy>

wiêcej >> <http://4programmers.net/text.php>
Download <http://download.4programmers.net/>

    * Delphi <http://download.4programmers.net/Delphi>
    * C/C++ <http://download.4programmers.net/C/C++>
    * Turbo Pascal <http://download.4programmers.net/Turbo_Pascal>
    * Assembler <http://download.4programmers.net/Assembler>
    * PHP <http://download.4programmers.net/PHP>

    * Programy <http://download.4programmers.net/Programy>
    * Dokumentacja <http://download.4programmers.net/Dokumentacja>
    * Kursy <http://download.4programmers.net/Kursy>
    * Komponenty <http://download.4programmers.net/Komponenty>

wiêcej >> <http://download.4programmers.net/>
RSS <http://4programmers.net/Rss> | Forum
<http://forum.4programmers.net/> | Pastebin
<http://pastebin.4programmers.net/> | Regulamin
<http://4programmers.net/Regulamin> | Pomoc
<http://4programmers.net/Pomoc> | Usuñ cookies
<http://4programmers.net/ucp.php?mode=logout&option=all> | Prawa
autorskie <http://4programmers.net/Prawa_autorskie> | Kontakt
<http://4programmers.net/Kontakt> | Reklama
<http://4programmers.net/Reklama>
Copyright (c) <http://4programmers.net/Prawa_autorskie> 2000-2006 by
Coyote Group <http://4programmers.net/Coyote> 0.9.3-pre3
<http://4programmers.net/Wersja_oprogramowania>
Czas generowania strony: 1.1209 sek. (zapytañ SQL: 9)
